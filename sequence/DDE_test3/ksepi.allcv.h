/*
 *  ksepi.allcv.h
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Nov 24 2018
 *  Time : 13:36:59
 */

#ifndef h_ksepi_allcv_h
#define h_ksepi_allcv_h

long _firstcv = 0;

/*
 * reqcv
 * cvs required for communication between host applications
 * (scn, ifcc, psc, etc.) and any and all PSDs. The content
 * is order-sensitive and name sensitive. If any changes are
 * made to CV names or the order of CVs including new additions
 * anywhere, the revision must be changed to prevent adverse
 * and unpredictable changes to the data communicated to and from
 * the PSD.
 */

int psd_annefact_level = 0 






;

int rhpsd_annefact_level = 0 






;

float psd_relative_excited_volume_freq = -1.0 






;

float psd_relative_excited_volume_phase = -1.0 






;

float psd_relative_excited_volume_slice = 1.0 






;


float psd_relative_encoded_volume_freq = -1.0 






;

float psd_relative_encoded_volume_phase = 1.0 






;

float psd_relative_encoded_volume_slice = 1.0 






;

int opresearch = 0 






;

/* ****************************
   Patient/Study Parameters 
   ************************** */
float opweight = 50 






;

/* ****************************
   Patient Position Parameters 
   ************************** */

int oplandmark = PSD_OFF 






;

int optabent = 0 






;

int opentry = 1 






;

int oppos = 1 






;

int opplane = PSD_AXIAL 






;

int opphysplane = PSD_AXIAL 






;

int opobplane = PSD_AXIAL 






;

int opimode = PSD_2D 






;

int oppseq = 1 






;

/* opgradmode says which coil is active in TRM_COIL (twin gradient) (Gili) */
int opgradmode = 0 






;

/* Anatomy */
int opanatomy = 0 





;

/* ************************** 
   Imaging Options CVs 
   *************************** */
int piimgoptlist = 0 






;

int opcgate = 0 






;

int opexor = 0 






;

int opcmon = 0 






;

int opfcomp = 0 






;

int opgrx = 0 






;

int opgrxroi = 0 






;

int opnopwrap = 0 






;

int opptsize = 2 






;

int oppomp = 0 






;

int opscic = 0 






;

int oprect = 0 






;

int opsquare = 0 






;

int opvbw = 0 






;

int opblim = 0 






;

int opfast = 0 






;

int opcs = 0 






;

int opdeprep = 0 






;

int opirprep = 0 






;

int opsrprep = 0 






;

int opmph = 0 






;

int opdynaplan = 0 






;

int opdynaplan_mask_phase = 0 





;

/*  Black Blood Suppression */
int opbsp = 0 






;

int oprealtime = 0 






;

int opfluorotrigger = 0 






;

int opET = 0 






;

int opmultistation = 0 






;

int opepi = 0 






;

int opflair = 0 






;

int opt1flair = 0 






;

int opt2flair = 0 






;

int opdoubleir = 0 






;

int optissuet1 = 0 






;

int opautotissuet1 = 0 






;

int optlrdrf = 0 






;

int opfulltrain = 0 






;

int opirmode = SIRMODE 






;

int opmt = 0 






;

int opzip512 = 0 






;

int opzip1024 = 0 






;

int opslzip2 = 0 






;

int opslzip4 = 0 






;

int opsmartprep = 0 






;

int opssrf = 0 






;

int opt2prep = 0 






;

int opspiral = 0 






;

int opnav = 0 






;

int opfmri = 0 






;

/* ECTRICKS CVS */
int opectricks = 0 






;

int optricksdel = 1000000 





;

int optrickspause = 1 





;

int opfr = 0 






;

int opcube = 0 






;

int ophydro = 0 






;

/* Added for enabling fiesta-c psd is selected.: HK */
int opphasecycle = 0 






;

int oplava = 0 






;

int op3dcine_fiesta = 0 






;

int op3dcine_spgr = 0 






;

int op4dflow = 0 






;

int opbrava = 0 






;

int opcosmic = 0 






;

int opvibrant = 0 






;


int opbravo = 0 






;

int opdisco = 0 






;

int opmprage = 0 






;

/* PROMO CV */
int oppromo = 0 






;

int opprop = 0 






;

int opdwprop = 0 






;

int opdwpropduo = 0 






;

int opmuse = PSD_OFF 






;

int opallowedrescantime = 0 






;

int opbreastmrs = 0 






;

int opjrmode = 0 






;

int opssfse = 0 






;

int t1flair_flag = 0 






;
                                                                        
/*
   AF 03/22/01 Add condition parameter for Phase Sensitivity
   Reconstruction function when Phase Sensitivity radio button is selected
   on the Imaging Option page
*/

int opphsen = 0 






;

int opbc = 0 






;

int opfatwater = 0 






;

int oprtbc = 0 






;

int opnseg = 1 






;

int opnnex = 0 






;

int opsilent = 0 






;

int opsilentlevel = 1 






;

int opmerge = 0 






;

int opswan = 0 






;

int opphaseimage = 0 






;

int opdixon = 0 






;

/*----------------------------------------------------------------
Bit pattern for opdixproc
-------------------------
bit 0 used for indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
----------------------------------------------------------------*/
int opdixproc = 0 






;

int opmedal = 0 






;

int opquickstep = 0 






;

int opidealiq = 0 






;

int opsilentmr = 0 






;

int opmagic = 0 






;

/* ************************************
   added for Zoom Gradient limitations
   ************************************ */
float opzoom_fov_xy = 440.0 






;

float opzoom_fov_z = 350.0 






;

float opzoom_dist_ax = 120.0 






;

float opzoom_dist_cor = 120.0 






;

float opzoom_dist_sag = 150.0 






;

int app_grad_type = 0 






;

int opzoom_coil_ind = 0 






;

int pizoom_index = 0 






;


/* *****************
   SAT CVs 
   **************** */
int opsat = 0 
;

int opsatx = 0 






;

int opsaty = 0 






;

int opsatz = 0 






;

float opsatxloc1 = 9999 






;

float opsatxloc2 = 9999 






;

float opsatyloc1 = 9999 






;

float opsatyloc2 = 9999 






;

float opsatzloc1 = 9999 






;

float opsatzloc2 = 9999 






;

float opsatxthick = 40.0 






;

float opsatythick = 40.0 






;

float opsatzthick = 40.0 






;

int opsatmask = 0 






;

int opfat = 0 






;

int opwater = 0 






;

int opccsat = 0 






;

int opfatcl = 0 





;


int opspecir = 0 





;

/* ***************************
   These are for graphic sats.
   *************************** */
int opexsatmask = 0 






;

float opexsathick1 = 40.0 






;

float opexsathick2 = 40.0 






;

float opexsathick3 = 40.0 






;

float opexsathick4 = 40.0 






;

float opexsathick5 = 40.0 






;

float opexsathick6 = 40.0 






;

float opexsatloc1 = 9999 






;

float opexsatloc2 = 9999 






;

float opexsatloc3 = 9999 






;

float opexsatloc4 = 9999 






;

float opexsatloc5 = 9999 






;

float opexsatloc6 = 9999 






;

int opexsatparal = 0 






;

/*
   The opexsatoff<> cvs are for future use when targeted sat pulses
   are implemented 
*/
int opexsatoff1 = 0 






;

int opexsatoff2 = 0 






;

int opexsatoff3 = 0 






;

int opexsatoff4 = 0 






;

int opexsatoff5 = 0 






;

int opexsatoff6 = 0 






;

int opexsatlen1 = 480 






;

int opexsatlen2 = 480 






;

int opexsatlen3 = 480 






;

int opexsatlen4 = 480 






;

int opexsatlen5 = 480 






;

int opexsatlen6 = 480 






;
/* end of unused targeted sat cvs */

/* default sat band thicknesses */
float opdfsathick1 = 40.0 






;

float opdfsathick2 = 40.0 






;

float opdfsathick3 = 40.0 






;

float opdfsathick4 = 40.0 






;

float opdfsathick5 = 40.0 






;

float opdfsathick6 = 40.0 






;

/* **********************************************************************
   Pseudo-header variables. These values keep the following
   information for manual inclusion in the header -- that is, the PSD
   needs to copy the information to someplace else, like opusers, in
   order for the data to be included in the header. These values are
   calculated by Scan and are not used internally. Not OP, IH, PI, or RH.

   Thickness = sqrt(normth_R^2 + normth_A^2 + normth_S^2)
   Normal vector = [normth_R, normth_A, normth_S]/Thickness
   Sat center = dist * Normal vector.
   ********************************************************************** */

float exsat1_normth_R = 0;
float exsat1_normth_A = 0;
float exsat1_normth_S = 0;
float exsat2_normth_R = 0;
float exsat2_normth_A = 0;
float exsat2_normth_S = 0;
float exsat3_normth_R = 0;
float exsat3_normth_A = 0;
float exsat3_normth_S = 0;
float exsat4_normth_R = 0;
float exsat4_normth_A = 0;
float exsat4_normth_S = 0;
float exsat5_normth_R = 0;
float exsat5_normth_A = 0;
float exsat5_normth_S = 0;
float exsat6_normth_R = 0;
float exsat6_normth_A = 0;
float exsat6_normth_S = 0;
float exsat1_dist = 0;
float exsat2_dist = 0;
float exsat3_dist = 0;
float exsat4_dist = 0;
float exsat5_dist = 0;
float exsat6_dist = 0;

/* Graphic IR Bands */
int pigirscrn = 0;      /* To control Graphic IR screen */
int piautoirbands = 0;  /* To control Auto IR Bands button */
float pigirdefthick = 200.0;    /* Graphic IR Bands default thickness in mm */

int pinumgir = MAX_NUM_GIR 





;

int opnumgir = 0 





;

int pigirmode = 3 





;

int opgirmode = 0 





;

/* Cardiac Tagging */
int optagging = 0 






;

int optagspc = 7 





;

/*
 * Allow Tagging angles of 0 and 90 degrees 
 * with default as 45 degrees. The CV taggingangle in 
 * Tagging.e has been replaced with optagangle and moved
 * to epic.h
 */
float optagangle = 45.0 





;


/* *****************
   Vascular CVs
   ***************** */
float opvenc = 50.0 





;

int opflaxx = 0 





;

int opflaxy = 0 





;

int opflaxz = 0 





;

int opflaxall = 0 





;

int opproject = 0 





;

int opcollapse = 1 





; 

int oprlflow = 0 





;

int opapflow = 0 





;

int opsiflow = 0 





;

int opmagc = 1 





;

int opflrecon = 0 





;

int oprampdir = 0 





;

int project = 0 





;

int vas_ovrhd = 0 





;

int slice_col = 1 





; 

int phase_col = 0 





;

int read_col = 0 





;

int mag_mask = 1 





;

int phase_cor = 1 





;

int extras = 0 





;

int mag_create = 1 





;

int rl_flow = 0 





;

int ap_flow = 0 





;

int si_flow = 0 





;

int imagenum = 1 





;

int motsa_ovrhd = 0 





;

int opslinky = 0 





;

int opinhance = 0 






;

int opmavric = 0 






;

int opinhsflow = 0 






;

int opmsde = 0 





;

float opvest = 50.0 





;

int opmsdeaxx = 0 





;

int opmsdeaxy = 0 





;

int opmsdeaxz = 0 





;

/* Auto Navigator Tracker */
int opbreathhold= 0 





;

/********************************************************/
/*      AUTO SUBTRACT                                   */
/********************************************************/

int opautosubtract = 0 






;

int opsepseries = 0 






;

/* **********************
   op user CVs
   ********************* */
int pititle = 0 ;
float opuser0  = 0 ;
float opuser1  = 0 ;
float opuser2  = 0 ;
float opuser3  = 0 ;
float opuser4  = 0 ;
float opuser5  = 0 ;
float opuser6  = 0 ;
float opuser7  = 0 ;
float opuser8  = 0 ;
float opuser9  = 0 ;
float opuser10 = 0 ;
float opuser11 = 0 ;
float opuser12 = 0 ;
float opuser13 = 0 ;
float opuser14 = 0 ;
float opuser15 = 0 ;
float opuser16 = 0 ;
float opuser17 = 0 ;
float opuser18 = 0 ;
float opuser19 = 0 ;
float opuser20 = 0 ;
float opuser21 = 0 ;
float opuser22 = 0 ;
float opuser23 = 0 ;
float opuser24 = 0 ;
float opuser25 = 0 ;
float opuser26 = 0 ;
float opuser27 = 0 ;
float opuser28 = 0 ;
float opuser29 = 0 ;
float opuser30 = 0 ;
float opuser31 = 0 ;
float opuser32 = 0 ;
float opuser33 = 0 ;
float opuser34 = 0 ;
float opuser35 = 0 ;
/* Do not use the following UserCVs. They are reserved for common purposes. */
float opuser36 = 0 ;
float opuser37 = 0 ;
float opuser38 = 0 ;
float opuser39 = 0 ;
float opuser40 = 0 ;
float opuser41 = 0 ;
float opuser42 = 0 ;
float opuser43 = 0 ;
float opuser44 = 0 ;
float opuser45 = 0 ;
float opuser46 = 0 ;
float opuser47 = 0 ;
float opuser48 = 0 ;

/********************************************************/
/*   Multi-Station cvs                                  */
/********************************************************/

int opnostations = 1 





;

int opstation = 1 





;

int oploadprotocol = 0 





;

int opmask = 0 





;

int opvenous = 0 





;

/* Added to indicate whether Procol/Scan mode -TAA */
int opprotRxMode = 0 





;

/********************************************************/
/*   Multi-Phase cvs				        */
/********************************************************/

int opacqo = 1 





;

int opfphases = PHASES_MIN 





;

int opsldelay = 50000 





;

int avminsldelay = 50000 





;

/* ECTRICKS CVS */
int optphases = PHASES_MIN 





;

int opdynaplan_nphases = 1 





;

int opvsphases = PHASES_MIN 





;

/********************************************************/
/*   EPI DWI/TENSOR cvs				        */
/********************************************************/

int opdiffuse = 0 






;

int opsavedf = 0 





;
	
int opmintedif = 1 





;

int opseparatesynb = 1 





;

int opdfaxx = 0;        /*   diffusion direction variables      */
int opdfaxy = 0;
int opdfaxz = 0;
int opdfaxall = 0;
int opdfaxtetra = 0;
int opdfax3in1 = 0;

int opbval = 0 





;

int opnumbvals = 1 





;

int opautonumbvals = 0 





;

int opnumsynbvals = MIN_NUM_SYNBVALS 





;

float opdifnext2 = 1 





;

int opautodifnext2 = 0 





;

int optensor = 0 





;

int opdifnumdirs = 1 





;

int opdifnumt2 = 1 





;

int opautodifnumt2 = 0 





;

int opdualspinecho = 0 





;

int opdifproctype = 0 





;

int opdifnumbvalues = 1 





;

int dti_plus_flag = 0 





;

/***********************************/
/*   MR-TOUCH CVs                  */
/***********************************/
int optouch = 0 






;

int optouchfreq = 60 





;

int optouchmegfreq = 60 





;

int optouchamp = 30 





;

int optouchtphases = 4 





;

int optouchcyc = 3 





;

int optouchax = 4 





;

/*********************
    Silenz-ASL CVs
 ********************/
int opaslprep = 0 






;
 
/* ********************
   3dASL CVs
   ********************/
int opasl = 0 






;
      
float oppostlabeldelay = 1525.0 






;

int rhchannel_combine_method = 0 






;

int rhasl_perf_weighted_scale = 32 






;

/* ****************************************
   Acoustic Reduction Technology (ART) CVs
   **************************************** */
float cfslew_artmedium = 2.0 





;

float cfgmax_artmedium = 3.3 





;

float cfslew_arthigh = 2.0 





;

float cfgmax_arthigh = 3.3 





;

int cfnumartlevels = 0 





;

int pinumartlevels = 0 





;

/*Two CV added for SV system*/
float cfslew_artmediumopt = 5.0 





;

float cfgmax_artmediumopt = 2.2 





;

/* *********************
   fMRI CVs
   ******************** */
int oprep_active = 1 





;

int oprep_rest = 1 





;

int opdda = 0 





;

int opinit_state = 0 





;

int opfMRIPDTYPE = SIMPLE_BLOCK 





;

int opview_order = 1 





;

int opslice_order = 0 





;

int oppsd_trig = 0 





;

int oppdgm_str = -1 





;

int opbwrt = 0 





;

int cont_flag = PSD_OFF 





;

/* *******************
   Scan Timing CVs 
   ******************* */

/* Show opnecho by default for all PSDs */
int opautonecho = 1 





;

int opnecho = 1 






;

int opnshots = 1 





;

int opautote = 0 





;

int opte = 25000 





;

int opte2 = 50000 





;

/* cv for Faster sequence TE selection */
int optefw = 0 





;

int opti = TI_MIN 





;

int opbspti = TI_MIN 






;

int opautoti = 0 





;

int opautobti = 0 





;

int optrecovery = TRECOVERY_MIN 





;

int optlabel = TLABEL_DEF 





;

int opt2prepte = 25000 





;

int opautotr = 0 





;

int opnspokes = 128 





;

float opoversamplingfactor = 1.0 





;

int opacs = 4 





;

int opharmonize = 0 






;

int pieffbladewidth = 1 





;

int opinrangetr = 0 





;

int opinrangetrmin = 160000 





;

int opinrangetrmax = 10000000 





;

int optr = 400000 





;

float opflip = 90 





;

int opautoflip = 0 





;

int opautoetl = 0 





;

int opetl = 8 





;

int opautorbw = 0 





;

/* oprbw is receive bw for echoes 2-4 for 1.5 T, receive bw for 1st echo
for 0.5 T */

float oprbw = 16.0 





;

float oprbw2 = 16.0 





;

/* *******************
   Scanning Range CVs 
   ******************* */		

float opfov = FOV_MAX 





;

float opphasefov = 1 





;

float opnpwfactor = 1.0 





;

float opfreqfov = 1 





;

int opautoslquant = 0 





;

int opslquant = 1 





;

int opsllocs = 1 





;

float opslthick = 5 





;

float opslspace = 10 





;

int opileave = 0 





;

/* 0 is non coaxial
   1 is coaxial through isocenter
   2 is coaxial not through isocenter */

int opcoax = 1 





;

float opvthick = 320 





;

int opvquant = 1 





;

int opovl = 0 





;

/* ***********************
   Graphic ROI CVs
   ********************** */

float oplenrl = 0 





;

float oplenap = 0 





;

float oplensi = 0 





;

float oplocrl = 0 





;

float oplocap = 0 





;

float oplocsi = 0 





;

float oprlcsiis = 1 





;

float opapcsiis = 2 





;

float opsicsiis = 3 





;

/* SmartPrep CVs */

float opmonfov = 200 





;

float opmonthick = 20 





;

float opinittrigdelay = 1000000 





;

/* ***********************
   Acquisition Time CVs 
   ********************** */

int opxres = 256 





;

int opyres = 128 





;

int opautonex = 0 





;

float opnex = 1 





;

int opslicecnt = 0 





;

int opnbh = 0 






;

int opspf = 0 





;

int opcfsel = 2 





;

int opfcaxis = 0 





;

int opphcor = 0 





;

float opdose = 0 





;

int opcontrast = 0 






;

/* ****************
   Regular CINE CVs 
   **************** */

int opchrate = 100 






;

int opcphases = 1 






;

int opaphases = 1 






;

int opclocs = 1 






;

/* **************
   Cardiac CVs 
   ************** */

int ophrate = 60 






;

int oparr = 10 





;

int ophrep = 1 





;

int opautotdel1 = 0 





;

int optdel1 = 20000 





;

int optseq = 1 





;

int opphases = 1 





;

int opcardseq = 0 





;

int opmphases = 0 





;

int oparrmon = 1 





;

int opvps = 8 





;

int opautovps = 0 





;

int opcgatetype = CARDIAC_GATE_TYPE_NONE 





;

int opadvgate = 0 





;

/* Fast CINE */
int opfcine = 0 






;

/* **************************
   CineIR CVs
   ************************** */
int opcineir = 0 





;

/* **************************
   STRESS/CREATIV Feature CVs
   ************************** */

/* CREATIV feature activation CV */
int opstress = 0 





;

/* Number of R-R Intervals */
int opnrr = 0 





;

/* DisDaqs for Monitor Mode */
int opnrr_dda = 8 





;

/* ********************
   Resp Trig CVs
   ******************** */

int oprtcgate = 0 






;

int oprtrate = 12 





;

int oprtrep = 1 





;

int oprttdel1 = 20000 





;

int oprttseq = 1 





;

int oprtcardseq = 0 





;

int oprtarr = 10 





;

int oprtpoint= 10 





;

/* ********************
 *    Navigator CVs
 * ******************** */

int opnavrrmeas = 0 





;

int opnavrrmeastime = 20 





;

int opnavrrmeasrr = 12 





;

int opnavsltrack = 0 





;

int opnavautoaccwin = 0 





;

float opnavaccwin = 2.0 





;

int opnavautotrigtime = 10 





;

int opnavpsctime = 10 





;

int opnavmaxinterval = 200 





;

int opnavtype = PSD_NAV_TYPE_90_180 





;

int opnavpscpause = 0 





;

int opnavsigenhance = 0 





;


int opasset = 0 





;

int opassetcal = 0 






;

int opassetscan = 0 






;

int rhcoilno = 0 





;

/* ******************************
   Bit patterns for rhcal_options
   ------------------------------
   bit 0 set for Ext 3D Cal;
   bit 1 set for Ext 2D Cal;
   bit 2 set for Int ACS Lines Cal;
   bit 3 set for Int 1st phase Cal;
   bit 4 set for Cache calibration;
   ********************************************* */
int rhcal_options = 0 





;

int rhasset = 0 





;

int rhasset_calthresh = 10000 





;

float rhasset_R = 0.5 





;

int rhasset_phases = PHASES_MIN 





;

float rhscancent = 0.0 





;

int rhasset_alt_cal = 0 






;

int rhasset_torso = 0 






;

int rhasset_localTx = 0 






;

float rhasset_TuningFactor = 15.0 






;

float rhasset_SnrMin = 15.0 






;

float rhasset_SnrMax = 75.0 






;

float rhasset_SnrScalar = 1.0 






;

/*
 * PURE cvs
 */
int oppure = 0 






;

int rhpure = 0 






; 

int oppurecal = 0 






;

int rhpurechannel = 0 






;

/*PURE filter selection*/ 
int rhpurefilter= 0 






;

float rhpure_scale_factor = 1.0 






;

int cfpure_filtering_mode = 1 






;

int rhpure_filtering_mode = 1 






;

float rhpure_lambda = 10.0 






;

float rhpure_tuning_factor_surface = 0.0 






;

float rhpure_tuning_factor_body = 1.0 






;

float rhpure_derived_cal_fraction = 0.0 






;

float rhpure_cal_reapodization = 12.0 






;

int opcalrequired = PSD_OFF 






;

int rhpure_blur_enable = 0 






;

float rhpure_blur = 0.0 






;

float rhpure_mix_lambda = 10.0 






;

float rhpure_mix_tuning_factor_surface = 0.0 






;

float rhpure_mix_tuning_factor_body = 1.0 






;

int rhpure_mix_blur_enable = 0 






;

float rhpure_mix_blur = 0.0 






;

float rhpure_mix_alpha = 0.0 






;

int rhpure_mix_otsu_class_qty = 2 






;

float rhpure_mix_exp_wt = 0.0 






;

int rhpure_mix_erode_dist = 0 






;

int rhpure_mix_dilate_dist = 0 






;

int rhpure_mix_aniso_blur = 0 






;

int rhpure_mix_aniso_erode_dist = 0 






;

int rhpure_mix_aniso_dilate_dist = 0 






;

int opcalmode = CAL_MODE_STANDARD 






;

int rhcalmode = 0 






;

int opcaldelay = 5000000 






;

int rhcal_pass_set_vector = 12 






;

int rhcal_nex_vector = 101 






;

int rhcal_weight_vector = 101 






;

int sifsetwokey = 0 





;

int opautosldelay = PSD_OFF 





;

/* *******************
    Spectroscopy CVs
   ******************* */
int specnuc = 1 






;

int specpts = 256 






;

int specwidth = 2000 






;

int specnavs = 1 






;

int specnex = 2 






;

int specdwells = 1 






;

int acquire_type = 0 






;

/* ********************
   Spectro Hardware 
   ******************** */

int pixmtband = AMP_ERBTEC 






;

int pibbandfilt = 0 






;


/* *********************
   Prescan CVs
   ********************* */

/* Flag for warm up mode CF prescan on Profile *//* MFO 10/16/98 YI */
int opwarmup = 0 





;

int pscahead = 0 





;

int opprescanopt = 0 





;

int autoadvtoscn = 0 





;

int opapa = 0 





;

int oppscapa = 0 





;

int PSslice_ind = 0 






; 

int oppscshimtg = 0 





;

int opdyntg = 0 





;

/*** DynTG ***/
float dynTG_fov = FOV_MAX 





;

int dynTG_slquant = 1 





;

float dynTG_flipangle = 60.0 





;

float dynTG_slthick = 10.0 





;

int dynTG_xres = 64 





;

int dynTG_yres = 64 





;

int dynTG_baseline = 0 





;

int dynTG_ptsize = 4 





;

float dynTG_b1factor = 1.0 





;

/*** RF Shim ***/
float rfshim_fov = FOV_MAX 





;

int rfshim_slquant = 1 





;

float rfshim_flipangle = 60.0 





;

float rfshim_slthick = 10.0 





;

int rfshim_xres = 64 





;

int rfshim_yres = 64 





;

int rfshim_baseline = 0 





;

int rfshim_ptsize = 4 





;

float rfshim_b1factor = 1.0 





;

/*** EXTCAL ***/
int cal_xres = 32 





;

int cal_yres = 32 





;

int cal_slq = 36 





;

int cal_nex = 2 





;

int cal_interleave = 0 





;

float cal_fov = FOV_MAX 





;

float cal_slthick = 15 





;

int cal_pass = 2 





;

/*** AUTOCOIL ***/
int coil_xres = 32 





;

int coil_yres = 32 





;

int coil_slq = 36 





;

int coil_nex = 2 





;

float coil_fov = FOV_MAX 





;

float coil_slthick = 15 





;

int coil_pass = 1 





;

int coil_interleave = 0 





;

/* *********************
   Autoshim CVs
   ********************* */
float asfov = FOV_MAX 





;

int asslquant = 1 





;

float asflip = 20 





;

float asslthick = 10 





;

int asxres = 256 





;

int asyres = 128 





;

int asbaseline = 8 





;

int asrhblank = 4 





;

int asptsize = 4 





;

int opascalcfov = 0 





;

/* ************************
   Transmit Gain CVs 
   ************************ */
float tgfov = FOV_MAX 





;

int tgcap = MAX_SYS_TG 





;

int tgwindow = MAX_SYS_TG 





;

/* ************************
   Multi-Volume Prescan CVs
   ************************ */

int oppscvquant = 0 





;

/* ************************
   Dual Drive CVs
   ************************ */
int opdrivemode = 1 





;

int pidrivemodenub = 7 





;

/* Excitation Mode CV */
int opexcitemode = 0 





;

/* ***************************
   Low power parameters  (GE)
   *************************** */
float lp_stretch = 2.0 






;

int lp_mode = 0 






;

float derateb1_body_factor = 1.0 






;

float SAR_bodyNV_weight_lim = 110.0 






;

float derateb1_NV_factor = 1.0 






;

float jstd_multiplier_body = 0.145 






;

float jstd_multiplier_NV = 0.0137 






;

float jstd_exponent_body = 0.763 






;

float jstd_exponent_NV = 1.154 






;


int pidiffmode = 0;

int pifmriscrn = 0; /* To control fmri screen */

/* pi values for spiral */
int piresol = 0 





;

int pioverlap = 0 





;

int piforkvrgf = 0;  /*  1 causes scan to spawn the vrgf process upon download */
int pinofreqoffset = 0; /*  1 disables fov offset in frequency direction */
/* Needed picvs for fmri */

int pirepactivenub = 0;
int pireprestnub = 0;
int piddanub = 0;
int piinitstatnub = 0;
int piviewordernub = 0;
int pisliceordnub = 0;
int pipsdtrignub = 0;

int pispssupnub = 1;  /* for water suppression button on Spectro Prescan UI */

/* **********************
   Lx: FMPVAS/FGRE CVs
   ********************** */
int pi_neg_sp = 0 





;

float piisvaldef = 2.0 





;

/* FGRE/2DMDE CV */
int pi2dmde = 0 





;

/* **********************
   Clock Operation CVs 
   ********************** */
int pidmode = 0 





;

int piviews = 0 





;

int piclckcnt = 1 





;

float avmintscan = 0.0 





;

float pitslice = 0.0 





;

float pitscan = 0.0 





;

/* ECTRICKS */
float pimscan = 0.0 





;

float pivsscan = 0.0 





;

/* AKR: Recon Lag Model output */
float pireconlag = -3.0 





;



float pitres = 0.0 





;

float pitres2 = 0.0 





;

/* **********************
   Image Creation CVs 
   ********************** */
int pisaveinter = 0 





;

int pivextras = 0 





;

int pinecho = 0 





;

/* *****************************
   TGT Needs for Table Position 
   ***************************** */
float piscancenter = 0.0 





;

float pilandmark = 0.0 





;

float pitableposition = 0.0 





;

/* ******************
   Service CVs
   ***************** */
int pismode = 0 





;

int pishldctrl = PSD_OFF 





;

int pinolr = PSD_ON 





;

int pinoadc = PSD_OFF 





;

int pimixtime = 0 





;

/* High order shim CVs */

int pishim2 = HO_SHIM_NO 





;

int pi1stshimb = HO_SHIM_1ST_BUTTON_ON 





;

/* Added for SNR Index */
float pifractecho = 1.0 





;

int nope = PSD_OFF 





;

/* *******************
   Custom Scan Schema CVs
   ****************** */
int opuser_usage_tag = 0x00000000 





;

int rhuser_usage_tag = 0x00000000 





;

int rhFillMapMSW = 0x00000000 





;

int rhFillMapLSW = 0x00000000 





;

/* *******************
   Recon Header CVs
   ****************** */
int rhbline = 0 





;

int rhblank = 4 





;

int rhnex  = 1 





;

int rhnavs = 1 





;

int rhnslices = 1 





;

int rhnrefslices = 0 





;

int rhnframes = 256 





;

int rhfrsize = 256 





;

int rhnecho = 1 





;

int rhnphases = 1 





;

int rhmphasetype = 0 





;

/* More bits may be added in the future*/
int rhtrickstype = 0 





;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   RHTYPCHP       1
   bit 0  Set if chopper data
   RHTYPCINE      2
   bit 1  Set if CINE
   RHTYPSHIM      4
   bit 2  Set if SHIM
   RHTYPGR        8
   bit 3  Set if GRASS
   RHTYPFRACTNEX  16
   bit 4  Set for fractional processing
   RHTYPSTRIP     32
   bit 5  Set for strip scan Y
   RHTYP3D        64
   bit 6  Set for 3-D processing
   RHTYPXOR       128
   bit 7  Set if exorcist
   RHTYPNPW       256
   bit 8  Set if NPW
   RHTYPNFW       512
   bit 9  Set if NFW
   RHTYPXSTRIP    1024
   bit 10 Set if strip scan X.
   RHTYPFRACTECHO 2048
   bit 12 No longer used.
   RHTYP75NEX     8192
   bit 13 Set if 3/4 nex.
   RHTYPPOMP      16384
   bit 14 Set if pomp
   RHTYPTURBO     32768
   ****************************** */
int rhtype = 0 





;

/* ********************************
   Bit patterns for rhtype1
   ------------------------------
   RHTYP1HOMODYNE      1
   bit 0  Unset (0) if regular recon, set (1) if homodyne recon
   RHTYP1NEXA          2
   bit 1  Set if nex table per echo is required
   RHTYP1CINEODDNEX    4
   bit 2  Set if odd NEX CINE
   RHTYP1SFRAME        8
   bit 3  Set if mulit-coil superframe
   RHTYP13DM           16
   bit 4  Set if 3D multi-slab
   RHTYP1MAXOVL        32
   bit 5 on, bit 6 off  Maximum intersity pixel collapse overlap processing
   RHTYP1MINOVL        64
   bit 5 off, bit 6 on  Minimum intersity pixel collapse overlap processing
   RHTYP1AVEOVL        96
   bit 5 on, bit 6 on   Average intersity pixel collapse overlap processing
   RHTYP1FPHASEOFF     128
   bit 7  Set for "fast phase off" in phase-contrast scans
   RHTYP1AUTOPASS      256
   bit 8  Set if automatic scan/pass detection scheme is enabled.  If set,
   *      then data acquisition will assert scan and pass packets based on
   *      frame counter limits.  These limits are set by:
   *      rhrefframes and rhrefframep for reference scan acquisitions
   *      rhscnframe and repasframe for other entry points (except prescan)
   RHTYP1IMGNEX        512
   bit 9
   RHTYP1SPIRAL        1024
   bit 10 Set if Spiral acquisition matrix
   RHTYP1FVRGF         2048
   bit 11 Set if Fast VRGF recon required
   RHTYP1RCALLPASS     4096
   bit 12 Set to instruct recon to allocate as many passes as possible
   *      in the BAM. BAM is also recycled in this case.
   RHTYP1LINE          8192
   RHTYP1LSDI          8192
   bit 13 Set to indicate Line Scan diffusion
   RHTYPECTRICKS       16384
   bit 14 Set for ECTRICKS reconstruction
   RHTYP1PCORVRGF      32768
   bit 15 Set so recon performs VRGF processing AFTER phase correction
   RHTYP10ROWENDS      65536
   bit 16 Set to zero out the ends of edges of kspace (fine line fix)
   RHTY1PRETRO_PC      131072
   bit 17 Set to do retrospective phase correction (FSE)
   RHTYP1BAM0FILL      262144
   bit 18 Set to zero-fill BAM before start of acquisition
   RHTYP13DGRADWARP    4194304
   bit 22 Set to 3d Gradwarp (0 off, 1 on) 
   ******************************** */
int rhtype1 = 0 





;

/* merged 55 bch into vmx.  YH  10/13/94 */
/* ******************************
   Bit patterns for rhformat
   -----------------------------
 RHF_NO_GRADWARP            1- bit 0 set if no grad warp is desired
 RHF_NO_FERMI               2- bit 1 set if no fermi filtering is desired
 RHF_ZCHOP                  4- bit 2 For 3D, set if RF is chopped Z-encode
 RHF_YCHOP                  8- bit 3 For 3D, set if RF is chopped on Y encode
 RHF_IIC                   16- bit 4 set if IIC (opscic == RHF_ON)
 RHF_CSI                   32- bit 5 set if acquiring spectroscopic data
 RHF_HS                    64- bit 6 set if epi dab packet is used
 RHF_SPECTRO              128- bit 7 set if acquiring non-CSI
                               spectroscopic data (Single voxel)
 RHF_IMAGE_CHECKSUM       256- bit 8 set if using image checksum
 RHF_NOREC_CHECKSUM       512- bit 9 set if using norec checksum
 RHF_GRADWARP_USE_FILE   1024- bit 10 set if using extern gradwarp file
 RHF_USE_FLIPTABLE       2048- bit 11 set if row flip file
                               (/usr/g/bin/rowflip.param) is used
 RHF_CERD_USE_FLIP_SSP   4096- bit 12 set if ??
 RHF_PSIR_CORRECTION     8192- bit 13 set if opphsen is set to 1
 RHF_SINGLE_PHASE_INFO  16384- bit 14 For > 1024 im/ser. Set if
                               data_acq_order table is filled only 
                               for a single phase in a multiphase scan.

   ********************************************* */
int rhformat = 0 





;

int rhptsize = 2 





;

int rhnpomp = 1 





;

/* ******************************
   Bit patterns for rhrcctrl
   ------------------------------
   bit 0 set for magnitude images   ; RHRCMAG  = 1
   bit 1 set for phase images       ; RHRCPHS  = 2
   bit 2 set for I magnitude images ; RHRCIMAG = 4
   bit 3 set for Q magnitude images ; RHRCQMAG = 8
   bit 4 set for compressed images  ; RHRCCOMP = 16
   bit 7 set for raw image recon    ; RHRCRAW  = 128
   changed for 7.0 from 17 to 1..gp
                                      RHRCGRID_ON           = 32
                                      RHRCSKIP_ALL_RECON    = 128
                                      RHRCSKIP_ROW_FFT      = 256
                                      RHRCSKIP_COL_FFT      = 512
                                      RHRCSKIP_HALF_FOURIER = 1024
                                      RHRCSKIP_FERMI        = 2048
                                      RHRCSKIP_NEX_SCALE    = 4096
                                      RHRCSKIP_IMAGE_SCALE  = 8192
                                      RHRCSKIP_3DJOB_FFT    = 16384
   ********************************************* */
int rhrcctrl = 1 





;

/* ******************************
   bit patterns for rhdacqctrl
   ----------------------------
   bit 0	0= NO_REC data, 1=RAW data
   bit 1	Set if even echo phase flip desired.
   bit 2	Set if odd echo phase flip desired.
   bit 3	Set if even echo frequency flip desired.
   bit 4	Set if odd echo frequency flip desired.
   bit 5	Set if RAW collection without DAB SSP packets is desired.
   bit 6	Set if RAW collection should wrap around to the top of the
		buffer if overflow occurs.
   bit 10       set if fcine echotrain data acq. mode is used.
                RH_FCINE_ET = 1024
   bit 11       Set if passthrough data acq. mode is used.; 
                                          RH_PASS_THROUGH_CERD_FLAG = 2048
   ********************************************* */
int rhdacqctrl = 2 





;

/* ******************************
   bit patterns for rhexecctrl
   ------------------------------
RHXC_AUTO_DISPLAY               1- Set if Auto display desired
RHXC_AUTO_LOCK                  2- Set if auto lock of raw/no_rec files desired
RHXC_AUTO_LOCK_ALLRECS          4- Set if auto lock of all recs desired
RHXC_XFER_IM                    8- Set if images should be transferred to disk
RHXC_SAVE_IM                    16- Set if images should be saved in BAM memory
RHXC_TAPE_LOCK                  32- Don't use
RHXC_INTERMEDIATE               64- Set if intermediate multi coil images
                                    are to be saved
RHXC_OVERRIDE_BROADCAST         128
RHXC_OVERRIDE_IMG_INSTALL       256
RHXC_OVERRIDE_AUTODISPLAY       512
RHXC_RTD_XFER_IM_REMOTE         1024
RHXC_RTD_SCAN                   2048
RHXC_REF_SCAN                   4096
RHXC_DONT_WRITE_OR_INSTALL      8192
RHXC_RTD_XFER_ALL_IM_PER_PASS   16384
RHXC_XFER_IMG_RIR               32768

 * ********************************************** */
int rhexecctrl = (RHXC_AUTO_DISPLAY | RHXC_XFER_IM) 





;

/* *********************************
   bit patterns for FEEDER control
   ---------------------------------
   bit 0	0= feed DAB, 1= feed filters.
   bit 1	0= locked, 1= unlocked
   bit 2	0= see bit 1, 1= use algorithm
   bit 3	Set if timing simulation desired
 * ********************************************** */
int rhfdctrl = 0 





;

float rhxoff = 0.0 





;

float rhyoff = 0.0 





;

int rhrecon = 0 





;

int rhdatacq = 0 





;

int rhvquant = 0 





;

int rhslblank = 2 





;

int rhhnover = 0 





;

/* RV: Needed for IDEAL minTE processing */
int rhfeextra = 0 





;

int rhheover = 0 





;

int rhoscans = 0 





;

int rhddaover = 0 





;

float rhzeroph = 128.5 





;

float rhalpha = 0.46 





;

float rhnwin = 0.0 





;

float rhntran = 2.0 





;

int rhherawflt = 0 





;

float rhherawflt_befnwin = 1.0 





;

float rhherawflt_befntran = 2.0 





;

float rhherawflt_befamp = 1.0 





;

float rhherawflt_hpfamp = 1.0 





;

float rhfermw = 10.0 





;

float rhfermr = 128.0 





;

float rhferme = 1.0 





;

float rhclipmin = 0.0 





;

float rhclipmax = 16383.0 





;

float rhdoffset = 0.0 





;

int rhudasave = 0 





;

int rhsspsave = 0 





;

float rh2dscale = 1.0 





;
 
float rh3dscale = 1.0 





;
 
int rhnpasses = 1 





;

int rhincrpass = 1 





;

int rhinitpass = 1 





;

int rhmethod = 0 





;

int rhdaxres = 256 





;

int rhdayres = 256 





;

int rhrcxres = 256 





;

int rhrcyres = 256 





;

int rhimsize = 256 





;

int rhnoncart_dual_traj = 0 





;

int rhnoncart_traj_kmax_ratio = 8 






;

int rhnspokes_lowres = 8192 






;

int rhnspokes_highres = 8192 






;

int rhnoncart_traj_merge_start = 3 






;

int rhnoncart_traj_merge_end = 5 






;

float rhoversamplingfactor = 1.0 





;

float rhnoncart_grid_factor = 2.0 





;

int rhnoncart_traj_mode = RADIAL3D_TRAJECTORY_MODE_MIN 





;

int rhviewSharing3D = 0 





;

int rhdaviewsPerBlade = 24 





;

float rhrotationThreshold = 2.0 





;

float rhshiftThreshold = 0.01 





;

float rhcorrelationThreshold = 0.50 





;

float rhphaseCorrFiltFreqRadius = 1.0 





;

float rhphaseCorrFiltPhaseRadius = 1.0 





;

float rhnpwfactor = 1.0 





;





float rhuser0  = 0 ;
float rhuser1  = 0 ;
float rhuser2  = 0 ;
float rhuser3  = 0 ;
float rhuser4  = 0 ;
float rhuser5  = 0 ;
float rhuser6  = 0 ;
float rhuser7  = 0 ;
float rhuser8  = 0 ;
float rhuser9  = 0 ;
float rhuser10 = 0 ;
float rhuser11 = 0 ;
float rhuser12 = 0 ;
float rhuser13 = 0 ;
float rhuser14 = 0 ;
float rhuser15 = 0 ;
float rhuser16 = 0 ;
float rhuser17 = 0 ;
float rhuser18 = 0 ;
float rhuser19 = 0 ;
float rhuser20 = 0 ;
float rhuser21 = 0 ;
float rhuser22 = 0 ;
float rhuser23 = 0 ;
float rhuser24 = 0 ;
float rhuser25 = 0 ;
float rhuser26 = 0 ;
float rhuser27 = 0 ;
float rhuser28 = 0 ;
float rhuser29 = 0 ;
float rhuser30 = 0 ;
float rhuser31 = 0 ;
float rhuser32 = 0 ;
float rhuser33 = 0 ;
float rhuser34 = 0 ;
float rhuser35 = 0 ;
float rhuser36 = 0 ;
float rhuser37 = 0 ;
float rhuser38 = 0 ;
float rhuser39 = 0 ;
float rhuser40 = 0 ;
float rhuser41 = 0 ;
float rhuser42 = 0 ;
float rhuser43 = 0 ;
float rhuser44 = 0 ;
float rhuser45 = 0 ;
float rhuser46 = 0 ;
float rhuser47 = 0 ;
float rhuser48 = 0 ;

int rhdab0s = 0 





;

int rhdab0e = 0 





;

float rhctr = 1.0 





;

float rhcrrtime = 1.0 





;

int rhcphases = 1 





;

int rhaphases = 1 





;

int rhovl = 0 





;

/* **********************************
   Vascular Recon CVs 
   ********************************** */

/* **********************************
   Vascular Recon Types
   1: vascular
   2: phase contrast scan
   4: unused
   8: 2 set processing
   16: anti alias algorithm
   32: phase contrast bit 1
   64: phase contrast bit 2
   128: apply noise suppression mask
   256: display magnitude image
   512: display physical x location
   1024: display physical y location
   2048: display physical z location
   4096: collapse logical z
   8192: collapse logical x
   16384: collapse logical y
   32768: vinnie 1 slice, 2 set
   65536: vinnie 1 slice, 4 set
   131072: vinnie 2 slice, 2 set
   ****************************************** */
int rhvtype = 0 





;

float rhvenc = 0.0 





;

float rhvcoefxa = 0.0 





;

float rhvcoefxb = 0.0 





;

float rhvcoefxc = 0.0 





;

float rhvcoefxd = 0.0 





;

float rhvcoefya = 0.0 





;

float rhvcoefyb = 0.0 





;

float rhvcoefyc = 0.0 





;

float rhvcoefyd = 0.0 





;

float rhvcoefza = 0.0 





;

float rhvcoefzb = 0.0 





;

float rhvcoefzc = 0.0 





;

float rhvcoefzd = 0.0 





;

/* The following are flow to static translation for phase contrast 
   scans if the phase correction bits are set or noise suppression or display
   magnitude bits are set. */

float rhvmcoef1 = 0.0 





;

float rhvmcoef2 = 0.0 





;

float rhvmcoef3 = 0.0 





;

float rhvmcoef4 = 0.0 





;

/* *********************
   Asymmetric FOV cvs
   ********************* */
float rhphasescale = 1.0 





;

float rhfreqscale = 1.0 





;

/* Raw image recon */
int rawmode = 0 





;
						   
/* ****************************
   Reference Scan/EPI recon cvs
   **************************** */

int rhileaves = 1 





;

int rhkydir = 0 





;

int rhalt = 0 





;

int rhreps = 1 





;

int rhref = 1 





;

/****************************************/
/* EPI Phase Correction recon header CVs */
/****************************************/

int rhpcthrespts = 2 





;

int rhpcthrespct = 15 





;

int rhpcdiscbeg = 0 





;

int rhpcdiscmid = 0 





;

int rhpcdiscend = 0 





;

int rhpcileave = 0 





;

int rhpcextcorr = 0 





;

int rhrefframes = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcsnore = 0 





;
                                     
int rhpcspacial = 0 





;

int rhpctemporal = 0 





;

float rhpcbestky = 64.0 





;

int rhhdbestky = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcinvft = 0 





;

int rhpcctrl = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpctest = 0 





;

int rhpcgraph = 0 





;

int rhpclin = 0 





;

int rhpclinnorm = 0 





;

int rhpclinnpts = 0 





;

int rhpclinorder = 2 





;

int rhpclinfitwt = 0 





;

int rhpclinavg = 0 





;

int rhpccon = 0 





;

int rhpcconnorm = 0 





;

int rhpcconnpts = 2 





;

int rhpcconorder = 2 





;

int rhpcconfitwt = 0 





;

/****************************************/
/* VRGF recon header CVs */
/****************************************/
 
int rhvrgfxres = 128 





;

int rhvrgf = 0 





;

/****************************************/
/* Bandpass correction recon header CVs */
/****************************************/
 
int rhbp_corr = 0 





;

float rhrecv_freq_s = 0.0 





;

float rhrecv_freq_e = 0.0 





;

int rhhniter = 0 





;

int rhfast_rec = 0 





;


/*************************************/
/* Spiral gridding recon related CVs */
/*************************************/
int rhgridcontrol = 0 





;

int rhb0map = 0 





;

int rhtediff = 0 





;

float rhradiusa = 0 





;

float rhradiusb = 0 





;

float rhmaxgrad = 0.0 





;

float rhslewmax = 0.0 





;

float rhscanfov = 0.0 





;

float rhtsamp = 0.0 





;

float rhdensityfactor = 0.0 





;

float rhdispfov = 0.0 





;

int rhmotioncomp = 0 





;

int grid_fov_factor = 2 





;

/***************************************/
/* Dynamic Frequency Monitor Recon CVs */
/***************************************/

int rhte = 25000 





;

int rhte2 = 50000 





;

int rhdfm = 0 





;

int rhdfmnavsperpass = 1 





; 

int rhdfmnavsperview = 1 





;

float rhdfmrbw = 4.0 





;

int rhdfmptsize = 2 





;

int rhdfmxres = 32 





;

int rhdfmdebug = 0 





;

float rhdfmthreshold = 0.0 





;

/* Following CVs are Added for Image Enhance */
int rh_rc_enhance_enable = 0 





;

int rh_ime_scic_enable = 0 





;

float rh_ime_scic_edge = 0.0 





;

float rh_ime_scic_smooth = 0.0 





;

float rh_ime_scic_focus = 0.0 





;

int rh_ime_clariview_type = 0 





;

float rh_ime_clariview_edge = 0.0 





;

float rh_ime_clariview_smooth = 0.0 





;

float rh_ime_clariview_focus = 0.0 





;

int rh_ime_definefilter_nr = 0 





;

int rh_ime_definefilter_sh = 0 





;

float rh_ime_scic_reduction = 0.0 





;

float rh_ime_scic_gauss = 0.0 





;	

float rh_ime_scic_threshold = 0.0 





;

float rh_ime_scic_contrast = 0.0 





;

int cfscic_allowed = 1 





;

float cfscic_edge = 0.0 





;

float cfscic_smooth = 0.0 





;

float cfscic_focus = 0.0 





;

float cfscic_reduction = 0.0 





;

float cfscic_gauss = 0.0 





;	

float cfscic_threshold = 0.0 





;

float cfscic_contrast = 0.0 





;

int piscic = 0 





;

/* CVs for SCENIC filter */
int cfscenic = 0 





;

int piscenic = 0 





;

int opscenic = 0 





;

int rhscenic_type = 0 





;

/* cf CVs for ITK N4 */
int cfn4_allowed = 1 





;

float cfn4_slice_down_sample_rate = 1.0 





;

float cfn4_inplane_down_sample_rate = 0.15 





;

int cfn4_num_levels_max = 4 





;

int cfn4_num_iterations_max = 50 





;

float cfn4_convergence_threshold = 0.001 





;

int cfn4_gain_clamp_mode = 0 





;

float cfn4_gain_clamp_value = 5.0 





;

/* rh CVs for ITK N4 */
float rhn4_slice_down_sample_rate = 1.0 





;

float rhn4_inplane_down_sample_rate = 0.15 





;

int rhn4_num_levels_max = 4 





;

int rhn4_num_iterations_max = 50 





;

float rhn4_convergence_threshold = 0.002 





;

int rhn4_gain_clamp_mode = 0 





;

float rhn4_gain_clamp_value = 5.0 





;

/* rh CVs for PURE gain clamp*/
int rhpure_gain_clamp_mode = 0 





;

float rhpure_gain_clamp_value = 5.0 





;

/* For PSMDE feature */
int rhphsen_pixel_offset = 0 





;

/* For SCIC++ Feature */

int rhapp = 0 






;

int rhapp_option = 0 






;

/* For N-coil selection routines in recon */

int rhncoilsel = 0 






;

int rhncoillimit = 45 






;

int rhrefframep = 0 






;

int rhscnframe = 0 






;

int rhpasframe = 0 






;

int rhpcfitorig = 1 






;

int rhpcshotfirst = 0 






;

int rhpcshotlast = 0 






;

int rhpcmultegrp = 0 






;

int rhpclinfix = 1 






;

float rhpclinslope = 0.0 






;

int rhpcconfix = 1 






;

float rhpcconslope = 0.0 






;

int rhpccoil = 1 






;

float rhmaxcoef1a = 0 






;

float rhmaxcoef1b = 0 






;

float rhmaxcoef1c = 0 






;

float rhmaxcoef1d = 0 






;

float rhmaxcoef2a = 0 






;

float rhmaxcoef2b = 0 






;

float rhmaxcoef2c = 0 






;

float rhmaxcoef2d = 0 






;

float rhmaxcoef3a = 0 






;

float rhmaxcoef3b = 0 






;

float rhmaxcoef3c = 0 






;

float rhmaxcoef3d = 0 






;

int rhdptype = 0 






;

int rhnumbvals = 1 





;

int rhdifnext2 = 1 





;

int rhnumdifdirs = 1 





;

int rhutctrl = 0 






;

float rhzipfact = 0 






;

int rhfcinemode = 0 






;

int rhfcinearw = 10 






;

int rhvps = 8 






;

int rhvvsaimgs = 1 






;

int rhvvstr = 0 






;

int rhvvsgender = 0 






;

/* to get opgradmode value into the raw header */
int rhgradmode = 0;

int rhfatwater = 0 






;

int rhfiesta = 0 






;

int rhlcfiesta = 0 






;

float rhlcfiesta_phase = 0.0 






;

/* *************************************************
   Recon Header CVs for Navigator Echo Correction on DW-EPI
   ************************************************ */
int rhdwnavview = 0 






;

int rhdwnavcorecho = 2 






;

int rhdwnavsview = 1 






;

int rhdwnaveview = 1 






;

int rhdwnavsshot = 1 






;

int rhdwnaveshot = 2 






;

float rhdwnavcoeff = 0.5 






;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   bit 0  Set if navigator echo correction is on
   bit 1  Set if phase shifted navigator echo correction is on
   ****************************** */
int rhdwnavcor = 0 






;

/* Added new CVs for Slice ASSET */ 
float rhassetsl_R = 1.0 






;

float rhasset_slwrap = 0.0 






;

/* Added new CVs for FIESTA - C */

int rh3dwintype = 0 






;

float rh3dwina = 0.1 






;

float rh3dwinq = 0.0 






;

/* Recon Header CV's for TRICKS recon */
int rhectricks_num_regions = 0;

int rhectricks_input_regions = 0;

/* ************************************************* */
/* HFO3 merge 02/18/2003 YI */
/* FSE retrospective phase correction - RDP
   Bit patterns for rhretro_control
   ---------------------------------
   bit 0 set for Ahn/Cho fitting method
   bit 1 set for Least Squares fitting method
   bit 2 set for zeroth-order coefficient correction
   bit 3 set for first-order coefficient correction
   bit 4 set for one extra etl reference set
   bit 5 set for second extra etl reference set
   ***************************************************** */
int rhretro_control = 0 






;

int rhetl = 0 






;

/* RDP - rh CVs for fine line correction */
int rhleft_blank = 0 






;

int rhright_blank = 0 






;


/* Standardize spectroscopy recon header variables */

float rhspecwidth = 0.0 






;

int rhspeccsidims = 0 






;

int rhspecrescsix = 0 






;

int rhspecrescsiy = 0 






;

int rhspecrescsiz = 0 






;

float rhspecroilenx = 0.0 






;

float rhspecroileny = 0.0 






;

float rhspecroilenz = 0.0 






;

float rhspecroilocx = 0.0 






;

float rhspecroilocy = 0.0 






;

float rhspecroilocz = 0.0 






;

int rhexciterusage = 1 






;

int rhexciterfreqs = 1 






;

/* rh values for MART deblurring (NDG) */
int rhwiener = 0 





;

float rhwienera = 0.0 





;

float rhwienerb = 0.0 





;

float rhwienert2 = 0.0 





;

float rhwieneresp = 0.0 





;

int rhflipfilter = 0 





;

int rhdbgrecon = 0 





;

int rhech2skip = 0 





;

/* Recon header CVs for IDEAL processing */
/*----------------------------------------------------------------*/
/* Bit pattern for rhrcideal
bit 0 used for turning on/off IDEAL processing
bit 1 used for turning on/off IDEAL half-nex processing
bit 2 used for turning on/off IDEAL half-echo processing
bit 3 is on to indicate reversal of echo2 and echo3 order to recon
bit 4 is on to indicate that minTE is Rx'ed; this prompts recon to
center the echo in the readout direction during zero-filled recon
bit 5 used for turning on/off T2* correction
bit 6 used for turning on/off multi peak processing
bit 7 used for turning on/off magnitude based fitting
----------------------------------------------------------------*/
int rhrcideal = 0 






;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcdixproc
bit 0 is ON by default, indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
bit 8 used for indicating water fraction image to be reconstructed
bit 9 used for indicating water image before correction to be reconstructed
bit 10 used for indicating fat image before correction to be reconstructed
bit 11 used for indicating in-phase image before correction to be reconstructed
bit 12 used for indicating out-of-phase image before correction to be reconstructed
bit 13 used for indicating field map image before correction to be reconstructed
bit 14 used for indicating fat fraction image before correction to be reconstructed
bit 15 used for indicating water fraction image before correction to be reconstructed
bit 16 used for indicating the coil combined complex images to be reconstructed
----------------------------------------------------------------*/
int rhrcdixproc = 0 







;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcidealctrl
bit 0 used for dumping the raw data that is going to be used by IDEAL
bit 1 used for loading the raw data that is going to be used by IDEAL
bit 2 used for controlling IDEAL output before post-checker
bit 3 used for controlling IDEAL output after post-checker
bit 4 used for controlling the gradwarp operation that will be performed on each image before we perform the receiver combined
This operation is expensive but takes us closer the host recon implementation
bit 5 used for storing the data in shorts that will be used by IDEAL. This saves BAM as data is in BAM 
bit 6 used for performing IDEAL processing on receiver-combined images
bit 7 used for peforming clipping operation on the images that will be used by IDEAL
bit 8 used for performing gradwarp after receiver combine operation
bit 9 used for calling a function that does a chopper operation and a scaling  
bit 10 used for turning on/off post processing
bit 11 used for disabling chemical shift
bit 12 used for debugging image numbering
bit 13 used for disabling new finding CF
bit 14 used to reverse frequency axis direction
bit 15 used to reverse phase axis direction
bit 16 used to reverse homodyne
bit 17 used to reverse frequency direction
bit 18 used for generic debug
bit 19 used to choose type of multi-peak processing. 0:pre cal 1:self cal
----------------------------------------------------------------*/
int rhrcidealctrl = 0 







;

int rhdf = FATWATER_DIXFREQ_1_5T 





;

int rhmedal_mode = 0 






;

int rhmedal_nstack_size = 54 






;

int rhmedal_echo_order = 0 






;

int rhmedal_up_kernel_size = 15 






;

int rhmedal_down_kernel_size = 8 






;

int rhmedal_smooth_kernel_size = 8 






;

int rhmedal_starting_slice = 0 






;

int rhmedal_ending_slice = 10 






;

float rhmedal_param = 3.0 






;

int rhvibrant = 0 






;

int rhkacq_uid = 0 






;

/* NEX for unacquired encodes for when zero-fill BAM is enabled */
int rhnex_unacquired = 1 





;

/* Acquisition to Disk Control Bitmask
   Bit 0 (=1) is used to enable/disable acquisition to disk feature
   Bit 1 (=2) is used to capture raw frame and control data to disk
*/
int rhdiskacqctrl = 0 






;

/* IDEAL IQ Phase Correction Recon Header CV */
int rhechopc_extra_bot = 0 






;

int rhechopc_ylines = 0 






;

int rhechopc_primary_yfirst = 0 






;

int rhechopc_reverse_yfirst = 0 






;

int rhechopc_zlines = 0 






;

int rhechopc_yxfitorder = 1 






;

int rhechopc_ctrl = 0 






;

int rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_NONE 






;

float rhchannel_combine_filter_width = 0.3 






;

float rhchannel_combine_filter_beta = 2 






;

float rh_low_pass_nex_filter_width = 8.0 





;

int rh3dgw_interptype = 0 






;

/* 3dcine recon control bitmap */
int rhrc3dcinectrl = 0 






;

/* recon cv for total num of cardiac cycles in 3dcine */
int rhncycles_cine = 0 






;

/* recon cv for virtual coil channels with coil compression */
int rhnvircchannel = 0 






;

/* ********************************
   Bit patterns for rhrc_cardt1map_ctrl 
   ------------------------------
   bit 0  Set if T1 mapping recon mode is on
   bit 1  Set on = IR Prep (2), off = SR Prep (0)
   bit 2  Set on = TI must be updated in recon, off = skip update in recon,
          after recon, on = successful update, off = failed update
   ****************************** */
int rhrc_cardt1map_ctrl  = 0 






;

/* ********************************
   Bit patterns for rhrc_moco_ctrl
   ------------------------------
   bit 0  Set on = recon must apply motion correction, off = no MoCo      
          after recon, on = successful motion correction. off = failed MoCo
   ****************************** */
int rhrc_moco_ctrl  = 0 






;


/* ********************************
   Bit patterns for rhrc_algorithm_ctrl
   ------------------------------
   bit 0  Asset Custom Tuning 	Set on = 1 , off = 0      
   ****************************** */
int rhrc_algorithm_ctrl  = 0 






;

/* ******************
   Image header CVs
   ****************** */
int ihtr = TR_MIN 





;

int ihti = 0 





;

int ihtdel1 = MIN_TDEL1 





;

float ihnex = 1 





;

float ihflip = 90 





;

int ihte1 = 0 





;

int ihte2 = 0 





;

int ihte3 = 0 





;

int ihte4 = 0 





;

int ihte5 = 0 





;

int ihte6 = 0 





;

int ihte7 = 0 





;

int ihte8 = 0 





;

int ihte9 = 0 





;

int ihte10 = 0 





;

int ihte11 = 0 





;

int ihte12 = 0 





;

int ihte13 = 0 





;

int ihte14 = 0 





;

int ihte15 = 0 





;

int ihte16 = 0 





;

int ihdixonte = 0 





;

int ihdixonipte = 0 





;


int ihdixonoopte = 0 





;

float ihvbw1 = 16.0 





;

float ihvbw2 = 16.0 





;

float ihvbw3 = 16.0 





;

float ihvbw4 = 16.0 





;

float ihvbw5 = 16.0 





;

float ihvbw6 = 16.0 





;

float ihvbw7 = 16.0 





;

float ihvbw8 = 16.0 





;

float ihvbw9 = 16.0 





;

float ihvbw10 = 16.0 





;

float ihvbw11 = 16.0 





;

float ihvbw12 = 16.0 





;

float ihvbw13 = 16.0 





;

float ihvbw14 = 16.0 





;

float ihvbw15 = 16.0 





;

float ihvbw16 = 16.0 





;

int ihnegscanspacing = 0 






;

int ihoffsetfreq = 1200 






;

int ihbsoffsetfreq = 4000 






;

int iheesp = 0 






;

int ihfcineim = 0 






;

int ihfcinent = 0 






;

int ihbspti = TI_MIN 






;

float ihtagfa = 180.0 






;

float ihtagor = 45.0 






;

/* RV: IDEAL debug ihCV's */
float ih_idealdbg_cv1 = 0 ;
float ih_idealdbg_cv2 = 0 ;
float ih_idealdbg_cv3 = 0 ;
float ih_idealdbg_cv4 = 0 ;
float ih_idealdbg_cv5 = 0 ;
float ih_idealdbg_cv6 = 0 ;
float ih_idealdbg_cv7 = 0 ;
float ih_idealdbg_cv8 = 0 ;
float ih_idealdbg_cv9 = 0 ;
float ih_idealdbg_cv10 = 0 ;
float ih_idealdbg_cv11 = 0 ;
float ih_idealdbg_cv12 = 0 ;
float ih_idealdbg_cv13 = 0 ;
float ih_idealdbg_cv14 = 0 ;
float ih_idealdbg_cv15 = 0 ;
float ih_idealdbg_cv16 = 0 ;
float ih_idealdbg_cv17 = 0 ;
float ih_idealdbg_cv18 = 0 ;
float ih_idealdbg_cv19 = 0 ;
float ih_idealdbg_cv20 = 0 ;
float ih_idealdbg_cv21 = 0 ;
float ih_idealdbg_cv22 = 0 ;
float ih_idealdbg_cv23 = 0 ;
float ih_idealdbg_cv24 = 0 ;
float ih_idealdbg_cv25 = 0 ;
float ih_idealdbg_cv26 = 0 ;
float ih_idealdbg_cv27 = 0 ;
float ih_idealdbg_cv28 = 0 ;
float ih_idealdbg_cv29 = 0 ;
float ih_idealdbg_cv30 = 0 ;
float ih_idealdbg_cv31 = 0 ;
float ih_idealdbg_cv32 = 0 ;

/* 3dASL CVs for dicom header  */
int ihlabeltime = 0 






;

int ihpostlabeldelay = 0 






;

int ihnew_series = 0 






;

/* Heartbeat pattern for cardiac T1 mapping */
int ihcardt1map_hb_pattern = 0 






;

/* added for Multiple dB/dt Operation Modes - March 25, 2001 */

int dbdt_option_key_status = 0 






;

int dbdt_mode = 0 






;

int opsarmode = 0 






;

int cfdbdttype = 0 






;

float cfrinf = 23.4 






;

int cfrfact = 334 






;

float cfdbdtper_norm = 80.0 






;

float cfdbdtper_cont = 100.0 






;

float cfdbdtper_max = 200.0 






;


/* AKR Recon Lag Model input Parameters */

int cfnumicn = 1 






;  

int cfdppericn = 4 






;

/* ***********************
   System configuration CVs
   *********************** */

int cfgradcoil = 2;  /* Indicate gradient coil type : 1:CRD 2:Roemer
                        101:HGC 102:Vectra 103:Permanent */

/* dynamic Gradient Digitization Period CVs */
int cfswgut    = 4;
int cfswrfut   = 2;
int cfswssput  = 1;
                             
int cfhwgut    = 4;
int cfhwrfut   = 2;
int cfhwssput  = 1;

int cfoption = SEC_CODE_INIT 






;


/******************** 03/06/2003 YI  for DCERD support
 * RF Board Type
 *  0 : Remote RF
 *  1 : DCERD
 *******************/
int cfrfboardtype = RF_BOARD_RRF 






;

/* psd_board_type is the set of SSP commands to use for the current
 * hardware architecture.  For hardware introduced for DVMR, use
 * PSDDVMR.  For hardware introduced for 10.0-14.0, use PSDCERD */
int psd_board_type = PSDDVMR 






;

/* ********************************
   Dynamic Frequency Monitoring CVs
   ******************************** */
int opdfm         = 0 






;

int opdfmprescan  = 0 






;

int  cfdfm   =  0  






;

int  cfdfmTG = 70  






;

int  cfdfmR1 = 13  






;

int  cfdfmDX = 0   






;

/* For ACGD Compensation Feature */
int derate_ACGD = 0 






;

/* rh cvs for EPI internal ref scan */ 
int rhextra_frames_top = 0 






;

int rhextra_frames_bot = 0 






;

int rhpc_ref_start = 0 






;
int rhpc_ref_stop = 0 






;

int rhpc_ref_skip = 0 






;

int opaxial_slice=0 






;

int opsagittal_slice =0 






;

int opcoronal_slice=0 






;

int opvrg = 0 






;

int opmart = 0 






;

int piassetscrn = 0 






;

/*For multistation no. of station */
int opseriessave = 0 






;

/* T1Map CV */
int opt1map = 0 






;

/* T2Map CV */
int opt2map = 0 






;

/* R2* CV */
int opmer2 = 0 






;

/* New RH CVs for New WW/WL algorithm used by RECON */
int rhnew_wnd_level_flag = 1 






;

int rhwnd_image_hist_area = 60 






;

float rhwnd_high_hist = 1.0 






;

float rhwnd_lower_hist = 1.0 






;

/*DLH, New RH variables for MAVRIC-SL*/
int rhrcmavric_control = 0 






;
/*Definitions of rhrcmavric_control(Debugging and Research):
 *rhrcmavric_control bit 0: MAVRIC Recon ON/OFF
 *rhrcmavric_control bit 1: MAVRIC Recon with De-Blurring Algorithm
 *rhrcmavric_control bit 2: MAVRIC Recon with Jocobian Algorithm
 */
int rhrcmavric_image = 0 






;
/*Definitions of rhrcmavric_image(Debugging and Research):
 * rhrcmavric_image bit 0:    Echo Images (Bin Images)
 * rhrcmavric_image bit 1:    SOS Corrected Images (Default)
 * rhrcmavric_image bit 2:    Initial SOS Images
 * rhrcmavric_image bit 3:    FieldMap Image
 * rhrcmavric_image bit 4:    Threshold FieldMap Image
 * rhrcmavric_image bit 5:    FieldMap Blurred Image
 * rhrcmavric_image bit 6:    Gradient Ratio Image
 * rhrcmavric_image bit 7:    Blurred Gradient Ratio Image
 * rhrcmavric_image bit 8:    Capped & Normalized Blurred Gradient Map
 * */
int rhrcmavric_bin_separation = 1000 






;

/* New RF related Definitions.*/
int cfrfupa = -50 






;

int cfrfupd = 50 






;

int cfrfminblank = 200 






;

int cfrfminunblk = 200 






;

int cfrfminblanktorcv = 50 






;

float cfrfampftconst = 0.784 






;

float cfrfampftlinear = 0.0 






;

float cfrfampftquadratic = 15.125 






;

int opradialrx = 0 





;

int cfsupportreceivefreqbands = 0 






;

float cfcntfreefreqlow = 0.0 






;

float cfcntfreefreqhigh = 10000.0 






; 


int optracq = 0 






;

/* Additions for SWIFT */
int opswift = 0 






;

int rhswiftenable = 0 





;

int rhnumCoilConfigs = 0 





;

int rhnumslabs = 1 





;

/* The number of coil configurations in coilInfo and volRecCoilInfo */
int opncoils = 1 





;

/* New cvs for RT SAR Feature Move to @reqcv from @reqexport */
/* New cvs for RT SAR Feature */

int rtsar_first_series_flag = 0 





;

int rtsar_enable_flag = 0 





;

int measured_TG = -1 





;

int predicted_TG = -1 





;

float sar_correction_factor = 1.0 





;

int gradHeatMethod = PSD_OFF 






;

int gradHeatFile = PSD_OFF 






;

int gradCoilMethod = GRADIENT_COIL_METHOD_AUTO  






;

int gradHeatFlag = PSD_OFF 






;

int xgd_optimization = PSD_ON 






;

int gradChokeFlag = PSD_OFF 






;

/* Burst Mode */
int piburstmode = PSD_OFF 






;

int opburstmode = PSD_OFF 






;

int burstreps = 1 






;

float piburstcooltime = 0.0 






;

/* Parallel Imaging UI */
float opaccel_ph_stride = 1.0 






;

float opaccel_sl_stride = 1.0 






;

float opaccel_t_stride = 1.0 






;

int opaccel_mb_stride = 2 






;

/* Multiband on/off flag */
int opmb = PSD_OFF 






;

/* recon cv for Multiband slice acceleration factor */
int rhmb_factor = 1 






;


/* recon cv for Multiband blipped Slice FOV shift */
int rhmb_slice_fov_shift_factor = 1 






; 

/* recon cv for Multiband Slice Order Sign */
int rhmb_slice_order_sign = 1 






; 

/* recon cv for Muse */
int rhmuse = 0 






; 

/* recon cv for Muse with phase mapping second echo */
int rhmuse_nav = PSD_OFF 






; 

/* recon cv for Muse with phase acceleration */
int rhmuse_nav_accel = 1 






; 

/* recon cv for Muse number of overscans for phase mapping readout */
int rhmuse_nav_hnover = 16 






; 

/* recon cv for Muse phase mapping readout yres */
int rhmuse_nav_yres = 96 






; 

float opaccel_cs_stride = 1.0 






;

/* Compressed Sensing on/off flag */
int opcompressedsensing = PSD_OFF 






;

/* recon cv for Compressed Sensing acceleration factor */
float rhcs_factor = 1.0 






;

/* recon cv for Compressed Sensing flag */
int rhcs_flag = 0 






; 

/* recon cv for Compressed Sensing max iteration */
int rhcs_maxiter = 3 






;

/* recon cv for Compressed Sensing consistency flag */
float rhcs_consistency = 0 






; 

/* recon cv for ARC acceleration along phase */
int rhcs_ph_stride = 1 






; 

/* recon cv for ARC acceleration along slice */
int rhcs_sl_stride = 1 






; 

int oparc = PSD_OFF 






;

int opaccel_kt_stride = 8 






;

int rhkt_factor = 1 






;

/* recon cv for kt calibration acceleration factor */
int rhkt_cal_factor = 1 






;

/* recon cv for kt calibration size in ph */
int rhkt_calwidth_ph = 0 






;

/* recon cv for kt calibration size in sl */
int rhkt_calwidth_sl = 0 






;

/* Maximal RF Imaging Option
 * PSD_ON:  MRF imaging option is selected
 * PSD_OFF: MRF imaging option is not selected
 */
int opab1 = PSD_OFF 






;

int op3dgradwarp = 0 






;

int opauto3dgradwarp = 1 






;

int cfmaxtransmitoffsetfreq = 650000 






;

/* -250000 Hz for HD, 0 for DV */
int cfreceiveroffsetfreq = 0 






;

/* See COIL_SWITCH defines for bit definitions */
int cfcoilswitchmethod = COIL_SWITCH_SSP_HUB_INDEX 






;
/* TG_record store the appropriate TG value for adaptive B1 Max calculation */
int TG_record = 0 





;
/* ab1_enable is a control flag that is set by host and has three status:
 * 0 - adaptive B1max calculation is turned off and conventional B1max calculation is used
 * 1 - adaptive B1max is truned on
 * 2 - adaptive B1max calculation is turned off and previously calculated B1max is used
 */
int ab1_enable = 0 





;

int cfreceivertype = CFG_VAL_RECEIVER_RRX   






;

int cfreceiverswitchtype = CFG_VAL_RCV_SWITCH_RF_HUB 






;

int cfEllipticDriveEnable = 0 






;

int pi3dgradwarpnub = 1 






;

int cfDualDriveCapable = 0 






;

/* TRIP addition */
int optrip = 0 






;

/* RTB0 correction flag */
int oprtb0 = 0 






;

int pirtb0vis = 0 






;

int pirtb0nub = 0 






;


/* HOEC correction flag */
int ophoecc = 0 






;

/* recon cv for HOEC correction */
int rhhoecc = 0 






;

/* recon cv for fit order of HOEC */
int rhhoec_fit_order = 3 






;

/* EPI Distortion Correction flag */
int opdistcorr = 0 






;

/* EPI Distortion Correction UI control
   0: Hide, 1: Visible, grey-out, 2: Visible, active */
int pidistcorrnub = 0 






;

/* EPI Distortion Correction UI default value
   when not stored in protocol */
int pidistcorrdefval = 0 






;

/* EPI Distortion Correction Recon Control CV */
int rhdistcorr_ctrl = 0 






;

/* EPI Distortion Correction Recon kernel size. Unused in recon per DOC1872962 */
int rhdistcorr_B0_filter_size = 5 






;

/* EPI Distortion Correction Recon std dev. Unused in recon per DOC1872962 */
float rhdistcorr_B0_filter_std_dev = 1.5 






;

/* EPI Distortion Correction Image Header CV 
   Reflects rhdistcorr_ctrl */
int ihdistcorr = 0 






;

/* EPI Custom Diffusion Directions Tensor File number */
int rhtensor_file_number = 0 






;

/* Phase Encoding Polarity Image Header CV */
int ihpepolar = 0 






;

/* recon cv for echo spacing */
int rhesp = 500 






;

/*dual echo FSE view sharing copied k space lines number*/
int viewshd_num = 0 






;

/* The below variables are used for eC3 reconstruction for spine scan to reduce annefact. */
float grad_intensity_thres = 3.0 






;

int anne_mask_dilation_length = 2 






;

float anne_intensity_thres = 0.0 






;

float anne_channel_percentage = 0.4 






;

int ec3_iterations = 1 






;

float combined_coil_map_thres = 0.15 






;

float coil_map_smooth_factor = 0.02 






;

float coil_map_2_filter_width = 0.02 






;

int ec3_iteration_method = 0 






;

/* The CV will be used by epi application for controlling EDR on or off */
int edr_support = PSD_OFF 






;

float recon_bandwidth_factor = 1.0 






;

/* The CV will be set to different datatype (0: unknown, 1: short, 2: int, 3: float, 4: double) by Host based on system configuration,
 *  * then transfer to PSD. The default value will be 0 due to PSD not know about system configuration. PSD use the CV to get the system configuration */
int dacq_data_type = 0 






;

int rawmode_scaling = 0 






;

float rawmode_scaling_factor = 1.0 






;

/* RG calibration mode */
int oprgcalmode = RG_CAL_MODE_MEASURED 






;

/* number of MSMA groups */
int opnumgroups = 0 






;

/* System selection for allowing SAR burst mode */
int opsarburst = 0 






;

int opheadscout = PSD_OFF 






;

int rhposition_detection = PSD_OFF 






;

/* Focused Ultrasound */
int opfus = 0 






;

int opexamnum = 0 






;

int opseriesnum = 0 






;


/* Scan volume shift flag */
int vol_shift_type = 0 






;

int vol_shift_constraint_type = 0 






;

/* Scan volume scaling flag for image cut redution */
int vol_scale_type = 0 






;

int vol_scale_constraint_type = 0 






;

/* recon CVs for Channel Compression and Optimal Recon */
int rhsnrnoise = 0 






;

int rhvircpolicy = 0 






;

int rhvirsenstype = 1 






;

int rhvircoiltype = 1 






;

int rhvircoilunif = 0 






;

int rhvircoilchannels = 1 






;

int cffield = B0_15000 






;

float act_field_strength = 30000.0 






;

int enableReceiveFreqBands = 0 






;

int offsetReceiveFreqLower = 0 






;

int offsetReceiveFreqHigher = 0 






;

int cfrfamptyp = 0 






;

int cfssctype = 0 






;

int cfbodycoiltype = PSD_15_XRM_BODY_COIL 






;

int cfptxcapable = 0 






;

/* 750w body coil cable TG limit */
int cfbdcabletglimit = 1 






;

/* delta frequency for body coil cable mode, kHz */
int cfcablefreq = 226 






;

/* TG limit at cable resonance freq */
int cfcabletg = 175 






;

/* 3dB bw for body coil cable mode, kHz */
int cfcablebw = 500 






; 

int opgradshim = 2 






;

int track_flag = 0 






;



int prevent_scan_under_emul = 0 






;

/* MRIhc18338 */
int acqs = 1 






;

int avround = 1 






;

int baseline = 0 






;

/* CV nex has value 1 for .5 nex and .75 nex scans */
int nex = 1 






;

float trunex = 1.0 






;

int isOddNexGreaterThanOne = 0 






;

int isNonIntNexGreaterThanOne = 0 






;

/* ***************
 * fn 1 full kspace
 *    .5 half nex
 *    .75 3/4 nex 
 **************** */
float fn = 1.0 






;

int enablfracdec = 1 






;

int npw_flag = 0 






;

float nop = 1.0 






;

int acq_type = TYPSPIN 






;

int seq_type = TYPNCAT 






;

int num_images = 1 






;

/* Image Type CVs */
int recon_mag_image = 1 






;

int recon_pha_image = 0 






;

int recon_imag_image = 0 






;

int recon_qmag_image = 0 






;


int slquant1 = 1 






;

int psd_grd_wait = 56 






;

int psd_rf_wait = 0 






;

/* pos_moment_start holds the time in us from the start of the sequence
   to the middle of the alpha pulse.  This is used to automate flow
   compensation and zeroth moment graphing tests.   */
int pos_moment_start = 0 






;

/* mps1rf1_inst and scanrf1_inst are used to hold the index into
   the rf1 instruction for scan and mps1. This allows the code
   for MPS1Prescan to simply copy the rf1 waveform used in scan.
   Thus, MPS1 is simplified for non-typical rf pulses  */

int mps1rf1_inst = 0 






;

int scanrf1_inst = 0 






;

/* cfcarddelay holds the delay of the cardiac hardware  */
int cfcarddelay = 10 






;


int psd_card_hdwr_delay = 0 






;

/*Default to proton at 4257.59 */
float GAM = GAMMA_PROTON 






;

int off90 = 80 






;

int TR_SLOP = 2000 






;

int TR_PASS = 50000 






;

int TR_PASS3D = 550000 






;

int csweight= 100 






;

/* Nex can not be accumulated with exorcist running.  exnex
 * calculates the number of frames/view that must be stored in BAM */
int exnex = 1 






;

float truenex = 0.0 






;

int eg_phaseres = 128 






;

int sp_satcard_loc = 0 






;

int min_rfdycc = 0; /* minimum seq time based on duty cycle (us) */

int min_rfavgpow = 0; /* minimum seq time based on avg. power (us) */

int min_rfrmsb1 = 0; /* minimum seq time based on rms B1 limitation (us). */

int coll_prefls = 1 






;

/* following parameters are new for 55.  YH  10/14/94 */
int maxGradRes = 1 






;

float dfg = 2 






;

float pg_beta = 1.0 






;
     
int split_dab = 0 






;
 
float freq_scale = 1.0 






;

int numrecv = 1 






;
 
/* for phase encoding */
int pe_on = 1 






;
 
float psd_targetscale = 1.0; /* %fullscale for amps-set in obloptimize */
 
float psd_zero = 0.0 






;

/* gram pulse modulation width time per logical axis */
int lx_pwmtime = 0; 
int ly_pwmtime = 0;
int lz_pwmtime = 0;

/* gram pulse modulation width time per physical axis  */
int px_pwmtime = 0; 
int py_pwmtime = 0;
int pz_pwmtime = 0;

int min_seqgrad = 0;  /* minimum sequence time based on Gradient subsystem */
int min_seqrfamp = 0; /* minimum sequence time based on RF amplifier */

/* per axis loading in units of A^2*uSec */
float xa2s = 0;
float ya2s = 0;
float za2s = 0;

int minseqcoil_t = 0;         /* minseq time based on coil heating  */
int minseqcoilx_t = 0;         /* minseq time based on coil heating  */
int minseqcoily_t = 0;         /* minseq time based on coil heating  */
int minseqcoilz_t = 0;         /* minseq time based on coil heating  */
int minseqcoilburst_t = 0;    /* minseq time based on Burst Mode coil limit */
int minseqcoilvrms_t = 0;     /* minseq time based on coil RMS voltage limit */
int minseqgram_t = 0;         /* minseq time based on gram heating  */
int minseqchoke_t = 0;
int minseqcable_t = 0;        /* minseq time based on Irms */
int minseqcable_maxpow_t = 0; /* minseq time based on Irms of maximum power waveform */
int minseqcableburst_t = 0;   /* minseq time based on Burst Mode cable limit */
int minseqbusbar_t = 0;       /* minseq time based on bus bar limit */
int minseqps_t = 0;       /* minseq time based on power supply */
int minseqpdu_t = 0;      /* minseq time based on power distribution unit */
int minseqpdubreaker_t = 0; /* minseq time based on PDU breaker current limit */
int minseqcoilcool_t = 0; /* minseq time baed on coil cooling limit */
int minseqsyscool_t = 0;  /* minseq time based on system cooling limit */
int minseqccucool_t = 0;  /* minseq time based on CCU cooling limit */
int minseqxfmr_t = 0;     /* minseq time based on transformer RMS current limit */
int minseqresist_t = 0;   /* minseq time based on RC filter resistor wattage limit */

/* min seq time based on gradient driver heating  */
int minseqgrddrv_t = 0;      /* minseqtime based on gradient driver heating */
int minseqgrddrv_case_t = 0; /* minseqtime based on cold plate heanting in gradient driver */
int minseqgrddrvx_t = 0;     /* minseqtime based on X gradient driver heating */
int minseqgrddrvy_t = 0;     /* minseqtime based on Y gradient driver heating */
int minseqgrddrvz_t = 0;     /* minseqtime based on Z gradient driver heating */
float powerx = 0;             /* total scaled power in X in Ampere^2 usec     */
float powery = 0;             /* total scaled power in Y in Ampere^2 usec     */
float powerz = 0;             /* total scaled power in Z in Ampere^2 usec     */
float pospowerx = 0;          /* positive scaled power in X in Ampere^2 usec  */
float pospowery = 0;          /* positive scaled power in Y in Ampere^2 usec  */
float pospowerz = 0;          /* positive scaled power in Z in Ampere^2 usec  */
float negpowerx = 0;          /* negative scaled power in X in Ampere^2 usec  */
float negpowery = 0;          /* negative scaled power in Y in Ampere^2 usec  */
float negpowerz = 0;          /* negative scaled power in Z in Ampere^2 usec  */
float amptrans_lx = 0;          /* logical X ampere trans in (Amp/usec)*usec   */
float amptrans_ly = 0;          /* logical Y ampere trans in (Amp/usec)*usec   */
float amptrans_lz = 0;          /* logical Z ampere trans in (Amp/usec)*usec   */
float amptrans_px = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_py = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_pz = 0;        /* physical Y ampere trans in (Amp/usec)*usec   */
float abspower_lx = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_ly = 0;          /* logical Y abs avrg ampere in Ampere * usec   */
float abspower_lz = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_px = 0;        /* physical X abs avrg amperere in Amp * usec   */
float abspower_py = 0;        /* physical Y abs avrg amperere in Amp * usec   */
float abspower_pz = 0;        /* physical Y abs avrg amperere in Amp * usec   */

/* SGD gradient heating */
int minseqpwm_x = 0;
int minseqpwm_y = 0;
int minseqpwm_z = 0;
int minseqgpm_t = 0;        /* minseq time based on power supply heating */
int minseqgpm_maxpow_t = 0; /* minseq time based on power supply capability */

/* ratio between estimated bus voltage and required bus voltage for gradient generation */
float vol_ratio_est_req = 2.0;

/* flag to skip waveform & rotation matrix check in minseq() */
int skip_waveform_rotmat_check = 0;

/* flag to search rotation matrix with highest duty in minseq() */
int set_realtime_rotmat = 0;

/* flag to skip rotation matrix search for highest duty in minseq() */
int skip_rotmat_search = 0;

/* flag to force minseqseg() to be called in minseq() */
int enforce_minseqseg = 0;

/* flag to force dbdt optimization to be called in calcOptimizaedPulses() */
int enforce_dbdtopt = 0;

/* flag to show if minseqseg() was skipped or not */
int skip_minseqseg = 0;

/* flag to show if dbdtopt initialization should be skipped or not */
int skip_initialize_dbdtopt = 0;

int time_pgen = 0;       /* timing variable added to monitor pulsegen execution time RK 6/11/96 */

int cont_debug = 0 






;

/* CVs added for Maxwell correction for phase-contrast */
int maxpc_cor = 0 






;

int maxpc_debug = 0 






;

int maxpc_points = 500 






;

/* Added for MGD for pass through filter */
int pass_thru_mode = 0 






;

/* Universally used timing CVs */
int tmin = 0 






;

int tmin_total = 0 






;

int psd_tol_value = 0 






;

/* Universally used board index CV */
int bd_index = PSD_XCVR2 






;

/* Error message data base flag */
int use_ermes = 0 






;

/* Added field strength CV to be able to use RSP.MFO 05/31/00 AY*/
float fieldstrength = 15000;

int asymmatrix = 0 






;

int psddebugcode = 0 






;

int psddebugcode2 = 0 






;

int serviceMode = 0 






;

/* UPM bit mask for disabling cross terms */
int upmxdisable = 16 






;

/*
 * MRIge47485 - Improved Gradient Duty Cycle
 */

/* Linear segment heating model */
int tsamp = 4 






;

int seg_debug = 0 






;

int CompositeRMS_method = PSD_OFF 






;

int gradDriverMethod = PSD_OFF 






;


/* gradDCsafeMethod selects Safe DC model for coil heating calculation MRIhc16090 */
int gradDCsafeMethod = PSD_ON 






;

/* stopwatchFlag for debugging */
int stopwatchFlag = 0 






;

int seqEntryIndex = 0 






;

/* dB/dtOpt CVs - RJF */
int dbdt_debug = 0 






;

int reilly_mode = 0 






;

/* Use this cv to manually turn on/off dB/dt feature */

int dbdt_disable = 0 






;

/* Add the following cv as a logic flag.  This depends on 3 conditions:
   1)Reilly Model being used, 2)CRM is present, 3)dB/dt feature is turned on.*/

int use_dbdt_opt = 1 






;

float srderate =  1.0 






;

int config_update_mode = 0 






;

int phys_record_flag = 0 






;

int phys_rec_resolution = 25 






;

/***********************************************************************
 * Bit control of channel selection for physiological data recording 
 * --------------------------------------------------------------
 * Bit 0 (1): respiratory trigger recording 
 * Bit 1 (2): respiratory waveform data recording
 * Bit 2 (4): PG trigger recording
 * Bit 3 (8): PG waveform data recording
 * Bit 4 (16): ECG 3 trigger recording
 * Bit 5 (32): ECG 3 waveform data recording 
 * Bit 6 (64): ECG 2 trigger recording 
 * Bit 7 (128): ECG 2 waveform data recording 
 ***********************************************************************/
int phys_record_channelsel = 15 






;

/* MRIge91983 */
int rotateflag = 0 






;

/* MRIge93114 */
int rhpcspacial_dynamic = 0 






;

int rhpc_rationalscale = 0 






;

int rhpcmag = 0 






;

int mild_note_support = 0 






;

int save_grad_spec_flag = 0 






;

int grad_spec_change_flag = 0 






;

int value_system_flag = 0 






;

int rectfov_npw_support = 0 






;

int pigeosrot = 0 






;


int minseqrf_cal = 1 






;

int min_rfampcpblty = 0 






;

int b1derate_flag = 0 






;

int oblmethod_dbdt_flag = 0 






; 

/* Non PGOH DC model CV parameters MRIhc16090 */
int minseqcoil_esp = 1000 






;

int aspir_flag = 0 






;

int rhrawsizeview = 0 






;

int chksum_scaninfo_view = 0 






;

int chksum_rhdacqctrl_view = 0 






;

float fnecho_lim = 1.0 






;

int psdcrucial_debug = 0 






;

float b1max_scale = 1.0 






;

int disable_exciter_unblank = 0 






;

int TGlimit = MAX_SYS_TG;      /* max TG limit based on offset */
int sat_TGlimit = MAX_SYS_TG;  /* max TG limit based on offset for SpSat */

int autoparams_debug = 0 






;

int num_autotr_cveval_iter = 1 






;

int apx_cveval_counter = 0 






;

int enforce_inrangetr = 0 






;

int passtime = 0 






;

int retropc_extra = 0 





;

int esp = 10000 






;

int echoint = 1 






;

int arc_flag = 0 






;

int arc_ph_calwidth = 24 






;

int arc_sl_calwidth = 24 






;

int vrgfsamp = 0 






;

float srate_x = 15.0 






;

float glimit_x = 3.6 






;

float srate_y = 15.0 






;

float glimit_y = 3.6 






;

float srate_z = 15.0 






;

float glimit_z = 3.6 






;

float act_srate_x = 10.0 






;

float act_srate_y = 10.0 






;

float act_srate_z = 10.0 






;

int mkgspec_x_sr_flag = 0 






;
int mkgspec_x_gmax_flag = 0 






;

int mkgspec_y_sr_flag = 0 






;

int mkgspec_y_gmax_flag = 0 






;

int mkgspec_z_sr_flag = 0 






;

int mkgspec_z_gmax_flag = 0 






;

int mkgspec_flag = 0 






;

int mkgspec_epi2_flag = 0 






;

int pfkz_total = 32 






;

/* Scan volume scaling for image cut reduction */
float fov_freq_scale = 1.0 






;

float fov_phase_scale = 1.0 






;

float slthick_scale = 1.0 






;

int silent_mode = PSD_OFF 






;

float silent_slew_rate = 3.0 






;

int rhpropellerCtrl = 0 






;

float prop_act_npwfactor = 1.0 






;

float prop_act_oversamplingfactor = 1.0 






;

int navtrig_wait_before_imaging = 200000 






;

int xtg_volRecCoil = 0 






;

int minseqseg_max_full = 0 






;
        
int sphericalGradient = 0 






;

int minseqcoil_option = 0 






;

int minseqgrad_option = 0 






;

int rtp_bodyCoilCombine = 1 






;

int ntxchannels = 1 






;

int napptxchannels = 1 






;

int seqcfgdebug = 0 






;

int enable_acoustic_model = 0 






;
int acoustic_seq_repeat_time = 4 






;
float avgSPL_non_weighted = -1 






;
int noisecal_in_scan_flag = 1 






;

/*
 * Copyright 2017 General Electric Company.  All rights reserved.
 */
 
/*
 * @ipgexport
 * Variables declared in this file are shared between groups of
 * PSDs and may be critical to the operation of all PSDs.
 * Contains the variable declarations that carry potentially complex
 * data from the host PSD to the target PSD during the
 * serialization/deserialization step of download. Standard CVs (the
 * other form of serializable information) are restricted to simple
 * primitive types. Add variables to this file when (1) they are
 * needed by a large subset of all PSDs for correct operation (vs.
 * an @ipgexport section in a PSD or inline file), and (2)
 * the data needs to be conveyed from the Host PSD to the Target PSD
 * during download (vs. an @rsp or @rspvar or @reqexport section), and
 * (3) the data type is more complicated than a signed single- or
 * double- length primitive type (vs. @cv or @reqcv). 
 *
 * This file is included in epic.h
 *
 */ 
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/
int autolock = 0 





; /* vmx 10/13/94 YI */

int blank = 4 





; /* vmx 10/3/94 YI */

int nograd = 0 





; /* vmx 10/13/94 YI */

int nofermi = 0 





; /* vmx 10/13/94 YI */

int rawdata = 0 





; /* vmx 10/13/94 YI */

int saveinter = 0 





; /* vmx 10/13/94 YI */

int zchop = 1 





;/* vmx 10/13/94 YI */

int eepf = 0 





; /* vmx 10/13/94 YI */

int oepf = 0 





; /* vmx 10/13/94 YI */

int eeff = 0 





; /* vmx 10/13/94 YI */

int oeff = 0 





; /* vmx 10/13/94 YI */

int cine_choplet = 0 





; /* vmx 10/13/94 YI */

/*** CVs for Fermi Filter ***/
float fermi_rc = 0.5 





;

float fermi_wc = 1.0 





;

int apodize_level_flag = 0 





;

float fermi_r_factor = 1.0 





;

float fermi_w_factor = 1.0 





;

float pure_mix_tx_scale = 1.0 






;

int channel_compression = PSD_OFF 






;

int optimal_channel_combine = PSD_OFF 






;

int enforce_cal_for_channel_combine = PSD_OFF 






;

int override_opcalrequired = PSD_OFF 






;

int dump_channel_comp_optimal_recon = PSD_OFF 






;

int dump_scenic_parameters = PSD_OFF 






;


 int cv_rfupa          = -600 ;
 int system_type = 0  ;
 int cvlock = 1 ;
 int psd_taps = -1 
;
 int fix_fermi = 0 
;
 int grad_spec_ctrl = 0 
  ;
 float srate = 1.651 ;
 float glimit = 1.0 ;
 float save_gmax = 1.0;
 float save_srate = 2.551;
 int save_cfxfull = 32752;
 int save_cfyfull = 32752;
 int save_cfzfull = 32752;
 float save_cfxipeak = 194.0;
 float save_cfyipeak = 194.0;
 float save_cfzipeak = 194.0;
 int save_ramptime = 600;
 int debug_grad_spec = 0 ;
 float act_srate=1.651;
 int val15_lock = 0 
  ;
/* flag to calculate average power for Smart Burst Mode with XFD */
 int avecrushpepowscale_for_SBM_XFD = 0;  
 
/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PScvs                                 *
 *                                                                   *
 * Standard C variables of _limited_ types common for both the Host  *
 * and Tgt PSD processes. Declare here all the simple types, e.g,    *
 * int, float, and C structures containing the min and max values,   *
 * and ID description, etc.                                          *
 *                                                                   *
 * NOTE FOR Lx:                                                      *
 * Since the architectures between the Host and the Tgt sides are    *
 * different, the memory alignment for certain types varies. Hence,  *
 * the following types are "forbidden": short, char, and double.     *
 *********************************************************************/
float PSsr_derate_factor = 1.0 ;
float PSamp_derate_factor = 1.0 ;
float PSassr_derate_factor = 1.0 ;
float PSasamp_derate_factor = 1.0 ;
int PSTR_PASS = 20000;

/* ezi (GE) */
float mpsfov = 100  ;

int fastprescan = 0 ;
int pre_slice = 0 ;
int PSslice_num = 0;
float xmtaddAPS1 = 0, xmtaddCFL = 0, xmtaddCFH = 0, xmtaddFTG = 0, xmtadd = 0, xmtaddRCVN = 0;
float ps1scale = 0, cflscale = 0, cfhscale = 0, ftgscale = 0;
float extraScale = 0;  /* for external PSD use */
int PSdebugstate = 0 ;
int PSfield_strength = B0_5000 ;
int PScs_sat = 1 ;
int PSir = 1 ;
int PSmt = 1 ;
int ps1_rxcoil = 0 ;
int ps_seed = 21001;    /* spgr RF phase seed */

/* vmx 06/14/95 YI */
int tg_1_2_pw = 1 ;
int tg_axial = 1 ;
float coeff_pw_tg = 1.0;
float fov_lim_mps = 350.0 ;
/* end vmx */

int TGspf = 0 ;

float flip_rf2cfh = 0;
float flip_rf3cfh = 0; /* For presscfh MRIhc08321 */
float flip_rf4cfh = 0;
int ps1_tr=2000000;
int cfl_tr=398000;
int cfh_tr=398000;
int rcvn_tr=398000;

float cfh_ec_position = (16.0/256.0) ;
				/* vmx 05/02/95 YO */
int cfl_dda = 4 ;
int cfl_nex = 2 ;
int cfh_dda = 4 ;
int cfh_nex = 2 ;
int rcvn_dda = 0 ;
int rcvn_nex = 1 ;

/* PRESS XTG and APS1 */
int local_tg = 0 ;
float fov_scaling = 0.8 ;
float flip_rf1xtg = 90.0;
float gscale_rf1xtg = 1.0;
int init_xtg_deadtime = 0;
float flip_rf1mps1 = 90.0;
float gscale_rf1mps1 = 1.0;

/* presscfh  cvs -  For  MRIhc08321 */ 
/* Definitions in epic.h
 * PRESSCFH_SLICE 1      
 * PRESSCFH_SLAB 2                                              
 * PRESSCFH_SHIMVOL 3
 * PRESSCFH_SHIMVOL_SLICE 4
 * PRESSCFH_NONE          5
 * */
int presscfh_override = 0  ;
int presscfh = PRESSCFH_NONE  ;
int presscfh_ctrl = PRESSCFH_NONE  ;
int presscfh_outrange = 0;
int presscfh_cgate = 0;
int presscfh_debug = 0 ;
int presscfh_wait_rf12 = 0;
int presscfh_wait_rf23 = 0;
int presscfh_wait_rf34 = 0;
int presscfh_minte = 20000;
float presscfh_fov = 0.0;
float presscfh_fov_ratio = 1.0;
float presscfh_pfov_ratio = 1.0;
float presscfh_slab_ratio = 1.0;
float presscfh_pfov = 0.0; 
float presscfh_slthick = 10.0;
float presscfh_slice = 10.0;  /* for the third refocus pulse in presscfh_shimvol_slice*/
float presscfh_ir_slthick = 10.0;
int presscfh_ir_noselect = 1;
/* SXZ: change from 0.5 to 0.3 to make sure presscfh is more probably
 * used for PRESSCFH_SLICE mode */
float presscfh_minfov_ratio = 0.3; /* SXZ: change from 0.5 to 0.3 */ 

/* steam_flag */
int cfh_steam_flag = 0;
int steam_pg_gap = 8;

float area_gykcfl = 0;
float area_gykcfh = 0;
float area_xtgzkiller = 0;
float area_xtgykiller = 0;
int PSoff90=80  ;
int dummy_pw = 0;
int min180te = 0;

float PStloc = 0;
float PSrloc = 0;
float PSphasoff = 0;
int PStrigger = 0;

/* begin aps1_mod changes (GE) */
float PStloc_mod = 0;
float PSrloc_mod = 0;
float PSphasoff_mod = 0;
float thickPS_mod = 0;
/* end aps1_mod changes (GE) */

float asx_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float asz_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float cfhir_killer_area = 4086.0; /* based on 5.4:  .9 * ( 4000 + 540 ) */
float ps_crusher_area = 714.0; /* based on 5.4:  .7 * ( 600 + 420 ) */
float cfh_crusher_area = 4000.0; /* MRIhc57311: increased crusher area to kill signal from outside slice */
float target_cfh_crusher = 0;
float target_cfh_crusher2 = 0;  /* For presscfh MRIhc08321 */ 

int cfh_newmode = 1;
float cfh_rf1freq = 0 ;
float cfh_rf2freq = 0 ;
float cfh_rf3freq = 0 ; /* For presscfh MRIhc08321 */
float cfh_rf4freq = 0 ;
float cfh_fov = 0 ;
int cfh_ti = CFHTI_1HT;
int eff_cfh_te = CFHTE_1HT;
int PScfh_shimvol_debug = PSCFH_SHIMVOL_DEBUG_NONE ;
int debug_shimvol_slice = 0;

/* variables for sequencers in shimvol_slice mode */
int wg_cfh_rf3 = 0;
int wg_cfh_rf4 = 0;


/**** FastTG CVs   *******/
float FTGslthk = 20 ;

float FTGopslthickz1=80 ;
float FTGopslthickz2=80 ;
float FTGopslthickz3=20 ;
int   ftgtr = 2000000 ;
float FTGfov = 480.0 ;
float FTGau  = 4 ;
float FTGtecho = 4 ;
int FTGtau1   = 8192   ;
int FTGtau2   = 32768   ;
int FTGacq1   = 0 ;
int FTGacq2   = 1 ;
int epi_ir_on = 0 ;	/* ypd */
int ssfse_ir_on = 0 ;	/* MRIge66767 */
int ftg_dda = 0 ;

float FTGecho1bw = 3.90625 ;
int FTGtestpulse  = 0 ;
int FTGxres    = 256 ;
float FTGxmtadd = 0;
int pw_gxw2ftgleft = 4096; /* HCSDM00161809: time of 2nd readout window to S1 echo */

/**** eXpressTG CVs   *******/
int   xtgtr = 200000 ;
int XTGtau1   = 8192   ;
float XTGfov = 480.0 ;
int pw_bsrf = 4000;
int xtg_offres_freq = 2000; /* 2kHz off-resonance */
float XTGecho1bw = 15.625 ;
int XTGxres    = 256 ;
float xmtaddXTG = 0, xtgscale = 0;
int xtg_dda = 0 ;
int XTGacq1   = 0 ;
float TGopslthick = 10.0 ;
float TGopslthickx = 30.0 ;
float TGopslthicky = 30.0 ;
int XTG_minimizeYKillerGap = 0 ;

/* Dynamic TG */
int dynTG_etl = 2 ;
int dtg_iso_delay = 1280   ;
int dtg_off90 = 80;
int dtg_dda = 4 ;
int rf1dtg_type = 1 ;
float echo1bwdtg = 15.625 ;
int dtgt_exa = 0, dtgt_exb = 0, tleaddtg = 0, td0dtg = 0;
int dtgphorder = PH_CENTRIC_LOW;
int dtgspgr_flag = 0 ;
int pw_rf1dtg = 0;
float a_rf1dtg = 0;
int min_dtgte = 0, dtg_esp = 0;
int tr_dtg = 20000;
int time_ssidtg = 400;

/**** B1 Map CVs   *******/
int rsaxial_flag = 1 ;
int rsspgr_flag = 1 ;
int multi_channel = 1 ;
int minph_iso_delay = 1280   ;
int rs_off90 = 80;
int rs_iso_delay = 1280   ;
float echo1bwrs = 15.625 ;
int rsphorder = PH_CENTRIC_LOW;

int rs_dda = 4 ;
int rst_exa = 0, rst_exb = 0, tleadrs = 0, td0rs = 0;
int pw_rf1rs = 0;
int ia_rf1rs = 0;
float a_rf1rs = 0;
int rf1rs_type = 1 ;

float gscale_rf1rs = 0;
float flip_rf1rs = 0, flip_rfbrs = 0, cyc_rf1rs = 0;
float flip_rf1dtg = 0, flip_rfbdtg = 0, cyc_rf1dtg = 0, gscale_rf1dtg = 0;
int ia_rf1dtg = 0;
float rf1rs_scale = 0, rf1dtg_scale = 0;
float xmtaddrs = 0, xmtadddtg = 0;
int pw_acqrs1 = 0, pw_acqdtg1 = 0;
int min_rste = 0, rs_esp = 0;
int tr_rs = 0, tr_prep_rs = 0;
int rd_ext_rs = 0, rd_ext_dtg = 0;
int fast_xtr = 50;
int attenlen = ATTEN_UNLOCK_LENGTH;
int tns_len = 4;
int e2_delay_rs = 4;
int e2_delay_dtg = 4;
int time_ssirs = 400;

int rfshim_etl = 2;
int B1Cal_mode = 0 ;
int DD_delay = 2000 ;
int DD_channels = 2 ;
int DD_nCh = 1;
int DD_debug = 0 ;

int endview_iamprs = 0, endview_iampdtg = 0;
float endview_scalers = 0, endview_scaledtg = 0;


/**** ExtCal CVs ****/
float echo1bwcal = 62.5 ;
int cal_dda = 128 ;
int cal_delay = 4000000 ;
int cal_delay_dda = 0;
int calspgr_flag = 1 ;
int cal_tr_interleave = 0;
int cal_nex_interleave = 0;
float cal_xfov = 100.0;
float cal_yfov = 100.0;
float cal_vthick = 10.0;
int cal_btw_rf_rba_ssp = 0;
int cal_grd_rf_delays = 0;
int tleadcal = 0;
int td0cal = 0;
int calt_exa = 4;
int calt_exb = 4;
int tacq_cal = 4;
int te_cal = 4;
int tr_cal = 4;
float flip_rf1cal = 0.0;
int cal_iso_delay = 0;
int endview_iampcal = 0;
int endviewz_iampcal = 0;
float endview_scalecal = 1.0;
float endviewz_scalecal = 1.0;
float a_combcal = 1.0;
float a_endcal = 1.0;
float a_combcal2 = 1.0;
float a_endcal2 = 1.0;
int time_ssical = 160;
float xmtaddcal = 0.0;
float cal_amplimit = 0.0;
float cal_slewrate = 100.0;
float cal_freq_scale = 1.0;
float cal_phase_scale = 1.0;
float area_gzkcal = 300.0;
float cal_ampscale = 1.05;
int cal_pfkr_flag = 1;
float cal_pfkr_fraction = 1.0;
int cal_sampledPts = 0;

/**** AutoCoil CVs ****/
float echo1bwcoil = 62.5 ;
int coil_dda = 4 ;
int coilspgr_flag = 1 ;
int coil_nex_interleave = 0;
float coil_xfov = 100.0;
float coil_yfov = 100.0;
float coil_vthick = 10.0;
int tleadcoil = 0;
int td0coil = 0;
int coilt_exa = 4;
int coilt_exb = 4;
int tacq_coil = 4;
int te_coil = 4;
int tr_coil = 4;
float flip_rf1coil = 0.0;
int coil_iso_delay = 0;
int endview_iampcoil = 0;
int endviewz_iampcoil = 0;
float endview_scalecoil = 1.0;
float endviewz_scalecoil = 1.0;
float a_combcoil = 1.0;
float a_endcoil = 1.0;
float a_combcoil2 = 1.0;
float a_endcoil2 = 1.0;
int time_ssicoil = 160;
float xmtaddcoil = 0.0;
float coil_amplimit = 0.0;
float coil_slewrate = 100.0;
float coil_freq_scale = 1.0;
float coil_phase_scale = 1.0;
int coil_pfkr_flag = 1;
float coil_pfkr_fraction = 1.0;
int coil_sampledPts = 0;

/**** CFL/CFH CVs   *******/
int CFLxres = 256 ; /* MRIhc54366 */
int CFHxres = 256 ;
 
float echo1bwcfl = 2.016129 ;
float echo1bwcfh = 0.50 ;

float echo1bwrcvn = 15.625 ;
int rcvn_xres   = 4096 ;
int rcvn_loops  = 10;  /* number of iterations RCVN entry point will loop */
int pw_grdtrig= 8   ;    /* trigger for grad diagnostic */

int wait_time_before_cfh = 1000000 ;

/**** AutoShim CVs *******/

float echo1bwas = 15.625 ;

int off90as  = 80   ;
int td0as  = 4 ;
int t_exaas = 0 ;
int time_ssias = 400   ;
int tleadas = 25   ;

int te_as = 0;
int tr_as = 0;
int as_dda = 4 ;

int pw_isislice= 200   ;    /* duration of isi interrupt */
int pw_rotslice= 12   ;   /* duration of rotation matrix update signal for WARP */
int isi_sliceextra = 32   ;


/**** Receive Gain CVs ****/

int rgfeature_enable  = PSD_OFF ;

/**** Map TG CVs ****/
int enableMapTg = PSD_OFF ;

/********** Required for mrsaps/opt prescan ****************/
/********** pimrsapsflg must be on *************************/
float aslenap = 200 ;
float aslenrl = 200 ;
float aslensi = 200 ;

float aslocap = 0 ;
float aslocrl = 0 ;
float aslocsi = 0 ;
/***********************************************************/

/* temp crusher amplitudes */
float area_gxwas = 0;                  /* readout pulse area */
float area_gz1as = 0;
float area_readrampas = 0;             /* area of left readout ramp */
int avail_pwgx1as = 0;                 /* avail time for gx1as pulse */
int avail_pwgz1as = 0;               /* avail time for gz1as pulse */
int bw_rf1as = 0;                    /* bandwidth of rf pulses */

/* filter info for 1st, 2nd echo */
float flip_pctas=1.0;                 /* flip angle % for rf scaling */

int dix_timeas = 0;              /* dixon delay for even excitations */
float xmtaddas = 0,xmtlogas = 0;     /* rf attenuation */
int ps1obl_debug = 0 
;
int asobl_debug = 0 
;
int ps1_newgeo = 1;

int as_newgeo = 1;
int pw_gy1as_tot = 0;
int endview_iampas = 0;
float endview_scaleas = 0;

/* YMSmr09211  04/26/2006 YI */
int cfh_newgeo = 1; 
int cfhobl_debug = 0 
;

float deltf = 1.0 ;

int IRinCFH = 0 ;
int cfh_each = 0 ;
int cfh_slquant = 0 ;

int noswitch_slab_psc = 0 ;
int noswitch_coil_psc = 0 ;
int PStest_slab = 1 ;
/******************** Communication cv's (Prescan)**********/
int pimrsapsflg = 0 ;
int pimrsaps1 = MRSAPS_CFL 



;
int pimrsaps2 = MRSAPS_FTG 



;
int pimrsaps3 = MRSAPS_AS 



;
int pimrsaps4 = MRSAPS_TR 



;
int pimrsaps5 = MRSAPS_RCVN 



;
int pimrsaps6 = MRSAPS_CFH 



;
int pimrsaps7 = MRSAPS_OFF 



;
int pimrsaps8 = MRSAPS_OFF 



;
int pimrsaps9 = MRSAPS_OFF 



;
int pimrsaps10 = MRSAPS_OFF 



;
int pimrsaps11 = MRSAPS_OFF 



;
int pimrsaps12 = MRSAPS_OFF 



;
int pimrsaps13 = MRSAPS_OFF 



;
int pimrsaps14 = MRSAPS_OFF 



;
int pimrsaps15 = MRSAPS_OFF 



;

/* MRIhc15304: CVs related to coil switching
 * By changing the hub index for the coil and sending
 * it through SSP packet (RFHUB ssp packet)
 */
int pw_contrfhubsel = 4 ;
int delay_rfhubsel = 20;
int pw_contrfsel = 4 ;
int csw_tr = 0 ;
int csw_wait_sethubindeximm = 250000 
;
int csw_wait_setrcvportimm = 100000 
;
int csw_wait_before = 10000 ;
int csw_time_ssi = 50   
;

/* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient in the RCVN sequence */
float area_gxkrcvn = 10000;
float area_gykrcvn = 10000;
float area_gzkrcvn = 10000;
int pre_rcvn_tr = 20000 ;
int rcvn_flag = 1 ;

/* Prescan PSD controls */
int psd_startta_override = 0 ;
int psd_psctg = APS_CONTROL_PSC 
;
int psd_pscshim = APS_CONTROL_PSC 
;
int psd_pscall = APS_CONTROL_PSC 
;

/* temp cvs, to be removed */
int bw_rf1cal = 0, bw_rf1coil = 0;

/***********************************************************/


int obl_debug = 0 ;
int obl_method = PSD_OBL_OPTIMAL ;
/* filter_echo1 must be defined for prescan for the noise measurement */
int filter_echo1 = 0 ;

int pw_passpacket = 50000 ;
/* KSFoundation CVs */
int ks_rfconf      = ENBL_RHO1 + ENBL_THETA + ENBL_OMEGA + ENBL_OMEGA_FREQ_XTR1; /* 1 + 4 + 8 + 128 = 141 */
int ks_simscan     = 1 ;
float ks_srfact    = 1.0 ;
float ks_qfact     = 1.0 ;
float ks_gheatfact = 1.0 ;
int ks_plot_filefmt = KS_PLOT_MAKEPNG ;
int ks_plot_kstmp = FALSE ;


/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSSpSat.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/
int ksspsat_flag = KSSPSAT_OFF ;
float ksspsat_flip = KSSPSAT_DEFAULT_FLIP ;
int ksspsat_rftype = KSSPSAT_RF_COMPLEX ;
float ksspsat_spoilerscale = KSSPSAT_DEFAULT_SPOILERSCALE ;
int ksspsat_spoilallaxes = KSSPSAT_DEFAULT_SPOILALLAXES ;
int ksspsat_ssi_time = KSSPSAT_DEFAULT_SSITIME ;
int ksspsat_debug = 0 ;
int ksspsat_oblmethod = PSD_OBL_RESTRICT ;


/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSChemSat.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/
int kschemsat_flag = KSCHEMSAT_OFF ;
float kschemsat_flip = KSCHEMSAT_DEFAULT_FLIP ;
int kschemsat_rftype = KSCHEMSAT_RF_STD  ;
int kschemsat_sinc_bw = KSCHEMSAT_DEFAULT_SINCRF_BW_3T ;
int kschemsat_sinc_tbp = KSCHEMSAT_DEFAULT_SINCRF_TBP ;
int kschemsat_rfoffset = 0 ;
float kschemsat_spoilerarea = KSCHEMSAT_DEFAULT_SPOILERAREA ;
int kschemsat_ssi_time = KSCHEMSAT_DEFAULT_SSITIME ;


/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSInversion.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/
int ksinv_ssi_time = KSINV_DEFAULT_SSITIME ;
int ksinv_filltr_ssi_time = KSINV_FILLTR_SSITIME ;
int ksinv_mintr_t2flair = KSINV_MINTR_T2FLAIR ;
int ksinv_mintr_t1flair = KSINV_MINTR_T1FLAIR ;
int ksinv_maxtr_t1flair = KSINV_MAXTR_T1FLAIR ;
int ksinv_slicecheck = 0 ;
int ksinv_approxti = 1 ;

/* CVs for KSINV_PARAMS */
float ksinv_flip = KSINV_DEFAULT_FLIP ;
float ksinv_slthickfact = 1.0 ;
int ksinv_rfoffset = 0 ;
int ksinv_rftype = KSINV_RF_ADIABATIC  ;
float ksinv_spoilerarea = KSINV_DEFAULT_SPOILERAREA ;
int ksinv_startpos = KSINV_DEFAULT_STARTPOS ;

/* CVs for T2 preppred T2 FLAIR --> KSINV_FLAIR_T2PREP_BLOCK*/
int ksinv_t2prep = 0 ;
int ksinv_t2prep_exc_flip = 90 ;
int ksinv_t2prep_N_Refoc = 1 ;
int ksinv_t2prep_TE = 100000 ;
int ksinv_t2prep_rftype_refoc = KSINV_RF_STD ;
float ksinv_slthickfact_exc = 1.0 ;
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksepi_implementation_diffusion.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/
int ksepi_diffusion_ramptime = 1500 ;
float ksepi_diffusion_maxamp = 0.0 ;
float ksepi_diffusion_amp = 0.0 ;
int ksepi_diffusion_echotime = 0 ;
float ksepi_diffusion_2ndcrushfact = 2.0 ;
int ksepi_diffusion_returnmode = OFFLINE_DIFFRETURN_ALL ;

/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksepi_implementation.e: CVs (modifiable on HOST, readable on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/

/*****************************************************************************************************
* RF Excitation
*****************************************************************************************************/
float ksepi_excthickness = 0;
float ksepi_gscalerfexc = 0.9 ; /* default gradient scaling for slice thickness */
int ksepi_slicecheck = 0 ;
float ksepi_spoilerarea = 3000.0 ;
int ksepi_rfspoiling = 1 ;
int ksepi_fse90 = 0 ;
int ksepi_rf3Dopt = 0 ;
float ksepi_kissoff_factor = 0.04 ;
/*****************************************************************************************************
* RF Refocusing
*****************************************************************************************************/
float ksepi_crusherscale = 1.0 ;
float ksepi_gscalerfref = 0.9 ; 

/*****************************************************************************************************
* EPI train - readout
*****************************************************************************************************/
int ksepi_rampsampling = 1 ;
int ksepi_readlobegap = 0 ;
int ksepi_echogap = 0 ;
int ksepi_readsign = 1 ;
float ksepi_readampmax = 3.0 ;
float ksepi_sr = 0.01 ;
int ksepi_esp = 0 ;

/*****************************************************************************************************
* EPI train - phase encoding
*****************************************************************************************************/
int ksepi_blipsign = KS_EPI_POSBLIPS ;
int ksepi_echotime_shifting = 1 ;
int ksepi_kynover = 24 ;
int ksepi_kznover = 0 ;
int ksepi_ky_R = 1 ;
int ksepi_kz_R = 1 ;
int ksepi_kz_nacslines = 16 ;
int ksepi_caipi = 0 ;

/*****************************************************************************************************
* Flow comp directions (when opfcomp = 1, only for GE-EPI)
*****************************************************************************************************/
int ksepi_fcy = 1 ;
int ksepi_fcz = 1 ;

/*****************************************************************************************************
* FLEET calibration volume
*****************************************************************************************************/
int ksepi_fleet = 0 ;
float ksepi_fleet_flip = 15.0 ;
int ksepi_fleet_dda = 0 ;
int ksepi_fleet_num_ky = 36 ;
int ksepi_fleet_num_kz = 24 ;

/*****************************************************************************************************
* phase reference lines EPI train
*****************************************************************************************************/
int ksepi_reflines = 0 ;

/*****************************************************************************************************
* SWI recon
*****************************************************************************************************/
int ksepi_swi_returnmode = 0 ;

/*****************************************************************************************************
* Sequence general
*****************************************************************************************************/
int ksepi_pos_start = KS_RFSSP_PRETIME ;
int ksepi_ssi_time = KSEPI_DEFAULT_SSI_TIME ;
int ksepi_dda = 1 ;
int ksepi_debug = 1 ;
int ksepi_imsize = KS_IMSIZE_POW2 ;
int ksepi_abort_on_kserror = FALSE ;
int ksepi_onlinerecon = 0 ;
int ksepi_ghostcorr = 1 ;
int ksepi_ref_nsegments = 1 ;
int ksepi_multishot_control = KSEPI_MULTISHOT_B0VOLS ;
int ksepi_multivolpfile = TRUE ;


/*****************************************************************************************************
* Temporary CVs for testing
*****************************************************************************************************/
/* ---- emmweber DDE ---------------*/
int opdde = 0 ;/* if 2: DDE*/
int num_oscillations = 0 ;/* if 2: DDE*/
int opuser51 = 1500 ;


/*****************************************************************************************************
 * CVs
 *****************************************************************************************************/



  float a_rf1mps1 = 0;
  int ia_rf1mps1 = 0;
  int pw_rf1mps1 = 0;
  int res_rf1mps1 = 0;
  float cyc_rf1mps1 = 0;
  int off_rf1mps1 = 0;
  float alpha_rf1mps1 = 0;
  int wg_rf1mps1  = 0;


  float a_gyrf1mps1 = 0;
  int ia_gyrf1mps1 = 0;
  int pw_gyrf1mps1a = 0;
  int pw_gyrf1mps1d = 0;
  int pw_gyrf1mps1 = 0;
  int wg_gyrf1mps1  = 0;


  float a_gy1mps1 = 0;
  int ia_gy1mps1 = 0;
  int pw_gy1mps1a = 0;
  int pw_gy1mps1d = 0;
  int pw_gy1mps1 = 0;
  int wg_gy1mps1  = 0;


  float a_gzrf1mps1 = 0;
  int ia_gzrf1mps1 = 0;
  int pw_gzrf1mps1a = 0;
  int pw_gzrf1mps1d = 0;
  int pw_gzrf1mps1 = 0;
  int wg_gzrf1mps1  = 0;


  float a_gz1mps1 = 0;
  int ia_gz1mps1 = 0;
  int pw_gz1mps1a = 0;
  int pw_gz1mps1d = 0;
  int pw_gz1mps1 = 0;
  int wg_gz1mps1  = 0;


  float a_gx1mps1 = 0;
  int ia_gx1mps1 = 0;
  int pw_gx1mps1a = 0;
  int pw_gx1mps1d = 0;
  int pw_gx1mps1 = 0;
  int wg_gx1mps1  = 0;


  float a_gzrf2mps1 = 0;
  int ia_gzrf2mps1 = 0;
  int pw_gzrf2mps1a = 0;
  int pw_gzrf2mps1d = 0;
  int pw_gzrf2mps1 = 0;
  float a_rf2mps1 = 0;
  int ia_rf2mps1 = 0;
  int pw_rf2mps1 = 0;
  int res_rf2mps1 = 0;
  int temp_res_rf2mps1 = 0;
  float cyc_rf2mps1 = 0;
  int off_rf2mps1 = 0;
  float alpha_rf2mps1 = 0.46;
  float thk_rf2mps1 = 0;
  float gscale_rf2mps1 = 1.0;
  float flip_rf2mps1 = 0;
  int wg_rf2mps1 = TYPRHO1 
;


  float a_gzrf2lmps1 = 0;
  int ia_gzrf2lmps1 = 0;
  int pw_gzrf2lmps1a = 0;
  int pw_gzrf2lmps1d = 0;
  int pw_gzrf2lmps1 = 0;
  int wg_gzrf2lmps1  = 0;


  float a_gzrf2rmps1 = 0;
  int ia_gzrf2rmps1 = 0;
  int pw_gzrf2rmps1a = 0;
  int pw_gzrf2rmps1d = 0;
  int pw_gzrf2rmps1 = 0;
  int wg_gzrf2rmps1  = 0;


  float a_gxwmps1 = 0;
  int ia_gxwmps1 = 0;
  int pw_gxwmps1a = 0;
  int pw_gxwmps1d = 0;
  int pw_gxwmps1 = 0;
  int wg_gxwmps1  = 0;


  int filter_echo1mps1 = 0;


  float a_gzrf1cfl = 0;
  int ia_gzrf1cfl = 0;
  int pw_gzrf1cfla = 0;
  int pw_gzrf1cfld = 0;
  int pw_gzrf1cfl = 0;
  float a_rf1cfl = 0;
  int ia_rf1cfl = 0;
  int pw_rf1cfl = 0;
  int res_rf1cfl = 0;
  int temp_res_rf1cfl = 0;
  float cyc_rf1cfl = 0;
  int off_rf1cfl = 0;
  float alpha_rf1cfl = 0.46;
  float thk_rf1cfl = 0;
  float gscale_rf1cfl = 1.0;
  float flip_rf1cfl = 0;
  int wg_rf1cfl = TYPRHO1 
;


  float a_gz1cfl = 0;
  int ia_gz1cfl = 0;
  int pw_gz1cfla = 0;
  int pw_gz1cfld = 0;
  int pw_gz1cfl = 0;
  int wg_gz1cfl  = 0;


  int filter_cfl_fid = 0;


  float a_gykcfl = 0;
  int ia_gykcfl = 0;
  int pw_gykcfla = 0;
  int pw_gykcfld = 0;
  int pw_gykcfl = 0;
  int wg_gykcfl  = 0;


  float a_gxkrcvn = 0;
  int ia_gxkrcvn = 0;
  int pw_gxkrcvna = 0;
  int pw_gxkrcvnd = 0;
  int pw_gxkrcvn = 0;
  int wg_gxkrcvn  = 0;


  float a_gykrcvn = 0;
  int ia_gykrcvn = 0;
  int pw_gykrcvna = 0;
  int pw_gykrcvnd = 0;
  int pw_gykrcvn = 0;
  int wg_gykrcvn  = 0;


  float a_gzkrcvn = 0;
  int ia_gzkrcvn = 0;
  int pw_gzkrcvna = 0;
  int pw_gzkrcvnd = 0;
  int pw_gzkrcvn = 0;
  int wg_gzkrcvn  = 0;


  int pw_grd_trig = 0;
  int wg_grd_trig  = 0;


  float a_gxk2rcvn = 0;
  int ia_gxk2rcvn = 0;
  int pw_gxk2rcvna = 0;
  int pw_gxk2rcvnd = 0;
  int pw_gxk2rcvn = 0;
  int wg_gxk2rcvn  = 0;


  float a_gyk2rcvn = 0;
  int ia_gyk2rcvn = 0;
  int pw_gyk2rcvna = 0;
  int pw_gyk2rcvnd = 0;
  int pw_gyk2rcvn = 0;
  int wg_gyk2rcvn  = 0;


  float a_gzk2rcvn = 0;
  int ia_gzk2rcvn = 0;
  int pw_gzk2rcvna = 0;
  int pw_gzk2rcvnd = 0;
  int pw_gzk2rcvn = 0;
  int wg_gzk2rcvn  = 0;


  int pw_rcvn_wait = 0;
  int wg_rcvn_wait  = 0;


  int ia_rcvrbl = 0;


  int filter_rcvn_fid = 0;


  int ia_rcvrbl2 = 0;


  float a_gzrf0cfh = 0;
  int ia_gzrf0cfh = 0;
  int pw_gzrf0cfha = 0;
  int pw_gzrf0cfhd = 0;
  int pw_gzrf0cfh = 0;
  int res_gzrf0cfh = 0;
  float a_rf0cfh = 0;
  int ia_rf0cfh = 0;
  int pw_rf0cfh = 0;
  int res_rf0cfh = 0;
  float cyc_rf0cfh = 0;
  int off_rf0cfh = 0;
  float alpha_rf0cfh = 0.46;
  float thk_rf0cfh = 0;
  float gscale_rf0cfh = 1.0;
  float flip_rf0cfh = 0;
  int wg_rf0cfh = TYPRHO1 
;


  float a_omegarf0cfh = 0;
  int ia_omegarf0cfh = 0;
  int pw_omegarf0cfh = 0;
  int res_omegarf0cfh = 0;
  int off_omegarf0cfh = 0;
  int rfslot_omegarf0cfh = 0;

  float gscale_omegarf0cfh = 1.0;
  int n_omegarf0cfh = 0;
  int wg_omegarf0cfh  = 0;


  float a_gyrf0kcfh = 0;
  int ia_gyrf0kcfh = 0;
  int pw_gyrf0kcfha = 0;
  int pw_gyrf0kcfhd = 0;
  int pw_gyrf0kcfh = 0;
  int wg_gyrf0kcfh  = 0;


  int pw_zticfh = 0;
  int wg_zticfh  = 0;


  int pw_rticfh = 0;
  int wg_rticfh  = 0;


  int pw_xticfh = 0;
  int wg_xticfh  = 0;


  int pw_yticfh = 0;
  int wg_yticfh  = 0;


  int pw_sticfh = 0;
  int wg_sticfh  = 0;


  float a_gzrf1cfh = 0;
  int ia_gzrf1cfh = 0;
  int pw_gzrf1cfha = 0;
  int pw_gzrf1cfhd = 0;
  int pw_gzrf1cfh = 0;
  float a_rf1cfh = 0;
  int ia_rf1cfh = 0;
  int pw_rf1cfh = 0;
  int res_rf1cfh = 0;
  int temp_res_rf1cfh = 0;
  float cyc_rf1cfh = 0;
  int off_rf1cfh = 0;
  float alpha_rf1cfh = 0.46;
  float thk_rf1cfh = 0;
  float gscale_rf1cfh = 1.0;
  float flip_rf1cfh = 0;
  int wg_rf1cfh = TYPRHO1 
;


  float a_rf2cfh = 0;
  int ia_rf2cfh = 0;
  int pw_rf2cfh = 0;
  int res_rf2cfh = 0;
  float cyc_rf2cfh = 0;
  int off_rf2cfh = 0;
  float alpha_rf2cfh = 0;
  int wg_rf2cfh  = 0;


  float a_rf3cfh = 0;
  int ia_rf3cfh = 0;
  int pw_rf3cfh = 0;
  int res_rf3cfh = 0;
  float cyc_rf3cfh = 0;
  int off_rf3cfh = 0;
  float alpha_rf3cfh = 0;
  int wg_rf3cfh  = 0;


  float a_rf4cfh = 0;
  int ia_rf4cfh = 0;
  int pw_rf4cfh = 0;
  int res_rf4cfh = 0;
  float cyc_rf4cfh = 0;
  int off_rf4cfh = 0;
  float alpha_rf4cfh = 0;
  int wg_rf4cfh  = 0;


  float a_gxrf2cfh = 0;
  int ia_gxrf2cfh = 0;
  int pw_gxrf2cfha = 0;
  int pw_gxrf2cfhd = 0;
  int pw_gxrf2cfh = 0;
  int wg_gxrf2cfh  = 0;


  float a_gyrf2cfh = 0;
  int ia_gyrf2cfh = 0;
  int pw_gyrf2cfha = 0;
  int pw_gyrf2cfhd = 0;
  int pw_gyrf2cfh = 0;
  int wg_gyrf2cfh  = 0;


  float a_gzrf2lcfh = 0;
  int ia_gzrf2lcfh = 0;
  int pw_gzrf2lcfha = 0;
  int pw_gzrf2lcfhd = 0;
  int pw_gzrf2lcfh = 0;
  int wg_gzrf2lcfh  = 0;


  float a_gzrf2rcfh = 0;
  int ia_gzrf2rcfh = 0;
  int pw_gzrf2rcfha = 0;
  int pw_gzrf2rcfhd = 0;
  int pw_gzrf2rcfh = 0;
  int wg_gzrf2rcfh  = 0;


  float a_gyrf3cfh = 0;
  int ia_gyrf3cfh = 0;
  int pw_gyrf3cfha = 0;
  int pw_gyrf3cfhd = 0;
  int pw_gyrf3cfh = 0;
  int wg_gyrf3cfh  = 0;


  float a_gzrf3lcfh = 0;
  int ia_gzrf3lcfh = 0;
  int pw_gzrf3lcfha = 0;
  int pw_gzrf3lcfhd = 0;
  int pw_gzrf3lcfh = 0;
  int wg_gzrf3lcfh  = 0;


  float a_gzrf3rcfh = 0;
  int ia_gzrf3rcfh = 0;
  int pw_gzrf3rcfha = 0;
  int pw_gzrf3rcfhd = 0;
  int pw_gzrf3rcfh = 0;
  int wg_gzrf3rcfh  = 0;


  float a_gy1cfh = 0;
  int ia_gy1cfh = 0;
  int pw_gy1cfha = 0;
  int pw_gy1cfhd = 0;
  int pw_gy1cfh = 0;
  int wg_gy1cfh  = 0;


  float a_gx1cfh = 0;
  int ia_gx1cfh = 0;
  int pw_gx1cfha = 0;
  int pw_gx1cfhd = 0;
  int pw_gx1cfh = 0;
  int wg_gx1cfh  = 0;


  float a_gzrf4cfh = 0;
  int ia_gzrf4cfh = 0;
  int pw_gzrf4cfha = 0;
  int pw_gzrf4cfhd = 0;
  int pw_gzrf4cfh = 0;
  int wg_gzrf4cfh  = 0;


  int pw_isi_slice1 = 0;
  int wg_isi_slice1  = 0;


  int pw_rot_slice1 = 0;
  int wg_rot_slice1  = 0;


  int pw_isi_slice2 = 0;
  int wg_isi_slice2  = 0;


  int pw_rot_slice2 = 0;
  int wg_rot_slice2  = 0;


  float a_gzrf4lcfh = 0;
  int ia_gzrf4lcfh = 0;
  int pw_gzrf4lcfha = 0;
  int pw_gzrf4lcfhd = 0;
  int pw_gzrf4lcfh = 0;
  int wg_gzrf4lcfh  = 0;


  float a_gzrf4rcfh = 0;
  int ia_gzrf4rcfh = 0;
  int pw_gzrf4rcfha = 0;
  int pw_gzrf4rcfhd = 0;
  int pw_gzrf4rcfh = 0;
  int wg_gzrf4rcfh  = 0;


  int filter_cfh_fid = 0;


  float a_gykcfh = 0;
  int ia_gykcfh = 0;
  int pw_gykcfha = 0;
  int pw_gykcfhd = 0;
  int pw_gykcfh = 0;
  int wg_gykcfh  = 0;


  int ia_contrfhubsel = 0;


  int ia_contrfsel = 0;


  int pw_csw_wait = 0;
  int wg_csw_wait  = 0;


  float a_gzrf1ftg = 0;
  int ia_gzrf1ftg = 0;
  int pw_gzrf1ftga = 0;
  int pw_gzrf1ftgd = 0;
  int pw_gzrf1ftg = 0;
  float a_rf1ftg = 0;
  int ia_rf1ftg = 0;
  int pw_rf1ftg = 0;
  int res_rf1ftg = 0;
  int temp_res_rf1ftg = 0;
  float cyc_rf1ftg = 0;
  int off_rf1ftg = 0;
  float alpha_rf1ftg = 0.46;
  float thk_rf1ftg = 0;
  float gscale_rf1ftg = 1.0;
  float flip_rf1ftg = 0;
  int wg_rf1ftg = TYPRHO1 
;


  float a_gz1ftg = 0;
  int ia_gz1ftg = 0;
  int pw_gz1ftga = 0;
  int pw_gz1ftgd = 0;
  int pw_gz1ftg = 0;
  int wg_gz1ftg  = 0;


  float a_gzrf2ftg = 0;
  int ia_gzrf2ftg = 0;
  int pw_gzrf2ftga = 0;
  int pw_gzrf2ftgd = 0;
  int pw_gzrf2ftg = 0;
  float a_rf2ftg = 0;
  int ia_rf2ftg = 0;
  int pw_rf2ftg = 0;
  int res_rf2ftg = 0;
  int temp_res_rf2ftg = 0;
  float cyc_rf2ftg = 0;
  int off_rf2ftg = 0;
  float alpha_rf2ftg = 0.46;
  float thk_rf2ftg = 0;
  float gscale_rf2ftg = 1.0;
  float flip_rf2ftg = 0;
  int wg_rf2ftg = TYPRHO1 
;


  float a_gz2ftg = 0;
  int ia_gz2ftg = 0;
  int pw_gz2ftga = 0;
  int pw_gz2ftgd = 0;
  int pw_gz2ftg = 0;
  int wg_gz2ftg  = 0;


  float a_gzrf3ftg = 0;
  int ia_gzrf3ftg = 0;
  int pw_gzrf3ftga = 0;
  int pw_gzrf3ftgd = 0;
  int pw_gzrf3ftg = 0;
  float a_rf3ftg = 0;
  int ia_rf3ftg = 0;
  int pw_rf3ftg = 0;
  int res_rf3ftg = 0;
  int temp_res_rf3ftg = 0;
  float cyc_rf3ftg = 0;
  int off_rf3ftg = 0;
  float alpha_rf3ftg = 0.46;
  float thk_rf3ftg = 0;
  float gscale_rf3ftg = 1.0;
  float flip_rf3ftg = 0;
  int wg_rf3ftg = TYPRHO1 
;


  float a_gz3ftg = 0;
  int ia_gz3ftg = 0;
  int pw_gz3ftga = 0;
  int pw_gz3ftgd = 0;
  int pw_gz3ftg = 0;
  int wg_gz3ftg  = 0;


  float a_gx1ftg = 0;
  int ia_gx1ftg = 0;
  int pw_gx1ftga = 0;
  int pw_gx1ftgd = 0;
  int pw_gx1ftg = 0;
  int wg_gx1ftg  = 0;


  float a_gx1bftg = 0;
  int ia_gx1bftg = 0;
  int pw_gx1bftga = 0;
  int pw_gx1bftgd = 0;
  int pw_gx1bftg = 0;
  int wg_gx1bftg  = 0;


  float a_gxw1ftg = 0;
  int ia_gxw1ftg = 0;
  int pw_gxw1ftga = 0;
  int pw_gxw1ftgd = 0;
  int pw_gxw1ftg = 0;
  int wg_gxw1ftg  = 0;


  float a_postgxw1ftg = 0;
  int ia_postgxw1ftg = 0;
  int pw_postgxw1ftga = 0;
  int pw_postgxw1ftgd = 0;
  int pw_postgxw1ftg = 0;
  int wg_postgxw1ftg  = 0;


  int filter_echo1ftg = 0;


  float a_gz2bftg = 0;
  int ia_gz2bftg = 0;
  int pw_gz2bftga = 0;
  int pw_gz2bftgd = 0;
  int pw_gz2bftg = 0;
  int wg_gz2bftg  = 0;


  float a_gx2ftg = 0;
  int ia_gx2ftg = 0;
  int pw_gx2ftga = 0;
  int pw_gx2ftgd = 0;
  int pw_gx2ftg = 0;
  int wg_gx2ftg  = 0;


  float a_gxw2ftg = 0;
  int ia_gxw2ftg = 0;
  int pw_gxw2ftga = 0;
  int pw_gxw2ftgd = 0;
  int pw_gxw2ftg = 0;
  int wg_gxw2ftg  = 0;


  float a_gx2test = 0;
  int ia_gx2test = 0;
  int pw_gx2testa = 0;
  int pw_gx2testd = 0;
  int pw_gx2test = 0;
  int wg_gx2test  = 0;


  int filter_echo2ftg = 0;


  float a_rf1xtg = 0;
  int ia_rf1xtg = 0;
  int pw_rf1xtg = 0;
  int res_rf1xtg = 0;
  float cyc_rf1xtg = 0;
  int off_rf1xtg = 0;
  float alpha_rf1xtg = 0;
  int wg_rf1xtg  = 0;


  float a_gyrf1xtg = 0;
  int ia_gyrf1xtg = 0;
  int pw_gyrf1xtga = 0;
  int pw_gyrf1xtgd = 0;
  int pw_gyrf1xtg = 0;
  int wg_gyrf1xtg  = 0;


  float a_gzrf1xtg = 0;
  int ia_gzrf1xtg = 0;
  int pw_gzrf1xtga = 0;
  int pw_gzrf1xtgd = 0;
  int pw_gzrf1xtg = 0;
  int wg_gzrf1xtg  = 0;


  float a_gykxtgl = 0;
  int ia_gykxtgl = 0;
  int pw_gykxtgla = 0;
  int pw_gykxtgld = 0;
  int pw_gykxtgl = 0;
  int wg_gykxtgl  = 0;


       /* off-res B1 prep pulse */
       float a_rf3xtg = 0;
       int ia_rf3xtg = 0;
       int pw_rf3xtg = 0;
       int res_rf3xtg = 0;
       int off_rf3xtg = 0;
       float alpha_rf3xtg = 0.46;
       float gscale_rf3xtg = 1.0;
       float flip_rf3xtg = 0;
       int ia_phs_rf3xtg = 0;
       int wg_rf3xtg = TYPRHO1 
;


  float a_gz1xtg = 0;
  int ia_gz1xtg = 0;
  int pw_gz1xtga = 0;
  int pw_gz1xtgd = 0;
  int pw_gz1xtg = 0;
  int wg_gz1xtg  = 0;


  float a_gzrf2xtg = 0;
  int ia_gzrf2xtg = 0;
  int pw_gzrf2xtga = 0;
  int pw_gzrf2xtgd = 0;
  int pw_gzrf2xtg = 0;
  float a_rf2xtg = 0;
  int ia_rf2xtg = 0;
  int pw_rf2xtg = 0;
  int res_rf2xtg = 0;
  int temp_res_rf2xtg = 0;
  float cyc_rf2xtg = 0;
  int off_rf2xtg = 0;
  float alpha_rf2xtg = 0.46;
  float thk_rf2xtg = 0;
  float gscale_rf2xtg = 1.0;
  float flip_rf2xtg = 0;
  int wg_rf2xtg = TYPRHO1 
;


  float a_gz2xtg = 0;
  int ia_gz2xtg = 0;
  int pw_gz2xtga = 0;
  int pw_gz2xtgd = 0;
  int pw_gz2xtg = 0;
  int wg_gz2xtg  = 0;


       /* off-res B1 prep pulse */
       float a_rf4xtg = 0;
       int ia_rf4xtg = 0;
       int pw_rf4xtg = 0;
       int res_rf4xtg = 0;
       int off_rf4xtg = 0;
       float alpha_rf4xtg = 0.46;
       float gscale_rf4xtg = 1.0;
       float flip_rf4xtg = 0;
       int ia_phs_rf4xtg = 0;
       int wg_rf4xtg = TYPRHO1 
;


  float a_gykxtgr = 0;
  int ia_gykxtgr = 0;
  int pw_gykxtgra = 0;
  int pw_gykxtgrd = 0;
  int pw_gykxtgr = 0;
  int wg_gykxtgr  = 0;


  float a_gx1bxtg = 0;
  int ia_gx1bxtg = 0;
  int pw_gx1bxtga = 0;
  int pw_gx1bxtgd = 0;
  int pw_gx1bxtg = 0;
  int wg_gx1bxtg  = 0;


  float a_gxw1xtg = 0;
  int ia_gxw1xtg = 0;
  int pw_gxw1xtga = 0;
  int pw_gxw1xtgd = 0;
  int pw_gxw1xtg = 0;
  int wg_gxw1xtg  = 0;


  int filter_echo1xtg = 0;


  float a_gzrf1as = 0;
  int ia_gzrf1as = 0;
  int pw_gzrf1asa = 0;
  int pw_gzrf1asd = 0;
  int pw_gzrf1as = 0;
  float a_rf1as = 0;
  int ia_rf1as = 0;
  int pw_rf1as = 0;
  int res_rf1as = 0;
  int temp_res_rf1as = 0;
  float cyc_rf1as = 0;
  int off_rf1as = 0;
  float alpha_rf1as = 0.46;
  float thk_rf1as = 0;
  float gscale_rf1as = 1.0;
  float flip_rf1as = 0;
  int wg_rf1as = TYPRHO1 
;


  float a_gz1as = 0;
  int ia_gz1as = 0;
  int pw_gz1asa = 0;
  int pw_gz1asd = 0;
  int pw_gz1as = 0;
  int wg_gz1as  = 0;


  float a_gxwas = 0;
  int ia_gxwas = 0;
  int pw_gxwasa = 0;
  int pw_gxwasd = 0;
  int pw_gxwas = 0;
  int wg_gxwas  = 0;


  int filter_echo1as = 0;


  float a_gx1as = 0;
  int ia_gx1as = 0;
  int pw_gx1asa = 0;
  int pw_gx1asd = 0;
  int pw_gx1as = 0;
  int wg_gx1as  = 0;


  float a_gy1as = 0;
  float a_gy1asa = 0;
  float a_gy1asb = 0;
  int ia_gy1as = 0;
  int ia_gy1aswa = 0;
  int ia_gy1aswb = 0;
  int pw_gy1asa = 0;
  int pw_gy1asd = 0;
  int pw_gy1as = 0;
  int wg_gy1as  = 0;


  float a_gy1ras = 0;
  float a_gy1rasa = 0;
  float a_gy1rasb = 0;
  int ia_gy1ras = 0;
  int ia_gy1raswa = 0;
  int ia_gy1raswb = 0;
  int pw_gy1rasa = 0;
  int pw_gy1rasd = 0;
  int pw_gy1ras = 0;
  int wg_gy1ras  = 0;


  float a_gxkas = 0;
  int ia_gxkas = 0;
  int pw_gxkasa = 0;
  int pw_gxkasd = 0;
  int pw_gxkas = 0;
  int wg_gxkas  = 0;


  float a_gzkas = 0;
  int ia_gzkas = 0;
  int pw_gzkasa = 0;
  int pw_gzkasd = 0;
  int pw_gzkas = 0;
  int wg_gzkas  = 0;


  float a_xdixon = 0;
  int ia_xdixon = 0;
  int pw_xdixon = 0;
  int wg_xdixon  = 0;


  float a_ydixon = 0;
  int ia_ydixon = 0;
  int pw_ydixon = 0;
  int wg_ydixon  = 0;


  float a_zdixon = 0;
  int ia_zdixon = 0;
  int pw_zdixon = 0;
  int wg_zdixon  = 0;


  float a_sdixon = 0;
  int ia_sdixon = 0;
  int pw_sdixon = 0;
  int wg_sdixon  = 0;


  float a_sdixon2 = 0;
  int ia_sdixon2 = 0;
  int pw_sdixon2 = 0;
  int wg_sdixon2  = 0;


  int ia_dDDIQ = 0;


  int res_rf1rs = 0;
  int wg_rf1rs  = 0;


  float a_gzrf1rs = 0;
  int ia_gzrf1rs = 0;
  int pw_gzrf1rsa = 0;
  int pw_gzrf1rsd = 0;
  int pw_gzrf1rs = 0;
  int wg_gzrf1rs  = 0;


  float a_gxkbsrs = 0;
  int ia_gxkbsrs = 0;
  int pw_gxkbsrsa = 0;
  int pw_gxkbsrsd = 0;
  int pw_gxkbsrs = 0;
  int wg_gxkbsrs  = 0;


  float a_gz1rs = 0;
  int ia_gz1rs = 0;
  int pw_gz1rsa = 0;
  int pw_gz1rsd = 0;
  int pw_gz1rs = 0;
  int wg_gz1rs  = 0;


  float a_rfbrs = 0;
  int ia_rfbrs = 0;
  int pw_rfbrs = 0;
  int res_rfbrs = 0;
  int off_rfbrs = 0;
  int rfslot_rfbrs = 0;

  float gscale_rfbrs = 1.0;
  int n_rfbrs = 0;
  int wg_rfbrs  = 0;


  float a_thetarfbrs = 0;
  int ia_thetarfbrs = 0;
  int pw_thetarfbrs = 0;
  int res_thetarfbrs = 0;
  int off_thetarfbrs = 0;
  int rfslot_thetarfbrs = 0;

  float gscale_thetarfbrs = 1.0;
  int n_thetarfbrs = 0;
  int wg_thetarfbrs  = 0;


  float a_gzkbsrs = 0;
  int ia_gzkbsrs = 0;
  int pw_gzkbsrsa = 0;
  int pw_gzkbsrsd = 0;
  int pw_gzkbsrs = 0;
  int wg_gzkbsrs  = 0;


  float a_gxwrs = 0;
  int ia_gxwrs = 0;
  int pw_gxwrsa = 0;
  int pw_gxwrsd = 0;
  int pw_gxwrs = 0;
  int wg_gxwrs  = 0;


  int filter_echo1rs = 0;


  float a_gx2rs = 0;
  int ia_gx2rs = 0;
  int pw_gx2rsa = 0;
  int pw_gx2rsd = 0;
  int pw_gx2rs = 0;
  int wg_gx2rs  = 0;


  float a_gy2rs = 0;
  float a_gy2rsa = 0;
  float a_gy2rsb = 0;
  int ia_gy2rs = 0;
  int ia_gy2rswa = 0;
  int ia_gy2rswb = 0;
  int pw_gy2rsa = 0;
  int pw_gy2rsd = 0;
  int pw_gy2rs = 0;
  int wg_gy2rs  = 0;


  float a_gxw2rs = 0;
  int ia_gxw2rs = 0;
  int pw_gxw2rsa = 0;
  int pw_gxw2rsd = 0;
  int pw_gxw2rs = 0;
  int wg_gxw2rs  = 0;


  float a_gx1rs = 0;
  int ia_gx1rs = 0;
  int pw_gx1rsa = 0;
  int pw_gx1rsd = 0;
  int pw_gx1rs = 0;
  int wg_gx1rs  = 0;


  float a_gy1rrs = 0;
  float a_gy1rrsa = 0;
  float a_gy1rrsb = 0;
  int ia_gy1rrs = 0;
  int ia_gy1rrswa = 0;
  int ia_gy1rrswb = 0;
  int pw_gy1rrsa = 0;
  int pw_gy1rrsd = 0;
  int pw_gy1rrs = 0;
  int wg_gy1rrs  = 0;


  float a_gy1rs = 0;
  float a_gy1rsa = 0;
  float a_gy1rsb = 0;
  int ia_gy1rs = 0;
  int ia_gy1rswa = 0;
  int ia_gy1rswb = 0;
  int pw_gy1rsa = 0;
  int pw_gy1rsd = 0;
  int pw_gy1rs = 0;
  int wg_gy1rs  = 0;


  float a_gzkrs = 0;
  int ia_gzkrs = 0;
  int pw_gzkrsa = 0;
  int pw_gzkrsd = 0;
  int pw_gzkrs = 0;
  int wg_gzkrs  = 0;


  float a_gxkrs = 0;
  int ia_gxkrs = 0;
  int pw_gxkrsa = 0;
  int pw_gxkrsd = 0;
  int pw_gxkrs = 0;
  int wg_gxkrs  = 0;


  int res_rf1dtg = 0;
  int wg_rf1dtg  = 0;


  float a_gzrf1dtg = 0;
  int ia_gzrf1dtg = 0;
  int pw_gzrf1dtga = 0;
  int pw_gzrf1dtgd = 0;
  int pw_gzrf1dtg = 0;
  int wg_gzrf1dtg  = 0;


  float a_gxkbsdtg = 0;
  int ia_gxkbsdtg = 0;
  int pw_gxkbsdtga = 0;
  int pw_gxkbsdtgd = 0;
  int pw_gxkbsdtg = 0;
  int wg_gxkbsdtg  = 0;


  float a_gz1dtg = 0;
  int ia_gz1dtg = 0;
  int pw_gz1dtga = 0;
  int pw_gz1dtgd = 0;
  int pw_gz1dtg = 0;
  int wg_gz1dtg  = 0;


  float a_rfbdtg = 0;
  int ia_rfbdtg = 0;
  int pw_rfbdtg = 0;
  int res_rfbdtg = 0;
  int off_rfbdtg = 0;
  int rfslot_rfbdtg = 0;

  float gscale_rfbdtg = 1.0;
  int n_rfbdtg = 0;
  int wg_rfbdtg  = 0;


  float a_thetarfbdtg = 0;
  int ia_thetarfbdtg = 0;
  int pw_thetarfbdtg = 0;
  int res_thetarfbdtg = 0;
  int off_thetarfbdtg = 0;
  int rfslot_thetarfbdtg = 0;

  float gscale_thetarfbdtg = 1.0;
  int n_thetarfbdtg = 0;
  int wg_thetarfbdtg  = 0;


  float a_gzkbsdtg = 0;
  int ia_gzkbsdtg = 0;
  int pw_gzkbsdtga = 0;
  int pw_gzkbsdtgd = 0;
  int pw_gzkbsdtg = 0;
  int wg_gzkbsdtg  = 0;


  float a_gxwdtg = 0;
  int ia_gxwdtg = 0;
  int pw_gxwdtga = 0;
  int pw_gxwdtgd = 0;
  int pw_gxwdtg = 0;
  int wg_gxwdtg  = 0;


  int filter_echo1dtg = 0;


  float a_gx2dtg = 0;
  int ia_gx2dtg = 0;
  int pw_gx2dtga = 0;
  int pw_gx2dtgd = 0;
  int pw_gx2dtg = 0;
  int wg_gx2dtg  = 0;


  float a_gy2dtg = 0;
  float a_gy2dtga = 0;
  float a_gy2dtgb = 0;
  int ia_gy2dtg = 0;
  int ia_gy2dtgwa = 0;
  int ia_gy2dtgwb = 0;
  int pw_gy2dtga = 0;
  int pw_gy2dtgd = 0;
  int pw_gy2dtg = 0;
  int wg_gy2dtg  = 0;


  float a_gxw2dtg = 0;
  int ia_gxw2dtg = 0;
  int pw_gxw2dtga = 0;
  int pw_gxw2dtgd = 0;
  int pw_gxw2dtg = 0;
  int wg_gxw2dtg  = 0;


  float a_gx1dtg = 0;
  int ia_gx1dtg = 0;
  int pw_gx1dtga = 0;
  int pw_gx1dtgd = 0;
  int pw_gx1dtg = 0;
  int wg_gx1dtg  = 0;


  float a_gy1rdtg = 0;
  float a_gy1rdtga = 0;
  float a_gy1rdtgb = 0;
  int ia_gy1rdtg = 0;
  int ia_gy1rdtgwa = 0;
  int ia_gy1rdtgwb = 0;
  int pw_gy1rdtga = 0;
  int pw_gy1rdtgd = 0;
  int pw_gy1rdtg = 0;
  int wg_gy1rdtg  = 0;


  float a_gy1dtg = 0;
  float a_gy1dtga = 0;
  float a_gy1dtgb = 0;
  int ia_gy1dtg = 0;
  int ia_gy1dtgwa = 0;
  int ia_gy1dtgwb = 0;
  int pw_gy1dtga = 0;
  int pw_gy1dtgd = 0;
  int pw_gy1dtg = 0;
  int wg_gy1dtg  = 0;


  float a_gzkdtg = 0;
  int ia_gzkdtg = 0;
  int pw_gzkdtga = 0;
  int pw_gzkdtgd = 0;
  int pw_gzkdtg = 0;
  int wg_gzkdtg  = 0;


  float a_gxkdtg = 0;
  int ia_gxkdtg = 0;
  int pw_gxkdtga = 0;
  int pw_gxkdtgd = 0;
  int pw_gxkdtg = 0;
  int wg_gxkdtg  = 0;


  float a_rf1cal = 0;
  int ia_rf1cal = 0;
  int pw_rf1cal = 0;
  int res_rf1cal = 0;
  int off_rf1cal = 0;
  int rfslot_rf1cal = 0;

  float gscale_rf1cal = 1.0;
  int n_rf1cal = 0;
  int wg_rf1cal  = 0;


  float a_gzrf1cal = 0;
  int ia_gzrf1cal = 0;
  int pw_gzrf1cala = 0;
  int pw_gzrf1cald = 0;
  int pw_gzrf1cal = 0;
  int wg_gzrf1cal  = 0;


  float a_gzcombcal = 0;
  float a_gzcombcala = 0;
  float a_gzcombcalb = 0;
  int ia_gzcombcal = 0;
  int ia_gzcombcalwa = 0;
  int ia_gzcombcalwb = 0;
  int pw_gzcombcala = 0;
  int pw_gzcombcald = 0;
  int pw_gzcombcalf = 0;    /* pulse width of leading edge */
  int pw_gzcombcal = 0;
  int res_gzcombcal = 0;
  int per_gzcombcal = 0;
  int wg_gzcombcal  = 0;


  float a_gzprcal = 0;
  float a_gzprcala = 0;
  float a_gzprcalb = 0;
  int ia_gzprcal = 0;
  int ia_gzprcalwa = 0;
  int ia_gzprcalwb = 0;
  int pw_gzprcala = 0;
  int pw_gzprcald = 0;
  int pw_gzprcalf = 0;    /* pulse width of leading edge */
  int pw_gzprcal = 0;
  int res_gzprcal = 0;
  int per_gzprcal = 0;
  int wg_gzprcal  = 0;


  float a_gxwcal = 0;
  int ia_gxwcal = 0;
  int pw_gxwcala = 0;
  int pw_gxwcald = 0;
  int pw_gxwcal = 0;
  int wg_gxwcal  = 0;


  int filter_echo1cal = 0;


  float a_gx1cal = 0;
  float a_gx1cala = 0;
  float a_gx1calb = 0;
  int ia_gx1cal = 0;
  int ia_gx1calwa = 0;
  int ia_gx1calwb = 0;
  int pw_gx1cala = 0;
  int pw_gx1cald = 0;
  int pw_gx1calf = 0;    /* pulse width of leading edge */
  int pw_gx1cal = 0;
  int res_gx1cal = 0;
  int per_gx1cal = 0;
  int wg_gx1cal  = 0;


  float a_gy1cal = 0;
  float a_gy1cala = 0;
  float a_gy1calb = 0;
  int ia_gy1cal = 0;
  int ia_gy1calwa = 0;
  int ia_gy1calwb = 0;
  int pw_gy1cala = 0;
  int pw_gy1cald = 0;
  int pw_gy1calf = 0;    /* pulse width of leading edge */
  int pw_gy1cal = 0;
  int res_gy1cal = 0;
  int per_gy1cal = 0;
  int wg_gy1cal  = 0;


  float a_gy1rcal = 0;
  float a_gy1rcala = 0;
  float a_gy1rcalb = 0;
  int ia_gy1rcal = 0;
  int ia_gy1rcalwa = 0;
  int ia_gy1rcalwb = 0;
  int pw_gy1rcala = 0;
  int pw_gy1rcald = 0;
  int pw_gy1rcalf = 0;    /* pulse width of leading edge */
  int pw_gy1rcal = 0;
  int res_gy1rcal = 0;
  int per_gy1rcal = 0;
  int wg_gy1rcal  = 0;


  float a_rf1coil = 0;
  int ia_rf1coil = 0;
  int pw_rf1coil = 0;
  int res_rf1coil = 0;
  int off_rf1coil = 0;
  int rfslot_rf1coil = 0;

  float gscale_rf1coil = 1.0;
  int n_rf1coil = 0;
  int wg_rf1coil  = 0;


  float a_gzrf1coil = 0;
  int ia_gzrf1coil = 0;
  int pw_gzrf1coila = 0;
  int pw_gzrf1coild = 0;
  int pw_gzrf1coil = 0;
  int wg_gzrf1coil  = 0;


  float a_gzcombcoil = 0;
  float a_gzcombcoila = 0;
  float a_gzcombcoilb = 0;
  int ia_gzcombcoil = 0;
  int ia_gzcombcoilwa = 0;
  int ia_gzcombcoilwb = 0;
  int pw_gzcombcoila = 0;
  int pw_gzcombcoild = 0;
  int pw_gzcombcoilf = 0;    /* pulse width of leading edge */
  int pw_gzcombcoil = 0;
  int res_gzcombcoil = 0;
  int per_gzcombcoil = 0;
  int wg_gzcombcoil  = 0;


  float a_gzprcoil = 0;
  float a_gzprcoila = 0;
  float a_gzprcoilb = 0;
  int ia_gzprcoil = 0;
  int ia_gzprcoilwa = 0;
  int ia_gzprcoilwb = 0;
  int pw_gzprcoila = 0;
  int pw_gzprcoild = 0;
  int pw_gzprcoilf = 0;    /* pulse width of leading edge */
  int pw_gzprcoil = 0;
  int res_gzprcoil = 0;
  int per_gzprcoil = 0;
  int wg_gzprcoil  = 0;


  float a_gxwcoil = 0;
  int ia_gxwcoil = 0;
  int pw_gxwcoila = 0;
  int pw_gxwcoild = 0;
  int pw_gxwcoil = 0;
  int wg_gxwcoil  = 0;


  int filter_echo1coil = 0;


  float a_gx1coil = 0;
  float a_gx1coila = 0;
  float a_gx1coilb = 0;
  int ia_gx1coil = 0;
  int ia_gx1coilwa = 0;
  int ia_gx1coilwb = 0;
  int pw_gx1coila = 0;
  int pw_gx1coild = 0;
  int pw_gx1coilf = 0;    /* pulse width of leading edge */
  int pw_gx1coil = 0;
  int res_gx1coil = 0;
  int per_gx1coil = 0;
  int wg_gx1coil  = 0;


  float a_gy1coil = 0;
  float a_gy1coila = 0;
  float a_gy1coilb = 0;
  int ia_gy1coil = 0;
  int ia_gy1coilwa = 0;
  int ia_gy1coilwb = 0;
  int pw_gy1coila = 0;
  int pw_gy1coild = 0;
  int pw_gy1coilf = 0;    /* pulse width of leading edge */
  int pw_gy1coil = 0;
  int res_gy1coil = 0;
  int per_gy1coil = 0;
  int wg_gy1coil  = 0;


  float a_gy1rcoil = 0;
  float a_gy1rcoila = 0;
  float a_gy1rcoilb = 0;
  int ia_gy1rcoil = 0;
  int ia_gy1rcoilwa = 0;
  int ia_gy1rcoilwb = 0;
  int pw_gy1rcoila = 0;
  int pw_gy1rcoild = 0;
  int pw_gy1rcoilf = 0;    /* pulse width of leading edge */
  int pw_gy1rcoil = 0;
  int res_gy1rcoil = 0;
  int per_gy1rcoil = 0;
  int wg_gy1rcoil  = 0;

long _lastcv = 0;

#endif /* h_ksepi_allcv_h */

