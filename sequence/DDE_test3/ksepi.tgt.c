/*
 *  ksepi.tgt.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Nov 24 2018
 *  Time : 13:36:59
 */

#include <epic_struct.h>
#if defined(MGD_TGT) && defined(PSD_HW)
#include "valuesMGD.h"
#endif /* MGD_TGT && PSD_HW */
#include "ksepi.global.h"
#include <pgen_tmpl.h>
#include <epicfuns.h>
#ifdef PSD_HW
__asm__(".align 8");
#endif

#include "ksepi.allcv.h"
#include "ksepi.tgtex.h"
#include "ksepi.tgtdecl.h"
long _header_source_rev= 1564434063;
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: PULSEGEN functions
 *                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
 *
 *******************************************************************************************************
 *******************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

#include "addrfbits.h"
#include "rfsspsummary.h"

int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short dyntg_txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1 = res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl = res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


        if(3 == rcvn_flag)   /* Additional gradient waveform for Grad prognostic */
        {
            long ctrl_word;

               
  {
    pulsename(&grd_trig,"grd_trig");
    createconst(&grd_trig,(WF_PROCESSOR)wg_grd_trig,pw_grd_trig,(short)0); 
    createinstr( &grd_trig,(long)(posstart),pw_grd_trig,0);
  }

            getctrl(&ctrl_word, &grd_trig, 0);
            ctrl_word = ctrl_word | PSD_GRADR_SYNC;
            setctrl(ctrl_word, &grd_trig, 0);
            posstart = RUP_GRD(pendallssp(&grd_trig, 0)); 

            postemp = RUP_GRD(pend(&gxkrcvnd,"gxkrcvnd",0) + pw_gxk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gxk2rcvn, "gxk2rcvn", &gxk2rcvn, &gxk2rcvna,
                        &gxk2rcvnd, pw_gxk2rcvn, pw_gxk2rcvna, pw_gxk2rcvnd,
                        ia_gxk2rcvn, 0, 0, 0, 0, postemp-pw_gxk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gykrcvnd,"gykrcvnd",0) + pw_gyk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gyk2rcvn, "gyk2rcvn", &gyk2rcvn, &gyk2rcvna,
                        &gyk2rcvnd, pw_gyk2rcvn, pw_gyk2rcvna, pw_gyk2rcvnd,
                        ia_gyk2rcvn, 0, 0, 0, 0, postemp-pw_gyk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gzkrcvnd,"gzkrcvnd",0) + pw_gzk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gzk2rcvn, "gzk2rcvn", &gzk2rcvn, &gzk2rcvna,
                        &gzk2rcvnd, pw_gzk2rcvn, pw_gzk2rcvna, pw_gzk2rcvnd,
                        ia_gzk2rcvn, 0, 0, 0, 0, postemp-pw_gzk2rcvna, TRAP_ALL,
                        &rcvnloggrd);

        }
    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);

                movestretchedwave( grad_zrf0cfh, res_gzrf0cfh,
                                   &gzrf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

            movestretchedwave( rf_rf0cfh, res_rf0cfh,
                               &rf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {
        INT old_res =  res_omegarf0cfh; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0cfh += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

                movestretchedwave( fileloc_omegarf0cfh, old_res,
                                   &omegarf0cfh, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh = res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = temp_res_rf1cfh;
  }


    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (int)(0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                       + IMax(2, min_ssp,
                              (pw_gzrf1cfhd + pw_gzrf2lcfha
                               + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                       + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                       + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                            + IMax(2, min_ssp,
                                   (pw_gzrf1cfhd + pw_gzrf2lcfha
                                    + pw_gzrf2lcfh + pw_gzrf2lcfhd)));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                                 IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                                 + presscfh_wait_rf12);

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = (int)(0.5 * pw_rf3cfh
                                    + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                                    + presscfh_wait_rf23);
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = (int)(0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                                    + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                                    + presscfh_wait_rf34);

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh = rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


      
  {
    pulsename(&seqcfhwait,"seqcfhwait");
    createseq(&seqcfhwait,wait_time_before_cfh, off_seqcfhwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfhwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfhwait = %d\n", idx_seqcfhwait );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr = 15   + delay_rfhubsel + pw_contrfhubsel + pw_contrfsel
        + SSP_UPDATE_TIME + csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr = RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg = res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg = res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg = res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGyKXTG;          /* Y Killer pulse location          */
    INT PosOffResXTG;       /* Off resonance pulse location     */
    INT PosGzDephaserXTG;   /* Slice dephaser location          */
    INT PosGzRephaserXTG;   /* Slice rephaser location          */
    INT PosReadoutWindow;   /* Readout window location          */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

    }

    /* Set timing for YKillerL */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerL at same time as ZDephaser */
        PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                            pw_rf2xtg/2 - IMax(2, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld,
                            pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga) + pw_gykxtgla);
    }
    else
    {
        /* Apply YKillerL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gyrf1xtgd + pw_gykxtgla);
        }
        else
        {
            /* RF1 + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gykxtgla);
        }
    }
    /* Create YKillerL */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiL, accounting for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gyrf1xtgd));
        }
        else
        {
            /* RF1 + GzRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gzrf1xtgd));
        }
    }
    else
    {
        /* Apply FermiL after YKillerL */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf1xtg,"rf1xtg",0) + min_ssp, pendall(&gykxtgl,0)));
    }
    /* Create FermiL */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    /* theta1 Slice Dephaser */
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzDephaserXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                               pw_rf2xtg/2 - pw_gzrf2xtga - pw_gz1xtgd - pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGzDephaserXTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* rf2xtg Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 - pw_rf2xtg/2);
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg = res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = temp_res_rf2xtg;
  }


    /* theta2 Slice Rephaser */ 
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzRephaserXTG = pendall(&gzrf2xtg, 0) + pw_gz2xtga;
           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGzRephaserXTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiR, account for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiR after both ZRephaser and YKillerR */
        PosOffResXTG = RUP_GRD(pendall(&gzrf2xtg,0) - pw_gzrf2xtgd +
                               IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd,
                                                     pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd)));
    }
    else
    {
        /* Apply FermiR after ZRephaser */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf2xtg,"rf2xtg",0) + min_ssp, pendall(&gz2xtg,0)));
    }
    /* Create FermiR */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    /* Set timing for YKillerR */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerR after GzRF2 */
        PosGyKXTG = pendall(&gzrf2xtg,0) + pw_gykxtgra;
    }
    else
    {
        /* Apply YKillerR after FermiR */
        PosGyKXTG = RUP_GRD(pendall(&rf4xtg,0) + pw_gykxtgra);
    }
    /* Create YKillerR */
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout dephaser */
    postemp = RUP_GRD(pendall(&rf2xtg,0) - pw_rf2xtg/2 + XTGtau1 - 
                      pw_gxw1xtg/2-pw_gxw1xtga - pw_gx1bxtgd - pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout window */
    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 +
                                   2*XTGtau1 - pw_gxw1xtg/2));
    /* HD--Error Check For Gradient Overlap. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga))
    {
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }
           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0))); /* Update PosReadoutWindow to final value */
         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);
     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as = res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta = asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    disableRfSspControl();
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }

    enableRfSspControl();

        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(PSTR_PASS), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay = 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs = temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbrs; /* temp holder for old pulse resolution */

    if ( (wg_rfbrs != TYPRHO1)  && (wg_rfbrs != TYPRHO2) &&
         (wg_rfbrs != TYPTHETA) && (wg_rfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbrs,"rfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbrs, (WF_PROCESSOR)wg_rfbrs, new_res);

                movestretchedwave( fileloc_rfbrs, old_res,
                                   &rfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
                          old_res,fileloc_rfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbrs,ia_rfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbrs,off_rfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbrs);
    

    /*** Reset Resolution ***/
    res_rfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbrs; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbrs != TYPRHO1)  && (wg_thetarfbrs != TYPRHO2) &&
         (wg_thetarfbrs != TYPTHETA) && (wg_thetarfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbrs,"thetarfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbrs, (WF_PROCESSOR)wg_thetarfbrs, new_res);

                movestretchedwave( fileloc_thetarfbrs, old_res,
                                   &thetarfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
                          old_res,fileloc_thetarfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbrs,ia_thetarfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbrs,off_thetarfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbrs);
    

    /*** Reset Resolution ***/
    res_thetarfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbrs, &rfbrs, 0);
    setiamp(ia_thetarfbrs, &thetarfbrs, 0);

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg = temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_rfbdtg != TYPRHO1)  && (wg_rfbdtg != TYPRHO2) &&
         (wg_rfbdtg != TYPTHETA) && (wg_rfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbdtg,"rfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbdtg, (WF_PROCESSOR)wg_rfbdtg, new_res);

                movestretchedwave( fileloc_rfbdtg, old_res,
                                   &rfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
                          old_res,fileloc_rfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbdtg,ia_rfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbdtg,off_rfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbdtg);
    

    /*** Reset Resolution ***/
    res_rfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbdtg != TYPRHO1)  && (wg_thetarfbdtg != TYPRHO2) &&
         (wg_thetarfbdtg != TYPTHETA) && (wg_thetarfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbdtg,"thetarfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbdtg, (WF_PROCESSOR)wg_thetarfbdtg, new_res);

                movestretchedwave( fileloc_thetarfbdtg, old_res,
                                   &thetarfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
                          old_res,fileloc_thetarfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbdtg,ia_thetarfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbdtg,off_thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbdtg);
    

    /*** Reset Resolution ***/
    res_thetarfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbdtg, &rfbdtg, 0);
    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}



/*
 *  ExtCalpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcalwb = max_pg_wamp;

    ia_gzprcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcalwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0cal + pw_gzrf1cala;

         
               
  {
        INT old_res =  res_rf1cal; /* temp holder for old pulse resolution */

    if ( (wg_rf1cal != TYPRHO1)  && (wg_rf1cal != TYPRHO2) &&
         (wg_rf1cal != TYPTHETA) && (wg_rf1cal != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1cal += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1cal.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1cal,"rf1cal");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1cal].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1cal].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1cal, (WF_PROCESSOR)wg_rf1cal, new_res);

                movestretchedwave( fileloc_rf1cal, old_res,
                                   &rf1cal, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1cal = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1cal,(WF_PROCESSOR)wg_rf1cal,
                          old_res,fileloc_rf1cal);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1cal,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1cal,ia_rf1cal);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1cal,off_rf1cal,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1cal);
    

    /*** Reset Resolution ***/
    res_rf1cal = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1cal, &rf1cal, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1cal, "gzrf1cal", &gzrf1cal, &gzrf1cala,
                        &gzrf1cald, pw_gzrf1cal, pw_gzrf1cala, pw_gzrf1cald,
                        ia_gzrf1cal, 0, 0, 0, 0, pbeg(&rf1cal,"rf1cal",0)-psd_rf_wait-pw_gzrf1cala, TRAP_ALL,
                        &calloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) + pw_gzrf1cald);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcal_mem[res_gzcombcal];
        s16 gzcombcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcalf != 0))
        {
            uramp( (&gzcombcal_mem[gzcombcal_indx]),
                   (pw_gzcombcalf/per_gzcombcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcal_indx = ( pw_gzcombcalf/ per_gzcombcal );
            gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcala/per_gzcombcal),
               (short) 0, ia_gzcombcalwa , pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcalf)/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcal_mem[gzcombcal_indx]),
              (pw_gzcombcal/per_gzcombcal),
              ia_gzcombcalwa, ia_gzcombcalwb, pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcal + pw_gzcombcalf )/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcald/per_gzcombcal),
               ia_gzcombcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcal, "gzcombcal" );
        createreserve( &gzcombcal, (WF_PROCESSOR)wg_gzcombcal, res_gzcombcal );
        createinstr( &gzcombcal,(LONG)(PosTemp+pw_gzcombcala-pw_gzcombcala - 
                                         pw_gzcombcalf),
                     (pw_gzcombcalf + pw_gzcombcala + 
                      pw_gzcombcal + pw_gzcombcald), 
                     ia_gzcombcal );
        /* Move user pulse into waveform mem */
        gzcombcal_mem[res_gzcombcal-1] |= WEOS_BIT;  
        movewaveimm(gzcombcal_mem, &gzcombcal, 
                    (int)0, res_gzcombcal, TOHARDWARE);
        if ((wg_gzcombcal==TYPRHO1)||(wg_gzcombcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcal,0,(LONG)(PosTemp+pw_gzcombcala),
                      (pw_gzcombcala + pw_gzcombcal + pw_gzcombcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcal, "gzcombcal",
                   &gzcombcal, &gzcombcala, &gzcombcald,
                   pw_gzcombcal, pw_gzcombcala, pw_gzcombcald,
                   ia_gzcombcal, ia_gzcombcalwa, ia_gzcombcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcala - pw_gzcombcala - pw_gzcombcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal + tacq_cal/2 + pw_gzprcala);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcal_mem[res_gzprcal];
        s16 gzprcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcalf != 0))
        {
            uramp( (&gzprcal_mem[gzprcal_indx]),
                   (pw_gzprcalf/per_gzprcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcal_indx = ( pw_gzprcalf/ per_gzprcal );
            gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcala/per_gzprcal),
               (short) 0, ia_gzprcalwa , pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcalf)/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcal_mem[gzprcal_indx]),
              (pw_gzprcal/per_gzprcal),
              ia_gzprcalwa, ia_gzprcalwb, pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcal + pw_gzprcalf )/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcald/per_gzprcal),
               ia_gzprcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcal, "gzprcal" );
        createreserve( &gzprcal, (WF_PROCESSOR)wg_gzprcal, res_gzprcal );
        createinstr( &gzprcal,(LONG)(PosTemp-pw_gzprcala - 
                                         pw_gzprcalf),
                     (pw_gzprcalf + pw_gzprcala + 
                      pw_gzprcal + pw_gzprcald), 
                     ia_gzprcal );
        /* Move user pulse into waveform mem */
        gzprcal_mem[res_gzprcal-1] |= WEOS_BIT;  
        movewaveimm(gzprcal_mem, &gzprcal, 
                    (int)0, res_gzprcal, TOHARDWARE);
        if ((wg_gzprcal==TYPRHO1)||(wg_gzprcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcal,0,(LONG)(PosTemp),
                      (pw_gzprcala + pw_gzprcal + pw_gzprcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcal, "gzprcal",
                   &gzprcal, &gzprcala, &gzprcald,
                   pw_gzprcal, pw_gzprcala, pw_gzprcald,
                   ia_gzprcal, ia_gzprcalwa, ia_gzprcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcala - pw_gzprcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal - tacq_cal/2); /* from TE */
         

  trapezoid((WF_PROCESSOR)wg_gxwcal, "gxwcal", &gxwcal, &gxwcala,
                        &gxwcald, pw_gxwcal, pw_gxwcala, pw_gxwcald,
                        ia_gxwcal, 0, 0, 0, 0, PosTemp-pw_gxwcala, TRAP_ALL,
                        &calloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1cal,"echo1cal");
    acqq(&echo1cal, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1cal,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcal,"d3dcal");
    create3dim(&d3dcal,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcal, 0) - (pw_gx1cal + pw_gx1cald));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1cal_mem[res_gx1cal];
        s16 gx1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1calf != 0))
        {
            uramp( (&gx1cal_mem[gx1cal_indx]),
                   (pw_gx1calf/per_gx1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1cal_indx = ( pw_gx1calf/ per_gx1cal );
            gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cala/per_gx1cal),
               (short) 0, ia_gx1calwa , pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1calf)/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1cal_mem[gx1cal_indx]),
              (pw_gx1cal/per_gx1cal),
              ia_gx1calwa, ia_gx1calwb, pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1cal + pw_gx1calf )/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cald/per_gx1cal),
               ia_gx1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1cal, "gx1cal" );
        createreserve( &gx1cal, (WF_PROCESSOR)wg_gx1cal, res_gx1cal );
        createinstr( &gx1cal,(LONG)(PosTemp-pw_gx1cala - 
                                         pw_gx1calf),
                     (pw_gx1calf + pw_gx1cala + 
                      pw_gx1cal + pw_gx1cald), 
                     ia_gx1cal );
        /* Move user pulse into waveform mem */
        gx1cal_mem[res_gx1cal-1] |= WEOS_BIT;  
        movewaveimm(gx1cal_mem, &gx1cal, 
                    (int)0, res_gx1cal, TOHARDWARE);
        if ((wg_gx1cal==TYPRHO1)||(wg_gx1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1cal,0,(LONG)(PosTemp),
                      (pw_gx1cala + pw_gx1cal + pw_gx1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1cal, "gx1cal",
                   &gx1cal, &gx1cala, &gx1cald,
                   pw_gx1cal, pw_gx1cala, pw_gx1cald,
                   ia_gx1cal, ia_gx1calwa, ia_gx1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1cala - pw_gx1calf),
                   TRAP_ALL, &calloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1cal,"gzrf1cal",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1cal_mem[res_gy1cal];
        s16 gy1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1calf != 0))
        {
            uramp( (&gy1cal_mem[gy1cal_indx]),
                   (pw_gy1calf/per_gy1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1cal_indx = ( pw_gy1calf/ per_gy1cal );
            gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cala/per_gy1cal),
               (short) 0, ia_gy1calwa , pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1calf)/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1cal_mem[gy1cal_indx]),
              (pw_gy1cal/per_gy1cal),
              ia_gy1calwa, ia_gy1calwb, pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1cal + pw_gy1calf )/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cald/per_gy1cal),
               ia_gy1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1cal, "gy1cal" );
        createreserve( &gy1cal, (WF_PROCESSOR)wg_gy1cal, res_gy1cal );
        createinstr( &gy1cal,(LONG)(PosTemp+pw_gy1cala-pw_gy1cala - 
                                         pw_gy1calf),
                     (pw_gy1calf + pw_gy1cala + 
                      pw_gy1cal + pw_gy1cald), 
                     ia_gy1cal );
        /* Move user pulse into waveform mem */
        gy1cal_mem[res_gy1cal-1] |= WEOS_BIT;  
        movewaveimm(gy1cal_mem, &gy1cal, 
                    (int)0, res_gy1cal, TOHARDWARE);
        if ((wg_gy1cal==TYPRHO1)||(wg_gy1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1cal,0,(LONG)(PosTemp+pw_gy1cala),
                      (pw_gy1cala + pw_gy1cal + pw_gy1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1cal, "gy1cal",
                   &gy1cal, &gy1cala, &gy1cald,
                   pw_gy1cal, pw_gy1cala, pw_gy1cald,
                   ia_gy1cal, ia_gy1calwa, ia_gy1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1cala - pw_gy1cala - pw_gy1calf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcal,"gxwcal", 0) + tacq_cal);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcal_mem[res_gy1rcal];
        s16 gy1rcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcalf != 0))
        {
            uramp( (&gy1rcal_mem[gy1rcal_indx]),
                   (pw_gy1rcalf/per_gy1rcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcal_indx = ( pw_gy1rcalf/ per_gy1rcal );
            gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcala/per_gy1rcal),
               (short) 0, ia_gy1rcalwa , pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcalf)/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcal_mem[gy1rcal_indx]),
              (pw_gy1rcal/per_gy1rcal),
              ia_gy1rcalwa, ia_gy1rcalwb, pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcal + pw_gy1rcalf )/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcald/per_gy1rcal),
               ia_gy1rcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcal, "gy1rcal" );
        createreserve( &gy1rcal, (WF_PROCESSOR)wg_gy1rcal, res_gy1rcal );
        createinstr( &gy1rcal,(LONG)(PosTemp+pw_gy1rcala-pw_gy1rcala - 
                                         pw_gy1rcalf),
                     (pw_gy1rcalf + pw_gy1rcala + 
                      pw_gy1rcal + pw_gy1rcald), 
                     ia_gy1rcal );
        /* Move user pulse into waveform mem */
        gy1rcal_mem[res_gy1rcal-1] |= WEOS_BIT;  
        movewaveimm(gy1rcal_mem, &gy1rcal, 
                    (int)0, res_gy1rcal, TOHARDWARE);
        if ((wg_gy1rcal==TYPRHO1)||(wg_gy1rcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcal,0,(LONG)(PosTemp+pw_gy1rcala),
                      (pw_gy1rcala + pw_gy1rcal + pw_gy1rcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcal, "gy1rcal",
                   &gy1rcal, &gy1rcala, &gy1rcald,
                   pw_gy1rcal, pw_gy1rcala, pw_gy1rcald,
                   ia_gy1rcal, ia_gy1rcalwa, ia_gy1rcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcala - pw_gy1rcala - pw_gy1rcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycal,"attenuator_keycal");
  createatten(&attenuator_keycal, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcal,"seqcal");
    createseq(&seqcal,RUP_GRD(tr_cal), off_seqcal);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcal );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcal = %d\n", idx_seqcal );
#endif
  }

    attenflagon(&seqcal, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscal,"d3dpasscal");
    create3dim(&d3dpasscal,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecal,"pass_pulsecal");
    createpass(&pass_pulsecal,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcalpass,"seqcalpass");
    createseq(&seqcalpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssical), off_seqcalpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcalpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcalpass = %d\n", idx_seqcalpass );
#endif
  }


    return SUCCESS;
}   /* End of ExtCalpulsegen */


/*
 *  AutoCoilpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AutoCoilpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcoilwb = max_pg_wamp;
    
    ia_gzprcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcoilwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0coil + pw_gzrf1coila;

         
               
  {
        INT old_res =  res_rf1coil; /* temp holder for old pulse resolution */

    if ( (wg_rf1coil != TYPRHO1)  && (wg_rf1coil != TYPRHO2) &&
         (wg_rf1coil != TYPTHETA) && (wg_rf1coil != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1coil += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1coil.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1coil,"rf1coil");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1coil].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1coil].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1coil, (WF_PROCESSOR)wg_rf1coil, new_res);

                movestretchedwave( fileloc_rf1coil, old_res,
                                   &rf1coil, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1coil = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1coil,(WF_PROCESSOR)wg_rf1coil,
                          old_res,fileloc_rf1coil);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1coil,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1coil,ia_rf1coil);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1coil,off_rf1coil,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1coil);
    

    /*** Reset Resolution ***/
    res_rf1coil = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1coil, &rf1coil, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1coil, "gzrf1coil", &gzrf1coil, &gzrf1coila,
                        &gzrf1coild, pw_gzrf1coil, pw_gzrf1coila, pw_gzrf1coild,
                        ia_gzrf1coil, 0, 0, 0, 0, pbeg(&rf1coil,"rf1coil",0)-psd_rf_wait-pw_gzrf1coila, TRAP_ALL,
                        &coilloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) + pw_gzrf1coild);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcoil_mem[res_gzcombcoil];
        s16 gzcombcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcoilf != 0))
        {
            uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
                   (pw_gzcombcoilf/per_gzcombcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcoil_indx = ( pw_gzcombcoilf/ per_gzcombcoil );
            gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoila/per_gzcombcoil),
               (short) 0, ia_gzcombcoilwa , pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoilf)/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcoil_mem[gzcombcoil_indx]),
              (pw_gzcombcoil/per_gzcombcoil),
              ia_gzcombcoilwa, ia_gzcombcoilwb, pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoilf )/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoild/per_gzcombcoil),
               ia_gzcombcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcoil, "gzcombcoil" );
        createreserve( &gzcombcoil, (WF_PROCESSOR)wg_gzcombcoil, res_gzcombcoil );
        createinstr( &gzcombcoil,(LONG)(PosTemp+pw_gzcombcoila-pw_gzcombcoila - 
                                         pw_gzcombcoilf),
                     (pw_gzcombcoilf + pw_gzcombcoila + 
                      pw_gzcombcoil + pw_gzcombcoild), 
                     ia_gzcombcoil );
        /* Move user pulse into waveform mem */
        gzcombcoil_mem[res_gzcombcoil-1] |= WEOS_BIT;  
        movewaveimm(gzcombcoil_mem, &gzcombcoil, 
                    (int)0, res_gzcombcoil, TOHARDWARE);
        if ((wg_gzcombcoil==TYPRHO1)||(wg_gzcombcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcoil,0,(LONG)(PosTemp+pw_gzcombcoila),
                      (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcoil, "gzcombcoil",
                   &gzcombcoil, &gzcombcoila, &gzcombcoild,
                   pw_gzcombcoil, pw_gzcombcoila, pw_gzcombcoild,
                   ia_gzcombcoil, ia_gzcombcoilwa, ia_gzcombcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcoila - pw_gzcombcoila - pw_gzcombcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil + tacq_coil/2 + pw_gzprcoila);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcoil_mem[res_gzprcoil];
        s16 gzprcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcoilf != 0))
        {
            uramp( (&gzprcoil_mem[gzprcoil_indx]),
                   (pw_gzprcoilf/per_gzprcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcoil_indx = ( pw_gzprcoilf/ per_gzprcoil );
            gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoila/per_gzprcoil),
               (short) 0, ia_gzprcoilwa , pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoilf)/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcoil_mem[gzprcoil_indx]),
              (pw_gzprcoil/per_gzprcoil),
              ia_gzprcoilwa, ia_gzprcoilwb, pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoil + pw_gzprcoilf )/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoild/per_gzprcoil),
               ia_gzprcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcoil, "gzprcoil" );
        createreserve( &gzprcoil, (WF_PROCESSOR)wg_gzprcoil, res_gzprcoil );
        createinstr( &gzprcoil,(LONG)(PosTemp-pw_gzprcoila - 
                                         pw_gzprcoilf),
                     (pw_gzprcoilf + pw_gzprcoila + 
                      pw_gzprcoil + pw_gzprcoild), 
                     ia_gzprcoil );
        /* Move user pulse into waveform mem */
        gzprcoil_mem[res_gzprcoil-1] |= WEOS_BIT;  
        movewaveimm(gzprcoil_mem, &gzprcoil, 
                    (int)0, res_gzprcoil, TOHARDWARE);
        if ((wg_gzprcoil==TYPRHO1)||(wg_gzprcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcoil,0,(LONG)(PosTemp),
                      (pw_gzprcoila + pw_gzprcoil + pw_gzprcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcoil, "gzprcoil",
                   &gzprcoil, &gzprcoila, &gzprcoild,
                   pw_gzprcoil, pw_gzprcoila, pw_gzprcoild,
                   ia_gzprcoil, ia_gzprcoilwa, ia_gzprcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcoila - pw_gzprcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil - tacq_coil/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwcoil, "gxwcoil", &gxwcoil, &gxwcoila,
                        &gxwcoild, pw_gxwcoil, pw_gxwcoila, pw_gxwcoild,
                        ia_gxwcoil, 0, 0, 0, 0, PosTemp-pw_gxwcoila, TRAP_ALL,
                        &coilloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1coil,"echo1coil");
    acqq(&echo1coil, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1coil,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcoil,"d3dcoil");
    create3dim(&d3dcoil,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcoil, 0) - (pw_gx1coil + pw_gx1coild));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1coil_mem[res_gx1coil];
        s16 gx1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1coilf != 0))
        {
            uramp( (&gx1coil_mem[gx1coil_indx]),
                   (pw_gx1coilf/per_gx1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1coil_indx = ( pw_gx1coilf/ per_gx1coil );
            gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coila/per_gx1coil),
               (short) 0, ia_gx1coilwa , pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coilf)/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1coil_mem[gx1coil_indx]),
              (pw_gx1coil/per_gx1coil),
              ia_gx1coilwa, ia_gx1coilwb, pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coil + pw_gx1coilf )/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coild/per_gx1coil),
               ia_gx1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1coil, "gx1coil" );
        createreserve( &gx1coil, (WF_PROCESSOR)wg_gx1coil, res_gx1coil );
        createinstr( &gx1coil,(LONG)(PosTemp-pw_gx1coila - 
                                         pw_gx1coilf),
                     (pw_gx1coilf + pw_gx1coila + 
                      pw_gx1coil + pw_gx1coild), 
                     ia_gx1coil );
        /* Move user pulse into waveform mem */
        gx1coil_mem[res_gx1coil-1] |= WEOS_BIT;  
        movewaveimm(gx1coil_mem, &gx1coil, 
                    (int)0, res_gx1coil, TOHARDWARE);
        if ((wg_gx1coil==TYPRHO1)||(wg_gx1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1coil,0,(LONG)(PosTemp),
                      (pw_gx1coila + pw_gx1coil + pw_gx1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1coil, "gx1coil",
                   &gx1coil, &gx1coila, &gx1coild,
                   pw_gx1coil, pw_gx1coila, pw_gx1coild,
                   ia_gx1coil, ia_gx1coilwa, ia_gx1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1coila - pw_gx1coilf),
                   TRAP_ALL, &coilloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1coil,"gzrf1coil",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1coil_mem[res_gy1coil];
        s16 gy1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1coilf != 0))
        {
            uramp( (&gy1coil_mem[gy1coil_indx]),
                   (pw_gy1coilf/per_gy1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1coil_indx = ( pw_gy1coilf/ per_gy1coil );
            gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coila/per_gy1coil),
               (short) 0, ia_gy1coilwa , pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coilf)/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1coil_mem[gy1coil_indx]),
              (pw_gy1coil/per_gy1coil),
              ia_gy1coilwa, ia_gy1coilwb, pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coil + pw_gy1coilf )/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coild/per_gy1coil),
               ia_gy1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1coil, "gy1coil" );
        createreserve( &gy1coil, (WF_PROCESSOR)wg_gy1coil, res_gy1coil );
        createinstr( &gy1coil,(LONG)(PosTemp+pw_gy1coila-pw_gy1coila - 
                                         pw_gy1coilf),
                     (pw_gy1coilf + pw_gy1coila + 
                      pw_gy1coil + pw_gy1coild), 
                     ia_gy1coil );
        /* Move user pulse into waveform mem */
        gy1coil_mem[res_gy1coil-1] |= WEOS_BIT;  
        movewaveimm(gy1coil_mem, &gy1coil, 
                    (int)0, res_gy1coil, TOHARDWARE);
        if ((wg_gy1coil==TYPRHO1)||(wg_gy1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1coil,0,(LONG)(PosTemp+pw_gy1coila),
                      (pw_gy1coila + pw_gy1coil + pw_gy1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1coil, "gy1coil",
                   &gy1coil, &gy1coila, &gy1coild,
                   pw_gy1coil, pw_gy1coila, pw_gy1coild,
                   ia_gy1coil, ia_gy1coilwa, ia_gy1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1coila - pw_gy1coila - pw_gy1coilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcoil,"gxwcoil", 0) + tacq_coil);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcoil_mem[res_gy1rcoil];
        s16 gy1rcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcoilf != 0))
        {
            uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
                   (pw_gy1rcoilf/per_gy1rcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcoil_indx = ( pw_gy1rcoilf/ per_gy1rcoil );
            gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoila/per_gy1rcoil),
               (short) 0, ia_gy1rcoilwa , pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoilf)/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcoil_mem[gy1rcoil_indx]),
              (pw_gy1rcoil/per_gy1rcoil),
              ia_gy1rcoilwa, ia_gy1rcoilwb, pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoilf )/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoild/per_gy1rcoil),
               ia_gy1rcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcoil, "gy1rcoil" );
        createreserve( &gy1rcoil, (WF_PROCESSOR)wg_gy1rcoil, res_gy1rcoil );
        createinstr( &gy1rcoil,(LONG)(PosTemp+pw_gy1rcoila-pw_gy1rcoila - 
                                         pw_gy1rcoilf),
                     (pw_gy1rcoilf + pw_gy1rcoila + 
                      pw_gy1rcoil + pw_gy1rcoild), 
                     ia_gy1rcoil );
        /* Move user pulse into waveform mem */
        gy1rcoil_mem[res_gy1rcoil-1] |= WEOS_BIT;  
        movewaveimm(gy1rcoil_mem, &gy1rcoil, 
                    (int)0, res_gy1rcoil, TOHARDWARE);
        if ((wg_gy1rcoil==TYPRHO1)||(wg_gy1rcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcoil,0,(LONG)(PosTemp+pw_gy1rcoila),
                      (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcoil, "gy1rcoil",
                   &gy1rcoil, &gy1rcoila, &gy1rcoild,
                   pw_gy1rcoil, pw_gy1rcoila, pw_gy1rcoild,
                   ia_gy1rcoil, ia_gy1rcoilwa, ia_gy1rcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcoila - pw_gy1rcoila - pw_gy1rcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycoil,"attenuator_keycoil");
  createatten(&attenuator_keycoil, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcoil,"seqcoil");
    createseq(&seqcoil,RUP_GRD(tr_coil), off_seqcoil);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoil );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoil = %d\n", idx_seqcoil );
#endif
  }

    attenflagon(&seqcoil, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscoil,"d3dpasscoil");
    create3dim(&d3dpasscoil,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecoil,"pass_pulsecoil");
    createpass(&pass_pulsecoil,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcoilpass,"seqcoilpass");
    createseq(&seqcoilpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssicoil), off_seqcoilpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoilpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoilpass = %d\n", idx_seqcoilpass );
#endif
  }


    return SUCCESS;
}   /* End of AutoCoilpulsegen */



/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of pulsegen()

 In the beginning of `pulsegen()` the following lines should be added:
 \code{.c}
 GEReq_pulsegenBegin();
 \endcode

 This function up various global GE stuff related to pulsegen()
********************************************************************************************************/
void GEReq_pulsegenBegin(void) {

  sspinit(psd_board_type);

  {
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */

  }
} /* GEReq_pulsegenBegin() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the end of pulsegen()

 In the end of `pulsegen()`, but before `buildinstr()`, the following lines should be added:
 \code{.c}
 GEReq_pulsegenEnd();
 \endcode

 This function up prescan pulsegen and adds a PASSPACK sequence ("GEendpass"), which is used to dump
 rawdata and mark the end of scan. See GEReq_endofpass() and GEReq_endofscan() and how they are used
 in a psd.
********************************************************************************************************/
void GEReq_pulsegenEnd(void) {

#ifdef IPG
  {
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();
AutoCoilpulsegen();
ExtCalpulsegen();

  }

/* pass sequence to dump Pfiles */
 
  {
    pulsename(&GEendpass,"GEendpass");
    createpass(&GEendpass,(long)(pw_passpacket-1000));
  }

  
  {
    pulsename(&GEpass,"GEpass");
    createseq(&GEpass,pw_passpacket, off_GEpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_GEpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_GEpass = %d\n", idx_GEpass );
#endif
  }


#endif
} /* GEReq_pulsegenEnd() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to trigger data (Pfile) writing and reconstruction

 After calling this function, the parent function must switch back to the previous/main sequence 
 using ks_scan_playsequence() (or *boffset()*).
********************************************************************************************************/
void GEReq_endofpass() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABPASS, &GEendpass, 2 ); /* end of pass */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofpass() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofscan() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABSCAN, &GEendpass, 2 ); /* end of scan */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofscan() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofpassandscan() {
  #ifdef IPG
    boffset(off_GEpass);
    setwamp(SSPD + DABPASS + DABSCAN, &GEendpass, 2 ); /* end of scan */
    startseq(0, (short) MAY_PAUSE);
  #endif
  } /* GEReq_endofscan() */
  
  

/*****************************************************************************************************
 * RSP Variables
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/

/* For IPG Simulator: will generate the entry point list in the IPG tool */
CHAR *entry_name_list[ENTRY_POINT_MAX] = {
  "scan",
  "mps2",
  "aps2",
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                           PSeplist                                *
 *                                                                   *
 * Additional list of entry points for Prescan.                      *
 *********************************************************************/
         "cfl",
         "cfh",
         "mps1",
         "aps1", 
         "autoshim",
         "fasttg",
         "rcvn",
         "expresstg",
         "RFshim",
         "DynTG",
         "extcal",
         "Autocoil",
         0	/* 0 is needed for the parser */


};

/* Do not move the line above and do not insert any code or blank
   lines before the line above.  The code inline'd from Prescan.e
   adds more entry points and closes the list. */
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                            PScore                                 *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

long PSrsptrigger[MAX_PSC_VQUANT]={0};   /* prescan trigger */ /* vmx 10/13/94 YI */

void
dump_rsp_psc_info( void )
{
    INT i ;
    printf("\nPSD-> Dump of Prescan Shim Vol. Info\n");

    for (i=0; i<oppscvquant; i++)
    {
        printf("PSD->\nPSD->PscVol %d\t\t\t\ttloc = %+6f, rloc = %+6f, phaseoff = %+6f\n",
               i, rsp_psc_info[i].rsppsctloc, rsp_psc_info[i].rsppscrloc, rsp_psc_info[i].rsppscphasoff);
        printf("PSD->\nPSD->Index %d\t\t\t\tlenx = %+6d, leny = %+6d, lenz = %+6d\n",
               i, rsp_psc_info[i].rsppsclenx, rsp_psc_info[i].rsppscleny, rsp_psc_info[i].rsppsclenz);

        printf("\n Shim volume rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[0], rsp_psc_info[i].rsppscrot[1], rsp_psc_info[i].rsppscrot[2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[3], rsp_psc_info[i].rsppscrot[4], rsp_psc_info[i].rsppscrot[5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[6], rsp_psc_info[i].rsppscrot[7], rsp_psc_info[i].rsppscrot[8]);
    }
}

INT
get_psc_vol_index( void )
{
    int vol_index = 0;

    vol_index = (noswitch_slab_psc == PSD_ON) ? (PStest_slab-1) : (psc_vol_index-1);
    vol_index = (vol_index > 0) ? vol_index : 0;

    return vol_index;
}

/*
 *  mps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
mps1( void )
{
    rspent = L_MPS1;
    strcpy(psdexitarg.text_arg, "MPS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);

    PSmps1(2);
    rspexit();

    return SUCCESS;
}   /* end mps1() */


/*
 *  aps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
aps1( void )
{
    rspent=L_APS1;
    strcpy(psdexitarg.text_arg, "APS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(1);
    rspexit();

    return SUCCESS;
}   /* end aps1() */


/*
 *  cfl
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfl( void )
{
    rspent=L_CFL;
    strcpy(psdexitarg.text_arg, "CFL");

    PSinit(PSrot);
    PScfl();
    rspexit();

    return SUCCESS;
}   /* end cfl() */


/*
 *  rcvn
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
rcvn( void )
{
    rspent=L_RCVN;
    strcpy(psdexitarg.text_arg, "RCVN");

    PSinit(rsp_rcvnrot);

    /* Check if need to run RCVN for Full Rec coil mode */
    rcvn_usefullcoil = rspusefullcoil & RCVN_FULLCOIL;
        
    if (RCVN_FULLCOIL == rcvn_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for RCVN \n");
        }
        rspusefullcoil &= ~RCVN_FULLCOIL;
    }

    PSrcvn();
    rspexit();

    return SUCCESS;
}   /* end rcvn() */


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This sets the rotation matrix with the one from the scan plane before the 3rd refocus pulse,
   and sets the rotation matrix back to the default one after the 3rd refocus pulse.
 */
void
cfh_set_rot_matrix_slice( void )
{
    static int rot_matrix_index = 0;
    int cfh_slab_index = get_psc_vol_index();

    if (rot_matrix_index == 0)
    {
        setrotateimm(PSrot[0], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 1;
    }
    else
    {
        setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 0;
    }
    return;
}

void
cfh_set_rot_matrix_default( void )
{
    int cfh_slab_index = get_psc_vol_index();

    setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
    return;
}


/*
 *  cfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfh( void )
{
    /* Insert wait sequence before CFH for T1 recovery if the previous entry is XTG */
    if (rspent == L_XTG)
    {
        setperiod(wait_time_before_cfh, &seqcfhwait, 0);
        boffset(off_seqcfhwait);
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    rspent=L_CFH;
    strcpy(psdexitarg.text_arg, "CFH");


    if ( (presscfh_ctrl == PRESSCFH_SHIMVOL) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE) )
    {
        int cfh_slab_index = get_psc_vol_index();
        PSinit(&rsp_PSrot[cfh_slab_index]);
    }
    else
    {
        PSinit(rsp_PSrot);
    }

    if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
    {
        isivector(3, cfh_set_rot_matrix_slice, (short) FALSE);
    }
    else
    {
        isivector(3, cfh_set_rot_matrix_default, (short) FALSE);
    }

    cfh_usefullcoil = rspusefullcoil & CFH_FULLCOIL;
    if (CFH_FULLCOIL == cfh_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for CFH \n");
        }
        rspusefullcoil &= ~CFH_FULLCOIL;
    }

    PScfh();
    rspexit();

    return SUCCESS;
}   /* end cfh() */

/*
 *  fasttg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
fasttg( void )
{
    rspent=L_FTG;
    PSinit(PSrot_mod);
    PSfasttg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;
}   /* end fasttg() */

/*
 *  expresstg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
expresstg( void )
{
    rspent=L_XTG;
    PSinit(PSrot_mod);

    xtg_usefullcoil = rspusefullcoil & XTG_FULLCOIL;
    if ((XTG_FULLCOIL == xtg_usefullcoil) && (PSD_OFF == xtg_volRecCoil))
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for XTG \n");
        }
        rspusefullcoil &= ~XTG_FULLCOIL;
    }

    PSexpresstg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;    
}   /* end expresstg() */

/*
 * B1 Map acquisition for RF Shim 
 *
 * Type: Public Function
 *
 */
STATUS
RFshim( void )
{
    rspent=L_RFSHIM;
    strcpy(psdexitarg.text_arg, "RFshim");

    PSrfshim();    /* flag on for RFShim mode */
    printdbg("Normal End of RFshim", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

int rspdtg = PSD_OFF;              /* rsp update for DynTG setting, set by prescan server */
int deltatg_temp[MAX_DYNTG_NOSLICES];
int *deltatg = (int *) deltatg_temp;    /* rsp update for DynTG setting, set by prescan server. */

STATUS DtgInitPsc()
{
    INT i;

    rspdtg = PSD_OFF;
    for (i=0; i<opslquant; i++)
    {
        deltatg[i] = 0;
    }
    return SUCCESS;
}

/* 
 * B1 Map for Dynamic TG
 *
 * Type: Public Function
 *
 */
STATUS
DynTG( void )
{
    rspent=L_DYNTG;
    strcpy(psdexitarg.text_arg, "DynTG");

    DtgInitPsc();
    PSdyntg();
    printdbg("Normal End of DynTG", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

STATUS
mapTg( void )
{
    rspent=L_MAPTG;
    strcpy(psdexitarg.text_arg, "mapTg");

    PSdyntg();
    printdbg("Normal End of mapTg", PSdebugstate);

    rspexit();
    return SUCCESS;
}


/* 
 * ExtCal Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
extcal( void )
{
    if((L_AUTOSHIM == rspent) || (L_RCVN == rspent) || (L_AUTOCOIL == rspent))
    {
        rspdda = cal_dda;
    }
    else
    {
        rspdda = cal_dda + cal_delay_dda;
    }

    rspent=L_EXTCAL;
    strcpy(psdexitarg.text_arg, "ExtCal");

    printdbg("Start of extcal", PSdebugstate);

    /* reset for coil switching */
    loaddab_hub_r1(&echo1cal, 0, 0, 0, 1, 0, 0, (TYPDAB_PACKETS)DABOFF, PSD_LOAD_DAB_HUB_R1_RESET);

    PSextcal();
    printdbg("Normal End of extcal", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/* 
 * AutoCoil Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
Autocoil( void )
{
    rspdda = coil_dda;

    rspent=L_AUTOCOIL;
    strcpy(psdexitarg.text_arg, "Autocoil");
    printdbg("Start of Autocoil", PSdebugstate);

    PSautocoil();
    printdbg("Normal End of Autocoil", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/*
 *  autoshim
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
autoshim( void )
{
    rspent=L_AUTOSHIM;
    strcpy(psdexitarg.text_arg, "Autoshim");

    ASautoshim(rspsct);
    rspexit();

    return SUCCESS;
}   /* end autoshim() */


/*
 *  PSmps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSmps1( INT mps1nex )
{
    INT acq_type;
    SHORT temp_short;
    INT slice_freq;
    FLOAT receive_freq;
    FLOAT rsp_PStloc=0.0;
    FLOAT rsp_PSrloc=0.0;
    FLOAT rsp_PSphasloc=0.0;
    INT old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Starting PSmps1",PSdebugstate);
    boffset(off_seqmps1);

    scopeon(&seqmps1);	/* Activate scope for core */
    syncon(&seqmps1);	/* Activate sync for core */

    rsp_PStloc = PStloc_mod;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasloc = PSphasoff_mod;
    /* begin aps1_mod changes (GE) */

    if(PSD_ON == local_tg)
    {
        slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                            (10* TARDIS_FREQ_RES) );
    }
    else
    {
        slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                            (10* TARDIS_FREQ_RES) );
    }
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf1mps1,0);

    slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf2mps1,0);

    receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

    /* end aps1_mod changes (GE) */ 

    setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
		 &echo1mps1, 0);

    if(PSdebugstate)
    {
        printf("\nAPS1/MPS1 Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                thickPS_mod,mpsfov, PStloc_mod, PSrloc_mod);
        printf("\nAPS1/MPS1 Xmit Freq = %i, Rcv Freq  = %f\n", slice_freq, receive_freq);
        printf("%s\n","APS1/MPS1 Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("PSmps1: psc_vol_index = %d\n",psc_vol_index );
    }


    
    for (view = -1; view <= 30000; view++)
    {
        for (excitation = 1; excitation <= mps1nex; excitation++)
    	{
            if (view > 0)

      	    {
                if (excitation == mps1nex)
      	      	{
                    attenlockoff(&attenuator_keymps1);
      	      	}
                else
      	      	{
                    attenlockon(&attenuator_keymps1);
      	      	}
      	    }

            if ((view > 0) && (excitation >= 1))
      	    {
                acq_type = (int)DABON;
      	    }
            else
      	    {
                acq_type = (int)DABOFF;
      	    }

            loaddab(&echo1mps1, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL); 

            /* For SWIFT(PSmps1): We are trying not to use the CV opswift.
               Instead use psc_vol_index.  */
            if( (psc_vol_index > 0) && (opvquant > 1))
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqmps1);
                    }
                        
                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSmps1: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            else
            {
                slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf1mps1,0);

            slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf2mps1,0);

            receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

            /* end aps1_mod changes (GE) */

            setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
                    &echo1mps1, 0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            syncoff(&seqmps1);

            /* Chopper logic */
            getiamp(&temp_short, &rf1mps1,0);
            setiamp((-temp_short),&rf1mps1,0);
	}
    }

    printdbg("Returning from PSmps1",PSdebugstate);

    return SUCCESS;
}   /* end PSmps1() */


/*
 *  PScfl
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PScfl( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    INT slice_freq; /* transmit frequency for the prescan slice */
    SHORT temp_short; /* temp variable */
    float rsp_PStloc;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PScfl", PSdebugstate);
    boffset(off_seqcfl); 
    scopeon(&seqcfl);
    syncon(&seqcfl); 
    attenlockoff(&cfl_attenkey);
  
    rsp_PStloc = PStloc;
    slice_freq = (int)(GAM * a_gzrf1cfl * PStloc/
                       (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
  
    setfrequency(slice_freq, &rf1cfl,0);
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &cfl_fid, 0);

    if( PSdebugstate )
    {
        printf("PScfl: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -cfl_dda+1 ; view <= 30000; view ++)
    {
        for (excitation = 1; excitation <= cfl_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == cfl_nex)
                    attenlockoff(&cfl_attenkey);
                else
                    attenlockon(&cfl_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&cfl_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PScfl): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfl); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfl: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = (int)(GAM * a_gzrf1cfl * rsp_PStloc/
                               (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */

            setfrequency(slice_freq, &rf1cfl,0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfl);

            if(PSdebugstate && view == 0)
            {
                printf("\n CFL:  Xmit Location = %f Receive Location = %f\n ", PStloc, 0.0 );
                printf ("%s\n","CFL : Rotation Matrix");
                printf("\t %6ld %6ld %6ld \n", PSrot[0][0], PSrot[0][1], PSrot[0][2]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][3], PSrot[0][4], PSrot[0][5]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][6], PSrot[0][7], PSrot[0][8]);
                fflush(stdout);
            }

            getiamp(&temp_short, &rf1cfl, 0);
            setiamp(-temp_short, &rf1cfl, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfl() */


/*
 *  PSrcvn
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PSrcvn( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PSrcvn", PSdebugstate);

    /* GEHmr03545 */
    if ( rcvn_flag != PSD_OFF )
    {
        boffset( off_pre_rcvn );
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    boffset(off_seqrcvn); 
    scopeon(&seqrcvn);
    syncon(&seqrcvn); 
    attenlockoff(&rcvn_attenkey);
  
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &rcvn_fid, 0);

    if( PSdebugstate )
    {
        printf("PSrcvn: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -rcvn_dda+1 ; view <= rcvn_loops ; view ++)
    {
        for (excitation = 1; excitation <= rcvn_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == rcvn_nex)
                    attenlockoff(&rcvn_attenkey);
                else
                    attenlockon(&rcvn_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&rcvn_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PSrcvn): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch slab*/
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqrcvn); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSrcvn: psc_vol_index=%d\n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            startseq((short)0,(short)MAY_PAUSE);

            syncoff(&seqrcvn);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PSrcvn() */

/*
 *  NoiseCalrcvn
 *  
 *  Type: Public Function
 *  
 *  Description: NoiseCal in scan. Override opcode to DNOISE (16) for rcvn_fid
 *  
 */
STATUS
NoiseCalrcvn( void )
{
    short dabbits;
    LONG resolution;

    if(noisecal_in_scan_flag && (fopen(".DisableNoiseCalinScan", "r")==NULL))
    {
        printdbg("Entering NoiseCalrcvn", PSdebugstate);

        if ( rcvn_flag != PSD_OFF )
        {
            if(scalerotmats(rsp_rcvnrot, &loggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
            {
                return FAILURE;
            }   
            setrotatearray((short)1, rsp_rcvnrot[0]);
            boffset( off_pre_rcvn );
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        }

        boffset(off_seqrcvn); 
        scopeon(&seqrcvn);
        syncon(&seqrcvn); 
        attenlockoff(&rcvn_attenkey);

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                     &rcvn_fid, 0);

        dabbits = DNOISECAL;
        sspload(&dabbits,
                &rcvn_fid,
                1, /*opcode*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        dabbits = 1; 
        sspload(&dabbits,
                &rcvn_fid,
                2, /*frame*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        resolution = rcvn_xres; 
        sspextload(&resolution,
                   &rcvn_fid,
                   3, /*resolution*/
                   1,
                   (HW_DIRECTION)TOHARDWARE,
                   (SSP_S_ATTRIB)SSPS2);

        startseq((short)0,(short)MAY_PAUSE);

        syncoff(&seqrcvn);

        /* return to imaging sequence */
        boffset(off_seqcore);
    }
    return SUCCESS;
}   /* end NoiseCalrcvn() */



/*
 *  PScfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScfh( void )
{
    static INT rsp_PSshift = 0;  /* RSP shimvol shift for debug purpose */
    INT acq_type;      /* enable or disable data acquisiton */
    INT slice_freq  = 0;   /* transmit frequency for the prescan slice */
    INT slice2_freq = 0;   /* transmit frequency for the prescan slice */
    INT slice3_freq = 0;   /* presscfh: transmit frequency for the prescan slice */
    INT slice4_freq = 0;   /* presscfh-slice: transmit frequency for the prescan slice */
    INT ir_slice_freq = 0; /* IR sequence transmit freq. for the prescan slice */
    SHORT temp_short;  /* temp variable */
    long init_cfh_deadtime; /* initial deadtime of the seqcfh sequence */
    long new_cfh_deadtime;  /* updated cfh deadtime */

    float rsp_PStloc = 0;    /* RSP transmit location */
    float rsp_PSrloc = 0;    /* RSP receive location */
    float rsp_PSphasoff = 0; /* RSP phase off location */
    float rsp_PSslicetloc = 0;    /* RSP slice refocus location */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    
    showfp = 0;

    printdbg("Entering PScfh", PSdebugstate);
    boffset(off_seqcfh); 
    scopeon(&seqcfh);
    syncon(&seqcfh); 
    attenlockoff(&cfh_attenkey);

    if (psc_vol_index == 0) {

        slice_freq = (int)cfh_rf1freq;
        setfrequency(slice_freq, &rf1cfh,0);

        slice2_freq = (int)cfh_rf2freq;
        setfrequency(slice2_freq, &rf2cfh,0);
        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);
    }

#ifdef PSD_CFH_CHEMSAT

    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        if (PSir != PSD_ON)
        {
            setiamp(ia_rfcssatcfh, &rfcssat, cscfh_satindex);
        }
        else
        {
            setiamp(0, &rfcssat, cscfh_satindex);
        }
    }
    cstun = 0;

#endif


    if (PSD_ON == PSir)
    {
        /* Inversion */
        /* factor 10 is because rsptloc is in mm */
        ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
        setfrequency(ir_slice_freq, &rf0cfh,0);
    }

    /* Setting tislice to PSslice_num+1 so user sees slices start at 1*/
    tislice=PSslice_num+1;
    tislice_start=PSslice_num+1;

    /* Setting psctitime to opti; results in every entry into CFH having
       psctitime=opti*/
    psctitime = cfh_ti/1000;
    noir = 0;

    /* Finding initial deadtime (psctitime = opti) of seqcfh */
    getperiod( &init_cfh_deadtime, &seqcfh, 0 );

    if( PSdebugstate )
    {
        printf("PScfh: psc_vol_index = %d\n",psc_vol_index );
    }


    for (view = -cfh_dda+1 ; view <= 30000; view ++)
    {
        /* Modified for MULTI VOLUME Prescan - AP */
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            int cfh_slab_index = get_psc_vol_index();

            if( ( presscfh_ctrl != PRESSCFH_SHIMVOL ) && ( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE ) )
            {
                rsp_PStloc = presscfh_info[cfh_slab_index].oppsctloc;
                rsp_PSrloc = presscfh_info[cfh_slab_index].oppscrloc;
                rsp_PSphasoff = presscfh_info[cfh_slab_index].oppscphasoff;
            }
            else
            {
                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            }

            if (PScfh_shimvol_debug != PSCFH_SHIMVOL_DEBUG_NONE)
            {
                rsp_PSshift = rsp_PSshift + 10;
                if ( rsp_PSshift > 100 )
                {
                    rsp_PSshift = -100;
                }
            }
            else
            {
                rsp_PSshift = 0;
            }

            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Z)
            {
                rsp_PStloc = rsp_PStloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_X)
            {
                rsp_PSrloc = rsp_PSrloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Y)
            {
                rsp_PSphasoff = rsp_PSphasoff + rsp_PSshift;
            }

            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/ (10 * TARDIS_FREQ_RES));
            slice2_freq = (int)(GAM * a_gxrf2cfh * rsp_PSrloc/ (10 * TARDIS_FREQ_RES));
            slice3_freq = (int)(GAM * a_gyrf3cfh * rsp_PSphasoff/ (10 * TARDIS_FREQ_RES));

            if(PSdebugstate)
            {
                printf("\n");
                printf(" slice1_freq -> rsp_PStloc %0f \n", rsp_PStloc);
                printf(" slice2_freq -> rsp_PSrloc %0f \n", rsp_PSrloc);
                printf(" slice3_freq -> rsp_PSphasoff %0f \n", rsp_PSphasoff);
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                rsp_PSslicetloc = PStloc;
                slice4_freq = (int)(GAM * a_gzrf4cfh * rsp_PSslicetloc/ (10 * TARDIS_FREQ_RES));

                if(PSdebugstate)
                {
                    printf(" slice4_freq -> rsp_PSslicetloc %0f \n", rsp_PSslicetloc);
                }
            }

            if( PSD_ON == PSir ) {
                ir_slice_freq = (int)( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else if ( psc_vol_index > 0 )
        {
            /* PRESSCFH_NONE */

            int cfh_switch_coil=0;

            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            if ( opswift == PSD_ON )
            {
                    cfh_switch_coil = 1;
            }

            if( cfh_switch_coil )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfh); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfh: psc_vol_index=%d \n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
            if((opcoax != 0) && cfh_newmode)
            {
                slice2_freq = (int)(GAM * (opspf ? rsp_PSphasoff * a_gyrf2cfh : rsp_PSrloc * a_gxrf2cfh )/(10 * TARDIS_FREQ_RES));
            }
            else
            {
                slice2_freq = 0;
            }

            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else
        {
            /* This is for the 3D scan volume - psc_vol_index = 0 */
            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            slice_freq = (int)cfh_rf1freq;
            slice2_freq = (int)cfh_rf2freq;
            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  /* end of psc_vol_index */

        setfrequency(slice_freq, &rf1cfh,0);
        setfrequency(slice2_freq, &rf2cfh,0);
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            setfrequency(slice3_freq, &rf3cfh,0); /* for presscfh_ctrl */
            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                setfrequency(slice4_freq, &rf4cfh,0); /* for presscfh_ctrl */
            }
        }

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);

        if(PSdebugstate)
        {
            INT pscrot_idx;

            pscrot_idx = psc_vol_index;
            if (psc_vol_index > 0)
            {
                pscrot_idx = psc_vol_index-1;
            }
            printf("\n %d rsp_PStloc (tx, rec, phase) -> %0f %0f %0f\n",
                   psc_vol_index, rsp_PStloc, rsp_PSrloc, rsp_PSphasoff);
            printf ("CFH : Rotation Matrix for Prescan Volume Index %d\n", psc_vol_index);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][0], rsp_PSrot[pscrot_idx][1], rsp_PSrot[pscrot_idx][2]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][3], rsp_PSrot[pscrot_idx][4], rsp_PSrot[pscrot_idx][5]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][6], rsp_PSrot[pscrot_idx][7], rsp_PSrot[pscrot_idx][8]);

            fflush(stdout);
        }


        /* INVERSION RECOVERY CODE */
        if (PSD_ON == PSir)
        {
            /* Check for IR pulse being turned off */
            if (noir==1)
            {
                setiamp(0,&rf0cfh,0);
            }
            else
            {
                setiamp(ia_rf0cfh,&rf0cfh,0);
            }
            /* End check for IR pulse being on/off */

            if (tislice != (PSslice_num+1))
            {
                /* user has changed slice, so change frequencies */
                /* Check for proper range */
                if ((tislice < 1) || (tislice > opslquant)) 
                {
                    tislice=tislice_start;
                    PSslice_num=tislice-1;
                } 
                else
                {
                    PSslice_num=tislice-1;
                    /* changing the slice */

                    /* Calculation of new slice loc */
                    new_slice_loc = PStloc - ((opslspace + opslthick) *
                                              (tislice_start - tislice));
                    /* Inversion */
                    /* factor 10 is because rsptloc is in mm */
                    ir_slice_freq = (int)(GAM * a_gzrf0cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(ir_slice_freq, &rf0cfh,0);

                    /* Spin Echo */
                    /* factor 10 is because rsptloc is in mm */
                    slice_freq = (int)(GAM * a_gzrf1cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(slice_freq, &rf1cfh,0);
                    /* end of changing the slice */
                }
            }

            /* Changing the inversion time realtime */
            if (psctitime<50)
            {
                psctitime=50;
            }

            /* Need this check to reset psctitime to opti. Download error were
               happening because of invalid titimes */
            if(psctitime > 300)
            {
                psctitime = cfh_ti/1000;
            }

            titime_us = (psctitime*1000);
            new_dur=dur_invse + (titime_us - cfh_ti);
            new_dur = RUP_GRD(new_dur);
            setperiod(new_dur,&zticfh,0);
            setperiod(new_dur,&xticfh,0);
            setperiod(new_dur,&yticfh,0);
            setperiod(new_dur,&rticfh,0);
            setperiod(new_dur,&sticfh,0);

            /* Change the deadtime of seqcfh to preserve the cfh_tr value */
            /* If the seqcfh deadtime < 5 then set to the minimum of 4us */
            new_cfh_deadtime = init_cfh_deadtime + (cfh_ti - titime_us);
            if (new_cfh_deadtime < 5)
            {
                new_cfh_deadtime = 4;
            }

            setperiod( new_cfh_deadtime, &seqcfh, 0 );
            /* End deadtime change */

            /* End inversion time change */

            /* END INVERSION CORE CODE */
        } 
#ifdef PSD_CFH_CHEMSAT
        if( (cs_sat == PSD_ON) && PScs_sat )
        {
            CsSatMod((int)(cscfh_satindex+1));
        }
#endif
        /* Check should play cs/mt or stir for manual cfh */
        if( PSir )
        {
            StIRMod();
        }

        for( excitation = 1; excitation <= cfh_nex; excitation ++ )
        {
            if( view > 0 ) 
            {
                acq_type = (int)DABON;

                if( excitation == cfh_nex )
                {
                    attenlockoff(&cfh_attenkey);
                }
                else
                {
                    attenlockon(&cfh_attenkey);
                }
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&cfh_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfh); 

            getiamp(&temp_short, &rf1cfh, 0);
            setiamp(-temp_short, &rf1cfh, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfh() */


/* disable STIR cfh if cs/mttun is on */
void
StIRMod(void)
{
    int do_mttun = 0;
    int do_cstun = 0;


#ifdef PSD_CFH_CHEMSAT
    if(PSD_ON == PScs_sat)
    {
        do_cstun = cstun;
    }
    else
    {
        do_cstun = PSD_OFF;
    }
#endif /* PSD_CFH_CHEMSAT */

    if( do_cstun || do_mttun || showfp ) 
    {
        /* disable stir cfh pulse */
        rfoff(&rf0cfh, 0);
        setiampt(0, &gyrf0kcfh, 0);
    }
    else {
        rfon(&rf0cfh, 0);
        setiampt(amp_gyrf0kcfh, &gyrf0kcfh, 0);
    }
    return;
}


/*  begin aps1_mod changes (GE) */
/*
 *  PSinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSinit( long (*PSrotmat)[9] )
{   
    INT i;

    /* Range check for psc_vol_index */
    if ( psc_vol_index < 0 )
    {
        if(PSdebugstate)
            printf("WRONG psc_vol_index =%d\n",psc_vol_index);
        psc_vol_index = 0;
    }

    setrfconfig((short) 5);	/* only activate rho1 */
    setssitime(100);	/* set ssi counter to 400 us. */
    rspqueueinit(200);	/* initialize to 200 entries */

    if( presscfh_cgate && rspent == L_CFH ){
        PSrsptrigger[0] = TRIG_ECG;
    } else{
        PSrsptrigger[0] = PStrigger;
    }
    setrotatearray((short)1, *PSrotmat);
    settriggerarray((short)1, PSrsptrigger);
    
    /* Always use scan rot matrix for SWIFT*/
    if(opswift == PSD_ON)
    {
        setrotatearray((short)opvquant,rsprot[0]);
        for(i=0;i<opvquant;i++)
            PSrsptrigger[i] = PStrigger;

        settriggerarray((short)opvquant,PSrsptrigger);
    }


    return SUCCESS;
}   /* end PSinit() */

/* end aps1_mod changes (GE) */

/*
 *  PSfasttg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfasttg( INT preslice,
          INT debugstate)
{
    printdbg("Greetings from FastTG", PSdebugstate);
    rspent = L_FTG;
    rspdda = ftg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "FastTG");
    
    FastTGCore( PStloc_mod,
                (int)rspdda,
                (int)rspvus,
                (int)rspnex,
                (int)PSdebugstate);
 
    printdbg("Normal End of FastTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSfasttg() */


/*
 *  PSexpresstg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSexpresstg( INT preslice,
             INT debugstate)
{
    printdbg("Greetings from eXpress TG", PSdebugstate);
    rspdda = xtg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "eXpressTG");
    
    eXpressTGCore( PStloc_mod,
                   (int)rspdda,
                   (int)rspvus,
                   (int)rspnex,
                   (int)PSdebugstate);
 
    printdbg("Normal End of eXpressTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSexpresstg() */


/*
 *  FastTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    ftg_disdaqs: number of disdaq pairs
 *    ftg_views: # of max views to be executed in ftg
 *    ftg_nex: # of excitations in ftg
 *    ftg_chop: No chop if = 2
 *    ftg_debug: debug state
 */
STATUS
FastTGCore( DOUBLE slice_loc,
            INT ftg_disdaqs,
            INT ftg_views,
            INT ftg_nex,
            INT ftg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT slice_freq3;
    INT rcv_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (FTGacq1 == 1)
    {
        ftg_acq1 = (int)DABON;
    }
    else
    {
        ftg_acq1 = (int)DABOFF;
    }
      
    if (FTGacq2 == 1)
    {
        ftg_acq2 = (int)DABON;
    }
    else
    {
        ftg_acq2 = (int)DABOFF;
    }
      
    printdbg("Entering FastTGCORE", (SHORT)ftg_debug);
    boffset(off_seqftg);
    scopeon(&seqftg);
    syncon(&seqftg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&ftg_attenkey);
    slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

    setfrequency(slice_freq1, &rf1ftg,0);
    setfrequency(slice_freq2, &rf2ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1ftg, 0);
    setfrequency(slice_freq3, &rf3ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo2ftg, 0);
 
    if(PSdebugstate)
    {
        printf("\nFTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                FTGslthk,FTGfov, slice_loc, PSrloc_mod);
        printf("\nFTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","FTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("FTG: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = (-ftg_disdaqs + 1) ; view <= ftg_views; view ++)
    {
        for (excitation = 1; excitation <= ftg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&ftg_attenkey);
                if (excitation == ftg_nex)
                    attenlockoff(&ftg_attenkey);
                ftg_acq2 = (int)DABON;
            }
            else
            {
                ftg_acq2 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq1, PSD_LOAD_DAB_ALL);
            loaddab(&echo2ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq2, PSD_LOAD_DAB_ALL);

            /* For SWIFT(fasttg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200] = "";
                        sprintf(tempstr,"fasttgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

            setfrequency(slice_freq1, &rf1ftg,0);
            setfrequency(slice_freq2, &rf2ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo1ftg, 0);
            setfrequency(slice_freq3, &rf3ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo2ftg, 0);


            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)ftg_debug);
            syncoff(&seqftg);
 
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end FastTGCore() */


/*
 *  eXpressTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    xtg_disdaqs: number of disdaq pairs
 *    xtg_views: # of max views to be executed in xtg
 *    xtg_nex: # of excitations in xtg
 *    xtg_chop: No chop if = 2
 *    xtg_debug: debug state
 */
STATUS
eXpressTGCore( DOUBLE slice_loc,
            INT xtg_disdaqs,
            INT xtg_views,
            INT xtg_nex,
            INT xtg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT rcv_freq;
    SHORT temp_short;
    INT rf3xtg_freq, rf4xtg_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    float rsp_PSphasoff=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    long tmp_period;

    if (XTGacq1 == PSD_ON)
    {
        xtg_acq1 = (int)DABON;
    }
    else
    {
        xtg_acq1 = (int)DABOFF;
    }
            
    printdbg("Entering eXpressTGCORE", (SHORT)xtg_debug);

    tmp_period = (long)init_xtg_deadtime;
    tmp_period = RUP_GRD(tmp_period);
                                                  
    boffset(off_seqxtg);
    setperiod(tmp_period, &seqxtg, 0);

    scopeon(&seqxtg);
    syncon(&seqxtg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasoff = PSphasoff_mod;

    attenlockoff(&xtg_attenkey);
    if(PSD_ON == local_tg)
    {
        slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }
    else
    {
        slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }

    slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);

    setfrequency(slice_freq1, &rf1xtg,0);
    setfrequency(slice_freq2, &rf2xtg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1xtg, 0);
 
    if(PSdebugstate)
    {
        printf("\nXTG Slthick = %f xFOV = %f yFOV = %f Xmit location = %f, Rcv location  = %f, Phase off = %f\n", 
               TGopslthick, TGopslthickx, TGopslthicky, PStloc_mod, PSrloc_mod, PSphasoff_mod);

        printf("\nXTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","XTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
        printf("XTG: psc_vol_index = %d\n",psc_vol_index );
    }

    rf4xtg_freq = (int)(xtg_offres_freq/TARDIS_FREQ_RES);
    rf3xtg_freq = rf4xtg_freq;

    if(L_MPS1 == rspent)  /* set it off for MPS1 */
    {
        setiamp(0, &rf3xtg, 0);
        setiamp(0, &rf4xtg, 0);
    }
    else
    {
        setiamp(-ia_rf4xtg, &rf3xtg, 0);
        setiamp(ia_rf4xtg, &rf4xtg, 0);
    }

    for (view = (-xtg_disdaqs + 1) ; view <= xtg_views; view ++)
    {
        if( PSdebugstate )
        {
            printf("XTG: view = %d\n",view);
        }

        if(view == (-xtg_disdaqs + 1))
        {
            getiamp(&temp_short, &rf4xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            getiamp(&temp_short, &rf1xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf1xtg, 0);
            }
        }

        for (excitation = 1; excitation <= xtg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&xtg_attenkey);
                if (excitation == xtg_nex)
                    attenlockoff(&xtg_attenkey);
                if(XTGacq1 == PSD_ON)
                {
                    xtg_acq1 = (int)DABON;
                }
            }
            else
            {
                xtg_acq1 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1xtg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)xtg_acq1, PSD_LOAD_DAB_ALL);

            /* For SWIFT(expresstg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                        rsp_PSphasoff = rsp_info[psc_vol_index-1].rspphasoff;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                        rsp_PSphasoff = rsp_info[PStest_slab-1].rspphasoff;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"eXpresstgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }
            else
            {
                slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }

            slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);
            
            setfrequency(slice_freq1, &rf1xtg,0);
            setfrequency(slice_freq2, &rf2xtg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                         &echo1xtg, 0);

            /* phase and freq cycling  */
            if(view%2 == 1) /* freq and phase cycling */
            {
                setfrequency(rf4xtg_freq, &rf4xtg, 0);
                setfrequency((-rf3xtg_freq), &rf3xtg, 0);

                /* phase cycling */
                getiamp(&temp_short, &rf4xtg, 0);
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            else
            {
                setfrequency((-rf4xtg_freq), &rf4xtg, 0);
                setfrequency(rf3xtg_freq, &rf3xtg, 0);
            }
            
            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)xtg_debug);
            syncoff(&seqxtg);
 
            /* Chopper logic */
            getiamp(&temp_short, &rf1xtg,0);
            setiamp((-temp_short),&rf1xtg,0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end eXpressTGCore() */


/*
 *  ASautoshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASautoshim( INT rspsct_ )
{
    SHORT temp_short;
    INT dix_shift;

    INT phase_step[3];
    INT phase_sign[3];
    INT yres_phase;

    long asrottemp[3][9]; /* vmx 3/6/95 YI */
    INT *rf1_freq;
    INT *receive_freq1;
    SHORT viewtable[513];
    long trigger_temp[3]; /* vmx 10/13/94 YI */
    INT acquire_echo1;
    INT dab_view,dab_op;
    SHORT disdaqs;
    FLOAT tempGAM;

    printdbg("Greetings from autoshim", PSdebugstate);
    boffset(off_seqaushim);

    disdaqs = as_dda;
    tempGAM = GAM;
    GAM = GAMMA_PROTON; /*only shim on proton*/

    /**************************************************************
      so here's how we loop through this entry point:

        pass = rspslq;               each slice is a pass
        for all slices
           for all views              
             (first echo)           note: these aren't really 2echos,
             reset dixon shift to 0       we just pretend they are.
             do the disdaqs               there's really a separate
             do the baselines             excitation for each 'echo'.
             collect the data 'echo'
             (second echo)
             do dixon shift
             do the disdaqs
             do the baselines
             collect the data 'echo'
           next view
           decrement pass
           send pass packet
        next slice
        send end of scan packet
     ******************************************************************/

    setrfconfig((short) 5);

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    rf1_freq = (int *)AllocNode((as_slquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((as_slquant + 2)*sizeof(int));

    rf1_freq[0] = (int)(astloc1*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[1] = (int)(astloc2*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[2] = (int)(astloc3*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));

    asrottemp[0][0] = hostToRspRotMat( asrot0 );  asrottemp[0][1] = hostToRspRotMat( asrot1 ); asrottemp[0][2] = hostToRspRotMat( asrot2 );  
    asrottemp[0][3] = hostToRspRotMat( asrot3 );  asrottemp[0][4] = hostToRspRotMat( asrot4 ); asrottemp[0][5] = hostToRspRotMat( asrot5 );
    asrottemp[0][6] = hostToRspRotMat( asrot6 );  asrottemp[0][7] = hostToRspRotMat( asrot7 ); asrottemp[0][8] = hostToRspRotMat( asrot8 );

    asrottemp[1][0] = hostToRspRotMat( asrot9 );  asrottemp[1][1] = hostToRspRotMat( asrot10 ); asrottemp[1][2] = hostToRspRotMat( asrot11 ); 
    asrottemp[1][3] = hostToRspRotMat( asrot12 ); asrottemp[1][4] = hostToRspRotMat( asrot13 ); asrottemp[1][5] = hostToRspRotMat( asrot14 );
    asrottemp[1][6] = hostToRspRotMat( asrot15 ); asrottemp[1][7] = hostToRspRotMat( asrot16 ); asrottemp[1][8] = hostToRspRotMat( asrot17 );

    asrottemp[2][0] = hostToRspRotMat( asrot18 ); asrottemp[2][1] = hostToRspRotMat( asrot19 ); asrottemp[2][2] = hostToRspRotMat( asrot20 ); 
    asrottemp[2][3] = hostToRspRotMat( asrot21 ); asrottemp[2][4] = hostToRspRotMat( asrot22 ); asrottemp[2][5] = hostToRspRotMat( asrot23 );
    asrottemp[2][6] = hostToRspRotMat( asrot24 ); asrottemp[2][7] = hostToRspRotMat( asrot25 ); asrottemp[2][8] = hostToRspRotMat( asrot26 );

    scalerotmats(asrottemp, &asloggrd, &phygrd, 3, asobl_debug);

    if(PSdebugstate)
    {
        printf("\n%d astlocs (1,2,3) -> %0f %0f %0f\n",
               as_slquant, astloc1, astloc2, astloc3);
        printf("\nrf1_freq (1,2,3) -> %d %d %d\n",
               rf1_freq[0], rf1_freq[1], rf1_freq[2]);
    }

    /* AutoShim Changes to Center Image always - HH- Sept 21, 2004 */
    /* Use asrot0 , asrot11 and asrot20 to decide on read and phase directions on the 3 planes */
    /* Slice 1 = Axial    - Z slice (astloc1) - X/Y read (astloc2/astloc3) - Y/X Phase (astloc3/astloc2) */
    /* Slice 2 = Sagittal - X slice (astloc2) - Z/Y read (astloc1/astloc3) - Y/Z Phase (astloc3/astloc1) */
    /* Slice 3 = Coronal  - Y slice (astloc3) - Z/X read (astloc1/astloc2) - X/Z Phase (astloc2/astloc1) */

/* Old Code */
    receive_freq1[0] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc1))/ TARDIS_FREQ_RES);
    receive_freq1[1] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc2))/ TARDIS_FREQ_RES);
    receive_freq1[2] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc3))/ TARDIS_FREQ_RES);

    phase_sign[0] = (asploc1 >= 0) ? 1 : -1;
    phase_step[0] = (int)(.5 + fabs(FS_2PI*asploc1/asfov));
    phase_step[0] = (phase_step[0] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[1] = (asploc2 >= 0) ? 1 : -1;
    phase_step[1] = (int)(.5 + fabs(FS_2PI*asploc2/asfov));
    phase_step[1] = (phase_step[1] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[2] = (asploc3 >= 0) ? 1 : -1;
    phase_step[2] = (int)(.5 + fabs(FS_2PI*asploc3/asfov));
    phase_step[2] = (phase_step[2] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    trigger_temp[0] = TRIG_INTERN;
    trigger_temp[1] = TRIG_INTERN;
    trigger_temp[2] = TRIG_INTERN;

    setupphasetable(viewtable, TYPNORM,(int)asyres);


    /* Set ssi time.  This is time from eos to start of sequence   */
    /* interrupt in internal triggering.  The minimum time is 50us */
    /* plus 2us*(number of waveform and instruction words modified */
    /* in the update queue).                                       */
    setssitime((LONG)time_ssias/HW_GRAD_UPDATE_TIME);

    settriggerarray(as_slquant, trigger_temp);

    if(PSdebugstate)
    {
        printf("\n AUTOSHIM VOLUME INDEX:  %d\n", as_index); 
        printf("\n AUTOSHIM:  FOV = %f astloc1 = %f, astloc2 = %f  astloc3  = %f\n", asfov, astloc1,astloc2,astloc3); 
        printf("\n AUTOSHIM:  asrloc1 = %f, asrloc2 = %f  asrloc3  = %f\n", asrloc1,asrloc2,asrloc3); 
        printf("\n AUTOSHIM:  asploc1 = %f, asploc2 = %f  asploc3  = %f\n", asploc1,asploc2,asploc3); 
        printf("\n AUTOSHIM:  asdim1 = %f, asdim2 = %f  asdim3  = %f\n", asdim1,asdim2,asdim3); 
        printf("%s\n", "AUTOSHIM:  Slice 1 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][0],asrottemp[0][1],asrottemp[0][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][3],asrottemp[0][4],asrottemp[0][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][6],asrottemp[0][7],asrottemp[0][8]);
        printf("%s\n", "AUTOSHIM:  Slice 2 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][0],asrottemp[1][1],asrottemp[1][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][3],asrottemp[1][4],asrottemp[1][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][6],asrottemp[1][7],asrottemp[1][8]);
        printf("%s\n", "AUTOSHIM:  Slice 3 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][0],asrottemp[2][1],asrottemp[2][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][3],asrottemp[2][4],asrottemp[2][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][6],asrottemp[2][7],asrottemp[2][8]);

        printf("\n AUTOSHIM SLICE1:   slice loc= %f read loc= %f phase loc= %f \n", astloc1, asrloc1, asploc1); 
        printf("\n AUTOSHIM SLICE2:   slice loc= %f read loc= %f phase loc= %f \n", astloc2, asrloc2, asploc2); 
        printf("\n AUTOSHIM SLICE3:   slice loc= %f read loc= %f phase loc= %f \n", astloc3, asrloc3, asploc3); 

        fflush(stdout);
    }

    setrotatearray(as_slquant,asrottemp[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyas);
    scopeon(&seqaushim);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqaushim);
    syncoff(&seqpassas);


    for (as_slice = 0; as_slice < as_slquant; as_slice++)
    {
        dab_op = DABSTORE;

        setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);

        for (as_view=(-(disdaqs+asbaseline)+1); as_view<= asyres; as_view++)
        {
            /* Collect baseline first and set RF to 0 for baseline collection */
            if (as_view <= -disdaqs)
            {
                setiamp((short)0, &rf1as, 0);
            }
            else if (as_view == -disdaqs+1) /* Disdaq collection after baseline and set RF amp for disdaqs/data acq */
            {
                setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);
            }

            if (as_view<=0)
            {
                /* for the baselines in each slice, set the phase encode
                   amplitude to the first view */
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[1], &gy1as, 0);
                setiampt(viewtable[1], &gy1ras, 0);

                setiphase(0,&echo1as,0);
            }
            else
            {
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[as_view], &gy1as, 0);
                setiampt(viewtable[as_view], &gy1ras, 0);

                setiphase(0,&echo1as,0);
                yres_phase = -phase_sign[as_slice]*(((as_view-1)* phase_step[as_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                setiphase(yres_phase, &echo1as, 0);
            }
            for (as_excitation=1; as_excitation <= 1; as_excitation++)
            {
                /* Scope Trigger */
                if ((rspsct_ == as_slice) || (rspsct_ == -1))
                {
                    scopeon(&seqaushim);
                }
                else
                {
                    scopeoff(&seqaushim);
                }
                /*MRIge33520 - VB*/
                acquire_echo1 = DABON; /* ON for baseline */
                if ((as_view > -disdaqs) && (as_view <= 0))  /* DABOFF for disdaq */
                {
                    acquire_echo1 = (int)DABOFF;
                }

                /* Load Transmit and Receive frequencies */
                setfrequency(rf1_freq[as_slice], &rf1as, 0);
                setfrequency(receive_freq1[as_slice], &echo1as, 0);

                if (as_view > 0)
                {
                    dab_view = as_view;
                    if (as_excitation == 1)
                    {
                        dab_op = 0;
                    }
                    else
                    {
                        dab_op = 3 - 2*(as_excitation % 2);
                    }
                }
                else
                {
                    dab_op = 0;
                    dab_view = 0;
                }

                /* set up the dixon shift for every other seq */
                for(dixon=0;dixon<=1;++dixon)
                {
                    dix_shift = (dixon % 2)*RUP_GRD((dix_timeas))+GRAD_UPDATE_TIME;
                    setperiod(dix_shift,&xdixon,0);
                    setperiod(dix_shift,&ydixon,0);
                    setperiod(dix_shift,&zdixon,0);
                    setperiod(dix_shift,&sdixon,0);
                    setperiod((int)(dix_shift - dixon*dix_timeas),&sdixon2,0);
                    /* All DAB Info is Set. Pretend even views are 2nd echo. */
                    /* Load up dab packet!                                   */
                    loaddab(&echo1as,(short)0,dixon,dab_op,dab_view,(TYPDAB_PACKETS)acquire_echo1, PSD_LOAD_DAB_ALL);

                    startseq((short)as_slice, (short)MAY_PAUSE);

                    syncoff(&seqaushim);
                }

                getiamp(&temp_short, &rf1as, 0);
                setiamp(-temp_short, &rf1as, 0);

            } /* as_excitation */

        }  /* as_view */


        boffset(off_seqpassas);
        if (as_slice == (as_slquant-1)  ) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_aushim, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_aushim, 2);
            printdbg("End of Pass", PSdebugstate);
        }


        startseq((short)0, (short)MAY_PAUSE);
        boffset(off_seqaushim);

    }

    /* Reset the rotation matrix */
    setrotatearray((short)opslquant,rsprot[0]);

    GAM = tempGAM;

    printdbg("Normal End of autoshim", PSdebugstate);

    return SUCCESS;
} /* End of ASautoshim */

/*
 *  PSrfshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSrfshim( void )
{
    INT *rf1rs_freq;
    INT *rec_freq1rs;
    INT rs_slice, rs_view, DD_loop, tmp_DD_nCh;
    long rs_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT rs_yres_phase, rs_trains; 
    INT rs_yres_phase2toN[16];
    INT dab_view,dab_op, dabechors;
    INT acq_echors;
    INT i, tempi, rs_seq_count, rs_exphase, rs_rcphase;
    INT train_idx, bls_idx, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from RFShim B1 Map", PSdebugstate);
    rspdda = rs_dda;
    rspsct = 0;

    rs_trains = rfshim_yres/rfshim_etl;

    boffset(off_seqrs);

    dabechors = 0;
    rs_seq_count = 1;
    rs_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < rfshim_slquant; i++)
    {
        if (rsrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*rsrsp_info[i].rspphasoff/rfshim_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1rs_freq = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));
    rec_freq1rs = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));

    setupslices(rf1rs_freq, rsrsp_info, rfshim_slquant, a_gzrf1rs,
                               (float)1, rfshim_fov, TYPTRANSMIT);

    setupslices(rec_freq1rs, rsrsp_info, rfshim_slquant, (float)0,
                echo1bwrs, rfshim_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)rfshim_yres);
    phase_ordering(viewtab, rsphorder, rfshim_yres, rfshim_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1rs, 0);
    setiampt(0, &gy1rrs, 0);
    if(rfshim_etl >=2)
    {
        for(i=0;i<rfshim_etl-1;i++)
        {
            setiampt(0, &gy2rs, i);
        }
    }

    setiamp((short)ia_rf1rs, &rf1rs, 0);
    setiphase(0, &rf1rs, 0);

    setssitime((LONG)time_ssirs/HW_GRAD_UPDATE_TIME);

    for ( rs_slice = 0 ; rs_slice < rfshim_slquant; rs_slice++ )
    {
        rs_trigger[rs_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)rfshim_slquant, rs_trigger);

    setrotatearray((short)rfshim_slquant,rsrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyrs);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqrs);
    syncoff(&seqpassrs);

    for (rs_slice = 0; rs_slice < rfshim_slquant; rs_slice++)
    {
        tmp_DD_nCh = DD_nCh;

        if(PSdebugstate && (rs_slice >= 0))
        {
            printf("\n RFShim Sls = %i FOV = %f  slthick = %f\n", rfshim_slquant, rfshim_fov, rfshim_slthick);
            printf("\n RFShim Offsets: Tx = %f Rx = %f Phase = %f\n", rsrsp_info[rs_slice].rsptloc, 
                   rsrsp_info[rs_slice].rsprloc, rsrsp_info[rs_slice].rspphasoff);
            printf("%s\n"," RFShim Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][0], rsrsprot[0][1], rsrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][3], rsrsprot[0][4], rsrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][6], rsrsprot[0][7], rsrsprot[0][8]);
            fflush(stdout);
        }

        dab_op = DABSTORE;

        setiamp((short)ia_rf1rs, &rf1rs, 0);

        for (DD_loop=0;DD_loop<tmp_DD_nCh;DD_loop++)
        {
            if ((B1Cal_mode) || (0!=DD_debug))
            {
                boffset(off_seqIQControl);

                if(B1Cal_mode)
                {
                    if (0==(DD_loop%2))
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }
                else
                {
                    if (1==DD_debug)
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }

                settrigger((short)TRIG_INTERN, (short)0);

                startseq((SHORT)0,(SHORT)MAY_PAUSE);
            }

            boffset(off_seqrs);

            for (train_idx=(-(rs_dda+rfshim_baseline)+1); train_idx<= rs_trains; train_idx++)
            {
                if (train_idx > 0)
                {
                    rs_view = (train_idx-1)*rfshim_etl;
                    dab_view = viewtab[rs_view];

                    setiampt(-viewtable[dab_view], &gy1rs, 0);

                    if(rfshim_etl>=2)
                    {
                        for(tempi=0;tempi<rfshim_etl-1;tempi++)
                        {
                            setiampt(viewtable[viewtab[rs_view+tempi]]-viewtable[viewtab[rs_view+1+tempi]], &gy2rs, tempi);
                        }
                        setiampt(viewtable[viewtab[rs_view+rfshim_etl-1]], &gy1rrs, 0);
                    }
                    else
                    {
                        setiampt(viewtable[dab_view], &gy1rrs, 0);
                    }
                }
                else
                {
                    rs_view = 0;
                    dab_view = 0;
                }

                for (bls_idx = 0; bls_idx < 2; bls_idx++)
                {
                    dabechors = bls_idx;

                    if (0==bls_idx)
                    {
                        setiamp(ia_thetarfbrs, &thetarfbrs, 0);
                    }
                    else
                    {
                        setiamp(-ia_thetarfbrs, &thetarfbrs, 0);
                    }

                    dab_op = DABSTORE;


                    for (excitation=1; excitation <= 1; excitation++)
                    {
                        /* Scope Trigger */
                        if ((rspsct == rs_slice) || (rspsct == -1))
                        {
                            scopeon(&seqrs);
                        }
                        else
                        {
                            scopeoff(&seqrs);
                        }

                        if (train_idx > 0)
                        {
                            acq_echors = (int)DABON;
                        }
                        else
                        {
                            acq_echors = (int)DABOFF;
                        }

                        /* Load Transmit and Receive frequencies */
                        setfrequency(rf1rs_freq[rs_slice], &rf1rs, 0);
                        setfrequency(rec_freq1rs[rs_slice], &echo1rs, 0);

                        if (rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<(rfshim_etl-1);tempi++)
                            {
                                setfrequency(rec_freq1rs[rs_slice], &(rs_echo2toN[tempi]), 0);
                            }
                        }

                        if (train_idx > 0)
                        {
                            if (excitation == 1)
                            {
                                dab_op = 0;
                            }
                            else
                            {
                                dab_op = 3 - 2*(excitation % 2);
                            }

                            rs_yres_phase = phase_sign[rs_slice]*(((dab_view-1)*
                                                                   phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                        }
                        else
                        {
                            rs_yres_phase = 0;
                        }

                        if(rsspgr_flag)
                        {
                            rs_exphase = ((int)((float)rs_exphase + (float)rs_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            rs_seq_count++;
                        }
                        else
                        {
                            rs_exphase = 0;
                        }
                        setiphase(rs_exphase, &rf1rs, 0);

                        rs_rcphase = (rs_exphase + rs_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                        setiphase(rs_rcphase, &echo1rs, 0);

                        if(rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                rs_yres_phase2toN[tempi] = phase_sign[rs_slice]*
                                    (((viewtab[rs_view+tempi+1]-1)*phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                                rs_yres_phase2toN[tempi] = (rs_exphase + rs_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                                if (PSdebugstate)
                                {
                                    sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,rs_yres_phase2toN[tempi]);
                                    printdbg(psddbgstr, PSdebugstate);
                                    sprintf(psddbgstr,"view=%d;  slice=%d\n",rs_view, rs_slice);
                                    printdbg(psddbgstr, PSdebugstate);
                                }

                                setiphase(rs_yres_phase2toN[tempi], &(rs_echo2toN[tempi]), 0);  /* yres phase */
                            }
                        }

                        /* Load up dab packet */
                        loaddab(&echo1rs,(short)0,dabechors+DD_loop*2,dab_op,dab_view,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                        if(rfshim_etl>=2)
                        {
                            INT temp_dabview;

                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                temp_dabview = viewtab[rs_view+tempi+1];
                                loaddab(&rs_echo2toN[tempi],(short)0,dabechors+DD_loop*2,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                            }
                        }

                        startseq((short)rs_slice, (short)MAY_PAUSE);

                        syncoff(&seqrs);

                    } /* excitation */
                } /* End of BLS cycling loop */

            }  /* End of Echo Train train_idx loop */

        }/* DD loop */

        boffset(off_seqpassrs);
        if (rs_slice == (rfshim_slquant-1)) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_rs, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (rs_slice >=0)
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_rs, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD, &pass_rs, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqrs);

        if (B1Cal_mode && (rs_slice == (rfshim_slquant-1)))
        {
            boffset(off_seqIQControl);

            /* Enable I & Q channels again */
            setwamp(SSPD, &dDDIQ, 2);

            settrigger((short)TRIG_INTERN, (short)0);

            startseq((SHORT)0,(SHORT)MAY_PAUSE);
        }

    } /* End of slice loop */

    printdbg("Normal End of RFShim Map", PSdebugstate);

    return SUCCESS;
}   /* end PSrfshim() */


/*
 *  PSdyntg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSdyntg( void )
{
    INT *rf1dtg_freq;
    INT *rec_freq1dtg;
    INT dtg_slice, dtg_trains;
    INT train_idx, bls_idx;
    INT tempi;
    long dtg_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT dtg_yres_phase; 
    INT dtg_yres_phase2toN[16];
    INT dtg_view, dab_view, dab_op, dabechodtg;
    INT acq_echodtg;
    INT i, dtg_seq_count, dtg_exphase, dtg_rcphase, yoffs1;
    char psddbgstr[256] = "";

    if(L_MAPTG == rspent)
    {
        printdbg("Greetings from mapTg B1Map", PSdebugstate);
    }
    else
    {
        printdbg("Greetings from dynTG B1Map", PSdebugstate);
    }
    rspdda = dtg_dda;
    rspsct = 0;

    dtg_trains = dynTG_yres/dynTG_etl;

    boffset(off_seqdtg);

    dabechodtg = 0;
    dtg_seq_count = 1;
    dtg_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < dynTG_slquant; i++)
    {
        if (dtgrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*dtgrsp_info[i].rspphasoff/dynTG_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1dtg_freq = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));
    rec_freq1dtg = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));

    setupslices(rf1dtg_freq, dtgrsp_info, dynTG_slquant, a_gzrf1dtg,
                               (float)1, dynTG_fov, TYPTRANSMIT);

    setupslices(rec_freq1dtg, dtgrsp_info, dynTG_slquant, (float)0,
                echo1bwdtg, dynTG_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)dynTG_yres);
    phase_ordering(viewtab, dtgphorder, dynTG_yres, dynTG_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1dtg, 0);
    setiampt(0, &gy1rdtg, 0);
    if(dynTG_etl>=2)
    {
        for(tempi=0;tempi<dynTG_etl-1;tempi++)
        {
            setiampt(0, &gy2dtg, tempi);
        }
    }

    setiamp((short)ia_rf1dtg, &rf1dtg, 0);
    setiphase(0, &rf1dtg, 0);

    setssitime((LONG)time_ssidtg/HW_GRAD_UPDATE_TIME);

    for ( dtg_slice = 0 ; dtg_slice < dynTG_slquant; dtg_slice++ )
    {
        dtg_trigger[dtg_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)dynTG_slquant, dtg_trigger);

    setrotatearray((short)dynTG_slquant,dtgrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keydtg);
    scopeon(&seqdtg);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqdtg);
    syncoff(&seqpassdtg);

    boffset(off_seqdtg);

    for (dtg_slice = 0; dtg_slice < dynTG_slquant; dtg_slice++)
    {
        if(PSdebugstate && (dtg_slice >= 0))
        {
            printf("\n DynTG Sls = %i FOV = %f  slthick = %f\n", dynTG_slquant, dynTG_fov, dynTG_slthick);
            printf("\n DynTG Offsets: Tx = %f Rx = %f Phase = %f\n", dtgrsp_info[dtg_slice].rsptloc, 
                   dtgrsp_info[dtg_slice].rsprloc, dtgrsp_info[dtg_slice].rspphasoff);
            printf("%s\n"," DynTG Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][0], dtgrsprot[0][1], dtgrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][3], dtgrsprot[0][4], dtgrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][6], dtgrsprot[0][7], dtgrsprot[0][8]);
            fflush(stdout);
        }
        for (train_idx=-rspdda-dynTG_baseline; train_idx<= dtg_trains; train_idx++)
        {

            if (train_idx > 0)
            {
                dtg_view = (train_idx-1)*dynTG_etl;
                dab_view = viewtab[dtg_view];

                /* If after disdaqs, set phase encoding gradients. */
                setiampt(-viewtable[dab_view], &gy1dtg, 0);

                if(dynTG_etl>=2)
                {
                    for(tempi=0;tempi<dynTG_etl-1;tempi++)
                    {
                        setiampt(viewtable[viewtab[dtg_view+tempi]]-viewtable[viewtab[dtg_view+1+tempi]], &gy2dtg, tempi);
                    }
                    setiampt(viewtable[viewtab[dtg_view+dynTG_etl-1]], &gy1rdtg, 0);
                }
                else
                {
                    setiampt(viewtable[dab_view], &gy1rdtg, 0);
                }
            }
            else
            {
                dtg_view = 0;
                dab_view = 0;
            }

            /* BLS cycling loop */
            for (bls_idx = 0; bls_idx < 2; bls_idx++)
            {
                dabechodtg = bls_idx;

                if (0==bls_idx)
                {
                    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);
                }
                else
                {
                    setiamp(-ia_thetarfbdtg, &thetarfbdtg, 0);
                }

                dab_op = DABSTORE;


                for (excitation=1; excitation <= 1; excitation++)
                {
                    /* Scope Trigger */
                    if ((rspsct == dtg_slice) || (rspsct == -1))
                    {
                        scopeon(&seqdtg);
                    }
                    else
                    {
                        scopeoff(&seqdtg);
                    }

                    if (train_idx > 0)
                    {
                        acq_echodtg = (int)DABON;
                    }
                    else
                    {
                        acq_echodtg = (int)DABOFF;
                    }

                    /* Load Transmit and Receive frequencies */
                    setfrequency(rf1dtg_freq[dtg_slice], &rf1dtg, 0);
                    setfrequency(rec_freq1dtg[dtg_slice], &echo1dtg, 0);
                    if (dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<(dynTG_etl-1);tempi++)
                        {
                            setfrequency(rec_freq1dtg[dtg_slice], &(dtg_echo2toN[tempi]), 0);
                        } 
                    }

                    if (train_idx > 0)
                    {
                        if (excitation == 1)
                        {
                            dab_op = 0;
                        }
                        else
                        {
                            dab_op = 3 - 2*(excitation % 2);
                        }

                        dtg_yres_phase = phase_sign[dtg_slice]*(((dab_view-1)*
                                                                 phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                    }
                    else
                    {
                        dtg_yres_phase = 0;
                    }

                    if(dtgspgr_flag)
                    {
                        dtg_exphase = ((int)((float)dtg_exphase + (float)dtg_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                        dtg_seq_count++;
                    }
                    else
                    {
                        dtg_exphase = 0;
                    }
                    setiphase(dtg_exphase, &rf1dtg, 0);

                    dtg_rcphase = (dtg_exphase + dtg_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                    setiphase(dtg_rcphase, &echo1dtg, 0);
                    if(dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            dtg_yres_phase2toN[tempi] = phase_sign[dtg_slice]*
                                (((viewtab[dtg_view+tempi+1]-1)*phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                            dtg_yres_phase2toN[tempi] = (dtg_exphase + dtg_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                            setiphase(dtg_yres_phase2toN[tempi], &(dtg_echo2toN[tempi]), 0);  /* yres phase */
                            if (PSdebugstate)
                            {
                                sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,dtg_yres_phase2toN[tempi]);
                                printdbg(psddbgstr, PSdebugstate);
                            }

                        }
                    }

                    /* Load up dab packet */
                    loaddab(&echo1dtg,(short)0,dabechodtg,dab_op,dab_view,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);

                    if(dynTG_etl>=2)
                    {
                        INT temp_dabview;
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            temp_dabview = viewtab[dtg_view+tempi+1];
                            loaddab(&dtg_echo2toN[tempi],(short)0,dabechodtg,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);
                        }
                    }

                    startseq((short)dtg_slice, (short)MAY_PAUSE);

                    syncoff(&seqdtg);

                } /* excitation */
            }  /* End of BLS cycling loop */
        } /* End of Echo Train train_idx loop */

        /* now it is one pass for all dtg slices */
        boffset(off_seqpassdtg);
        if (dtg_slice == (dynTG_slquant-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_dtg, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (dtg_slice >=0)
        {
            setwamp(SSPD + DABPASS, &pass_dtg, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            setwamp(SSPD, &pass_dtg, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqdtg);

    } /* End of Slice dtg_slice loop */

    if(L_MAPTG == rspent)
    {
        printdbg("Normal End of mapTg B1Map", PSdebugstate);
    }
    else
    {
        printdbg("Normal End of dynTG B1Map", PSdebugstate);
    }

    return SUCCESS;
}   /* end PSdyntg() */


/*
 *  PSextcal
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSextcal( void )
{
    INT cal_sltab[CAL_SLTAB_MAX + 1];
    INT cal_slrtab[CAL_SLTAB_MAX + 1];
    SHORT cal_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long cal_trigger[CAL_SLTAB_MAX];
    INT caldabop;
    INT cal_acq;
    INT calsl_idx, calview_idx, calpass_idx, calcoil_idx, calnex_idx, longnex_idx;
    INT *calrf1_freq;
    INT *calrec_freq;
    INT cal_yphase;
    INT cal_zphase;
    INT cal_exphase;
    INT cal_rcphase;
    INT cal_seq_count;
    INT acq_passes;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT cal_superidx = 0;

    if(PSdebugstate)
    {

        {
            printf("\n AutoCal Sls = %i FOV = %f  slthick = %f\n", cal_slq, cal_fov, cal_slthick);
            printf("\n AutoCal: Tx = %f Rx = %f Phase = %f\n", calrsp_info[cal_slq/2].rsptloc,
                   calrsp_info[cal_slq/2].rsprloc, calrsp_info[cal_slq/2].rspphasoff);
            printf("%s\n"," AutoCal Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][0], calrsprot[0][1], calrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][3], calrsprot[0][4], calrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][6], calrsprot[0][7], calrsprot[0][8]);
            fflush(stdout);
        }

    }

    cal_yphase = 0;
    cal_zphase = 0;
    cal_rcphase = 0;

    cal_exphase = 0;
    cal_seq_count = 1;

    acq_passes = cal_pass;
    acq_nexs = cal_nex;
    acq_longnexs = 1;
    
    /* Initialize cal_sltab  */
    memset(cal_sltab, 0, sizeof(cal_sltab));
    memset(cal_slrtab, 0, sizeof(cal_slrtab));

    if(CAL_NEX_INTERLEAVED == cal_interleave)
    {
        acq_longnexs = cal_pass*cal_nex;
        acq_nexs = 1;
    }

    if(cal_interleave > CAL_NONE_INTERLEAVED)
    {
        acq_passes = 1;
    }
    else
    {
        acq_passes = cal_pass;
    }

    /* calculate Slab Offset */
    zoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rsptloc/cal_vthick));
    if (calrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)cal_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (calrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rspphasoff/cal_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    calrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    calrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(calrf1_freq, calrsp_info, 1, a_gzrf1cal,
                (float)1, cal_fov, TYPTRANSMIT);

    /* setup rec freq for each slice, calc here so fov is not scaled by
     * fov_freq_scale */
    if(cal_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcal * 1000/ cal_xfov;
        calrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * calrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocal", 0);
    }


    if(PSdebugstate)
    {
        printf("\n AutoCal tx freq = %i calrec_freq = %i \n", calrf1_freq[0], calrec_freq[0]);
    }

    for(calsl_idx=0;calsl_idx<cal_slq;calsl_idx++)
    {
        cal_sltab[calsl_idx+1] = (short)((((float)calsl_idx*(a_combcal - a_endcal)/
                                           (float)(cal_slq-1) - a_combcal)/calloggrd.tz)*max_pg_iamp);

        cal_slrtab[calsl_idx+1] = (int)((((float)calsl_idx*(a_combcal2 - a_endcal2)/
                                    (float)(cal_slq-1) - a_combcal2)/calloggrd.tz)*max_pg_iamp);

        cal_trigger[calsl_idx] = (long)TRIG_INTERN;
    }

    setupphasetable(cal_viewtab, (INT)TYPNORM, cal_yres);

    setssitime((LONG)time_ssical/HW_GRAD_UPDATE_TIME);

    setiamp(-cal_viewtab[cal_zyindex[0].view+1],&gy1cal,0);
    setiamp(cal_viewtab[cal_zyindex[0].view+1],&gy1rcal,0);

    temp_short = cal_sltab[cal_zyindex[0].slice];
    setiamp(temp_short,&gzcombcal,0);
    temp_short = cal_slrtab[cal_zyindex[0].slice];
    setiamp(-temp_short,&gzprcal,0);

    setiamp((short)ia_rf1cal, &rf1cal, 0);
    setiphase(0, &rf1cal, 0);

    setfrequency(calrf1_freq[0],&rf1cal,0);
    setfrequency(calrec_freq[0],&echo1cal,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)cal_slq,cal_trigger);

    setrotatearray((SHORT)cal_slq,*calrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycal);
    scopeon(&seqcal);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcal);
    syncoff(&seqcalpass);

    boffset(off_seqcal);

    /* Turn off 3dpacket */
    load3d(&d3dcal,0,(TYPDAB_PACKETS)DABOFF);

    cal_acq = (INT)DABOFF;
    loaddab(&echo1cal, 0,0,0,0, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);


    for (calview_idx = -rspdda; calview_idx <= -1; calview_idx++)
    {
        if(calview_idx < -cal_dda)  /* delay time, set rf1cal to 0 amplitude */
        {
            setiamp(0, &rf1cal, 0);
        }
        else
        {
            setiamp((short)ia_rf1cal, &rf1cal, 0);
        }

        if(calspgr_flag)
        {
            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            cal_seq_count++;
        }
        else
        {
            cal_exphase = 0;
        }

        setiphase(cal_exphase, &rf1cal, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcal);
    }

    for (calpass_idx = 0; calpass_idx < acq_passes; calpass_idx++)
    {
        cal_acq = (INT)DABON;

        /* switch to body coil in 2nd pass for PURE Cal */
        if(calpass_idx > 0)
        {
            if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
            {
                if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                {
                    return FAILURE;
                }
                boffset(off_seqcal);
                printf("switch to body coil\n");
            }

        }

        for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
        {
            if(CAL_NEX_INTERLEAVED == cal_interleave)
            {
                /* switch coil in NEX loop PURE Cal */
                if(0 == longnex_idx %2)
                {
                    if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
                    {
                        if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcal);
                        printf("switch to body coil\n");
                    }
                }
                else
                {
                    if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[0], 1))
                    {
                        return FAILURE;
                    }

                    boffset(off_seqcal);
                    printf("switch to surface coil\n");
                }
            }


            for (cal_superidx = 0; cal_superidx < cal_sampledPts; cal_superidx++)
            { 
                calview_idx = cal_zyindex[cal_superidx].view + 1;
                setiamp(-cal_viewtab[calview_idx],&gy1cal,0);
                setiamp(cal_viewtab[calview_idx],&gy1rcal,0);

                calsl_idx = cal_zyindex[cal_superidx].slice;
                cal_zphase =zsign*((calsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
                cal_yphase = phase_sign*(((calview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI - FS_PI);

                setiamp(cal_sltab[calsl_idx+1],&gzcombcal,0);
                setiamp(-cal_slrtab[calsl_idx+1],&gzprcal,0);

                /* Need this loaddab for coil switching in interleaved mode.
                 * The loaddab_hub_r1 is only set related ssp control bits related to rfhub for coil switching.
                 * Need to set other dab bits (slice, view, filter etc) for data acquisition by using loaddab().
                 */
                loaddab(&echo1cal,calsl_idx,0,0,calview_idx, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);

                for (calcoil_idx = 0; calcoil_idx <= cal_tr_interleave; calcoil_idx++)
                {

                    for (calnex_idx = 1; calnex_idx <= acq_nexs; calnex_idx++)  /* EXCITATION LOOP */
                    {
                        if(calspgr_flag)
                        {
                            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            cal_seq_count++;
                        }
                        else
                        {
                            cal_exphase = 0;
                        }
                        setiphase(cal_exphase, &rf1cal, 0);

                        cal_rcphase = (cal_exphase + cal_zphase + cal_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                        setiphase(cal_rcphase, &echo1cal, 0); /* slab and offset phase */


                        if (cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else if (!cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == calnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABOFF);
                        }


                        if(cal_nex > 1)
                        {
                            caldabop = DABADD;
                        }
                        else
                        {
                            caldabop = DABSTORE;
                        }

                        if(cal_tr_interleave)
                        {
                            if(calcoil_idx == 0)
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, coilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                            else   /* idx == 1, body coil rec */
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, volRecCoilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                        }
                        else
                        {
                            loaddab(&echo1cal,calsl_idx,0,caldabop,calview_idx, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_ALL);
                        }

                        /* startseq should be after loaddab */
                        startseq((SHORT)calsl_idx,(SHORT)MAY_PAUSE);

                    }  /* End of Excitation */
                }  /* Coil switching for PURE cal */

            }  /* End of SuperIndex */
        }  /* End of Long Term Nex loop */

        /* pass packet logic */
        boffset(off_seqcalpass);

        if(calpass_idx == (acq_passes-1))
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecal, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            setwamp(SSPD + DABPASS , &pass_pulsecal,2);
        }

        /* load last 3d packet */
        load3d(&d3dpasscal,cal_yres,(TYPDAB_PACKETS)DABON);

        startseq(0,(SHORT)AUTO_PAUSE);
        syncoff(&seqcal);

        boffset(off_seqcal);

        printdbg("Returning from Ext Cal core",PSdebugstate);

    } /* End of calpass */


    return SUCCESS;
}

/*
 *  PSautocoil
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
    STATUS
PSautocoil( void )
{
    SHORT coil_sltab[CAL_SLTAB_MAX + 1];
    SHORT coil_slrtab[CAL_SLTAB_MAX + 1];
    SHORT coil_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long coil_trigger[CAL_SLTAB_MAX];
    INT coildabop;
    INT coil_acq;
    INT coilsl_idx, coilview_idx, coilnex_idx, longnex_idx;
    INT *coilrf1_freq;
    INT *coilrec_freq;
    INT coil_yphase;
    INT coil_zphase;
    INT coil_exphase;
    INT coil_rcphase;
    INT coil_seq_count;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT coil_superidx = 0;

    if(PSdebugstate)
    {
        printf("\n AutoCoil Sls = %i FOV = %f  slthick = %f\n", coil_slq, coil_fov, coil_slthick);
        printf("\n AutoCoil: Tx = %f Rx = %f Phase = %f\n", coilrsp_info[coil_slq/2].rsptloc,
               coilrsp_info[coil_slq/2].rsprloc, coilrsp_info[coil_slq/2].rspphasoff);
        printf("%s\n"," AutoCoil Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][0], coilrsprot[0][1], coilrsprot[0][2]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][3], coilrsprot[0][4], coilrsprot[0][5]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][6], coilrsprot[0][7], coilrsprot[0][8]);
        fflush(stdout);
    }

    /* Initialize coil_sltab  */    
    memset(coil_sltab, 0, sizeof(coil_sltab));
    memset(coil_slrtab, 0, sizeof(coil_slrtab));

    coil_yphase = 0;
    coil_zphase = 0;
    coil_rcphase = 0;

    coil_exphase = 0;
    coil_seq_count = 1;

    acq_nexs = coil_nex;
    acq_longnexs = 1;

    if(CAL_NEX_INTERLEAVED == coil_interleave)
    {
        acq_longnexs = coil_nex;
        acq_nexs = 1;
    }

    /* calculate Slab Offset */
    zoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rsptloc/coil_vthick));
    if (coilrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)coil_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (coilrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rspphasoff/coil_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    coilrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    coilrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(coilrf1_freq, coilrsp_info, 1, a_gzrf1coil,
                (float)1, coil_fov, TYPTRANSMIT);

    /* setup rec freq for each slice here so fov is not scaled
     * by fov_freq_scale */
    if(coil_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcoil * 1000/ coil_xfov;
        coilrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * coilrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocoil", 0);
    }

    for(coilsl_idx=0;coilsl_idx<coil_slq;coilsl_idx++)
    {
        coil_sltab[coilsl_idx+1] = (SHORT)((((float)coilsl_idx*(a_combcoil - a_endcoil)/
                                     (float)(coil_slq-1) - a_combcoil)/coilloggrd.tz)*max_pg_iamp);

        coil_slrtab[coilsl_idx+1] =(SHORT)((((float)coilsl_idx*(a_combcoil2 - a_endcoil2)/
                                     (float)(coil_slq-1) - a_combcoil2)/coilloggrd.tz)*max_pg_iamp);

        coil_trigger[coilsl_idx] = (long)TRIG_INTERN;
    }

    if(PSdebugstate)
    {
        printf("\n Sls encode = %d, = %d,  = %d \n", coil_sltab[0], coil_sltab[3], coil_sltab[5]);
        fflush(stdout);
    }

    setupphasetable(coil_viewtab, (INT)TYPNORM, coil_yres);

    setssitime((LONG)time_ssicoil/HW_GRAD_UPDATE_TIME);


    temp_short = coil_sltab[1];
    setiamp(temp_short,&gzcombcoil,0);
    temp_short = coil_slrtab[1];
    setiamp(-temp_short,&gzprcoil,0);

    setiamp((short)ia_rf1coil, &rf1coil, 0);
    setiphase(0, &rf1coil, 0);

    setfrequency(coilrf1_freq[0],&rf1coil,0);
    setfrequency(coilrec_freq[0],&echo1coil,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)coil_slq,coil_trigger);

    setrotatearray((SHORT)coil_slq,*coilrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycoil);
    scopeon(&seqcoil);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcoil);
    syncoff(&seqcoilpass);

    boffset(off_seqcoil);

    /* Turn off 3dpacket */
    load3d(&d3dcoil,0,(TYPDAB_PACKETS)DABOFF);

    coil_acq = (INT)DABOFF;
    loaddab(&echo1coil, 0,0,0,0, (TYPDAB_PACKETS)coil_acq,PSD_LOAD_DAB_ALL);

    for (coilview_idx = -rspdda; coilview_idx <= -1; coilview_idx++)
    {
        if(coilspgr_flag)
        {
            coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            coil_seq_count++;
        }
        else
        {
            coil_exphase = 0;
        }

        setiphase(coil_exphase, &rf1coil, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcoil);
    }

    for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
    {
        coil_acq = (INT)DABON;
        for (coil_superidx = 0; coil_superidx < coil_sampledPts; coil_superidx++)
        { 
            coilview_idx = coil_zyindex[coil_superidx].view + 1;
            setiamp(-coil_viewtab[coilview_idx],&gy1coil,0);
            setiamp(coil_viewtab[coilview_idx],&gy1rcoil,0);

            coilsl_idx = coil_zyindex[coil_superidx].slice;
            coil_zphase =zsign*((coilsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
            coil_yphase = phase_sign*(((coilview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI-FS_PI);


            setiamp(coil_sltab[coilsl_idx+1],&gzcombcoil,0);
            setiamp(-coil_slrtab[coilsl_idx+1],&gzprcoil,0);

            for (coilnex_idx = 1; coilnex_idx <= acq_nexs; coilnex_idx++)  /* EXCITATION LOOP */
            {
                if(coilspgr_flag)
                {
                    coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                    coil_seq_count++;
                }
                else
                {
                    coil_exphase = 0;
                }
                setiphase(coil_exphase, &rf1coil, 0);

                coil_rcphase = (coil_exphase + coil_zphase + coil_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                setiphase(coil_rcphase, &echo1coil, 0); /* slab and offset phase */

                if (coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else if (!coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == coilnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABOFF);
                }


                if(coil_nex > 1)
                {
                    coildabop = DABADD;
                }
                else
                {
                    coildabop = DABSTORE;
                }

                loaddab(&echo1coil,coilsl_idx,0,coildabop,coilview_idx, (TYPDAB_PACKETS)coil_acq, PSD_LOAD_DAB_ALL);

                /* startseq should be after loaddab */
                startseq((SHORT)coilsl_idx,(SHORT)MAY_PAUSE);

            }  /* End of Excitation */
        }  /* End of SuperIdx */
    }  /* End of Long Term Nex loop */

    /* pass packet logic */
    boffset(off_seqcoilpass);

    /* Set DAB pass packet to end of scan */
    setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecoil, 2);
    printdbg("End of Scan and Pass", PSdebugstate);

    /* load last 3d packet */
    load3d(&d3dpasscoil,coil_yres,(TYPDAB_PACKETS)DABON);

    startseq(0,(SHORT)AUTO_PAUSE);
    syncoff(&seqcoil);

    boffset(off_seqcoil);

    printdbg("Returning from AutoCOil core",PSdebugstate);


    return SUCCESS;
}



/* CoilSwitchSetCoil
 *
 *  Description: MRIhc15304
 *    This sets the RF HUB index for the coil by changing the data on an ssp
 *    pulse and/or with the sethubindeximm function.  Also calls
 *    setrcvportimm, if requested.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  
 *  (O) STATUS return variable - Did function complete successfully.
 *  (I) const COIL_INFO - coil info structure of coil to switch to
 *  (I) const INT setRcvPortFlag - Flag indicating that setrcvportimm needs
 *        to be executed.  This needs to be set whenever switching to or
 *        from the BODY coil.
 *  
 *  Globals:
 *  (I) txCoilInfo
 *
 */

STATUS
CoilSwitchSetCoil( const COIL_INFO coil,
                   const INT setRcvPortFlag)
{
    SHORT device = 0;

    if( setRcvPortFlag || (COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod) )
    {
        int wait_rspimm = 0;

        /* MRIhc14300: When switching coils, play a delay sequence to
           wait for scan prep to complete and scanning to start before the
           first setrcvportimm() & sethubindeximm().  These functions may not
           be called until scanning starts and the first startseq will not
           return until scanning starts. After scanning has started this will
           merely add an additional short delay to the switch time */

        boffset(off_seqcswWaitBefore);
        startseq((short)0, (SHORT)MAY_PAUSE);

        /* Need additional delay for setrcvpowerimm & sethubindeximm
         * to take effect.  The delay time must be set to guarantee
         * the completion of both setrcvportimm and sethubindeximm */

        if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
        {
            wait_rspimm = csw_wait_sethubindeximm;
        }

        if( setRcvPortFlag )
        {
            wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
        }

        setperiod(wait_rspimm, &csw_wait, 0);
    }
    else
    {
        /* No additional delay needed when not calling setrcvportimm */
        setperiod(SSP_UPDATE_TIME, &csw_wait, 0);
    }

    /* Setup hub index switching packet */
    device = 0;
    if( COIL_SWITCH_SSP_HUB_INDEX & cfcoilswitchmethod )
    {
        device = RDC;
        /* Set hub index on SSP packet */
        setwamp( (SHORT)(SSPD | (HUBIND + coil.hubIndex)), &contrfhubsel, (LONG)2 );
    }
    setwamp( (SHORT)(SSPDS | device), &contrfhubsel, (LONG)0 );

    /* Set receiver port & receiver input */
    if( setRcvPortFlag || (COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod) )
    {
        SHORT coil_port = PSD_RP_BODY;
        SHORT rcv_input = RFBODYI;

        /* Calculate coil port & receiver input */
        switch (coil.rxCoilType) 
        {
        case RX_COIL_BODY:
        default:
            /* Transmit & receive with body coil */
            coil_port = PSD_RP_BODY;
            rcv_input = RFBODYI;
            break;
        case RX_COIL_LOCAL:
            {
                /* Assume there is only one transmit coil.  If two transmit
                   coils, the primary will be used */
                n32 txCoilType = TX_COIL_BODY;
                if (TX_INDEX_NONE != coil.txIndexPri)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexPri].txCoilType;
                }
                else if (TX_INDEX_NONE != coil.txIndexSec)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexSec].txCoilType;
                }
                else
                {
                    printf("CoilSwitchSetCoil: No transmit coil defined!\n");
                    return FAILURE;
                }

                if (TX_COIL_LOCAL == txCoilType)
                {
                    /* Local transmit coil */
                    coil_port = PSD_RP_HEAD;
                    rcv_input = RHEADI;
                }
                else
                {
                    /* Surface coil */
                    coil_port = PSD_RP_SURFACE;
                    rcv_input = RFAUX;
                }
            }
            break;
        }

        /* Setup receiver input switching packet */
        device = 0;
        if( COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod )
        {
            device = RDC;
            setwamp( (SHORT)(SSPD | rcv_input), &contrfsel, (LONG)2 );
        }
        setwamp( (SHORT)(SSPDS | device), &contrfsel, (LONG)0 );

        /* Set receiver port using RSP function call when switching to/from 
         * body coil */
        if (setRcvPortFlag) 
        {
#ifdef PSD_HW
            setrcvportimm( (SHORT)coil_port );
#endif /* PSD_HW */
        }
    }

    /* Select coil using RSP function on MGD Rx chain */
    if(COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod)
    {
        sethubindeximm( coil.hubIndex );
    }
   
    boffset( off_seqcsw );
    startseq( (short)0, (SHORT)MAY_PAUSE );
    return SUCCESS;
}

/* phase_ordering 
 *
 *  Description: function for different phase ordering
 *  (O) SHORT* view_tab : View table with view acquisition order.
 *  (I) INT phase_order : Phase order variable.  Phase order types are:
 *           SEQUENTIAL 0
 *           CENTRIC 1
 *  (I) INT yviews : Number of views acquired in the scan.
 *
 *
*******************************/
STATUS
phase_ordering( SHORT *view_tab,
                const INT phase_order,
                const INT yviews, const INT yetl)
{
    INT i, j, num_trains, center;
    STATUS status = SUCCESS;

    num_trains = yviews/yetl;


    if(yetl >= 2)
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL: 
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (i*2)*yetl+j+1;
                        view_tab[(i*2+1)*yetl+j] = (i*2+1)*yetl+j+1; 
                    }
                }
                break;
            case PH_CENTRIC_LOW:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (yviews/2 - i - j*num_trains/2);
                        view_tab[(i*2+1)*yetl+j] = (yviews/2 + i + 1 + j*num_trains/2);
                    }
                }
                break;
            case PH_CENTRIC_HIGH:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = yviews/2 + i - j*num_trains/2 - num_trains/2 + 1;
                        view_tab[(i*2+1)*yetl+j] = yviews/2 - i + j*num_trains/2 + num_trains/2;
                    }
                }
                break;
        }
    }
    else
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL:
                {
                    for(i=0;i<yviews;i++)
                    {
                        view_tab[i]=i+1;
                    }
                }
                break;
            case PH_CENTRIC_LOW:
            case PH_CENTRIC_HIGH:
                center = yviews/2;

                for( i = 0, j = 0; i < yviews/ 2; ++i, j += 2 )
                {
                    view_tab[j % yviews] = center - i;
                    view_tab[(j + 1) % yviews] = center + i + 1;
                }
                break;
        }
    }
    return status;
}






/**
 *******************************************************************************************************
 @brief #### Not sure what this function does, but it exists in all product psds.
********************************************************************************************************/
void dummylinks(void) {
  epic_loadcvs( "thefile" ); /* for downloading CVs */
}




/**
 *******************************************************************************************************
 @brief #### RSP Init. To be inserted in the psdinit() function (or scan()) in the main sequence
********************************************************************************************************/
void GEReq_initRSP(void) {

  /* Initialize everything to a known state */
  setrfconfig((short) ks_rfconf);   /* ENBL_RHO1 + ENBL_THETA + ENBL_OMEGA + ENBL_OMEGA_FREQ_XTR1 = 141 */
  rspqueueinit(200);  /* Initialize to 200 entries */
  syncoff(&GEpass);   /* Deactivate sync during pass */
}

/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSSpSat.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydén, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
  *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSSpSat.e
* @brief This file contains Spatial Sat and should be `@inline`'d at the beginning of a KSFoundation PSD
********************************************************************************************************/

/*******************************************************************************************************
*******************************************************************************************************
*
*  KSSpSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/








/**
 *******************************************************************************************************
 @brief #### The ksspsat (spatial sat) pulse sequence module

 This is the spatial sat sequence module in ksspsat.e using the sequence objects in KSSPSAT_SEQUENCE with
 the sequence module name "ksspsat" (= ksspsat.seqctrl.description). On HOST, the minimum duration
of the sequence module is set by ks_eval_seqctrl_setminduration().

@param[in, out] ksspsat Pointer to KSSPSAT_SEQUENCE
@retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_pg(KSSPSAT_SEQUENCE *ksspsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  if (ksspsat->satlocation.active == KSSPSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksspsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* SelRF (including postgrad for spoiler) */
  loc.board = ksspsat->satlocation.gradboard;
  status = ks_pg_selrf(&ksspsat->selrf, loc, &ksspsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Optional spoiling using the postgrad trapezoid on the remaining two axes */
  if (ksspsat_params.spoilallaxes) {
    KS_SEQLOC tmploc = loc;
    tmploc.pos += ksspsat->selrf.grad.duration;
    switch (ksspsat->satlocation.gradboard) {
    case XGRAD:
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case YGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case ZGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    }
  }

  loc.pos += ksspsat->selrf.grad.duration + ksspsat->selrf.postgrad.duration + KS_RFSSP_POSTTIME;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (ksspsat->seqctrl.ssi_time must be > 0 and is added to ksspsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if ksspsat_params.satmode = KSSPSAT_OFF, then 2nd arg will be zero, making both ksspsat->seqctrl.min_duration and .duration = 0 */
  ksspsat->seqctrl.ssi_time = ksspsat_params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksspsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksspsat_pg() */



STATUS ksspsat_pulsegen() {
  int i;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    if (ksspsat[i].satlocation.active != KSSPSAT_OFF) {

      ksspsat_pg(&ksspsat[i]);

      switch (i) {
      case KSSPSAT_1:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat1, "seqKSSpSat1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat1, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat1 = %d\n", idx_seqKSSpSat1 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat1;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_2:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat2, "seqKSSpSat2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat2, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat2 = %d\n", idx_seqKSSpSat2 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat2;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_3:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat3, "seqKSSpSat3");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat3, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat3);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat3 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat3 = %d\n", idx_seqKSSpSat3 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat3;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat3;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat3;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_4:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat4, "seqKSSpSat4");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat4, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat4);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat4 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat4 = %d\n", idx_seqKSSpSat4 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat4;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat4;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat4;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_5:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat5, "seqKSSpSat5");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat5, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat5);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat5 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat5 = %d\n", idx_seqKSSpSat5 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat5;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat5;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat5;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_6:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat6, "seqKSSpSat6");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat6, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat6);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat6 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat6 = %d\n", idx_seqKSSpSat6 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat6;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat6;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat6;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      }

    }
  }

  return SUCCESS;
}





/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE

 This function sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE,
 incl. gradient amplitude changes, RF freq/phase for the current slice position.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void ksspsat_scan_seqstate(KSSPSAT_SEQUENCE *ksspsat, float rfphase) {
#ifdef IPG

  if (ksspsat->satlocation.active != KSSPSAT_OFF) {
    ks_scan_rotate(ksspsat->satlocation.loc);
    ks_scan_selrf_setfreqphase(&ksspsat->selrf, 0, ksspsat->satlocation.loc, rfphase);
  }

#endif
}




int ksspsat_scan_playsequences(int perform_slicetimeplot) {
  int i;
  int time = 0;
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {

    ksspsat_scan_seqstate(&ksspsat[i], rfphase);

    time += ks_scan_playsequence(&ksspsat[i].seqctrl);

    if (perform_slicetimeplot) {
      /* spatial sat not necessarily in the slice direction, so can't trust its thickness or direction.
        save it as 1000 mm thick at center (0) for now just to be able to mark it in time in the plot */
      ks_plot_slicetime(&ksspsat[i].seqctrl, 1, NULL, KS_NOTSET, KS_PLOT_STANDARD);
    }

  }

  return time;
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSChemSat.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydén, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
  *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSChemSat.e
* @brief This file contains FatSat (KSChemSat) and should be `@inline`'d at the beginning of a KSFoundation PSD
********************************************************************************************************/

/*******************************************************************************************************
*******************************************************************************************************
*
*  KSChemSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### The kschemsat (fatsat) pulse sequence module

 This is the fatsat sequence module in kschemsat.e using the sequence objects in KSCHEMSAT_SEQUENCE with
 the sequence module name "kschemsat" (= kschemsat.seqctrl.description). On HOST, the minimum duration
 of the sequence module is set by ks_eval_seqctrl_setminduration().

 @param[in,out] kschemsat Pointer to KSCHEMSAT_SEQUENCE
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS kschemsat_pg(KSCHEMSAT_SEQUENCE *kschemsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  /* return early if sat mode is off */
  if (kschemsat->params.satmode == KSCHEMSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (kschemsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* RF */
  status = ks_pg_rf(&kschemsat->rf, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->rf.rfwave.duration;

  /* Y spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Z spoiler */
  loc.board = ZGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->spoiler.duration;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (kschemsat->seqctrl.ssi_time must be > 0 and is added to kschemsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if kschemsat->params.satmode = KSCHEMSAT_OFF, then 2nd arg will be zero, making both kschemsat->seqctrl.min_duration and .duration = 0 */
  kschemsat->seqctrl.ssi_time = kschemsat->params.ssi_time;
  ks_eval_seqctrl_setminduration(&kschemsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* kschemsat_pg() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE

 This function sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE,
 incl. gradient amplitude and RF phase changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void kschemsat_scan_seqstate(KSCHEMSAT_SEQUENCE *kschemsat) {
#ifdef IPG
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  ks_scan_rf_setphase(&kschemsat->rf, INSTRALL, rfphase);

#endif
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSInversion.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydén, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSInversion.e
* @brief This file contains an inversion preparation module that should be `@inline`'d at the beginning
         of a KSFoundation PSD
********************************************************************************************************/




/*******************************************************************************************************
*******************************************************************************************************
*
*  KSInversion.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/

KS_MAT4x4 Mphysical_inversion = KS_MAT4x4_IDENTITY;




/**
 *******************************************************************************************************
 @brief #### Generation of the waveforms for the sequence objects in a KSINV_SEQUENCE

 Two KSINV_SEQUENCE structs are currently declared in KSInversion.e, `ksinv1` and `ksinv2`. By passing
 each one of them to this function, will generate the actual sequence on TGT. On HOST, the
 `seqctrl.min_duration` field is set and used by TI/TR calculations.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_pg(KSINV_SEQUENCE *ksinv) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;


  if (ksinv->params.irmode == KSINV_OFF)
    return SUCCESS;

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksinv->seqctrl.duration == 0)
    return SUCCESS;
#endif


  loc.pos = ksinv->params.startpos;

  if (loc.pos % GRAD_UPDATE_TIME) {
    return ks_error("%s: Start position of RF pulse must be divisible by GRAD_UPDATE_TIME (ksinv->params.rfstartpos = %d)", __FUNCTION__, ksinv->params.startpos);
  }
  if (loc.pos < KS_RFSSP_PRETIME) {
    return ks_error("%s: Start position of RF pulse must be at least %d [us] (ksinv->params.rfstartpos = %d)", __FUNCTION__, KS_RFSSP_PRETIME, ksinv->params.startpos);
  }

  /* RF */
  if (ksinv_slicecheck){
    loc.board = XGRAD;
  } else {
    loc.board = ZGRAD;
  }


  if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {

    if (ks_pg_selrf(&ksinv->selrfexc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;

    int mag_center_exc = loc.pos + ksinv->selrfexc.grad.ramptime + ksinv->selrfexc.rf.start2iso;

    /* now refocussing pulses*/
    /* we make sure that that delta_t_refoc/2 is a multiple of GRAD_UPDATE_TIME using the RUP_GRD function (division results are integer truncated) */
    int delta_t_refoc_half = RUP_GRD(ksinv->params.t2prep_TE/ ksinv->params.N_Refoc/ 2);

    /* first refocusing pulse*/
    loc.pos = mag_center_exc + delta_t_refoc_half - ksinv->selrfrefoc.grad.ramptime - ksinv->selrfrefoc.rf.start2iso - ksinv->selrfrefoc.pregrad.duration;
    if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    /* all other refocusing pulses*/
    int n;
    for (n = 1; n < ksinv->params.N_Refoc; n++) {
      loc.pos += 2*delta_t_refoc_half;
      if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
    }

    /***************************************************************************************************
     *  two different versions
     *  non adiabatic (+90)-(n*180)-(+90)
     *  adiabatic (+90)-(n*180)-(-90)-(180)
     *  the polarity of the flip angle of the flip pulse is set with loc.ampscale
     ***************************************************************************************************/

    loc.pos = mag_center_exc + ksinv->params.N_Refoc*delta_t_refoc_half*2 - ksinv->selrfflip.grad.ramptime - ksinv->selrfflip.rf.start2iso - ksinv->selrfflip.pregrad.duration;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      loc.ampscale = -1;
    } else {
      loc.ampscale = 1;
    }

    if (ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    
    /* Save absolute time in sequence for moment start, it is important to do that after 
    ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) because otherwise ksinv->seqctrl.momentstart would be overwritten as
    the "ROLE" of selrfflip is an excitation pulse, there is no ROLE for a flipup pulse yet */
    ksinv->seqctrl.momentstart = mag_center_exc;   

    loc.ampscale = 1; /* set it back to default */
    /* waveform overlap problems between selrfflip and selrfinv on DV25 --> 5*GRAD_UPDATE_TIME safety margin */
    loc.pos += ksinv->selrfflip.pregrad.duration + ksinv->selrfflip.grad.duration + 5*GRAD_UPDATE_TIME;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      if (ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
      loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;
    }
  } else {

    /* Save absolute time in sequence for moment start */
    ksinv->seqctrl.momentstart = loc.pos + ksinv->selrfinv.grad.ramptime + ksinv->selrfinv.rf.start2iso;

    status = ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl);
    if (status != SUCCESS) return status;

    loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;

  }

  /* Z spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&ksinv->spoiler, loc, &ksinv->seqctrl);
  if (status != SUCCESS) return status;
  loc.pos += ksinv->spoiler.duration;


 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksinv->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence module duration (ksinv->seqctrl.ssi_time must be > 0 and is added to ksinv->seqctrl.min_duration in ks_eval_seqctrl_setminduration()) */
  ksinv->seqctrl.ssi_time = ksinv->params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksinv->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif


  return SUCCESS;

} /* ksinv_pg() */




/**
 *******************************************************************************************************
 @brief #### Generation of all inversion-related sequence modules

 This function should be called directly from the `pulsegen()` function in a psd to create up to three
 sequence modules that can be used during scan.

 N.B.: If ksinvX.seqctrl.duration = 0, both ksinv_pg() and KS_SEQLENGTH() will return early avoiding this
 sequence module to be created. Similarly for the seqInvFillTR wait sequence.

 @return void
********************************************************************************************************/
void ksinv_pulsegen() {

  /* First (only) Inversion sequence module */
  ksinv_pg(&ksinv1);
   
    {
      if (ksinv1.seqctrl.duration > 0) {

        if (ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv1.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv1, "seqInv1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv1) failed", ksinv1.seqctrl.description);
          }  
          status = createseq(&seqInv1, ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time, off_seqInv1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv1) failed", ksinv1.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv1) failed", ksinv1.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv1 = %d\n", idx_seqInv1 );
          ksinv1.seqctrl.handle.index = idx_seqInv1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv1.seqctrl.handle.offset = off_seqInv1;
          ksinv1.seqctrl.handle.pulse = &seqInv1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv1.seqctrl.duration = 0 */

  /* 2nd Inversion sequence module */
  ksinv_pg(&ksinv2);
   
    {
      if (ksinv2.seqctrl.duration > 0) {

        if (ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv2.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv2, "seqInv2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv2) failed", ksinv2.seqctrl.description);
          }  
          status = createseq(&seqInv2, ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time, off_seqInv2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv2) failed", ksinv2.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv2) failed", ksinv2.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv2 = %d\n", idx_seqInv2 );
          ksinv2.seqctrl.handle.index = idx_seqInv2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv2.seqctrl.handle.offset = off_seqInv2;
          ksinv2.seqctrl.handle.pulse = &seqInv2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv2.seqctrl.duration = 0 */

  /* FillTR sequence for some inversion cases */
   
    {
      if (ksinv_filltr.duration > 0) {

        if (ksinv_filltr.duration - ksinv_filltr.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv_filltr.description);

        } else {

          STATUS status = pulsename(&seqInvFillTR, "seqInvFillTR");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInvFillTR) failed", ksinv_filltr.description);
          }  
          status = createseq(&seqInvFillTR, ksinv_filltr.duration - ksinv_filltr.ssi_time, off_seqInvFillTR);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInvFillTR) failed", ksinv_filltr.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInvFillTR );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInvFillTR) failed", ksinv_filltr.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInvFillTR = %d\n", idx_seqInvFillTR );
          ksinv_filltr.handle.index = idx_seqInvFillTR;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv_filltr.handle.offset = off_seqInvFillTR;
          ksinv_filltr.handle.pulse = &seqInvFillTR;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv_filltr.duration = 0 */

} /* ksinv_pulsegen() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of a KSINV_SEQUENCE during scanning

 This function sets the current state of all `ksinv` sequence objects being part of KSINV_SEQUENCE,
 specifically slice-dependent RF freq/phases changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] ksinv Pointer to KSINV_SEQUENCE
 @param[in] slice_info Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_scan_seqstate(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_info) {

  if (ksinv->params.irmode == KSINV_OFF || ksinv->seqctrl.duration == 0)
    return SUCCESS;

  if (slice_info != NULL) {

    ks_scan_rotate(*slice_info);

    if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
      ks_scan_rf_on(&ksinv->selrfexc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfexc, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfrefoc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfrefoc, INSTRALL, *slice_info, 90);

      ks_scan_rf_on(&ksinv->selrfinv.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfinv, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfflip.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfflip, INSTRALL, *slice_info, 0);

    } else {  
      ks_scan_rf_on(&ksinv->selrfinv.rf, 0);

      if (ksinv->selrfinv.sms_info.pulse_type == KS_SELRF_SMS_PINS_DANTE) {
        ks_scan_selrf_setfreqphase_pins(&ksinv->selrfinv, 0, *slice_info,
                                        ksinv->selrfinv.sms_info.mb_factor, ksinv->selrfinv.sms_info.slice_gap, 0.0);
      } else {
        ks_scan_selrf_setfreqphase(&ksinv->selrfinv, 0, *slice_info, 0);
      }
    }

  } else {

    ks_scan_rf_off(&ksinv->selrfinv.rf, 0);

  }

  return SUCCESS;

} /* ksinv_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Plays out one inversion slice in real time during scanning

  On TGT on the MR system (PSD_HW), this function sets up (ksepi_scan_seqstate()) and plays out one
  KSINV_SEQUENCE. The low-level function call `startseq()`, which actually starts the realtime sequence
  playout is called from within ks_scan_playsequence(), which in addition also returns the time to play
  out that sequence module (see time += ...).

  On HOST (in ksepi_eval_tr()) we call ksepi_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksepi_scan_scantime(), which returns the total time of the
  entire scan.

  @param[in] ksinv Pointer to KSINV_SEQUENCE
  @param[in] slice_pos Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
  @retval irtime Time taken in [us] to play out one inversion slice
********************************************************************************************************/
int ksinv_scan_irslice(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_pos) {
  SCAN_INFO slice_pos_updated;
  int time = 0;
  float tloc = 0.0;

  if (ksinv == NULL) {
    return 0;
  }

  if (ksinv->params.irmode != KSINV_OFF && ksinv->seqctrl.duration > 0) {

    if (slice_pos != NULL) {
      /* N.B.: Mphysical_inversion is an ipgexport KS_MAT4x4 variable that e.g. the main sequence can update in real time */
      ks_scan_update_slice_location(&slice_pos_updated, *slice_pos, Mphysical_inversion, NULL);
      tloc = slice_pos_updated.optloc;
      ksinv_scan_seqstate(ksinv, &slice_pos_updated);
    } else {
      ksinv_scan_seqstate(ksinv, slice_pos);
    }

    /* SMS offset */
    float offset = (ksinv->selrfinv.sms_info.slice_gap/ 2) * (ksinv->selrfinv.sms_info.mb_factor - 1);
    float sms_slice_positions[ksinv->selrfinv.sms_info.mb_factor];
    int slice = 0;
    for (slice = 0; slice < ksinv->selrfinv.sms_info.mb_factor; ++slice) {
      if (slice_pos != NULL)
        sms_slice_positions[slice] = tloc + ksinv->selrfinv.sms_info.slice_gap * (0.5 + slice - (ksinv->selrfinv.sms_info.mb_factor/ 2.0)) + offset;
      else
        sms_slice_positions[slice] = 0;
    }

    ks_plot_slicetime(&ksinv->seqctrl,
                      ksinv->selrfinv.sms_info.mb_factor,
                      sms_slice_positions,
                      ksinv->selrfinv.slthick,
                      slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

    time += ks_scan_playsequence(&ksinv->seqctrl);

  }

  return time;

} /* ksinv_scan_irslice() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slice_plan.nslices_per_pass` slices corresponding to one TR for inversion psds

 This function should replace the sliceloop function of a 2D psd when inversion is enabled. It will take
 over the sequence timing for one TR by playing out the inversion sequence module(s) and other sequence
 modules in an order that is subject to the inversion mode (`ksinvX.params.irmode`). The non-inversion
 sequence modules should be played out together in a 'core slice' function of the psd. This core slice
 function should have a wrapper function with standardized input arguments that conmplies with the
 function pointer (and core_nargs, core_args) passed to this function.

 @param[in] slice_plan  Pointer to the slice plan (KS_SLICE_PLAN) set up earlier using ks_calc_sliceplan() or similar
 @param[in] slice_positions Pointer to the SCAN_INFO array corresponding to the slice locations (typically `ks_scan_info`)
 @param[in] passindx  Pass index in range `[0, ks_slice_plan.npasses - 1]`
 @param[in] ksinv1    Pointer to KSINV_SEQUENCE corresponding to the 1st (or only) inversion. Cannot be NULL
 @param[in] ksinv2    Pointer to KSINV_SEQUENCE corresponding to an optional 2nd inversion. May be NULL
 @param[in] ksinv_filltr    Pointer to KS_SEQ_CONTROL for fillTR sequence for FLAIR block modes. May be NULL
 @param[in] ksinv_loop_mode If KSINV_LOOP_DUMMY, this function will pass in KS_NOTSET (-1) as the 2nd argument to 'play_coreslice'.
                       For this to work, the play_coreslice() function (usually the main sequence's coreslice),
                       must check if it's 2nd arg is KS_NOTSET, and if so shut off data collection in loaddab()
                       KSINV_LOOP_NORMAL: Slice excitation ON, Data acq. ON
                       KSINV_LOOP_DUMMY: Slice excitation ON, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_FIRST: Slice excitation ON for IR, OFF for coreslice, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_LAST: Slice excitation OFF for IR, ON for coreslice, Data acq. ON

 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval slicelooptime Time taken in [us] to play out `slice_plan.nslices_per_pass` slices
********************************************************************************************************/
int ksinv_scan_sliceloop(const KS_SLICE_PLAN *slice_plan, const SCAN_INFO *slice_positions, int passindx, 
                         KSINV_SEQUENCE *ksinv1, KSINV_SEQUENCE *ksinv2, KS_SEQ_CONTROL *ksinv_filltr, KSINV_LOOP_MODE ksinv_loop_mode,
                         int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {
  int time = 0;
  int i, sltimeinpass;
  int slloc, sltime_adjusted;
  const SCAN_INFO *slpos;

  if (ksinv1 == NULL) {
    ks_error("%s: 4th arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (ksinv1->params.irmode == KSINV_OFF) {
    return 0;  /* if the IR mode for the 1st IR is off, return quietly */
  }
  if (slice_plan == NULL) {
    ks_error("%s: 1st arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (slice_positions == NULL) {
    ks_error("%s: 2nd arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }

  if (play_coreslice == NULL) {
    ks_error("%s: 7th arg must be a function pointer to the coreslice function", __FUNCTION__);
    return KS_NOTSET;
  }


  if (ksinv1->params.irmode == KSINV_FLAIR_BLOCK || ksinv1->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
    /* For classic T2-FLAIR, we often end up with 2 sets of FLAIR+core per TR
       Here is a generalization, where number of sets is equal to:
       CEIL_DIV(slice_plan->nslices_per_pass, ksinv1->params.nflairslices), where slice_plan->nslices_per_pass = CEIL_DIV(slice_plan->nslices, slice_plan->npasses)
    */
   
    /* make sure nflairslices > 0, or else we will be stuck here as sltimeinpass will remain at 0 forever */
    if (ksinv1->params.nflairslices <= 0) {
      ks_error("%s: ksinv1.params.nflairslices must be > 0", __FUNCTION__);
      return -1;
    }

    sltimeinpass = 0;

    while (sltimeinpass < slice_plan->nslices_per_pass) {

      /*--------- 1st inversion sequence module as FLAIR block -----------*/
      for (i = 0; i < ksinv1->params.nflairslices; i++) {
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      for (i = 0; (i < ksinv1->params.nflairslices) && (sltimeinpass + i < slice_plan->nslices_per_pass); i++) {

        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;

        if (ksinv2 != NULL) {
          /*--------- optional 2nd inversion sequence module (DIR mode) attached to each coreslice playout -----------*/
          time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
        }

        /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
        time += play_coreslice(
                  slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                  (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : (sltimeinpass + i), /* if KS_NOTSET (-1), shut off data acquisition */
                  core_nargs, core_args);
      }

      sltimeinpass += ksinv1->params.nflairslices;

      if (ksinv_filltr != NULL) {
        /*--------- fillTR sequence module (to fill up to manual TR in CEIL_DIV(nslices_per_pass, ksinv1->params.nflairslices) chunks) -----------*/
        time += ks_scan_playsequence(ksinv_filltr);
        ks_plot_slicetime(ksinv_filltr, 1, NULL, KS_NOTSET, KS_PLOT_NO_EXCITATION); /* Add a filler to slicetime plot */
      }

    } /* while */


  } else {

    int sltime_start = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? (slice_plan->nslices_per_pass - ksinv1->params.nslicesahead) : 0;

    for (sltimeinpass = sltime_start; sltimeinpass < slice_plan->nslices_per_pass; sltimeinpass++) {

      /*--------- 1st inversion sequence module -----------*/
      if (ksinv1->params.irmode == KSINV_IR_SIMPLE || ksinv1->params.irmode == KSINV_IR_SLICEAHEAD)  {
        sltime_adjusted = (sltimeinpass + ksinv1->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;        
        slpos = ((ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_LAST) && (sltime_adjusted < ksinv1->params.nslicesahead)) ? NULL : slpos;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      /*--------- 2nd inversion sequence module -----------*/
      if (ksinv2 != NULL && (ksinv2->params.irmode == KSINV_IR_SIMPLE || ksinv2->params.irmode == KSINV_IR_SLICEAHEAD)) {
        sltime_adjusted = (sltimeinpass + ksinv2->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
      }

      /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
      slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass);
      slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
      slpos = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? NULL : slpos;
      time += play_coreslice(
                slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : sltimeinpass, /* if KS_NOTSET (-1), shut off data acquisition */
                core_nargs,
                core_args);

    } /* slice in pass */

  } /* else (not FLAIR-block) */

  return time;

} /* ksinv_scan_sliceloop() */
 
                         

int ksinv_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  KS_SLICE_PLAN slice_plan = KS_INIT_SLICEPLAN;
  slice_plan.nslices_per_pass = slperpass;
  SCAN_INFO *slice_positions = NULL;
  int passindx = 0;
  KSINV_SEQUENCE *ksinv1 = NULL;
  KSINV_SEQUENCE *ksinv2 = NULL;
  KS_SEQ_CONTROL *ksinv_filltr = NULL;
  KSINV_LOOP_MODE ksinv_loop_mode = KSINV_LOOP_NORMAL;
  int (*play_coreslice)(const SCAN_INFO *, int, int, void **) = 0;
  int core_nargs = 0;
  void **core_args = NULL;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain 7 or 9 elements: slice_positions, passindx, &ksinv1, &ksinv2, &ksinv_filltr, play_as_dummy, play_coreslice [, core_nargs, core_args]", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    slice_positions = (SCAN_INFO *) args[0];
  }
  if (nargs >= 2 && args[1] != NULL) {
    passindx = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    ksinv1 = (KSINV_SEQUENCE *) args[2];
  }
  if (nargs >= 4 && args[3] != NULL) {
    ksinv2 = (KSINV_SEQUENCE *) args[3];
  }
  if (nargs >= 5 && args[4] != NULL) {
    ksinv_filltr = (KS_SEQ_CONTROL *) args[4];
  }
  if (nargs >= 6 && args[5] != NULL) {
    ksinv_loop_mode = *((KSINV_LOOP_MODE *) args[5]);
  }
  if (nargs >= 7 && args[6] != NULL) {
    play_coreslice = (int (*)(const SCAN_INFO *, int, int, void **)) args[6];
  }
  if (nargs >= 8 && args[7] != NULL) {
    core_nargs = *((int *) args[7]);
  }
  if (nargs >= 9 && args[8] != NULL) {
    core_args = (void **) args[8];
  }

  return ksinv_scan_sliceloop(&slice_plan, slice_positions, passindx, ksinv1, ksinv2, ksinv_filltr, ksinv_loop_mode, play_coreslice, core_nargs, core_args); /* in [us] */

} /* ksfse_scan_sliceloop_nargs() */

/******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : ksepi_implementation_diffusion.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydén, Ola Norbeck, Tim Sprenger, Johan Berglund
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file ksepi_implementation_diffusion.e
* @brief This file contains the implementation details for the diffusion part of the *ksepi* psd
********************************************************************************************************/




STATUS ksepi_diffusion_pg(KSEPI_SEQUENCE *ksepi, int TE) {
    KS_SEQLOC tmploc = KS_INIT_SEQLOC;
    int i;

    if (opdiffuse != KS_EPI_DIFFUSION_ON) {
        return SUCCESS;
    }

    /* First diffusion gradient right after the excitation */
    tmploc.ampscale = 1.0;
    tmploc.pos = ksepi->seqctrl.momentstart + ksepi->selrfexc.rf.iso2end + ksepi->selrfexc.grad.ramptime + ksepi->selrfexc.postgrad.duration;



    if (ksepi_reflines>0) {
        tmploc.pos += ksepi->epireftrain.duration;
    }

/*------------------------------------------- */
    /* Selective RF Refocus with left (pregrad.) and right (postgrad.) crushers */
     if (opdualspinecho) {


/* emweber ----- change position of forst gradient to inculde it in the dualspin echo condition -- (before, outside the condition) */
        for (i = XGRAD; i <= ZGRAD; i++) {
        tmploc.board = i;
        if (ks_pg_trap(&ksepi->diffgrad, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;
        }

/* ----------------------------------------*/

        tmploc.board = ZGRAD;
        tmploc.pos = ksepi->seqctrl.momentstart + RUP_GRD(TE/ 4) - ksepi->selrfref.rf.start2iso - ksepi->selrfref.grad.ramptime - ksepi->selrfref.pregrad.duration;
        if (ks_pg_selrf(&ksepi->selrfref, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

        /* opdualspinecho: Second diffusion gradient after the 1st refocusing pulse */
        tmploc.ampscale = -1.0;
        tmploc.pos += ksepi->selrfref.pregrad.duration + ksepi->selrfref.grad.duration + ksepi->selrfref.postgrad.duration;
        for (i = XGRAD; i <= ZGRAD; i++) {
            tmploc.board = i;
            if (ks_pg_trap(&ksepi->diffgrad2, tmploc, &ksepi->seqctrl) == FAILURE)
                return FAILURE;
        }

        /* opdualspinecho: Third diffusion gradient right after the second */
        tmploc.ampscale = 1.0;
        tmploc.pos += ksepi->diffgrad2.duration;
        for (i = XGRAD; i <= ZGRAD; i++) {
            tmploc.board = i;
            if (ks_pg_trap(&ksepi->diffgrad2, tmploc, &ksepi->seqctrl) == FAILURE)
                return FAILURE;
        }

        tmploc.board = ZGRAD;
        tmploc.pos = ksepi->seqctrl.momentstart + RUP_GRD(TE * 3/ 4) - ksepi->selrfref2.rf.start2iso - ksepi->selrfref2.grad.ramptime - ksepi->selrfref2.pregrad.duration;
        if (ks_pg_selrf(&ksepi->selrfref2, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

        /* opdualspinecho: Fourth diffusion gradient after the 2nd refocusing pulse */
        tmploc.ampscale = -1.0;
        tmploc.pos += ksepi->selrfref2.pregrad.duration + ksepi->selrfref2.grad.duration + ksepi->selrfref2.postgrad.duration;
        for (i = XGRAD; i <= ZGRAD; i++) {
            tmploc.board = i;
            if (ks_pg_trap(&ksepi->diffgrad, tmploc, &ksepi->seqctrl) == FAILURE)
                return FAILURE;
        }

    } else if (num_oscillations>0) { /* emmweber -- DDE --- after refocusing pulse */

            
            int optm = opuser51;

            if ((optm<= ksepi->mytrap_1.ramptime) && (optm<= ksepi->mytrap_2.ramptime)){
            printf("Tooshort mixing time, must be at least %i\n", ksepi->mytrap_1.ramptime);
                optm=5000 ;
            }


            for (i = XGRAD; i <= ZGRAD; i++) {
                tmploc.board = i;
                if (ks_pg_trap(&ksepi->mytrap_1, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

            }

            tmploc.ampscale = -1.0;
            tmploc.pos+= ksepi->mytrap_1.duration+2000; /*optm;*/

            for (i = XGRAD; i <= ZGRAD; i++) {
                tmploc.board = i;
                if (ks_pg_trap(&ksepi->mytrap_1, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

            }

            /* refocusing pulse ----------------*/
            tmploc.ampscale = 1.0;
            tmploc.pos = ksepi->seqctrl.momentstart + TE/ 2 - ksepi->selrfref.rf.start2iso - ksepi->selrfref.grad.ramptime - ksepi->selrfref.pregrad.duration;
            if (ks_pg_selrf(&ksepi->selrfref, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

            /* Third diffusion gradient (after the refocusing pulse) */
        
            tmploc.ampscale = 1.0;
            tmploc.pos += ksepi->selrfref.pregrad.duration + ksepi->selrfref.grad.duration + ksepi->selrfref.postgrad.duration;
            


         for (i = XGRAD; i <= ZGRAD; i++) {
            tmploc.board = i;
            if (ks_pg_trap(&ksepi->mytrap_2, tmploc, &ksepi->seqctrl) == FAILURE)
                return FAILURE;
        }

            tmploc.ampscale = -1.0;
            tmploc.pos+=ksepi->mytrap_2.duration+2000;

         for (i = XGRAD; i <= ZGRAD; i++) {
            tmploc.board = i;
            if (ks_pg_trap(&ksepi->mytrap_2, tmploc, &ksepi->seqctrl) == FAILURE)
              
              return FAILURE;
        }
        /*--------------------------------------------------------------*/

    } else{/* tejskal-Tanner diffusion -----------*/


            /* emweber ----- change position of first gradient to inculde it in the dualspin echo condition -- (before, outside the condition) */
            for (i = XGRAD; i <= ZGRAD; i++) {
                tmploc.board = i;
                if (ks_pg_trap(&ksepi->diffgrad, tmploc, &ksepi->seqctrl) == FAILURE)
                    return FAILURE;
            }

/* ----------------------------------------*/


            tmploc.pos = ksepi->seqctrl.momentstart + TE/ 2 - ksepi->selrfref.rf.start2iso - ksepi->selrfref.grad.ramptime - ksepi->selrfref.pregrad.duration;
         if (ks_pg_selrf(&ksepi->selrfref, tmploc, &ksepi->seqctrl) == FAILURE)
            return FAILURE;

            /* Second diffusion gradient after the refocusing pulse */
        
            tmploc.ampscale = 1.0;
            tmploc.pos += 200000;/*ksepi->selrfref.pregrad.duration + ksepi->selrfref.grad.duration + ksepi->selrfref.postgrad.duration;*/
        
            for (i = XGRAD; i <= ZGRAD; i++) {
                tmploc.board = i;
                if (ks_pg_trap(&ksepi->diffgrad, tmploc, &ksepi->seqctrl) == FAILURE)
                return FAILURE;
        }


    }


    return SUCCESS;
}


void ksepi_diffusion_scan_diffamp(KSEPI_SEQUENCE *ksepi, int volindx) {
    int i;

    if (opdiffuse != KS_EPI_DIFFUSION_ON) {
        return;
    }

    /*
       d: ksepi.diffgrad
      d2: ksepi.diffgrad2 (opdualspinecho only)
    #<x>: instance number <x>

    opdualspinecho = TRUE (Twice-refocused):
    ========================================

             _d#0__                  ____d2#3___
    XGRAD __/      \___             /           \___        ___
                       \___d2#0____/                \__d#3_/
             _d#1__                  ____d2#4___
    YGRAD __/      \___             /           \___        ___
                       \___d2#2____/                \__d#4_/
             _d#2__                  ____d2#5___
    ZGRAD __/      \___             /           \___        ___
                       \___d2#3____/                \__d#5_/


    opdualspinecho = FALSE (Stejskal-Tanner):
    =========================================

             _d#0__     _d#3__
    XGRAD __/      \___/      \___
             _d#1__     _d#4__
    YGRAD __/      \___/      \___
             _d#2__     _d#5__
    ZGRAD __/      \___/      \___

    */


    for (i = XGRAD; i <= ZGRAD; i++) {
        
        if (opdualspinecho) {

            /*emmweber --- added in the condition*/
            float amp = (volindx >= 0) ? diffscheme[i][volindx] : 0; /* 0 if volindx < 0 */
            ks_scan_trap_ampscale_slice(&ksepi->diffgrad, i, 3, 2, amp);
            /*------*/
            ks_scan_trap_ampscale_slice(&ksepi->diffgrad2, i, 3, 2, amp);

        }
        /*emmweber -------- DDE*/
        else if (num_oscillations>0) {

            
            
            float amp1 = (volindx >= 0) ? diffscheme[i][volindx] : 0; /* 0 if volindx < 0 */
            float amp2 = (volindx >= 0) ? diffscheme_2[i][volindx] : 0; /* 0 if volindx < 0 */
            printf("am1=%f\n",amp1 );

           /* ks_scan_trap_ampscale (&ksepi->mytrap_2,i,amp2) ;*/


            ks_scan_trap_ampscale_slice(&ksepi->mytrap_1, i, 3, 2, amp1);
            ks_scan_trap_ampscale_slice(&ksepi->mytrap_2, i, 3, 2, amp2);

        }
        else{
            /*emmweber --- added in the condition*/
            float amp = (volindx >= 0) ? diffscheme[i][volindx] : 0; /* 0 if volindx < 0 */
            ks_scan_trap_ampscale_slice(&ksepi->diffgrad, i, 3, 2, amp);
        }
    }


}




/******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : ksepi_implementation.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydén, Ola Norbeck, Tim Sprenger, Johan Berglund
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file ksepi_implementation.e
* @brief This file contains the implementation details for the *ksepi* psd
********************************************************************************************************/


/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksepi_implementation.e: PULSEGEN - builing of the sequence from the sequence objects
 *
 *  HOST: Called in cveval() to dry-run the sequence to determine timings
 *  TGT:  Waveforms are being written to hardware and necessary memory automatically alloacted
 *
 *******************************************************************************************************
 *******************************************************************************************************/





/**
 *******************************************************************************************************
 @brief #### The ksepi (main) pulse sequence

 This is the main pulse sequence in ksepi.e using the sequence objects in KSEPI_SEQUENCE with
 the sequence module name "ksepimain" (= ksepi.seqctrl.description)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksepi_pg(int start_time) {
  KS_SEQLOC tmploc = KS_INIT_SEQLOC;
  int epi_startpos = KS_NOTSET;
  int fc_startpos = KS_NOTSET;
  int fcz_endpos = KS_NOTSET;
  int echo, board;

  if (start_time < KS_RFSSP_PRETIME) {
    return ks_error("%s: 1st arg (pos start) must be at least %d us", __FUNCTION__, KS_RFSSP_PRETIME);
  }

#ifdef HOST_TGT
  if (opte < avminte) {
    /* we cannot proceed until TE is in range.
       Return a long seq duration and pretend all is good */
    ks_eval_seqctrl_setminduration(&ksepi.seqctrl, 1000000);
    return SUCCESS;
  }
#endif


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;
  tmploc.pos = RUP_GRD(start_time + KS_RFSSP_PRETIME);
  tmploc.board = ZGRAD;

  /* N.B.: ks_pg_selrf()->ks_pg_rf() detects that ksepi.selrfexc is an excitation pulse
     (ksepi.selrfexc.rf.role = KS_RF_ROLE_EXC) and will also set ksepi.seqctrl.momentstart
     to the absolute position in [us] of the isocenter of the RF excitation pulse */
  if (ks_pg_selrf(&ksepi.selrfexc, tmploc, &ksepi.seqctrl) == FAILURE)
    return FAILURE;

  /* forward to end of selrfexc.postgrad (works for when slice sel gradient is KS_TRAP or KS_WAVE as only
     one of them can have non-zero duration at a given time) */
  tmploc.pos += ksepi.selrfexc.pregrad.duration + ksepi.selrfexc.grad.duration + ksepi.selrfexc.gradwave.duration + ksepi.selrfexc.postgrad.duration;
  
  /* Second flow comp gradient slice for slice excitation */
  if (ks_pg_trap(&ksepi.fcompslice, tmploc, &ksepi.seqctrl) == FAILURE) /* N.B.: will return quietly if ksepi.fcompslice.duration = 0 (opfcomp = 0) */
    return FAILURE;
  fcz_endpos = tmploc.pos + ksepi.fcompslice.duration;

  /*******************************************************************************************************
  *  EPI phase reference lines
  *******************************************************************************************************/
  tmploc.board = KS_FREQX_PHASEY;
  tmploc.pos = ksepi.seqctrl.momentstart + ksepi.selrfexc.rf.iso2end + ksepi.selrfexc.grad.ramptime + ksepi.selrfexc.postgrad.duration;
  tmploc.ampscale = ksepi_readsign;
  if (ks_pg_epi(&ksepi.epireftrain, tmploc, &ksepi.seqctrl) == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
  *  EPI trains: Begin   (> 1 only supported with offline recon)
  -------------------------------------------------------------------------------------------------------*/
  for (echo = 0; echo < opnecho; echo++) {

    if (acq_type == TYPSPIN) {
      if (opdiffuse == KS_EPI_DIFFUSION_ON && echo == 0) {
        if (ksepi_diffusion_pg(&ksepi, opte) == FAILURE)
          return FAILURE;
      } else {
        if (echo == 0) /* RF refocusing pulse for 1st EPI train at TE/2 */
          tmploc.pos = ksepi.seqctrl.momentstart + opte/ 2 - ksepi.selrfref.rf.start2iso - ksepi.selrfref.grad.ramptime - ksepi.selrfref.pregrad.duration;
        else /* RF refocusing pulse between two EPI trains (2nd-Nth EPI train are played out as tight as possible when ksepi_echogap = 0). Use epi_startpos from previous echo index (see below) */
          tmploc.pos = epi_startpos + ksepi.epitrain.duration + KS_RFSSP_PRETIME + ksepi_echogap/ 2;
        tmploc.board = ZGRAD;
        if (ks_pg_selrf(&ksepi.selrfref, tmploc, &ksepi.seqctrl) == FAILURE)
          return FAILURE;
      }
    } /* acq_type == TYPSPIN */

    /*******************************************************************************************************
    *  EPI readout including de/rephasers on freq, phase and slice encoding axes (net zero moment on both axes)
    *******************************************************************************************************/
    tmploc.board = (ksepi_slicecheck) ? KS_FREQZ_PHASEY : KS_FREQX_PHASEY;
    epi_startpos = ksepi.seqctrl.momentstart + opte - ksepi.epitrain.time2center + (echo * ksepi_interechotime);
    tmploc.pos = epi_startpos;
    tmploc.ampscale = ksepi_readsign;
    if (ks_pg_epi(&ksepi.epitrain, tmploc, &ksepi.seqctrl) == FAILURE)
      return FAILURE;

    /* Two extra dephasers for flowcomp on phase */
    tmploc.board = YGRAD;
    tmploc.pos = epi_startpos + IMax(3, ksepi.epitrain.readphaser.duration, ksepi.epitrain.blipphaser.grad.duration, ksepi.epitrain.zphaser.grad.duration); /* after all dephasers */

    tmploc.pos -= ksepi.epitrain.blipphaser.grad.duration + 2 * ksepi.fcompphase.duration;
    fc_startpos = tmploc.pos;
    tmploc.ampscale = 1;
    if (ks_pg_trap(&ksepi.fcompphase, tmploc, &ksepi.seqctrl) == FAILURE) /* instance #0. N.B.: will return quietly if ksepi.fcompphase.duration = 0 */
      return FAILURE;

    tmploc.pos += ksepi.fcompphase.duration;
    tmploc.ampscale = -1;
    if (ks_pg_trap(&ksepi.fcompphase, tmploc, &ksepi.seqctrl) == FAILURE) /* instance #1 */
      return FAILURE;

    /*******************************************************************************************************
    *  EPI echo time shifting
    *******************************************************************************************************/
    if (ksepi_echotime_shifting == TRUE && echo == 0) {
      for (board = XGRAD; board <= SSP; board++) {
        tmploc.board = board;
        if (oppseq == PSD_SE) {
          /* 2D: SE-EPI or DW-EPI */
           tmploc.pos = epi_startpos - GRAD_UPDATE_TIME;
        } else {
          /* 2D/3D: GE-EPI
           For XGRAD and YGRAD, place wait pulse just before dephasers (incl flowcomp if present), the smallest of epi_startpos and fc_startpos
           For the other boards, place wait pulse after last slice rephaser (incl slice flowcomp if present) */
           tmploc.pos = (board <= YGRAD) ? (IMin(2, epi_startpos, fc_startpos) - GRAD_UPDATE_TIME) : (fcz_endpos + GRAD_UPDATE_TIME + KS_RFSSP_POSTTIME);
        }
        if (ks_pg_wait(&ksepi.pre_delay, tmploc, &ksepi.seqctrl) != SUCCESS) {
          return FAILURE;
        }
      }
    }


  }
  /*------------------------------------------------------------------------------------------------------
   *  EPI trains: End
   *******************************************************************************************************/

  /*******************************************************************************************************
   *  Gradient spoilers on Y and Z (at the same time)
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;
  tmploc.pos = epi_startpos + ksepi.epitrain.duration;
  tmploc.board = YGRAD;
  if (ks_pg_trap(&ksepi.spoiler, tmploc, &ksepi.seqctrl) == FAILURE)
    return FAILURE;
  tmploc.board = ZGRAD;
  if (ks_pg_trap(&ksepi.spoiler, tmploc, &ksepi.seqctrl) == FAILURE)
    return FAILURE;

  tmploc.pos += ksepi.spoiler.duration;

  /*******************************************************************************************************
  *  EPI echo time shifting (post EPI readouts)
  *******************************************************************************************************/
  if (ksepi_echotime_shifting == TRUE) {
    tmploc.pos += GRAD_UPDATE_TIME;
    tmploc.board = KS_ALL;
    if (ks_pg_wait(&ksepi.post_delay, tmploc, &ksepi.seqctrl) != SUCCESS) {
      return FAILURE;
    }
    tmploc.pos += IMax(2, psd_grd_wait, psd_rf_wait) + GRAD_UPDATE_TIME;
    tmploc.pos += ksepi_echotime_shifting_sumdelay;
  }

  /*******************************************************************************************************
   *  Set the minimal sequence duration (ksepi.seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  tmploc.pos = RUP_GRD(tmploc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence duration (ksepi.seqctrl.ssi_time must be > 0 and is added to ksepi.seqctrl.min_duration in ks_eval_seqctrl_setminduration() */
  ksepi.seqctrl.ssi_time = ksepi_eval_ssitime();
  ks_eval_seqctrl_setminduration(&ksepi.seqctrl, tmploc.pos); /* tmploc.pos now corresponds to the end of last gradient in the sequence */
#endif

  /*******************************************************************************************************
   * Phase encoding table
   *
   * Need to call this in ksepi_pg() so it is run both on HOST and TGT. This, since the phase table
   * is dynamically allocated in ks_phaseencoding_generate_epi()->ks_phaseencoding_resize()
   *******************************************************************************************************/
  if (ks_phaseencoding_generate_epi(&ksepi.full_peplan, "Fully sampled EPI volume",
                                      &ksepi.epitrain, 
                                      ksepi_blipsign, 
                                      ksepi.epitrain.blipphaser.R, 
                                      ksepi.epitrain.zphaser.numlinestoacq, 
                                      ksepi_caipi) == FAILURE) {
    return FAILURE;
  }
  if (ks_phaseencoding_generate_epi(&ksepi.ref_peplan, "EPI reference volume",
                                      &ksepi.epitrain, 
                                      ksepi_blipsign, 
                                      ksepi.epitrain.blipphaser.R, 
                                      ksepi_ref_nsegments,
                                      ksepi_caipi) == FAILURE) {
    return FAILURE;
  }
  if (ks_phaseencoding_generate_epi(&ksepi.peplan, "Accelerated EPI volume",
                                      &ksepi.epitrain,
                                      ksepi_blipsign, 
                                      ksepi.epitrain.blipphaser.R/ ksepi_ky_R,
                                      ksepi.epitrain.zphaser.numlinestoacq,
                                      ksepi_caipi) == FAILURE) {
    return FAILURE;
  }

  ksepi.current_peplan = &ksepi.full_peplan;

  /* KS_NOTSET -> turns off phase blips for phase reference lines */
  ks_scan_epi_shotcontrol(&ksepi.epireftrain, 0, ks_scan_info[0], NULL, KS_NOTSET, 0);

  /* set EPI dephasers and blips to the first shot so we get the correct plots in WTools */
  ks_scan_epi_shotcontrol(&ksepi.epitrain, 0, ks_scan_info[0], &ksepi.full_peplan, 0, 0);

  return SUCCESS;

} /* ksepi_pg() */


/**
 *******************************************************************************************************
 @brief #### The fleet pulse sequence for GRAPPA calibration

 This is the fleet pulse sequence in ksepi.e using the sequence objects in KSEPI_FLEET_SEQUENCE with
 the sequence module name "ksepifleet" (= ksepi_fleet.seqctrl.description)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksepi_pg_fleet(int start_time) {
  KS_SEQLOC tmploc = KS_INIT_SEQLOC;

  if (ksepi_fleet == FALSE) {
    return SUCCESS;
  }

  if (start_time < KS_RFSSP_PRETIME) {
    return ks_error("%s: 1st arg (pos start) must be at least %d us", __FUNCTION__, KS_RFSSP_PRETIME);
  }

  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;
  tmploc.pos = RUP_GRD(start_time + KS_RFSSP_PRETIME);
  tmploc.board = ZGRAD;

  /* N.B.: ks_pg_selrf()->ks_pg_rf() detects that ksepi_fleetseq.selrfexc is an excitation pulse
     (ksepi_fleetseq.selrfexc.rf.role = KS_RF_ROLE_EXC) and will also set ksepi_fleetseq.seqctrl.momentstart
     to the absolute position in [us] of the isocenter of the RF excitation pulse */
  if (ks_pg_selrf(&ksepi_fleetseq.selrfexc, tmploc, &ksepi_fleetseq.seqctrl) == FAILURE)
    return FAILURE;

  tmploc.pos = ksepi_fleetseq.seqctrl.momentstart;
  tmploc.pos += KS_RFSSP_POSTTIME + ksepi_fleetseq.selrfexc.rf.iso2end + ksepi_fleetseq.selrfexc.grad.ramptime + ksepi_fleetseq.selrfexc.postgrad.duration;

  /*******************************************************************************************************
  *  EPI echo time shifting
  *******************************************************************************************************/
  if (ksepi_echotime_shifting == TRUE) {
    tmploc.board = KS_ALL;
    if (ks_pg_wait(&ksepi_fleetseq.pre_delay, tmploc, &ksepi_fleetseq.seqctrl) != SUCCESS) {
      return FAILURE;
    }
    tmploc.pos += GRAD_UPDATE_TIME;
  }

  /*******************************************************************************************************
  *  EPI readout including de/rephasers on freq and phase encoding axes (net zero moment on both axes)
  *******************************************************************************************************/

  if (ksepi_slicecheck)
    tmploc.board = KS_FREQZ_PHASEY;
  else
    tmploc.board = KS_FREQX_PHASEY;
  tmploc.ampscale = ksepi_readsign;
  if (ks_pg_epi(&ksepi_fleetseq.epitrain, tmploc, &ksepi_fleetseq.seqctrl) == FAILURE) {
    return FAILURE;
  }
  tmploc.pos += ksepi_fleetseq.epitrain.duration; /* end of EPI (incl. x/y rephasers, but not zphaser) */

  /*******************************************************************************************************
   *  Gradient spoilers on Y and Z (at the same time)
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;

  tmploc.board = YGRAD;
  if (ks_pg_trap(&ksepi_fleetseq.spoiler, tmploc, &ksepi_fleetseq.seqctrl) == FAILURE)
    return FAILURE;
  tmploc.board = ZGRAD;
  if (ks_pg_trap(&ksepi_fleetseq.spoiler, tmploc, &ksepi_fleetseq.seqctrl) == FAILURE)
    return FAILURE;

  tmploc.pos += ksepi_fleetseq.spoiler.duration;

  /*******************************************************************************************************
  *  EPI echo time shifting
  *******************************************************************************************************/
  if (ksepi_echotime_shifting == TRUE) {
    tmploc.pos += GRAD_UPDATE_TIME;
    tmploc.board = KS_ALL;
    if (ks_pg_wait(&ksepi_fleetseq.post_delay, tmploc, &ksepi.seqctrl) != SUCCESS) {
      return FAILURE;
    }
    tmploc.pos += IMax(2, psd_grd_wait, psd_rf_wait) + GRAD_UPDATE_TIME;
    tmploc.pos += ksepi_echotime_shifting_sumdelay;
  }

  /*******************************************************************************************************
   *  Set the minimal sequence duration (ksepi.seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  tmploc.pos = RUP_GRD(tmploc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence duration (ksepi_fleetseq.seqctrl.ssi_time must be > 0 and is added to ksepi_fleetseq.seqctrl.min_duration in ks_eval_seqctrl_setminduration() */
  ksepi_fleetseq.seqctrl.ssi_time = ksepi_eval_ssitime();
  ks_eval_seqctrl_setminduration(&ksepi_fleetseq.seqctrl, tmploc.pos); /* tmploc.pos now corresponds to the end of last gradient in the sequence */
#endif

  /*******************************************************************************************************
   * Phase encoding table
   * Need to call this in ksepi_pg_fleet() so it is run both on HOST and TGT. This, since the phase table
   * is dynamically allocated in ks_phaseencoding_generate_epi()->ks_phaseencoding_resize()
   *******************************************************************************************************/

  if (ks_phaseencoding_generate_epi(&ksepi_fleetseq.peplan, "Fully sampled EPI volume",
                                    &ksepi_fleetseq.epitrain,
                                    ksepi_blipsign, 
                                    ksepi_fleetseq.epitrain.blipphaser.R, 
                                    ksepi_fleetseq.epitrain.zphaser.numlinestoacq,
                                    ksepi_caipi) == FAILURE) {
    return FAILURE;
  }

  /* set EPI dephasers and blips to the first shot so we get the correct plots in WTools */
  ks_scan_epi_shotcontrol(&ksepi_fleetseq.epitrain, 0, ks_scan_info[0], &ksepi_fleetseq.peplan, 0, 0);

  return SUCCESS;

} /* ksepi_pg_fleet() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksepi sequence objects being part of KSEPI_SEQUENCE

 This function sets the current state of all ksepi sequence objects being part of KSEPI_SEQUENCE, incl.
 gradient amplitude changes, RF freq/phases and receive freq/phase based on current slice position and
 phase encoding indices.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] slice_info Position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @param[in] shot Linear ky kz `shot` index in range `[0, (ksepi.peplan.num_shots-1)]`
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksepi_scan_seqstate(SCAN_INFO slice_info, int shot) {
  int echo;
  int exc_rfphase;

  /* RF frequency & phase */
  if (ksepi_rfspoiling) {
    exc_rfphase = ks_scan_rf_phase_spoiling(rfspoiling_phase_counter);
    rfspoiling_phase_counter++;
  } else {
    exc_rfphase = 0;
  }


  ks_scan_rotate(slice_info);

  ks_scan_rf_on(&ksepi.selrfexc.rf, INSTRALL);
  ks_scan_rf_on(&ksepi.selrfref.rf, INSTRALL);

  ks_scan_selrf_setfreqphase(&ksepi.selrfexc, 0,        slice_info, exc_rfphase);
  ks_scan_selrf_setfreqphase(&ksepi.selrfref, INSTRALL, slice_info, exc_rfphase+90);

  if (opdiffuse == KS_EPI_DIFFUSION_ON && opdualspinecho) {
    ks_scan_rf_on(&ksepi.selrfref2.rf, 0);
    ks_scan_selrf_setfreqphase(&ksepi.selrfref2, 0, slice_info, exc_rfphase+90);
  }

  /* EPI echoes (i.e. EPI trains) */
  for (echo = 0; echo < opnecho; echo++) {
    ks_scan_epi_shotcontrol(&ksepi.epitrain, echo, slice_info, ksepi.current_peplan, shot, exc_rfphase);
  } /* opnecho */
  ks_scan_epi_shotcontrol(&ksepi.epireftrain, 0, slice_info, NULL, KS_NOTSET, exc_rfphase);

  return SUCCESS;

} /* ksepi_scan_seqstate() */


STATUS ksepi_fleet_scan_seqstate(const SCAN_INFO *slice_info, int shot) {
  int exc_rfphase;

  /* RF frequency & phase */
  if (ksepi_rfspoiling) {
    exc_rfphase = ks_scan_rf_phase_spoiling(rfspoiling_phase_counter);
    rfspoiling_phase_counter++;
  } else {
    exc_rfphase = 0;
  }

  if (slice_info != NULL) {
    ks_scan_rotate(*slice_info);
    ks_scan_rf_on(&ksepi_fleetseq.selrfexc.rf, INSTRALL);
    ks_scan_selrf_setfreqphase(&ksepi_fleetseq.selrfexc, 0, *slice_info, exc_rfphase);
    ks_scan_epi_shotcontrol(&ksepi_fleetseq.epitrain, 0, *slice_info, &ksepi_fleetseq.peplan, shot, exc_rfphase);
  } else {
    ks_scan_rf_off(&ksepi_fleetseq.selrfexc.rf, INSTRALL);
  }

  return SUCCESS;
} /* ksepi_fleet_scan_seqstate() */


/**
 *******************************************************************************************************
 @brief #### Sets all RF pulse amplitudes to zero

 @return void
********************************************************************************************************/
void ksepi_scan_rf_off() {
  ks_scan_rf_off(&ksepi.selrfexc.rf, INSTRALL);
  ks_scan_rf_off(&ksepi.selrfref.rf, INSTRALL);

  if (opdiffuse == KS_EPI_DIFFUSION_ON && opdualspinecho) {
    ks_scan_rf_off(&ksepi.selrfref2.rf, INSTRALL);
  }
}




/**
 *******************************************************************************************************
 @brief #### Plays out one slice in real time during scanning together with other active sequence modules

  On TGT on the MR system (PSD_HW), this function sets up (ksepi_scan_seqstate()) and plays out the
  core ksepi sequence with optional sequence modules also called in this function. The low-level
  function call `startseq()`, which actually starts the realtime sequence playout is called from within
  ks_scan_playsequence(), which in addition also returns the time to play out that sequence module (see
  time += ...).

  On HOST (in ksepi_eval_tr()) we call ksepi_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksepi_scan_scantime(), which returns the total time of the
  entire scan.

  After each call to ks_scan_playsequence(), ks_plot_slicetime() is called to add slice-timing
  information on file for later PDF-generation of the sequence. As scanning is performed in real-time
  and may fail if interrupted, ks_plot_slicetime() will return quietly if it detects both IPG (TGT)
  and PSD_HW (on the MR scanner). See predownload() for the PNG/PDF generation.

  @param[in] slice_pos Position of the slice to be played out (one element in the global
                      `ks_scan_info[]` array)
  @param[in] dabslice  0-based slice index for data storage
  @param[in] shot Linear ky kz `shot` index in range `[0, (ksepi.peplan.num_shots-1)]`
  @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksepi_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, /* psd specific: */ int shot) {
  int echo;
  int time = 0;
  float tloc = 0.0;
  SCAN_INFO slice_pos_updated;
  KS_MAT4x4 Mphysical = KS_MAT4x4_IDENTITY;
  const KS_MAT4x4 Identity = KS_MAT4x4_IDENTITY;

  if (slice_pos != NULL)
    tloc = slice_pos->optloc;

  /*******************************************************************************************************
  * Update slice info
  *******************************************************************************************************/
  if (slice_pos != NULL) {
    ks_scan_update_slice_location(&slice_pos_updated, *slice_pos, Mphysical, Identity);
  }

  /*******************************************************************************************************
  * SpSat sequence module
  *******************************************************************************************************/
  time += ksspsat_scan_playsequences(ks_perform_slicetimeplot);


  /*******************************************************************************************************
  * Chemsat sequence module
  *******************************************************************************************************/
  kschemsat_scan_seqstate(&kschemsat);
  time += ks_scan_playsequence(&kschemsat.seqctrl);
  ks_plot_slicetime(&kschemsat.seqctrl, 1, NULL, KS_NOTSET, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD); /* no slice location for fat sat */


  /*******************************************************************************************************
  * ksepi main sequence module
  *******************************************************************************************************/
  if (slice_pos != NULL) {
    /* modify sequence for next playout. If not entry point scan (e.g. L_REF), use no ky phase encodes */
    ksepi_scan_seqstate(slice_pos_updated, (rspent == L_SCAN) ? shot : KS_NOTSET);
  } else {
    /* false slice, shut off RF */
    ksepi_scan_rf_off();
  }

  /* data routing control */
  KS_PHASEENCODING_COORD coord = ks_phaseencoding_get(ksepi.current_peplan, 0, shot); /* coord to first line of EPI train */
  if (KS_3D_SELECTED) {
    if (ks_scan_info[1].optloc > ks_scan_info[0].optloc)
      dabslice = (opslquant * opvquant - 1) - coord.kz;
    else
      dabslice = coord.kz;
  }
  for (echo = 0; echo < opnecho; echo++) {
    ks_scan_epi_loadecho(&ksepi.epitrain, echo, echo, dabslice, ksepi.current_peplan, shot);
  }
  if (ksepi_reflines > 0) {
    /* store phase reference lines as opnecho:th echo */
    ks_scan_epi_loadecho(&ksepi.epireftrain, 0, opnecho, dabslice, ksepi.current_peplan, shot);
  }

  time += ks_scan_playsequence(&ksepi.seqctrl);
  ks_plot_slicetime(&ksepi.seqctrl, 1, &tloc, opslthick, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

  return time; /* in [us] */

} /* ksepi_scan_coreslice() */


/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksepi_scan_coreslice() with standardized input arguments

 KSInversion.e has functions (ksinv_eval_multislice(), ksinv_eval_checkTR_SAR() and
 ksinv_scan_sliceloop()) that expect a standardized function pointer to the coreslice function of a main
 sequence. When inversion mode is enabled for the sequence, ksinv_scan_sliceloop() is used instead of
 ksepi_scan_sliceloop() in ksepi_scan_acqloop(), and the generic ksinv_scan_sliceloop() function need a
 handle to the coreslice function of the main sequence.

 In order for these `ksinv_***` functions to work for any pulse sequence they need a standardized
 function pointer with a fixed set of input arguments. As different pulse sequences may need different
 number of input arguments (with different meaning) this ksepi_scan_coreslice_nargs() wrapper function
 provides the argument translation for ksepi_scan_coreslice().

 The function pointer must have SCAN_INFO and slice storage index (dabslice) as the first two input
 args, while remaining input arguments (to ksepi_scan_coreslice()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksepi_scan_coreslice().

 @param[in] slice_pos Pointer to the SCAN_INFO struct corresponding to the current slice to be played out
 @param[in] dabslice  0-based slice index for data storage
 @param[in] nargs Number of extra input arguments to ksepi_scan_coreslice() in range [0,2]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksepi_scan_coreslice()
 @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksepi_scan_coreslice_nargs(const SCAN_INFO *slice_pos, int dabslice, int nargs, void **args) {
  int shot = 0;

  if (nargs < 0 || nargs > 1) {
    ks_error("%s: 4th arg (void **) must contain 0-1 elements (shot), not %d", __FUNCTION__, nargs);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 4th arg (void **) cannot be NULL if nargs (3rd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    shot = *((int *) args[0]);
  }

  return ksepi_scan_coreslice(slice_pos, dabslice, shot); /* in [us] */

} /* ksepi_scan_coreslice_args() */


int ksepi_fleet_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, int shot) {
  int time = 0;
  float tloc = 0.0;

  if (ksepi_fleetseq.seqctrl.duration == 0) {
    return 0;
  }

  if (slice_pos != NULL)
    tloc = slice_pos->optloc; /* real slice */
  else
    dabslice = KS_NOTSET; /* shut off data acq if false slice */

  ksepi_fleet_scan_seqstate(slice_pos, (rspent == L_SCAN) ? shot  : KS_NOTSET);
  KS_PHASEENCODING_COORD coord = ks_phaseencoding_get(&ksepi_fleetseq.peplan, 0, shot); /* coord to first line of EPI train */
  if (KS_3D_SELECTED) {
    if (ks_scan_info[1].optloc > ks_scan_info[0].optloc)
      dabslice = (opslquant * opvquant - 1) - coord.kz;
    else
      dabslice = coord.kz;
  }
  ks_scan_epi_loadecho(&ksepi_fleetseq.epitrain, 0, 0, dabslice, &ksepi_fleetseq.peplan, shot);
  time += ks_scan_playsequence(&ksepi_fleetseq.seqctrl);
  ks_plot_slicetime(&ksepi_fleetseq.seqctrl, 1, &tloc, ksepi_fleetseq.selrfexc.slthick,
                    slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

  return time; /* in [us] */

} /* ksepi_fleet_scan_coreslice() */


/**
 *******************************************************************************************************
 @brief #### Plays out `slperpass` slices corresponding to one TR

 This function gets a spatial slice location index based on the pass index and temporal position within
 current pass. It then calls ksepi_scan_coreslice() to play out one coreslice (i.e. the main ksepi main
 sequence + optional sequence modules, excluding inversion modules).

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] volindx  Volume index in range `[0, opfphases - 1]`
 @param[in] passindx  Pass index in range `[0, ks_slice_plan.npasses - 1]`
 @param[in] shot Linear ky kz `shot` index in range `[0, (ksepi.peplan.num_shots-1)]`
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksepi_scan_sliceloop(int slperpass, int volindx, int passindx, int shot) {
  int time = 0;
  int slloc, sltimeinpass;
  SCAN_INFO centerposition = ks_scan_info[0]; /* first slice chosen here, need only rotation stuff */

  (void) volindx;

  if (KS_3D_SELECTED) {
    int centerslice = opslquant/2;
    /* for future 3D multislab support, let passindx update centerposition */
    centerposition.optloc = (ks_scan_info[centerslice-1].optloc + ks_scan_info[centerslice].optloc)/2.0;
  }


  for (sltimeinpass = 0; sltimeinpass < slperpass; sltimeinpass++) {

    SCAN_INFO *current_slice = &centerposition;
    if (!KS_3D_SELECTED) {
      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, passindx, sltimeinpass);
      current_slice = (slloc != KS_NOTSET) ? &ks_scan_info[slloc] : NULL;
    }
    time += ksepi_scan_coreslice(current_slice, sltimeinpass, shot);

  }

  return time; /* in [us] */

} /* ksepi_scan_sliceloop() */


/* FLEET sliceloop plays all shots sequentially */
int ksepi_fleet_scan_sliceloop(int slperpass, int volindx, int passindx) {
  int time = 0;
  int slloc, sltimeinpass, shot;
  SCAN_INFO centerposition = ks_scan_info[0]; /* first slice chosen here, need only rotation stuff */

  (void) volindx;

  if (KS_3D_SELECTED) {
    int centerslice = opslquant/2;
    /* for future 3D multislab support, let passindx update centerposition */
    centerposition.optloc = (ks_scan_info[centerslice-1].optloc + ks_scan_info[centerslice].optloc)/2.0;
  }

  for (sltimeinpass = 0; sltimeinpass < slperpass; sltimeinpass++) {

    SCAN_INFO *current_slice = &centerposition;
    if (!KS_3D_SELECTED) {
      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, passindx, sltimeinpass);
      current_slice = (slloc != KS_NOTSET) ? &ks_scan_info[slloc] : NULL;
    }

    for (shot = -ksepi_fleet_dda; shot < ksepi_fleetseq.peplan.num_shots; shot++) {

      if (ksepi_echotime_shifting == TRUE) {
        KS_PHASEENCODING_COORD coord = ks_phaseencoding_get(&ksepi_fleetseq.peplan, 0, shot); /* coord to first line of EPI train */
        const int kyshot = coord.ky % ksepi_fleetseq.peplan.phaser->R;

        ks_enum_epiblipsign blipsign = ks_scan_epi_verify_phaseenc_plan(&ksepi_fleetseq.epitrain, &ksepi_fleetseq.peplan, shot);
        int post_delay = 0;

        if (blipsign == KS_EPI_POSBLIPS) {
         post_delay = (kyshot <= 0) ? GRAD_UPDATE_TIME : RUP_GRD((int) (ksepi_echotime_shifting_shotdelay * kyshot));
        } else if (blipsign == KS_EPI_NEGBLIPS) {
         post_delay = (kyshot <= 0) ? GRAD_UPDATE_TIME : RUP_GRD((int) (ksepi_echotime_shifting_shotdelay * (ksepi_fleetseq.peplan.phaser->R-1-kyshot)));
        }

        ks_scan_wait(&ksepi.pre_delay, ksepi_echotime_shifting_sumdelay - post_delay);
        ks_scan_wait(&ksepi.post_delay, post_delay);
      }

      time += ksepi_fleet_scan_coreslice(current_slice, (shot >= 0) ? sltimeinpass : KS_NOTSET, (shot >= 0) ? shot : KS_NOTSET);

    }
    ks_plot_slicetime_endofslicegroup(ksepi_fleet_dda > 0 ? "FLEET shots (incl dummies)" : "FLEET shots");
  }

  ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_CALIBRATION);

  return time;

}


/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksepi_scan_sliceloop() with standardized input arguments

 For TR timing heat/SAR calculations of regular 2D multislice sequences, GEReq_eval_TR(),
 ks_eval_mintr() and GEReq_eval_checkTR_SAR() use a standardized function pointer with a fixed set of
 input arguments to call the sliceloop of the main sequence with different number of slices to check
 current slice loop duration. As different pulse sequences may need different number of input arguments
 (with different meaning) this ksepi_scan_sliceloop_nargs() wrapper function provides the argument
 translation for ksepi_scan_sliceloop().

 The function pointer must have an integer corresponding to the number of slices to use as its first
 argument while the remaining input arguments (to ksepi_scan_sliceloop()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksepi_scan_sliceloop().

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] nargs Number of extra input arguments to ksepi_scan_sliceloop() in range [0,3]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksepi_scan_sliceloop()
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksepi_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  int volindx = 0;
  int passindx = 0;
  int shot = KS_NOTSET; /* off */

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain up to 3 elements: volindx, passindx, shot. Not %d", __FUNCTION__, nargs);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    volindx = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    passindx = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    shot = *((int *) args[2]);
  }

  return ksepi_scan_sliceloop(slperpass, volindx, passindx, shot); /* in [us] */

} /* ksepi_scan_sliceloop_nargs() */





/**
 *******************************************************************************************************
 @brief #### Plays out all phase encodes for all slices belonging to one pass

 This function traverses through all shots (`ksepi_numshots`) to be played out and runs the
 ksepi_scan_sliceloop() for each set of shots and excitation. If ksepi_dda > 0, dummy scans
 will be played out before the phase encoding begins.

 In the case of inversion, ksinv_scan_sliceloop() is called instead of ksepi_scan_sliceloop(), where
 the former takes a function pointer to ksepi_scan_coreslice_nargs() in order to be able to play out
 the coreslice in a timing scheme set by ksinv_scan_sliceloop().

 @param[in] passindx  0-based pass index in range `[0, ks_slice_plan.npasses - 1]`
 @param[in] volindx  0-based image volume index in range `[0, opfphases - 1]`
 @param[in] multishotflag ksepi.epitrain.blipphaser.R is used as...
                          0: Parallel imaging factor
                          1: Multi-shot (all volumes, KSEPI_MULTISHOT_ON)
                          2: Multi-shot (multishot vol 1 (volindx=0), PI for vols 2-N, KSEPI_MULTISHOT_ON_VOL1)
                          3: Multi-shot (multishot for b0 volumes), PI for diffusion volumes (only when opdiffuse > 0)
 @retval passlooptime Time taken in [us] to play out all phase encodes and excitations for `slperpass`
                      slices. Note that the value is a `float` instead of `int` to avoid int overrange
                      at 38 mins of scanning
********************************************************************************************************/
float ksepi_scan_acqloop(int passindx, int volindx, int multishotflag) {
  float time = 0.0;
  int shot, kyshot;
  KS_PHASEENCODING_COORD coord;
  int ndummies = 0;
  int is_multishot = (multishotflag == KSEPI_MULTISHOT_ALLVOLS) || \
                     (multishotflag == KSEPI_MULTISHOT_1STVOL && (volindx == 0)) || \
                     (multishotflag == KSEPI_MULTISHOT_B0VOLS && opdiffuse && (volindx < opdifnumt2));

  if (ksepi_ghostcorr && volindx == -1) { /* reference volume */
    ksepi.current_peplan = &ksepi.ref_peplan;
  } else if (is_multishot) { /* multishot volume */
    ksepi.current_peplan = &ksepi.full_peplan;
  } else { /* accelerated volume */
    ksepi.current_peplan = &ksepi.peplan;
  }

  if (ksepi_fleet && volindx == -ksepi_fleet - ksepi_ghostcorr) { /* FLEET volume */
    time += (float) ksepi_fleet_scan_sliceloop(ks_slice_plan.nslices_per_pass, volindx, passindx);
  }
  else { /* non-FLEET volumes */
    if (volindx == 0)
      ndummies = ksepi_dda;
    else
      ndummies = 0;

    for (shot = -ndummies; shot < ksepi.current_peplan->num_shots; shot++) {

      if (shot == 0 && ndummies > 0) {
        ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_DUMMY);
      }

      if (ksepi_echotime_shifting == TRUE) {
        coord = ks_phaseencoding_get(ksepi.current_peplan, 0, shot); /* coord to first line of EPI train */
        kyshot = coord.ky % ksepi.current_peplan->phaser->R;

        ks_enum_epiblipsign blipsign = ks_scan_epi_verify_phaseenc_plan(&ksepi.epitrain, ksepi.current_peplan, shot);
        int post_delay = 0;

        if (blipsign == KS_EPI_POSBLIPS) {
         post_delay = (kyshot <= 0) ? GRAD_UPDATE_TIME : RUP_GRD((int) (ksepi_echotime_shifting_shotdelay * kyshot));
        } else if (blipsign == KS_EPI_NEGBLIPS) {
         post_delay = (kyshot <= 0) ? GRAD_UPDATE_TIME : RUP_GRD((int) (ksepi_echotime_shifting_shotdelay * (ksepi.current_peplan->phaser->R-1-kyshot)));
        }

        ks_scan_wait(&ksepi.pre_delay, ksepi_echotime_shifting_sumdelay - post_delay);
        ks_scan_wait(&ksepi.post_delay, post_delay);
      }

      if (ksinv1.params.irmode != KSINV_OFF) {
        void *args[] = {(void *) &shot}; /* pass on args via ksinv_scan_sliceloop() to ksepi_scan_coreslice() */
        int nargs = sizeof(args)/ sizeof(void *);
        time += (float) ksinv_scan_sliceloop(&ks_slice_plan, ks_scan_info, passindx, &ksinv1, &ksinv2, &ksinv_filltr,
                                              (shot < 0) ? KSINV_LOOP_DUMMY : KSINV_LOOP_NORMAL, ksepi_scan_coreslice_nargs, nargs, args);
      } else {
        time += (float) ksepi_scan_sliceloop(ks_slice_plan.nslices_per_pass, volindx, passindx, shot);
      }

      ks_plot_slicetime_endofslicegroup(volindx < 0 ? "ksepi ghostcorr" : "ksepi shots");

      /* save a frame of the main sequence */
      if (shot >= 0) {
        ks_plot_tgt_addframe(&ksepi.seqctrl);
      }

    } /* for shot */
    ks_plot_slicetime_endofpass(volindx < 0 ? KS_PLOT_PASS_WAS_CALIBRATION : KS_PLOT_PASS_WAS_STANDARD);
  }

  return time; /* in [us] */

} /* ksepi_scan_acqloop() */




/**
 *******************************************************************************************************
 @brief #### Plays out all volumes and passes of a single or multi-pass scan

 This function performs the entire scan and traverses through passes and volumes.
 For each `passindx` (in range `[0, ks_slice_plan.npasses-1]`), and `volindx`, ksepi_scan_acqloop()
 will be called to acquire all data for the current set of slices belong to the current
 pass (acquisition). At the end of each pass, GEReq_endofpass() is called to trigger GE's recon and
 to dump Pfiles (if `autolock = 1`). `volindx` will start at -1 if `ksepi_ghostcorr = 1`, in which case
 a leading extra image volume will be played out without phase encoding blips. This data is used by GE's
 integrated refscan (rhref=5) to ghost correct the remaining volumes. This process requires single-shot
 (ksepi.epitrain.phaseenc.R = 1) and single-echo (opnecho = 1). However, for offline reconstruction, it
 is possible to still use this extra volume for ghost correction even though ksepi.epitrain.phaseenc.R > 1
 and/or opnecho > 1.

 @retval scantime Total scan time in [us] (`float` to avoid int overrange after 38 mins)
********************************************************************************************************/
float ksepi_scan_scanloop() {
  float time = 0.0;
  int volindx, passindx;

  for (volindx = -ksepi_fleet - ksepi_ghostcorr; volindx < opfphases; volindx++) { /* opfphases = # volumes */

    if (ksepi_ghostcorr && volindx == -1) /* if ghostcorr is used it will be volume -1 */
      rspent = L_REF; /* will make zero phase encodes in ksepi_scan_coreslice() */
    else
      rspent = L_SCAN;

    if (opdiffuse == KS_EPI_DIFFUSION_ON) {
      ksepi_diffusion_scan_diffamp(&ksepi, volindx);
    }

    for (passindx = 0; passindx < ks_slice_plan.npasses; passindx++) {

      time += ksepi_scan_acqloop(passindx, volindx, ksepi_multishot_control);

#ifdef IPG
      if ( !((volindx + 1 == opfphases) && (passindx + 1 == ks_slice_plan.npasses)) ) {
        GEReq_endofpass(); /* don't play last time, we rely now on  GEReq_endofpassandscan() in ksepi.e:scan() */
      }
#endif

    } /* end: acqs (pass) loop */

  } /* end: volume loop */

  return time; /* in [us] */

} /* ksepi_scan_scanloop() */





/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksepi_implementation.e: SCAN in @rsp section (functions only accessible on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/

/**
 *******************************************************************************************************
 @brief #### Common initialization for prescan entry points MPS2 and APS2 as well as the SCAN entry point
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksepi_scan_init(void) {

  GEReq_initRSP();

  /* Here goes code common for APS2, MPS2 and SCAN */

  ks_scan_switch_to_sequence(&ksepi.seqctrl);  /* switch to main sequence */
  scopeon(&seqcore); /* Activate scope for core */
  syncon(&seqcore);  /* Activate sync for core */
  setssitime(ksepi.seqctrl.ssi_time/ HW_GRAD_UPDATE_TIME);

  /* can we make these independent on global rsptrigger and rsprot in orderslice? */
  settriggerarray( (short) ks_slice_plan.nslices_per_pass, rsptrigger);

  rfspoiling_phase_counter = 0;

  return SUCCESS;

} /* ksepi_scan_init() */




/**
 *******************************************************************************************************
 @brief #### Prescan loop called from both APS2 and MPS2 entry points
 @retval STATUS `SUCCESS` or `FAILURE`
*******************************************************************************************************/
STATUS ksepi_scan_prescanloop(int nloops, int dda) {
  int i, echoindx, sliceindx, shotindx, sltimeinpass;
  int slloc;

  /* turn off receivers for all echoes (thanks to slice = KS_NOTSET) */
  for (echoindx = 0; echoindx < opnecho; echoindx++) {
    ks_scan_epi_loadecho(&ksepi.epitrain, echoindx, echoindx, KS_NOTSET, NULL, KS_NOTSET);
  }
  if (ksepi_reflines > 0) {
    /* store phase reference echo as opnecho */
    ks_scan_epi_loadecho(&ksepi.epireftrain, 0, opnecho, KS_NOTSET, NULL, KS_NOTSET);
  }

  /* Diffusion gradients must be off during prescan to get the correct receiver gain */
  if (opdiffuse == KS_EPI_DIFFUSION_ON) {
    ksepi_diffusion_scan_diffamp(&ksepi, KS_NOTSET); /* KS_NOTSET zeroes all diffusion gradient amplitudes */
  }

  /* play dummy scans to get into steady state */
  for (i = -dda; i < nloops; i++) {

    /* loop over slices */
    for (sltimeinpass = 0; sltimeinpass < ks_slice_plan.nslices_per_pass; sltimeinpass++) {

      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, 0, sltimeinpass);

      /* modify sequence for next playout */
      ksepi_scan_seqstate(ks_scan_info[slloc], KS_NOTSET);

      /* data routing control */
      echoindx = 0; /* just to 1st echo for prescan */
      sliceindx = 0;
      shotindx = 0;
      if (i >= 0) {
        ks_scan_epi_loadecho(&ksepi.epitrain, echoindx, echoindx, sliceindx, NULL, shotindx);
      }

      ks_scan_playsequence(&ksepi.seqctrl);

    } /* for slices */

  } /* for nloops */

  return SUCCESS;

} /* ksepi_scan_prescanloop() */

/*****************************************************************************************************
 * PULSEGEN (Executes when pressing Scan or Research->Download)
 *****************************************************************************************************/

STATUS pulsegen( void ) {

  GEReq_pulsegenBegin();

  /* Main Pulse Sequence */
  ksepi_pg(ksepi_pos_start);
   
    {
      if (ksepi.seqctrl.duration > 0) {

        if (ksepi.seqctrl.duration - ksepi.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksepi.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqcore, "seqcore");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqcore) failed", ksepi.seqctrl.description);
          }  
          status = createseq(&seqcore, ksepi.seqctrl.duration - ksepi.seqctrl.ssi_time, off_seqcore);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqcore) failed", ksepi.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqcore );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqcore) failed", ksepi.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqcore = %d\n", idx_seqcore );
          ksepi.seqctrl.handle.index = idx_seqcore;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksepi.seqctrl.handle.offset = off_seqcore;
          ksepi.seqctrl.handle.pulse = &seqcore;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  

  /* Spatial Sat */
  ksspsat_pulsegen();

  /* ChemSat sequence module */
  kschemsat_pg(&kschemsat);
   
    {
      if (kschemsat.seqctrl.duration > 0) {

        if (kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", kschemsat.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSChemSat, "seqKSChemSat");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }  
          status = createseq(&seqKSChemSat, kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time, off_seqKSChemSat);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSChemSat) failed", kschemsat.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSChemSat );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSChemSat = %d\n", idx_seqKSChemSat );
          kschemsat.seqctrl.handle.index = idx_seqKSChemSat;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          kschemsat.seqctrl.handle.offset = off_seqKSChemSat;
          kschemsat.seqctrl.handle.pulse = &seqKSChemSat;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if kschemsat.seqctrl.duration = 0 */

  /* Inversion sequence modules */
  ksinv_pulsegen();

  /* FLEET module */
  ksepi_pg_fleet(ksepi_pos_start);
   
    {
      if (ksepi_fleetseq.seqctrl.duration > 0) {

        if (ksepi_fleetseq.seqctrl.duration - ksepi_fleetseq.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksepi_fleetseq.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqFLEET, "seqFLEET");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqFLEET) failed", ksepi_fleetseq.seqctrl.description);
          }  
          status = createseq(&seqFLEET, ksepi_fleetseq.seqctrl.duration - ksepi_fleetseq.seqctrl.ssi_time, off_seqFLEET);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqFLEET) failed", ksepi_fleetseq.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqFLEET );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqFLEET) failed", ksepi_fleetseq.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqFLEET = %d\n", idx_seqFLEET );
          ksepi_fleetseq.seqctrl.handle.index = idx_seqFLEET;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksepi_fleetseq.seqctrl.handle.offset = off_seqFLEET;
          ksepi_fleetseq.seqctrl.handle.pulse = &seqFLEET;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  

  GEReq_pulsegenEnd();

  buildinstr(); /* load the sequencer memory */


  return SUCCESS;

} /* pulsegen() */



/*****************************************************************************************************
 * RSP Functions
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/

/*****************************************************************************************************
 * MPS2: Manual Prescan ("Scan TR"). Should run the main sequence without phase encoding gradients
 * to determine receiver gains R1 (analog) and R2 (digital)
 *****************************************************************************************************/

STATUS mps2(void) {

  rspent = L_MPS2;
  strcpy(psdexitarg.text_arg, "mps2");

  if (ksepi_scan_init() == FAILURE)
    return rspexit();

  if (ksepi_scan_prescanloop(30000, ksepi_dda) == FAILURE)
    return rspexit();

  rspexit();

 return SUCCESS;

} /* mps2() */


/*****************************************************************************************************
 * APS2: Auto Prescan ("Scan TR"). Should run the main sequence without phase encoding gradients
 * to determine receiver gains R1 (analog) and R2 (digital)
 *****************************************************************************************************/

STATUS aps2(void) {

  rspent = L_APS2;
  strcpy(psdexitarg.text_arg, "aps2");

  if (ksepi_scan_init() == FAILURE)
    return rspexit();

  if (ksepi_scan_prescanloop(100, ksepi_dda) == FAILURE)
    return rspexit();

  rspexit();

  return SUCCESS;

} /* aps2() */


/*****************************************************************************************************
 * SCAN: Executed when pressing Scan. Runs the sequence
 * The code is halted at the function call startseq() and waits for the SSI interrupt at the of
 * each sequence playout
 *****************************************************************************************************/

STATUS scan(void) {

  rspent = L_SCAN;
  strcpy(psdexitarg.text_arg, "scan");

  if (ksepi_scan_init() == FAILURE)
    return rspexit();

  /* Scan hierarchy:

    Without inversion:
    ksepi_scan_scanloop() - Data for the entire scan
        ksepi_scan_acqloop() - All data for one set of slices that fit within one TR (one acquisition)
            ksepi_scan_sliceloop() - One set of slices that fit within one TR played out for one shot
                 ksepi_scan_coreslice() - One slice playout, with optional other sequence modules

    With inversion:
    ksepi_scan_scanloop() - Data for the entire scan
        ksepi_scan_acqloop() - All data for one set of slices that fit within one TR (one acquisition)
            ksinv_scan_sliceloop() - One set of slices that fit within one TR played out for one shot
                                     using the sliceloop in KSInversion.e. Note that ksinv_scan_sliceloop()
                                     takes over the TR timing from ksepi_scan_sliceloop() and uses a
                                     function pointer to ksepi_scan_coreslice_nargs() to execute the
                                     contents of ksepi_scan_coreslice().
  */
  ksepi_scan_scanloop();

  GEReq_endofpassandscan();

  /* So we can see the sequence in plotter after scan completes */
  ks_scan_switch_to_sequence(&ksepi.seqctrl);

  rspexit();

  return SUCCESS;

}   /* scan() */


/* Executed when scan is aborted */
STATUS psdcleanup(void) {
  /* return the right kind of success */
  return 0;
}


/* Include special CV download code */
#include "ksepi.cvcopy.cpp"

