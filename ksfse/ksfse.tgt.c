/*
 *  ksfse.tgt.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Feb 28 2018
 *  Time : 11:06:49
 */

#include <epic_struct.h>
#if defined(MGD_TGT) && defined(PSD_HW)
#include "valuesMGD.h"
#endif /* MGD_TGT && PSD_HW */
#include "ksfse.global.h"
#include <pgen_tmpl.h>
#include <epicfuns.h>
#ifdef PSD_HW
__asm__(".align 8");
#endif

#include "ksfse.allcv.h"
#include "ksfse.tgtex.h"
#include "ksfse.tgtdecl.h"
long _header_source_rev= 1555709114;
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: PULSEGEN functions
 *                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
 *
 *******************************************************************************************************
 *******************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1 = res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl = res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( rcvn_flag == 1 )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;
    INT min_ssp;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        short *temp_wave_space; /* temporary waveform space for rf scaling */
        short *wave_space; /* temporary waveform space for rf scaling */

        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    INT new_res;                  /* temp holder for new pulse resolution */

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	    /* Scale the pulse, and then move to the reserved memory */
	    temp_wave_space = (short *)AllocNode(res_gzrf0cfh*sizeof(short));
	    uextwave(temp_wave_space, res_gzrf0cfh, grad_zrf0cfh);
	    wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres/2*sizeof(short));
	    stretchpulse((int)res_gzrf0cfh,(int)rfpulseInfo[RF0_CFH_SLOT].newres/2,
			 temp_wave_space,wave_space);
	    /* res_gz$[slsel_name] = rfpulseInfo[$[rf_slot]].newres/2; */
	    new_res = rfpulseInfo[RF0_CFH_SLOT].newres/2;
	    /* Copy over original pulse data */
	    movewaveimm(wave_space, &gzrf0cfh, (int)0, new_res, TOHARDWARE);
	    FreeNode(wave_space);
	    FreeNode(temp_wave_space);
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

	/* Create some RHO waveform space, scale the pulse, and then move
	 * the local memory to the reserved RHO memory, and set pulsepointers
	 * to new stretched pulse
	 */
	temp_wave_space = (short *)AllocNode(res_rf0cfh*sizeof(short));
	uextwave(temp_wave_space, res_rf0cfh, rf_rf0cfh);
	wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres*sizeof(short));
	stretchpulse((int)res_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		     temp_wave_space,wave_space);
	/* res_$[slsel_name] = rfpulseInfo[$[rf_slot]].newres; */
	new_res = rfpulseInfo[RF0_CFH_SLOT].newres;
        /* Copy over original pulse data */
	movewaveimm(wave_space, &rf0cfh, (int)0, new_res, TOHARDWARE);
	FreeNode(wave_space);
	FreeNode(temp_wave_space);
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0cfh;
    new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

    n_omegarf0cfh += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0cfh);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0cfh,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh = res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = temp_res_rf1cfh;
  }


    min_ssp = RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH);

    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                  + IMax(2, min_ssp,
                         (pw_gzrf1cfhd + pw_gzrf2lcfha
                          + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                  + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                  + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                           + IMax(2, min_ssp,
                                  (pw_gzrf1cfhd + pw_gzrf2lcfha
                                   + pw_gzrf2lcfh + pw_gzrf2lcfhd));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                    IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                    + presscfh_wait_rf12;

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = 0.5 * pw_rf3cfh
                        + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                        + presscfh_wait_rf23;
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = 0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                        + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                        + presscfh_wait_rf34;

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh = rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr = 15   + delay_rfhubsel + pw_contrfhubsel + pw_contrfsel
        + SSP_UPDATE_TIME + csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr = RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg = res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg = res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg = res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGz1XTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
        postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gyrf1xtgd + pw_gykxtgla);
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

        postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gykxtgla);
    }

    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, postemp-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);

 
    postemp = RUP_GRD(pendall(&gykxtgl,0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf3xtg);
   }
 

    PosGz1XTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                        pw_rf2xtg/2-pw_gzrf2xtga-pw_gz1xtgd-pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                     pw_rf2xtg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg = res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = temp_res_rf2xtg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1XTG = pendall(&gzrf2xtg, 0)+pw_gz2xtga;

           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    postemp = RUP_GRD(pendall(&gz2xtg, 0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    postemp = RUP_GRD(pendall(&rf4xtg, 0)+pw_gykxtgra);
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, postemp-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&rf2xtg,0)-pw_rf2xtg/2+XTGtau1-pw_gxw1xtg/2
                      -pw_gxw1xtga-pw_gx1bxtgd-pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + 
                                   2*XTGtau1 - pw_gxw1xtg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga)){
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0)));

         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);

     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as = res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta = asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    rfdisable_add = YES;
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }


    rfdisable_add = NO;
        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(TR_PASS3D-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(TR_PASS3D), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *wave_space_theta;
    short *temp_wave_space;
    short *temp_wave_space2;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay = 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs = temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     rffrequency_length[bd_index]-rfupa+rfupd );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

    temp_res = res_rfbrs;
    res_thetarfbrs = res_rfbrs;

    strcpy(ext_filename,"bloch_siegert_abs.rho");
    /* Set new resolution and stretch external pulse */
    temp_wave_space = (short *)AllocNode(res_rfbrs*sizeof(short));
    temp_wave_space2 = (short *)AllocNode(res_thetarfbrs*sizeof(short));
    uextwave(temp_wave_space, res_rfbrs, ext_filename);
    uextwave(temp_wave_space2, res_thetarfbrs, "bloch_siegert_abs.pha");

    /* Stretch rf pw if needed */
    if (rfpulseInfo[RFB_RFSHIM_SLOT].change==PSD_ON)
    {
        res_rfbrs = rfpulseInfo[RFB_RFSHIM_SLOT].newres;
        res_thetarfbrs = res_rfbrs;

        wave_space = (short *)AllocNode(res_rfbrs*sizeof(short));
        stretchpulse((int)temp_res, (int)res_rfbrs,temp_wave_space,wave_space);

        wave_space_theta = (short *)AllocNode(res_thetarfbrs*sizeof(short));
        stretchpulse((int)temp_res,(int)res_thetarfbrs,temp_wave_space2,wave_space_theta);

        FreeNode(temp_wave_space);
        FreeNode(temp_wave_space2);
    }
    else
    {
        wave_space = temp_wave_space;
        wave_space_theta = temp_wave_space2;
    }

      
  {
    pulsename(&rfbrs,"rfbrs");
    createreserve(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
		  res_rfbrs);
  }

    createinstr( &rfbrs, PosTemp+psd_rf_wait, pw_rfbrs, ia_rfbrs );
    addrfbits(&rfbrs, 0, PosTemp+psd_rf_wait, pw_rfbrs);
    movewaveimm(wave_space, &rfbrs, (int)0, res_rfbrs, TOHARDWARE);
    FreeNode(wave_space);
    setiamp(ia_rfbrs, &rfbrs, 0);

    /* BLOCHSIEGERT_ADIABATIC Theta Board */
      
  {
    pulsename(&thetarfbrs,"thetarfbrs");
    createreserve(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
		  res_thetarfbrs);
  }

    createinstr(&thetarfbrs, (LONG)(PosTemp+psd_rf_wait), pw_rfbrs,ia_rfbrs_theta);
    addrfbits(&thetarfbrs,0, (LONG)(PosTemp+psd_rf_wait), pw_rfbrs);
    movewaveimm(wave_space_theta, &thetarfbrs, (long)0, res_thetarfbrs, TOHARDWARE);
    FreeNode(wave_space_theta);
    setiamp(ia_rfbrs_theta, &thetarfbrs, 0);

    res_rfbrs = temp_res;
    res_thetarfbrs = res_rfbrs;

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *wave_space_theta;
    short *temp_wave_space;
    short *temp_wave_space2;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg = temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     rffrequency_length[bd_index]-rfupa+rfupd );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

    temp_res = res_rfbdtg;
    res_thetarfbdtg = res_rfbdtg;

    strcpy(ext_filename,"bloch_siegert_abs.rho");
    /* Set new resolution and stretch external pulse */
    temp_wave_space = (short *)AllocNode(res_rfbdtg*sizeof(short));
    temp_wave_space2 = (short *)AllocNode(res_thetarfbdtg*sizeof(short));
    uextwave(temp_wave_space, res_rfbdtg, ext_filename);
    uextwave(temp_wave_space2, res_thetarfbdtg, "bloch_siegert_abs.pha");

    /* Stretch rf pw if needed */
    if (rfpulseInfo[RFB_DYNTG_SLOT].change==PSD_ON)
    {
        res_rfbdtg = rfpulseInfo[RFB_DYNTG_SLOT].newres;
        res_thetarfbdtg = res_rfbdtg;

        wave_space = (short *)AllocNode(res_rfbdtg*sizeof(short));
        stretchpulse((int)temp_res, (int)res_rfbdtg,temp_wave_space,wave_space);

        wave_space_theta = (short *)AllocNode(res_thetarfbdtg*sizeof(short));
        stretchpulse((int)temp_res,(int)res_thetarfbdtg,temp_wave_space2,wave_space_theta);

        FreeNode(temp_wave_space);
        FreeNode(temp_wave_space2);
    }
    else
    {
        wave_space = temp_wave_space;
        wave_space_theta = temp_wave_space2;
    }

      
  {
    pulsename(&rfbdtg,"rfbdtg");
    createreserve(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
		  res_rfbdtg);
  }

    createinstr( &rfbdtg, PosTemp+psd_rf_wait, pw_rfbdtg, ia_rfbdtg );
    addrfbits(&rfbdtg, 0, PosTemp+psd_rf_wait, pw_rfbdtg);
    movewaveimm(wave_space, &rfbdtg, (int)0, res_rfbdtg, TOHARDWARE);
    FreeNode(wave_space);
    setiamp(ia_rfbdtg, &rfbdtg, 0);

    /* BLOCHSIEGERT_ADIABATIC Theta Board */
      
  {
    pulsename(&thetarfbdtg,"thetarfbdtg");
    createreserve(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
		  res_thetarfbdtg);
  }

    createinstr(&thetarfbdtg, (LONG)(PosTemp+psd_rf_wait), pw_rfbdtg,ia_rfbdtg_theta);
    addrfbits(&thetarfbdtg,0, (LONG)(PosTemp+psd_rf_wait), pw_rfbdtg);
    movewaveimm(wave_space_theta, &thetarfbdtg, (long)0, res_thetarfbdtg, TOHARDWARE);
    FreeNode(wave_space_theta);
    setiamp(ia_rfbdtg_theta, &thetarfbdtg, 0);

    res_rfbdtg = temp_res;
    res_thetarfbdtg = res_rfbdtg;

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}


/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of pulsegen()

 In the beginning of `pulsegen()` the following lines should be added:
 \code{.c}
 GEReq_pulsegenBegin();
 \endcode

 This function up various global GE stuff related to pulsegen()
********************************************************************************************************/
void GEReq_pulsegenBegin(void) {

  sspinit(psd_board_type);

  {
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */

  }
} /* GEReq_pulsegenBegin() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the end of pulsegen()

 In the end of `pulsegen()`, but before `buildinstr()`, the following lines should be added:
 \code{.c}
 GEReq_pulsegenEnd();
 \endcode

 This function up prescan pulsegen and adds a PASSPACK sequence ("GEendpass"), which is used to dump
 rawdata and mark the end of scan. See GEReq_endofpass() and GEReq_endofscan() and how they are used
 in a psd.
********************************************************************************************************/
void GEReq_pulsegenEnd(void) {

#ifdef IPG
  {
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();

  }

/* pass sequence to dump Pfiles */
 
  {
    pulsename(&GEendpass,"GEendpass");
    createpass(&GEendpass,(long)(pw_passpacket-1000));
  }

  
  {
    pulsename(&GEpass,"GEpass");
    createseq(&GEpass,pw_passpacket, off_GEpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_GEpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_GEpass = %d\n", idx_GEpass );
#endif
  }


#endif
} /* GEReq_pulsegenEnd() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to trigger data (Pfile) writing and reconstruction

 After calling this function, the parent function must switch back to the previous/main sequence 
 using ks_scan_playsequence() (or *boffset()*).
********************************************************************************************************/
void GEReq_endofpass() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABPASS, &GEendpass, 2 ); /* end of pass */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofpass() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofscan() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABSCAN, &GEendpass, 2 ); /* end of scan */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofscan() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofpassandscan() {
  #ifdef IPG
    boffset(off_GEpass);
    setwamp(SSPD + DABPASS + DABSCAN, &GEendpass, 2 ); /* end of scan */
    startseq(0, (short) MAY_PAUSE);
  #endif
  } /* GEReq_endofscan() */
  
  

/*****************************************************************************************************
 * RSP Variables
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/

/* For IPG Simulator: will generate the entry point list in the IPG tool */
CHAR *entry_name_list[ENTRY_POINT_MAX] = {
  "scan",
  "mps2",
  "aps2",
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                           PSeplist                                *
 *                                                                   *
 * Additional list of entry points for Prescan.                      *
 *********************************************************************/
         "cfl",
         "cfh",
         "mps1",
         "aps1", 
         "autoshim",
         "fasttg",
         "rcvn",
         "expresstg",
         "RFshim",
         "DynTG",
         0	/* 0 is needed for the parser */


};

/* Do not move the line above and do not insert any code or blank
   lines before the line above.  The code inline'd from Prescan.e
   adds more entry points and closes the list. */
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                            PScore                                 *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

long PSrsptrigger[MAX_PSC_VQUANT]={0};   /* prescan trigger */ /* vmx 10/13/94 YI */

void
dump_rsp_psc_info( void )
{
    INT i ;
    printf("\nPSD-> Dump of Prescan Shim Vol. Info\n");

    for (i=0; i<oppscvquant; i++)
    {
        printf("PSD->\nPSD->PscVol %d\t\t\t\ttloc = %+6f, rloc = %+6f, phaseoff = %+6f\n",
               i, rsp_psc_info[i].rsppsctloc, rsp_psc_info[i].rsppscrloc, rsp_psc_info[i].rsppscphasoff);
        printf("PSD->\nPSD->Index %d\t\t\t\tlenx = %+6d, leny = %+6d, lenz = %+6d\n",
               i, rsp_psc_info[i].rsppsclenx, rsp_psc_info[i].rsppscleny, rsp_psc_info[i].rsppsclenz);

        printf("\n Shim volume rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[0], rsp_psc_info[i].rsppscrot[1], rsp_psc_info[i].rsppscrot[2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[3], rsp_psc_info[i].rsppscrot[4], rsp_psc_info[i].rsppscrot[5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[6], rsp_psc_info[i].rsppscrot[7], rsp_psc_info[i].rsppscrot[8]);
    }
}

INT
get_psc_vol_index( void )
{
    int vol_index = 0;

    vol_index = (noswitch_slab_psc == PSD_ON) ? (PStest_slab-1) : (psc_vol_index-1);
    vol_index = (vol_index > 0) ? vol_index : 0;

    return vol_index;
}

/*
 *  mps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
mps1( void )
{
    rspent = L_MPS1;
    strcpy(psdexitarg.text_arg, "MPS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);

    PSmps1(2);
    rspexit();

    return SUCCESS;
}   /* end mps1() */


/*
 *  aps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
aps1( void )
{
    rspent=L_APS1;
    strcpy(psdexitarg.text_arg, "APS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(1);
    rspexit();

    return SUCCESS;
}   /* end aps1() */


/*
 *  cfl
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfl( void )
{
    rspent=L_CFL;
    strcpy(psdexitarg.text_arg, "CFL");

    PSinit(PSrot);
    PScfl();
    rspexit();

    return SUCCESS;
}   /* end cfl() */


/*
 *  rcvn
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
rcvn( void )
{
    rspent=L_RCVN;
    strcpy(psdexitarg.text_arg, "RCVN");

    PSinit(PSrot);
    PSrcvn();
    rspexit();

    return SUCCESS;
}   /* end rcvn() */


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This sets the rotation matrix with the one from the scan plane before the 3rd refocus pulse,
   and sets the rotation matrix back to the default one after the 3rd refocus pulse.
 */
void
cfh_set_rot_matrix_slice( void )
{
    static int rot_matrix_index = 0;
    int cfh_slab_index = get_psc_vol_index();

    if (rot_matrix_index == 0)
    {
        setrotateimm(PSrot[0], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 1;
    }
    else
    {
        setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 0;
    }
    return;
}

void
cfh_set_rot_matrix_default( void )
{
    int cfh_slab_index = get_psc_vol_index();

    setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
    return;
}


/*
 *  cfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfh( void )
{
    rspent=L_CFH;
    strcpy(psdexitarg.text_arg, "CFH");

    if ( (presscfh_ctrl == PRESSCFH_SHIMVOL) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE) )
    {
        int cfh_slab_index = get_psc_vol_index();
        PSinit(&rsp_PSrot[cfh_slab_index]);
    }
    else
    {
        PSinit(rsp_PSrot);
    }

    if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
    {
        isivector(3, cfh_set_rot_matrix_slice, (short) FALSE);
    }
    else
    {
        isivector(3, cfh_set_rot_matrix_default, (short) FALSE);
    }

    PScfh();
    rspexit();

    return SUCCESS;
}   /* end cfh() */

/*
 *  fasttg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
fasttg( void )
{
    rspent=L_FTG;
    PSinit(PSrot_mod);
    PSfasttg();
    rspexit();

    return SUCCESS;
}   /* end fasttg() */

/*
 *  expresstg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
expresstg( void )
{
    rspent=L_XTG;
    PSinit(PSrot_mod);
    PSexpresstg();
    rspexit();

    return SUCCESS;    
}   /* end expresstg() */

/*
 * B1 Map acquisition for RF Shim 
 *
 * Type: Public Function
 *
 */
STATUS
RFshim( void )
{
    rspent=L_RFSHIM;
    strcpy(psdexitarg.text_arg, "RFshim");

    PSrfshim();    /* flag on for RFShim mode */
    printdbg("Normal End of RFshim", debugstate);

    rspexit();
    return SUCCESS;    
}

int rspdtg = PSD_OFF;              /* rsp update for DynTG setting, set by prescan server */
int deltatg_temp[MAX_DYNTG_NOSLICES];
int *deltatg = (int *) deltatg_temp;    /* rsp update for DynTG setting, set by prescan server. */

STATUS DtgInitPsc()
{
    INT i;

    rspdtg = PSD_OFF;
    for (i=0; i<opslquant; i++)
    {
        deltatg[i] = 0;
    }
    return SUCCESS;
}

/* 
 * B1 Map for Dynamic TG
 *
 * Type: Public Function
 *
 */
STATUS
DynTG( void )
{
    rspent=L_DYNTG;
    strcpy(psdexitarg.text_arg, "DynTG");

    DtgInitPsc();
    PSdyntg();
    printdbg("Normal End of DynTG", debugstate);

    rspexit();
    return SUCCESS;    
}

/*
 *  autoshim
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
autoshim( void )
{
    rspent=L_AUTOSHIM;
    strcpy(psdexitarg.text_arg, "Autoshim");

    ASautoshim();
    rspexit();

    return SUCCESS;
}   /* end autoshim() */


/*
 *  PSmps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSmps1( INT mps1nex )
{
    INT acq_type;
    SHORT temp_short;
    INT slice_freq;
    FLOAT receive_freq;
    FLOAT rsp_PStloc=0.0;
    FLOAT rsp_PSrloc=0.0;
    FLOAT rsp_PSphasloc=0.0;
    INT old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Starting PSmps1",PSdebugstate);
    boffset(off_seqmps1);

    scopeon(&seqmps1);	/* Activate scope for core */
    syncon(&seqmps1);	/* Activate sync for core */

    rsp_PStloc = PStloc_mod;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasloc = PSphasoff_mod;
    /* begin aps1_mod changes (GE) */

    if(PSD_ON == local_tg)
    {
        slice_freq = ( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                       (10* TARDIS_FREQ_RES) );
    }
    else
    {
        slice_freq = ( GAM * a_gzrf1mps1 * rsp_PStloc/
                       (10* TARDIS_FREQ_RES) );
    }
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf1mps1,0);

    slice_freq = ( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf2mps1,0);

    receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

    /* end aps1_mod changes (GE) */ 

    setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
		 &echo1mps1, 0);

    if(PSdebugstate)
    {
        printf("\nAPS1/MPS1 Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                thickPS_mod,mpsfov, PStloc_mod, PSrloc_mod);
        printf("\nAPS1/MPS1 Xmit Freq = %i, Rcv Freq  = %f\n", slice_freq, receive_freq);
        printf("%s\n","APS1/MPS1 Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("PSmps1: psc_vol_index = %d\n",psc_vol_index );
    }


    
    for (view = -1; view <= 30000; view++)
    {
        for (excitation = 1; excitation <= mps1nex; excitation++)
    	{
            if (view > 0)

      	    {
                if (excitation == mps1nex)
      	      	{
                    attenlockoff(&attenuator_keymps1);
      	      	}
                else
      	      	{
                    attenlockon(&attenuator_keymps1);
      	      	}
      	    }

            if ((view > 0) && (excitation >= 1))
      	    {
                acq_type = (int)DABON;
      	    }
            else
      	    {
                acq_type = (int)DABOFF;
      	    }

            loaddab(&echo1mps1, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL); 

            /* For SWIFT(PSmps1): We are trying not to use the CV opswift.
               Instead use psc_vol_index.  */
            if( (psc_vol_index > 0) && (opvquant > 1))
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqmps1);
                    }
                        
                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSmps1: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq = ( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                               (10* TARDIS_FREQ_RES) );
            }
            else
            {
                slice_freq = ( GAM * a_gzrf1mps1 * rsp_PStloc/
                               (10* TARDIS_FREQ_RES) );
            }
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf1mps1,0);

            slice_freq = ( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf2mps1,0);

            receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

            /* end aps1_mod changes (GE) */

            setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
                    &echo1mps1, 0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            syncoff(&seqmps1);

            /* Chopper logic */
            getiamp(&temp_short, &rf1mps1,0);
            setiamp((-temp_short),&rf1mps1,0);
	}
    }

    printdbg("Returning from PSmps1",PSdebugstate);

    return SUCCESS;
}   /* end PSmps1() */


/*
 *  PScfl
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PScfl( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    INT slice_freq; /* transmit frequency for the prescan slice */
    SHORT temp_short; /* temp variable */
    float rsp_PStloc;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PScfl", PSdebugstate);
    boffset(off_seqcfl); 
    scopeon(&seqcfl);
    syncon(&seqcfl); 
    attenlockoff(&cfl_attenkey);
  
    rsp_PStloc = PStloc;
    slice_freq = GAM * a_gzrf1cfl * PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
  
    setfrequency(slice_freq, &rf1cfl,0);
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &cfl_fid, 0);

    if( PSdebugstate )
    {
        printf("PScfl: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -cfl_dda+1 ; view <= 30000; view ++)
    {
        for (excitation = 1; excitation <= cfl_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == cfl_nex)
                    attenlockoff(&cfl_attenkey);
                else
                    attenlockon(&cfl_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&cfl_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PScfl): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfl); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfl: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = GAM * a_gzrf1cfl * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */

            setfrequency(slice_freq, &rf1cfl,0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfl);

            if(PSdebugstate && view == 0)
            {
                printf("\n CFL:  Xmit Location = %f Receive Location = %f\n ", PStloc, 0.0 );
                printf ("%s\n","CFL : Rotation Matrix");
                printf("\t %6ld %6ld %6ld \n", PSrot[0][0], PSrot[0][1], PSrot[0][2]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][3], PSrot[0][4], PSrot[0][5]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][6], PSrot[0][7], PSrot[0][8]);
                fflush(stdout);
            }

            getiamp(&temp_short, &rf1cfl, 0);
            setiamp(-temp_short, &rf1cfl, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfl() */


/*
 *  PSrcvn
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PSrcvn( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PSrcvn", PSdebugstate);

    /* GEHmr03545 */
    if ( rcvn_flag != PSD_OFF )
    {
        boffset( off_pre_rcvn );
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    boffset(off_seqrcvn); 
    scopeon(&seqrcvn);
    syncon(&seqrcvn); 
    attenlockoff(&rcvn_attenkey);
  
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &rcvn_fid, 0);

    if( PSdebugstate )
    {
        printf("PSrcvn: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -rcvn_dda+1 ; view <= rcvn_loops ; view ++)
    {
        for (excitation = 1; excitation <= rcvn_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == rcvn_nex)
                    attenlockoff(&rcvn_attenkey);
                else
                    attenlockon(&rcvn_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&rcvn_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PSrcvn): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch slab*/
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqrcvn); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSrcvn: psc_vol_index=%d\n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            startseq((short)0,(short)MAY_PAUSE);

            syncoff(&seqrcvn);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PSrcvn() */


/*
 *  PScfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScfh( void )
{
    static INT rsp_PSshift = 0;  /* RSP shimvol shift for debug purpose */
    INT acq_type;      /* enable or disable data acquisiton */
    INT slice_freq  = 0;   /* transmit frequency for the prescan slice */
    INT slice2_freq = 0;   /* transmit frequency for the prescan slice */
    INT slice3_freq = 0;   /* presscfh: transmit frequency for the prescan slice */
    INT slice4_freq = 0;   /* presscfh-slice: transmit frequency for the prescan slice */
    INT ir_slice_freq = 0; /* IR sequence transmit freq. for the prescan slice */
    SHORT temp_short;  /* temp variable */
    long init_cfh_deadtime; /* initial deadtime of the seqcfh sequence */
    long new_cfh_deadtime;  /* updated cfh deadtime */

    float rsp_PStloc = 0;    /* RSP transmit location */
    float rsp_PSrloc = 0;    /* RSP receive location */
    float rsp_PSphasoff = 0; /* RSP phase off location */
    float rsp_PSslicetloc = 0;    /* RSP slice refocus location */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    
    showfp = 0;

    printdbg("Entering PScfh", PSdebugstate);
    boffset(off_seqcfh); 
    scopeon(&seqcfh);
    syncon(&seqcfh); 
    attenlockoff(&cfh_attenkey);

    if (psc_vol_index == 0) {

        slice_freq = cfh_rf1freq;
        setfrequency(slice_freq, &rf1cfh,0);

        slice2_freq = cfh_rf2freq;
        setfrequency((int)slice2_freq, &rf2cfh,0);
        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);
    }

#ifdef PSD_CFH_CHEMSAT

    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        if (PSir != PSD_ON)
        {
            setiamp(ia_rfcssatcfh, &rfcssat, cscfh_satindex);
        }
        else
        {
            setiamp(0, &rfcssat, cscfh_satindex);
        }
    }
    cstun = 0;

#endif


    if (PSD_ON == PSir)
    {
        /* Inversion */
        /* factor 10 is because rsptloc is in mm */
        ir_slice_freq = GAM * a_gzrf0cfh * PStloc/(10 * 
                                                   TARDIS_FREQ_RES); 
        setfrequency(ir_slice_freq, &rf0cfh,0);
    }

    /* Setting tislice to PSslice_num+1 so user sees slices start at 1*/
    tislice=PSslice_num+1;
    tislice_start=PSslice_num+1;

    /* Setting psctitime to opti; results in every entry into CFH having
       psctitime=opti*/
    psctitime = cfh_ti/1000;
    noir = 0;

    /* Finding initial deadtime (psctitime = opti) of seqcfh */
    getperiod( &init_cfh_deadtime, &seqcfh, 0 );

    if( PSdebugstate )
    {
        printf("PScfh: psc_vol_index = %d\n",psc_vol_index );
    }


    for (view = -cfh_dda+1 ; view <= 30000; view ++)
    {
        /* Modified for MULTI VOLUME Prescan - AP */
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            int cfh_slab_index = get_psc_vol_index();

            if( ( presscfh_ctrl != PRESSCFH_SHIMVOL ) && ( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE ) )
            {
                rsp_PStloc = presscfh_info[cfh_slab_index].oppsctloc;
                rsp_PSrloc = presscfh_info[cfh_slab_index].oppscrloc;
                rsp_PSphasoff = presscfh_info[cfh_slab_index].oppscphasoff;
            }
            else
            {
                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            }

            if (PScfh_shimvol_debug != PSCFH_SHIMVOL_DEBUG_NONE)
            {
                rsp_PSshift = rsp_PSshift + 10;
                if ( rsp_PSshift > 100 )
                {
                    rsp_PSshift = -100;
                }
            }
            else
            {
                rsp_PSshift = 0;
            }

            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Z)
            {
                rsp_PStloc = rsp_PStloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_X)
            {
                rsp_PSrloc = rsp_PSrloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Y)
            {
                rsp_PSphasoff = rsp_PSphasoff + rsp_PSshift;
            }

            slice_freq = GAM * a_gzrf1cfh * rsp_PStloc/ (10 * TARDIS_FREQ_RES);
            slice2_freq = GAM * a_gxrf2cfh * rsp_PSrloc/ (10 * TARDIS_FREQ_RES);
            slice3_freq = GAM * a_gyrf3cfh * rsp_PSphasoff/ (10 * TARDIS_FREQ_RES);

            if(PSdebugstate)
            {
                printf("\n");
                printf(" slice1_freq -> rsp_PStloc %0f \n", rsp_PStloc);
                printf(" slice2_freq -> rsp_PSrloc %0f \n", rsp_PSrloc);
                printf(" slice3_freq -> rsp_PSphasoff %0f \n", rsp_PSphasoff);
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                rsp_PSslicetloc = PStloc;
                slice4_freq = GAM * a_gzrf4cfh * rsp_PSslicetloc/ (10 * TARDIS_FREQ_RES);

                if(PSdebugstate)
                {
                    printf(" slice4_freq -> rsp_PSslicetloc %0f \n", rsp_PSslicetloc);
                }
            }

            if( PSD_ON == PSir ) {
                ir_slice_freq = ( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else if ( psc_vol_index > 0 )
        {
            /* PRESSCFH_NONE */

            int cfh_switch_coil=0;

            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            if ( opswift == PSD_ON )
            {
                    cfh_switch_coil = 1;
            }

            if( cfh_switch_coil )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfh); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfh: psc_vol_index=%d \n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            slice_freq = GAM * a_gzrf1cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES);
            if((opcoax != 0) && cfh_newmode)
            {
                slice2_freq = GAM * (opspf ? rsp_PSphasoff * a_gyrf2cfh : rsp_PSrloc * a_gxrf2cfh )/(10 * TARDIS_FREQ_RES);
            }
            else
            {
                slice2_freq = 0;
            }

            if( PSD_ON == PSir )
            {
                ir_slice_freq = GAM * a_gzrf0cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES);
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else
        {
            /* This is for the 3D scan volume - psc_vol_index = 0 */
            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            slice_freq = cfh_rf1freq;
            slice2_freq = cfh_rf2freq;
            if( PSD_ON == PSir )
            {
                ir_slice_freq = GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES); 
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  /* end of psc_vol_index */

        setfrequency(slice_freq, &rf1cfh,0);
        setfrequency((int)slice2_freq, &rf2cfh,0);
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            setfrequency((int)slice3_freq, &rf3cfh,0); /* for presscfh_ctrl */
            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                setfrequency((int)slice4_freq, &rf4cfh,0); /* for presscfh_ctrl */
            }
        }

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);

        if(PSdebugstate)
        {
            INT pscrot_idx;

            pscrot_idx = psc_vol_index;
            if (psc_vol_index > 0)
            {
                pscrot_idx = psc_vol_index-1;
            }
            printf("\n %d rsp_PStloc (tx, rec, phase) -> %0f %0f %0f\n",
                   psc_vol_index, rsp_PStloc, rsp_PSrloc, rsp_PSphasoff);
            printf ("CFH : Rotation Matrix for Prescan Volume Index %d\n", psc_vol_index);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][0], rsp_PSrot[pscrot_idx][1], rsp_PSrot[pscrot_idx][2]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][3], rsp_PSrot[pscrot_idx][4], rsp_PSrot[pscrot_idx][5]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][6], rsp_PSrot[pscrot_idx][7], rsp_PSrot[pscrot_idx][8]);

            fflush(stdout);
        }


        /* INVERSION RECOVERY CODE */
        if (PSD_ON == PSir)
        {
            /* Check for IR pulse being turned off */
            if (noir==1)
            {
                setiamp(0,&rf0cfh,0);
            }
            else
            {
                setiamp(ia_rf0cfh,&rf0cfh,0);
            }
            /* End check for IR pulse being on/off */

            if (tislice != (PSslice_num+1))
            {
                /* user has changed slice, so change frequencies */
                /* Check for proper range */
                if ((tislice < 1) || (tislice > opslquant)) 
                {
                    tislice=tislice_start;
                    PSslice_num=tislice-1;
                } 
                else
                {
                    PSslice_num=tislice-1;
                    /* changing the slice */

                    /* Calculation of new slice loc */
                    new_slice_loc = PStloc - ((opslspace + opslthick) *
                                              (tislice_start - tislice));
                    /* Inversion */
                    /* factor 10 is because rsptloc is in mm */
                    ir_slice_freq = GAM * a_gzrf0cfh * new_slice_loc/(10 * 
                                                                      TARDIS_FREQ_RES); 

                    setfrequency(ir_slice_freq, &rf0cfh,0);

                    /* Spin Echo */
                    /* factor 10 is because rsptloc is in mm */
                    slice_freq = GAM * a_gzrf1cfh * new_slice_loc/(10 * 
                                                                   TARDIS_FREQ_RES); 

                    setfrequency(slice_freq, &rf1cfh,0);
                    /* end of changing the slice */
                }
            }

            /* Changing the inversion time realtime */
            if (psctitime<50)
            {
                psctitime=50;
            }

            /* Need this check to reset psctitime to opti. Download error were
               happening because of invalid titimes */
            if(psctitime > 300)
            {
                psctitime = cfh_ti/1000;
            }

            titime_us = (psctitime*1000);
            new_dur=dur_invse + (titime_us - cfh_ti);
            new_dur = RUP_GRD(new_dur);
            setperiod(new_dur,&zticfh,0);
            setperiod(new_dur,&xticfh,0);
            setperiod(new_dur,&yticfh,0);
            setperiod(new_dur,&rticfh,0);
            setperiod(new_dur,&sticfh,0);

            /* Change the deadtime of seqcfh to preserve the cfh_tr value */
            /* If the seqcfh deadtime < 5 then set to the minimum of 4us */
            new_cfh_deadtime = init_cfh_deadtime + (cfh_ti - titime_us);
            if (new_cfh_deadtime < 5)
            {
                new_cfh_deadtime = 4;
            }

            setperiod( new_cfh_deadtime, &seqcfh, 0 );
            /* End deadtime change */

            /* End inversion time change */

            /* END INVERSION CORE CODE */
        } 
#ifdef PSD_CFH_CHEMSAT
        if( (cs_sat == PSD_ON) && PScs_sat )
        {
            CsSatMod((int)(cscfh_satindex+1));
        }
#endif
        /* Check should play cs/mt or stir for manual cfh */
        if( PSir )
        {
            StIRMod();
        }

        for( excitation = 1; excitation <= cfh_nex; excitation ++ )
        {
            if( view > 0 ) 
            {
                acq_type = (int)DABON;

                if( excitation == cfh_nex )
                {
                    attenlockoff(&cfh_attenkey);
                }
                else
                {
                    attenlockon(&cfh_attenkey);
                }
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&cfh_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfh); 

            getiamp(&temp_short, &rf1cfh, 0);
            setiamp(-temp_short, &rf1cfh, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfh() */


/* disable STIR cfh if cs/mttun is on */
void
StIRMod(void)
{
    int do_mttun = 0;
    int do_cstun = 0;


#ifdef PSD_CFH_CHEMSAT
    if(PSD_ON == PScs_sat)
    {
        do_cstun = cstun;
    }
    else
    {
        do_cstun = PSD_OFF;
    }
#endif /* PSD_CFH_CHEMSAT */

    if( do_cstun || do_mttun || showfp ) 
    {
        /* disable stir cfh pulse */
        rfoff(&rf0cfh, 0);
        setiampt(0, &gyrf0kcfh, 0);
    }
    else {
        rfon(&rf0cfh, 0);
        setiampt(amp_gyrf0kcfh, &gyrf0kcfh, 0);
    }
    return;
}

/*  begin aps1_mod changes (GE) */
/*
 *  PSinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSinit( long (*PSrotmat)[9] )
{   
    INT i;

    /* Range check for psc_vol_index */
    if ( psc_vol_index < 0 )
    {
        if(PSdebugstate)
            printf("WRONG psc_vol_index =%d\n",psc_vol_index);
        psc_vol_index = 0;
    }

    setrfconfig((short) 5);	/* only activate rho1 */
    setssitime(100);	/* set ssi counter to 400 us. */
    rspqueueinit(200);	/* initialize to 200 entries */

    if( presscfh_cgate && rspent == L_CFH ){
        PSrsptrigger[0] = TRIG_ECG;
    } else{
        PSrsptrigger[0] = PStrigger;
    }
    setrotatearray((short)1, *PSrotmat);
    settriggerarray((short)1, PSrsptrigger);
    
    /* Always use scan rot matrix for SWIFT*/
    if(opswift == PSD_ON)
    {
        setrotatearray((short)opvquant,rsprot[0]);
        for(i=0;i<opvquant;i++)
            PSrsptrigger[i] = PStrigger;

        settriggerarray((short)opvquant,PSrsptrigger);
    }


    return SUCCESS;
}   /* end PSinit() */

/* end aps1_mod changes (GE) */

/*
 *  PSfasttg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfasttg( void )
{
    printdbg("Greetings from FastTG", debugstate);
    rspent = L_FTG;
    rspdda = ftg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = pre_slice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "FastTG");
    
    FastTGCore( PStloc_mod,
                (int)rspdda,
                (int)rspvus,
                (int)rspnex,
                (int)debugstate);
 
    printdbg("Normal End of FastTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSfasttg() */


/*
 *  PSexpresstg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSexpresstg( void )
{
    printdbg("Greetings from eXpress TG", debugstate);
    rspdda = xtg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = pre_slice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "eXpressTG");
    
    eXpressTGCore( PStloc_mod,
                   (int)rspdda,
                   (int)rspvus,
                   (int)rspnex,
                   (int)debugstate);
 
    printdbg("Normal End of eXpressTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSexpresstg() */


/*
 *  FastTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    ftg_disdaqs: number of disdaq pairs
 *    ftg_views: # of max views to be executed in ftg
 *    ftg_nex: # of excitations in ftg
 *    ftg_chop: No chop if = 2
 *    ftg_debug: debug state
 */
STATUS
FastTGCore( DOUBLE slice_loc,
            INT ftg_disdaqs,
            INT ftg_views,
            INT ftg_nex,
            INT ftg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT slice_freq3;
    INT rcv_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (FTGacq1 == 1)
    {
        ftg_acq1 = (int)DABON;
    }
    else
    {
        ftg_acq1 = (int)DABOFF;
    }
      
    if (FTGacq2 == 1)
    {
        ftg_acq2 = (int)DABON;
    }
    else
    {
        ftg_acq2 = (int)DABOFF;
    }
      
    printdbg("Entering FastTGCORE", (SHORT)ftg_debug);
    boffset(off_seqftg);
    scopeon(&seqftg);
    syncon(&seqftg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&ftg_attenkey);
    slice_freq1 = GAM * a_gzrf1ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = GAM * a_gzrf2ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    slice_freq3 = GAM * a_gzrf3ftg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    rcv_freq = 2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov;

    setfrequency(slice_freq1, &rf1ftg,0);
    setfrequency(slice_freq2, &rf2ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1ftg, 0);
    setfrequency(slice_freq3, &rf3ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo2ftg, 0);
 
    if(PSdebugstate)
    {
        printf("\nFTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                FTGslthk,FTGfov, slice_loc, PSrloc_mod);
        printf("\nFTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","FTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("FTG: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = (-ftg_disdaqs + 1) ; view <= ftg_views; view ++)
    {
        for (excitation = 1; excitation <= ftg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&ftg_attenkey);
                if (excitation == ftg_nex)
                    attenlockoff(&ftg_attenkey);
                ftg_acq2 = (int)DABON;
            }
            else
            {
                ftg_acq2 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq1, PSD_LOAD_DAB_ALL);
            loaddab(&echo2ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq2, PSD_LOAD_DAB_ALL);

            /* For SWIFT(fasttg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200] = "";
                        sprintf(tempstr,"fasttgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = GAM * a_gzrf1ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = GAM * a_gzrf2ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            slice_freq3 = GAM * a_gzrf3ftg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            rcv_freq = 2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov;

            setfrequency(slice_freq1, &rf1ftg,0);
            setfrequency(slice_freq2, &rf2ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo1ftg, 0);
            setfrequency(slice_freq3, &rf3ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo2ftg, 0);


            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)ftg_debug);
            syncoff(&seqftg);
 
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end FastTGCore() */


/*
 *  eXpressTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    xtg_disdaqs: number of disdaq pairs
 *    xtg_views: # of max views to be executed in xtg
 *    xtg_nex: # of excitations in xtg
 *    xtg_chop: No chop if = 2
 *    xtg_debug: debug state
 */
STATUS
eXpressTGCore( DOUBLE slice_loc,
            INT xtg_disdaqs,
            INT xtg_views,
            INT xtg_nex,
            INT xtg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT rcv_freq;
    SHORT temp_short;
    INT rf3xtg_freq, rf4xtg_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    float rsp_PSphasoff=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    long tmp_period;

    if (XTGacq1 == PSD_ON)
    {
        xtg_acq1 = (int)DABON;
    }
    else
    {
        xtg_acq1 = (int)DABOFF;
    }
            
    printdbg("Entering eXpressTGCORE", (SHORT)xtg_debug);

    tmp_period = (long)init_xtg_deadtime;
    tmp_period = RUP_GRD(tmp_period);
                                                  
    boffset(off_seqxtg);
    setperiod(tmp_period, &seqxtg, 0);

    scopeon(&seqxtg);
    syncon(&seqxtg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasoff = PSphasoff_mod;

    attenlockoff(&xtg_attenkey);
    if(PSD_ON == local_tg)
    {
        slice_freq1 = GAM * a_gyrf1xtg * rsp_PSphasoff/
            (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    }
    else
    {
        slice_freq1 = GAM * a_gzrf1xtg * rsp_PStloc/
            (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    }

    slice_freq2 = GAM * a_gzrf2xtg * rsp_PStloc/
        (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
    rcv_freq = 2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov;

    setfrequency(slice_freq1, &rf1xtg,0);
    setfrequency(slice_freq2, &rf2xtg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1xtg, 0);
 
    if(PSdebugstate)
    {
        printf("\nXTG Slthick = %f xFOV = %f yFOV = %f Xmit location = %f, Rcv location  = %f, Phase off = %f\n", 
               TGopslthick, TGopslthickx, TGopslthicky, PStloc_mod, PSrloc_mod, PSphasoff_mod);

        printf("\nXTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","XTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
        printf("XTG: psc_vol_index = %d\n",psc_vol_index );
    }

    rf4xtg_freq = (int)(xtg_offres_freq/TARDIS_FREQ_RES);
    rf3xtg_freq = rf4xtg_freq;

    if(L_MPS1 == rspent)  /* set it off for MPS1 */
    {
        setiamp(0, &rf3xtg, 0);
        setiamp(0, &rf4xtg, 0);
    }
    else
    {
        setiamp(-ia_rf4xtg, &rf3xtg, 0);
        setiamp(ia_rf4xtg, &rf4xtg, 0);
    }

    for (view = (-xtg_disdaqs + 1) ; view <= xtg_views; view ++)
    {
        if( PSdebugstate )
        {
            printf("XTG: view = %d\n",view);
        }

        if(view == (-xtg_disdaqs + 1))
        {
            getiamp(&temp_short, &rf4xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-1.0*temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-1.0*temp_short, &rf3xtg, 0);
            }
            getiamp(&temp_short, &rf1xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-1.0*temp_short, &rf1xtg, 0);
            }
        }

        for (excitation = 1; excitation <= xtg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&xtg_attenkey);
                if (excitation == xtg_nex)
                    attenlockoff(&xtg_attenkey);
                if(XTGacq1 == PSD_ON)
                {
                    xtg_acq1 = (int)DABON;
                }
            }
            else
            {
                xtg_acq1 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1xtg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)xtg_acq1, PSD_LOAD_DAB_ALL);

            /* For SWIFT(expresstg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                        rsp_PSphasoff = rsp_info[psc_vol_index-1].rspphasoff;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                        rsp_PSphasoff = rsp_info[PStest_slab-1].rspphasoff;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"eXpresstgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq1 = GAM * a_gyrf1xtg * rsp_PSphasoff/
                    (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            }
            else
            {
                slice_freq1 = GAM * a_gzrf1xtg * rsp_PStloc/
                    (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            }

            slice_freq2 = GAM * a_gzrf2xtg * rsp_PStloc/
                (10* TARDIS_FREQ_RES); /* factor 10 is because rsptloc is in mm */
            rcv_freq = 2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov;
            
            setfrequency(slice_freq1, &rf1xtg,0);
            setfrequency(slice_freq2, &rf2xtg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                         &echo1xtg, 0);

            /* phase and freq cycling  */
            if(view%2 == 1) /* freq and phase cycling */
            {
                setfrequency(rf4xtg_freq, &rf4xtg, 0);
                setfrequency((-1.0*rf3xtg_freq), &rf3xtg, 0);

                /* phase cycling */
                getiamp(&temp_short, &rf4xtg, 0);
                setiamp(-1.0*temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-1.0*temp_short, &rf3xtg, 0);
            }
            else
            {
                setfrequency((-1.0*rf4xtg_freq), &rf4xtg, 0);
                setfrequency(rf3xtg_freq, &rf3xtg, 0);
            }
            
            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)xtg_debug);
            syncoff(&seqxtg);
 
            /* Chopper logic */
            getiamp(&temp_short, &rf1xtg,0);
            setiamp((-temp_short),&rf1xtg,0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end eXpressTGCore() */


/*
 *  ASautoshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASautoshim( void )
{
    SHORT temp_short;
    INT dix_shift;

    INT phase_step[3];
    INT phase_sign[3];
    INT yres_phase;

    long asrottemp[3][9]; /* vmx 3/6/95 YI */
    INT *rf1_freq;
    INT *receive_freq1;
    SHORT viewtable[513];
    long trigger_temp[3]; /* vmx 10/13/94 YI */
    INT acquire_echo1;
    INT dab_view,dab_op;
    SHORT disdaqs;
    FLOAT tempGAM;

    printdbg("Greetings from autoshim", debugstate);
    boffset(off_seqaushim);

    disdaqs = as_dda;
    tempGAM = GAM;
    GAM = GAMMA_PROTON; /*only shim on proton*/

    /**************************************************************
      so here's how we loop through this entry point:

        pass = rspslq;               each slice is a pass
        for all slices
           for all views              
             (first echo)           note: these aren't really 2echos,
             reset dixon shift to 0       we just pretend they are.
             do the disdaqs               there's really a separate
             do the baselines             excitation for each 'echo'.
             collect the data 'echo'
             (second echo)
             do dixon shift
             do the disdaqs
             do the baselines
             collect the data 'echo'
           next view
           decrement pass
           send pass packet
        next slice
        send end of scan packet
     ******************************************************************/

    setrfconfig((short) 5);

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    rf1_freq = (int *)AllocNode((as_slquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((as_slquant + 2)*sizeof(int));

    rf1_freq[0] = astloc1*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);
    rf1_freq[1] = astloc2*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);
    rf1_freq[2] = astloc3*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES);

    asrottemp[0][0] = hostToRspRotMat( asrot0 );  asrottemp[0][1] = hostToRspRotMat( asrot1 ); asrottemp[0][2] = hostToRspRotMat( asrot2 );  
    asrottemp[0][3] = hostToRspRotMat( asrot3 );  asrottemp[0][4] = hostToRspRotMat( asrot4 ); asrottemp[0][5] = hostToRspRotMat( asrot5 );
    asrottemp[0][6] = hostToRspRotMat( asrot6 );  asrottemp[0][7] = hostToRspRotMat( asrot7 ); asrottemp[0][8] = hostToRspRotMat( asrot8 );

    asrottemp[1][0] = hostToRspRotMat( asrot9 );  asrottemp[1][1] = hostToRspRotMat( asrot10 ); asrottemp[1][2] = hostToRspRotMat( asrot11 ); 
    asrottemp[1][3] = hostToRspRotMat( asrot12 ); asrottemp[1][4] = hostToRspRotMat( asrot13 ); asrottemp[1][5] = hostToRspRotMat( asrot14 );
    asrottemp[1][6] = hostToRspRotMat( asrot15 ); asrottemp[1][7] = hostToRspRotMat( asrot16 ); asrottemp[1][8] = hostToRspRotMat( asrot17 );

    asrottemp[2][0] = hostToRspRotMat( asrot18 ); asrottemp[2][1] = hostToRspRotMat( asrot19 ); asrottemp[2][2] = hostToRspRotMat( asrot20 ); 
    asrottemp[2][3] = hostToRspRotMat( asrot21 ); asrottemp[2][4] = hostToRspRotMat( asrot22 ); asrottemp[2][5] = hostToRspRotMat( asrot23 );
    asrottemp[2][6] = hostToRspRotMat( asrot24 ); asrottemp[2][7] = hostToRspRotMat( asrot25 ); asrottemp[2][8] = hostToRspRotMat( asrot26 );

    scalerotmats(asrottemp, &asloggrd, &phygrd, 3, asobl_debug);

    if(PSdebugstate)
    {
        printf("\n%d astlocs (1,2,3) -> %0f %0f %0f\n",
               as_slquant, astloc1, astloc2, astloc3);
        printf("\nrf1_freq (1,2,3) -> %d %d %d\n",
               rf1_freq[0], rf1_freq[1], rf1_freq[2]);
    }

    /* AutoShim Changes to Center Image always - HH- Sept 21, 2004 */
    /* Use asrot0 , asrot11 and asrot20 to decide on read and phase directions on the 3 planes */
    /* Slice 1 = Axial    - Z slice (astloc1) - X/Y read (astloc2/astloc3) - Y/X Phase (astloc3/astloc2) */
    /* Slice 2 = Sagittal - X slice (astloc2) - Z/Y read (astloc1/astloc3) - Y/Z Phase (astloc3/astloc1) */
    /* Slice 3 = Coronal  - Y slice (astloc3) - Z/X read (astloc1/astloc2) - X/Z Phase (astloc2/astloc1) */

/* Old Code */
    receive_freq1[0] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc1))/ TARDIS_FREQ_RES;
    receive_freq1[1] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc2))/ TARDIS_FREQ_RES;
    receive_freq1[2] = (PSfreq_offset[rspent] +
                        ((2 * echo1bwas*1000/ (asfov))
                         * asrloc3))/ TARDIS_FREQ_RES;

    phase_sign[0] = (asploc1 >= 0) ? 1 : -1;
    phase_step[0] = .5 + fabs(FS_2PI*asploc1/asfov);
    phase_step[0] = (phase_step[0] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[1] = (asploc2 >= 0) ? 1 : -1;
    phase_step[1] = .5 + fabs(FS_2PI*asploc2/asfov);
    phase_step[1] = (phase_step[1] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[2] = (asploc3 >= 0) ? 1 : -1;
    phase_step[2] = .5 + fabs(FS_2PI*asploc3/asfov);
    phase_step[2] = (phase_step[2] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    trigger_temp[0] = TRIG_INTERN;
    trigger_temp[1] = TRIG_INTERN;
    trigger_temp[2] = TRIG_INTERN;

    setupphasetable(viewtable, TYPNORM,(int)asyres);


    /* Set ssi time.  This is time from eos to start of sequence   */
    /* interrupt in internal triggering.  The minimum time is 50us */
    /* plus 2us*(number of waveform and instruction words modified */
    /* in the update queue).                                       */
    setssitime((LONG)time_ssias/HW_GRAD_UPDATE_TIME);

    settriggerarray(as_slquant, trigger_temp);

    if(PSdebugstate)
    {
        printf("\n AUTOSHIM VOLUME INDEX:  %d\n", as_index); 
        printf("\n AUTOSHIM:  FOV = %f astloc1 = %f, astloc2 = %f  astloc3  = %f\n", asfov, astloc1,astloc2,astloc3); 
        printf("\n AUTOSHIM:  asrloc1 = %f, asrloc2 = %f  asrloc3  = %f\n", asrloc1,asrloc2,asrloc3); 
        printf("\n AUTOSHIM:  asploc1 = %f, asploc2 = %f  asploc3  = %f\n", asploc1,asploc2,asploc3); 
        printf("\n AUTOSHIM:  asdim1 = %f, asdim2 = %f  asdim3  = %f\n", asdim1,asdim2,asdim3); 
        printf("%s\n", "AUTOSHIM:  Slice 1 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][0],asrottemp[0][1],asrottemp[0][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][3],asrottemp[0][4],asrottemp[0][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][6],asrottemp[0][7],asrottemp[0][8]);
        printf("%s\n", "AUTOSHIM:  Slice 2 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][0],asrottemp[1][1],asrottemp[1][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][3],asrottemp[1][4],asrottemp[1][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][6],asrottemp[1][7],asrottemp[1][8]);
        printf("%s\n", "AUTOSHIM:  Slice 3 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][0],asrottemp[2][1],asrottemp[2][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][3],asrottemp[2][4],asrottemp[2][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][6],asrottemp[2][7],asrottemp[2][8]);

        printf("\n AUTOSHIM SLICE1:   slice loc= %f read loc= %f phase loc= %f \n", astloc1, asrloc1, asploc1); 
        printf("\n AUTOSHIM SLICE2:   slice loc= %f read loc= %f phase loc= %f \n", astloc2, asrloc2, asploc2); 
        printf("\n AUTOSHIM SLICE3:   slice loc= %f read loc= %f phase loc= %f \n", astloc3, asrloc3, asploc3); 

        fflush(stdout);
    }

    setrotatearray(as_slquant,asrottemp[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyas);
    scopeon(&seqaushim);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqaushim);
    syncoff(&seqpassas);


    for (as_slice = 0; as_slice < as_slquant; as_slice++)
    {
        dab_op = DABSTORE;

        setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);

        for (as_view=(-(disdaqs+asbaseline)+1); as_view<= asyres; as_view++)
        {
            /* Collect baseline first and set RF to 0 for baseline collection */
            if (as_view <= -disdaqs)
            {
                setiamp((short)0, &rf1as, 0);
            }
            else if (as_view == -disdaqs+1) /* Disdaq collection after baseline and set RF amp for disdaqs/data acq */
            {
                setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);
            }

            if (as_view<=0)
            {
                /* for the baselines in each slice, set the phase encode
                   amplitude to the first view */
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[1], &gy1as, 0);
                setiampt(viewtable[1], &gy1ras, 0);

                setiphase(0,&echo1as,0);
            }
            else
            {
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[as_view], &gy1as, 0);
                setiampt(viewtable[as_view], &gy1ras, 0);

                setiphase(0,&echo1as,0);
                yres_phase = -phase_sign[as_slice]*(((as_view-1)* phase_step[as_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                setiphase(yres_phase, &echo1as, 0);
            }
            for (as_excitation=1; as_excitation <= 1; as_excitation++)
            {
                /* Scope Trigger */
                if ((rspsct == as_slice) || (rspsct == -1))
                {
                    scopeon(&seqaushim);
                }
                else
                {
                    scopeoff(&seqaushim);
                }
                /*MRIge33520 - VB*/
                acquire_echo1 = DABON; /* ON for baseline */
                if ((as_view > -disdaqs) && (as_view <= 0))  /* DABOFF for disdaq */
                {
                    acquire_echo1 = (int)DABOFF;
                }

                /* Load Transmit and Receive frequencies */
                setfrequency(rf1_freq[as_slice], &rf1as, 0);
                setfrequency(receive_freq1[as_slice], &echo1as, 0);

                if (as_view > 0)
                {
                    dab_view = as_view;
                    if (as_excitation == 1)
                    {
                        dab_op = 0;
                    }
                    else
                    {
                        dab_op = 3 - 2*(as_excitation % 2);
                    }
                }
                else
                {
                    dab_op = 0;
                    dab_view = 0;
                }

                /* set up the dixon shift for every other seq */
                for(dixon=0;dixon<=1;++dixon)
                {
                    dix_shift = (dixon % 2)*RUP_GRD((dix_timeas))+GRAD_UPDATE_TIME;
                    setperiod(dix_shift,&xdixon,0);
                    setperiod(dix_shift,&ydixon,0);
                    setperiod(dix_shift,&zdixon,0);
                    setperiod(dix_shift,&sdixon,0);
                    setperiod((int)(dix_shift - dixon*dix_timeas),&sdixon2,0);
                    /* All DAB Info is Set. Pretend even views are 2nd echo. */
                    /* Load up dab packet!                                   */
                    loaddab(&echo1as,(short)0,dixon,dab_op,dab_view,(TYPDAB_PACKETS)acquire_echo1, PSD_LOAD_DAB_ALL);

                    /*printdbg("S", debugstate);*/
                    startseq((short)as_slice, (short)MAY_PAUSE);

                    syncoff(&seqaushim);
                }

                getiamp(&temp_short, &rf1as, 0);
                setiamp(-temp_short, &rf1as, 0);

            } /* as_excitation */

        }  /* as_view */


        boffset(off_seqpassas);
        if (as_slice == (as_slquant-1)  ) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_aushim, 2);
            printdbg("End of Scan and Pass", debugstate);
        }
        else
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_aushim, 2);
            printdbg("End of Pass", debugstate);
        }


        startseq((short)0, (short)MAY_PAUSE);
        boffset(off_seqaushim);

    }

    /* Reset the rotation matrix */
    setrotatearray((short)opslquant,rsprot[0]);

    GAM = tempGAM;

    printdbg("Normal End of autoshim", debugstate);

    return SUCCESS;
} /* End of ASautoshim */

/*
 *  PSrfshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSrfshim( void )
{
    INT *rf1rs_freq;
    INT *rec_freq1rs;
    INT rs_slice, rs_view, DD_loop, tmp_DD_nCh;
    long rs_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT rs_yres_phase, rs_trains; 
    INT rs_yres_phase2toN[16];
    INT dab_view,dab_op, dabechors;
    INT acq_echors;
    INT i, tempi, rs_seq_count, rs_exphase, rs_rcphase, rs_seed;
    INT train_idx, bls_idx, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from RFShim B1 Map", debugstate);
    rspdda = rs_dda;
    rspsct = 0;

    rs_trains = rfshim_yres/rfshim_etl;

    boffset(off_seqrs);

    dabechors = 0;
    rs_seq_count = 0;
    rs_exphase = 0;
    rs_seed = 21001;


    /* set up phase offset arrays */
    for (i = 0; i < rfshim_slquant; i++)
    {
        if (rsrsp_info[i].rspphasoff >=0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = .5 + fabs(FS_2PI*rsrsp_info[i].rspphasoff/rfshim_fov);
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1rs_freq = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));
    rec_freq1rs = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));

    setupslices(rf1rs_freq, rsrsp_info, rfshim_slquant, a_gzrf1rs,
                               (float)1, rfshim_fov, TYPTRANSMIT);

    setupslices(rec_freq1rs, rsrsp_info, rfshim_slquant, (float)0,
                echo1bwrs, rfshim_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)rfshim_yres);
    phase_ordering(viewtab, rsphorder, rfshim_yres, rfshim_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1rs, 0);
    setiampt(0, &gy1rrs, 0);
    if(rfshim_etl >=2)
    {
        for(i=0;i<rfshim_etl-1;i++)
        {
            setiampt(0, &gy2rs, i);
        }
    }

    setiamp((short)ia_rf1rs, &rf1rs, 0);
    setiphase(0, &rf1rs, 0);

    setssitime((LONG)time_ssirs/HW_GRAD_UPDATE_TIME);

    for ( rs_slice = 0 ; rs_slice < rfshim_slquant; rs_slice++ )
    {
        rs_trigger[rs_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)rfshim_slquant, rs_trigger);

    setrotatearray((short)rfshim_slquant,rsrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyrs);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqrs);
    syncoff(&seqpassrs);

    for (rs_slice = 0; rs_slice < rfshim_slquant; rs_slice++)
    {
        tmp_DD_nCh = DD_nCh;

        if(PSdebugstate && (rs_slice >= 0))
        {
            printf("\n RFShim Sls = %i FOV = %f  slthick = %f\n", rfshim_slquant, rfshim_fov, rfshim_slthick);
            printf("\n RFShim Offsets: Tx = %f Rx = %f Phase = %f\n", rsrsp_info[rs_slice].rsptloc, 
                   rsrsp_info[rs_slice].rsprloc, rsrsp_info[rs_slice].rspphasoff);
            printf("%s\n"," RFShim Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][0], rsrsprot[0][1], rsrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][3], rsrsprot[0][4], rsrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][6], rsrsprot[0][7], rsrsprot[0][8]);
            fflush(stdout);
        }

        dab_op = DABSTORE;

        setiamp((short)ia_rf1rs, &rf1rs, 0);

        for (DD_loop=0;DD_loop<tmp_DD_nCh;DD_loop++)
        {
            if ((B1Cal_mode) || (0!=DD_debug))
            {
                boffset(off_seqIQControl);

                if(B1Cal_mode)
                {
                    if (0==(DD_loop%2))
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }
                else
                {
                    if (1==DD_debug)
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }

                settrigger((short)TRIG_INTERN, (short)0);

                startseq((SHORT)0,(SHORT)MAY_PAUSE);
            }

            boffset(off_seqrs);

            for (train_idx=(-(rs_dda+rfshim_baseline)+1); train_idx<= rs_trains; train_idx++)
            {
                if (train_idx > 0)
                {
                    rs_view = (train_idx-1)*rfshim_etl;
                    dab_view = viewtab[rs_view];

                    setiampt(-viewtable[dab_view], &gy1rs, 0);

                    if(rfshim_etl>=2)
                    {
                        for(tempi=0;tempi<rfshim_etl-1;tempi++)
                        {
                            setiampt(viewtable[viewtab[rs_view+tempi]]-viewtable[viewtab[rs_view+1+tempi]], &gy2rs, tempi);
                        }
                        setiampt(viewtable[viewtab[rs_view+rfshim_etl-1]], &gy1rrs, 0);
                    }
                    else
                    {
                        setiampt(viewtable[dab_view], &gy1rrs, 0);
                    }
                }
                else
                {
                    rs_view = 0;
                    dab_view = 0;
                }

                for (bls_idx = 0; bls_idx < 2; bls_idx++)
                {
                    dabechors = bls_idx;

                    if (0==bls_idx)
                    {
                        setiamp(ia_rfbrs_theta, &thetarfbrs, 0);
                    }
                    else
                    {
                        setiamp(-ia_rfbrs_theta, &thetarfbrs, 0);
                    }

                    dab_op = DABSTORE;


                    for (excitation=1; excitation <= 1; excitation++)
                    {
                        /* Scope Trigger */
                        if ((rspsct == rs_slice) || (rspsct == -1))
                        {
                            scopeon(&seqrs);
                        }
                        else
                        {
                            scopeoff(&seqrs);
                        }

                        if (train_idx > 0)
                        {
                            acq_echors = (int)DABON;
                        }
                        else
                        {
                            acq_echors = (int)DABOFF;
                        }

                        /* Load Transmit and Receive frequencies */
                        setfrequency(rf1rs_freq[rs_slice], &rf1rs, 0);
                        setfrequency(rec_freq1rs[rs_slice], &echo1rs, 0);

                        if (rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<(rfshim_etl-1);tempi++)
                            {
                                setfrequency(rec_freq1rs[rs_slice], &(rs_echo2toN[tempi]), 0);
                            }
                        }

                        if (train_idx > 0)
                        {
                            if (excitation == 1)
                            {
                                dab_op = 0;
                            }
                            else
                            {
                                dab_op = 3 - 2*(excitation % 2);
                            }

                            rs_yres_phase = phase_sign[rs_slice]*(((dab_view-1)*
                                                                   phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                        }
                        else
                        {
                            rs_yres_phase = 0;
                        }

                        if(rsspgr_flag)
                        {
                            rs_exphase = ((int)((float)rs_exphase + (float)rs_seq_count*rs_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            rs_seq_count++;
                            setiphase(rs_exphase, &rf1rs, 0);
                        }
                        else
                        {
                            rs_exphase = 0;
                        }

                        rs_rcphase = (rs_exphase + rs_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                        setiphase(rs_rcphase, &echo1rs, 0);

                        if(rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                rs_yres_phase2toN[tempi] = phase_sign[rs_slice]*
                                    (((viewtab[rs_view+tempi+1]-1)*phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                                rs_yres_phase2toN[tempi] = (rs_exphase + rs_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                                if (debug)
                                {
                                    sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,rs_yres_phase2toN[tempi]);
                                    printdbg(psddbgstr, debugstate);
                                    sprintf(psddbgstr,"view=%d;  slice=%d\n",rs_view, rs_slice);
                                    printdbg(psddbgstr, debugstate);
                                }

                                setiphase(rs_yres_phase2toN[tempi], &(rs_echo2toN[tempi]), 0);  /* yres phase */
                            }
                        }

                        /* Load up dab packet */
                        loaddab(&echo1rs,(short)0,dabechors+DD_loop*2,dab_op,dab_view,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                        if(rfshim_etl>=2)
                        {
                            INT temp_dabview;

                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                temp_dabview = viewtab[rs_view+tempi+1];
                                loaddab(&rs_echo2toN[tempi],(short)0,dabechors+DD_loop*2,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                            }
                        }

                        startseq((short)rs_slice, (short)MAY_PAUSE);

                        syncoff(&seqrs);

                    } /* excitation */
                } /* End of BLS cycling loop */

            }  /* End of Echo Train train_idx loop */

        }/* DD loop */

        boffset(off_seqpassrs);
        if (rs_slice == (rfshim_slquant-1)) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_rs, 2);
            printdbg("End of Scan and Pass", debugstate);
        }
        else if (rs_slice >=0)
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_rs, 2);
            printdbg("End of Pass", debugstate);
        }
        else 
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD, &pass_rs, 2);
            printdbg("dummy slice", debugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqrs);

        if (B1Cal_mode && (rs_slice == (rfshim_slquant-1)))
        {
            boffset(off_seqIQControl);

            /* Enable I & Q channels again */
            setwamp(SSPD, &dDDIQ, 2);

            settrigger((short)TRIG_INTERN, (short)0);

            startseq((SHORT)0,(SHORT)MAY_PAUSE);
        }

    } /* End of slice loop */

    printdbg("Normal End of RFShim Map", debugstate);

    return SUCCESS;
}   /* end PSrfshim() */


/*
 *  PSdyntg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSdyntg( void )
{
    INT *rf1dtg_freq;
    INT *rec_freq1dtg;
    INT dtg_slice, dtg_trains;
    INT train_idx, bls_idx;
    INT tempi;
    long dtg_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT dtg_yres_phase; 
    INT dtg_yres_phase2toN[16];
    INT dtg_view, dab_view, dab_op, dabechodtg;
    INT acq_echodtg;
    INT i, dtg_seq_count, dtg_exphase, dtg_rcphase, dtg_seed, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from dynTG B1Map", debugstate);
    rspdda = dtg_dda;
    rspsct = 0;

    dtg_trains = dynTG_yres/dynTG_etl;

    boffset(off_seqdtg);

    dabechodtg = 0;
    dtg_seq_count = 0;
    dtg_exphase = 0;
    dtg_seed = 21001;

    /* set up phase offset arrays */
    for (i = 0; i < dynTG_slquant; i++)
    {
        if (dtgrsp_info[i].rspphasoff >=0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = .5 + fabs(FS_2PI*dtgrsp_info[i].rspphasoff/dynTG_fov);
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1dtg_freq = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));
    rec_freq1dtg = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));

    setupslices(rf1dtg_freq, dtgrsp_info, dynTG_slquant, a_gzrf1dtg,
                               (float)1, dynTG_fov, TYPTRANSMIT);

    setupslices(rec_freq1dtg, dtgrsp_info, dynTG_slquant, (float)0,
                echo1bwdtg, dynTG_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)dynTG_yres);
    phase_ordering(viewtab, dtgphorder, dynTG_yres, dynTG_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1dtg, 0);
    setiampt(0, &gy1rdtg, 0);
    if(dynTG_etl>=2)
    {
        for(tempi=0;tempi<dynTG_etl-1;tempi++)
        {
            setiampt(0, &gy2dtg, tempi);
        }
    }

    setiamp((short)ia_rf1dtg, &rf1dtg, 0);
    setiphase(0, &rf1dtg, 0);

    setssitime((LONG)time_ssidtg/HW_GRAD_UPDATE_TIME);

    for ( dtg_slice = 0 ; dtg_slice < dynTG_slquant; dtg_slice++ )
    {
        dtg_trigger[dtg_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)dynTG_slquant, dtg_trigger);

    setrotatearray((short)dynTG_slquant,dtgrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keydtg);
    scopeon(&seqdtg);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqdtg);
    syncoff(&seqpassdtg);

    boffset(off_seqdtg);

    for (dtg_slice = 0; dtg_slice < dynTG_slquant; dtg_slice++)
    {
        if(PSdebugstate && (dtg_slice >= 0))
        {
            printf("\n DynTG Sls = %i FOV = %f  slthick = %f\n", dynTG_slquant, dynTG_fov, dynTG_slthick);
            printf("\n DynTG Offsets: Tx = %f Rx = %f Phase = %f\n", dtgrsp_info[dtg_slice].rsptloc, 
                   dtgrsp_info[dtg_slice].rsprloc, dtgrsp_info[dtg_slice].rspphasoff);
            printf("%s\n"," DynTG Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][0], dtgrsprot[0][1], dtgrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][3], dtgrsprot[0][4], dtgrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][6], dtgrsprot[0][7], dtgrsprot[0][8]);
            fflush(stdout);
        }
        for (train_idx=-rspdda-dynTG_baseline; train_idx<= dtg_trains; train_idx++)
        {

            if (train_idx > 0)
            {
                dtg_view = (train_idx-1)*dynTG_etl;
                dab_view = viewtab[dtg_view];

                /* If after disdaqs, set phase encoding gradients. */
                setiampt(-viewtable[dab_view], &gy1dtg, 0);

                if(dynTG_etl>=2)
                {
                    for(tempi=0;tempi<dynTG_etl-1;tempi++)
                    {
                        setiampt(viewtable[viewtab[dtg_view+tempi]]-viewtable[viewtab[dtg_view+1+tempi]], &gy2dtg, tempi);
                    }
                    setiampt(viewtable[viewtab[dtg_view+dynTG_etl-1]], &gy1rdtg, 0);
                }
                else
                {
                    setiampt(viewtable[dab_view], &gy1rdtg, 0);
                }
            }
            else
            {
                dtg_view = 0;
                dab_view = 0;
            }

            /* BLS cycling loop */
            for (bls_idx = 0; bls_idx < 2; bls_idx++)
            {
                dabechodtg = bls_idx;

                if (0==bls_idx)
                {
                    setiamp(ia_rfbdtg_theta, &thetarfbdtg, 0);
                }
                else
                {
                    setiamp(-ia_rfbdtg_theta, &thetarfbdtg, 0);
                }

                dab_op = DABSTORE;


                for (excitation=1; excitation <= 1; excitation++)
                {
                    /* Scope Trigger */
                    if ((rspsct == dtg_slice) || (rspsct == -1))
                    {
                        scopeon(&seqdtg);
                    }
                    else
                    {
                        scopeoff(&seqdtg);
                    }

                    if (train_idx > 0)
                    {
                        acq_echodtg = (int)DABON;
                    }
                    else
                    {
                        acq_echodtg = (int)DABOFF;
                    }

                    /* Load Transmit and Receive frequencies */
                    setfrequency(rf1dtg_freq[dtg_slice], &rf1dtg, 0);
                    setfrequency(rec_freq1dtg[dtg_slice], &echo1dtg, 0);
                    if (dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<(dynTG_etl-1);tempi++)
                        {
                            setfrequency(rec_freq1dtg[dtg_slice], &(dtg_echo2toN[tempi]), 0);
                        } 
                    }

                    if (train_idx > 0)
                    {
                        if (excitation == 1)
                        {
                            dab_op = 0;
                        }
                        else
                        {
                            dab_op = 3 - 2*(excitation % 2);
                        }

                        dtg_yres_phase = phase_sign[dtg_slice]*(((dab_view-1)*
                                                                 phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                    }
                    else
                    {
                        dtg_yres_phase = 0;
                    }

                    if(dtgspgr_flag)
                    {
                        dtg_exphase = ((int)((float)dtg_exphase + (float)dtg_seq_count*dtg_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                        dtg_seq_count++;
                        setiphase(dtg_exphase, &rf1dtg, 0);
                    }
                    else
                    {
                        dtg_exphase = 0;
                    }

                    dtg_rcphase = (dtg_exphase + dtg_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                    setiphase(dtg_rcphase, &echo1dtg, 0);
                    if(dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            dtg_yres_phase2toN[tempi] = phase_sign[dtg_slice]*
                                (((viewtab[dtg_view+tempi+1]-1)*phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                            dtg_yres_phase2toN[tempi] = (dtg_exphase + dtg_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                            setiphase(dtg_yres_phase2toN[tempi], &(dtg_echo2toN[tempi]), 0);  /* yres phase */
                            if (debug)
                            {
                                sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,dtg_yres_phase2toN[tempi]);
                                printdbg(psddbgstr, debugstate);
                            }

                        }
                    }

                    /* Load up dab packet */
                    loaddab(&echo1dtg,(short)0,dabechodtg,dab_op,dab_view,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);

                    if(dynTG_etl>=2)
                    {
                        INT temp_dabview;
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            temp_dabview = viewtab[dtg_view+tempi+1];
                            loaddab(&dtg_echo2toN[tempi],(short)0,dabechodtg,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);
                        }
                    }

                    startseq((short)dtg_slice, (short)MAY_PAUSE);

                    syncoff(&seqdtg);

                } /* excitation */
            }  /* End of BLS cycling loop */
        } /* End of Echo Train train_idx loop */

        /* now it is one pass for all dtg slices */
        boffset(off_seqpassdtg);
        if (dtg_slice == (dynTG_slquant-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_dtg, 2);
            printdbg("End of Scan and Pass", debugstate);
        }
        else if (dtg_slice >=0)
        {
            setwamp(SSPD + DABPASS, &pass_dtg, 2);
            printdbg("End of Pass", debugstate);
        }
        else 
        {
            setwamp(SSPD, &pass_dtg, 2);
            printdbg("dummy slice", debugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqdtg);

    } /* End of Slice dtg_slice loop */

    printdbg("Normal End of dynTG B1Map", debugstate);

    return SUCCESS;
}   /* end PSdyntg() */


/* CoilSwitchSetCoil
 *
 *  Description: MRIhc15304
 *    This sets the RF HUB index for the coil by changing the data on an ssp
 *    pulse and/or with the sethubindeximm function.  Also calls
 *    setrcvportimm, if requested.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  
 *  (O) STATUS return variable - Did function complete successfully.
 *  (I) const COIL_INFO - coil info structure of coil to switch to
 *  (I) const INT setRcvPortFlag - Flag indicating that setrcvportimm needs
 *        to be executed.  This needs to be set whenever switching to or
 *        from the BODY coil.
 *  
 *  Globals:
 *  (I) txCoilInfo
 *
 */

STATUS
CoilSwitchSetCoil( const COIL_INFO coil,
                   const INT setRcvPortFlag)
{
    SHORT device = 0;

    if( setRcvPortFlag || (COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod) )
    {
        int wait_rspimm = 0;

        /* MRIhc14300: When switching coils, play a delay sequence to
           wait for scan prep to complete and scanning to start before the
           first setrcvportimm() & sethubindeximm().  These functions may not
           be called until scanning starts and the first startseq will not
           return until scanning starts. After scanning has started this will
           merely add an additional short delay to the switch time */

        boffset(off_seqcswWaitBefore);
        startseq((short)0, (SHORT)MAY_PAUSE);

        /* Need additional delay for setrcvpowerimm & sethubindeximm
         * to take effect.  The delay time must be set to guarantee
         * the completion of both setrcvportimm and sethubindeximm */

        if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
        {
            wait_rspimm = csw_wait_sethubindeximm;
        }

        if( setRcvPortFlag )
        {
            wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
        }

        setperiod(wait_rspimm, &csw_wait, 0);
    }
    else
    {
        /* No additional delay needed when not calling setrcvportimm */
        setperiod(SSP_UPDATE_TIME, &csw_wait, 0);
    }

    /* Setup hub index switching packet */
    device = 0;
    if( COIL_SWITCH_SSP_HUB_INDEX & cfcoilswitchmethod )
    {
        device = RDC;
        /* Set hub index on SSP packet */
        setwamp( (SHORT)(SSPD | (HUBIND + coil.hubIndex)), &contrfhubsel, (LONG)2 );
    }
    setwamp( (SHORT)(SSPDS | device), &contrfhubsel, (LONG)0 );

    /* Set receiver port & receiver input */
    if( setRcvPortFlag || (COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod) )
    {
        SHORT coil_port = PSD_RP_BODY;
        SHORT rcv_input = RFBODYI;

        /* Calculate coil port & receiver input */
        switch (coil.rxCoilType) 
        {
        case RX_COIL_BODY:
        default:
            /* Transmit & receive with body coil */
            coil_port = PSD_RP_BODY;
            rcv_input = RFBODYI;
            break;
        case RX_COIL_LOCAL:
            {
                /* Assume there is only one transmit coil.  If two transmit
                   coils, the primary will be used */
                n32 txCoilType = TX_INDEX_NONE; 
                if (TX_INDEX_NONE != coil.txIndexPri)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexPri].txCoilType;
                }
                else if (TX_INDEX_NONE != coil.txIndexSec)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexSec].txCoilType;
                }
                else
                {
                    printf("CoilSwitchSetCoil: No transmit coil defined!\n");
                    return FAILURE;
                }

                if (TX_COIL_LOCAL == txCoilType)
                {
                    /* Local transmit coil */
                    coil_port = PSD_RP_HEAD;
                    rcv_input = RHEADI;
                }
                else
                {
                    /* Surface coil */
                    coil_port = PSD_RP_SURFACE;
                    rcv_input = RFAUX;
                }
            }
            break;
        }

        /* Setup receiver input switching packet */
        device = 0;
        if( COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod )
        {
            device = RDC;
            setwamp( (SHORT)(SSPD | rcv_input), &contrfsel, (LONG)2 );
        }
        setwamp( (SHORT)(SSPDS | device), &contrfsel, (LONG)0 );

        /* Set receiver port using RSP function call when switching to/from 
         * body coil */
        if (setRcvPortFlag) 
        {
#ifdef PSD_HW
            setrcvportimm( (SHORT)coil_port );
#endif /* PSD_HW */
        }
    }

    /* Select coil using RSP function on MGD Rx chain */
    if(COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod)
    {
        sethubindeximm( coil.hubIndex );
    }
   
    boffset( off_seqcsw );
    startseq( (short)0, (SHORT)MAY_PAUSE );
    return SUCCESS;
}

/* phase_ordering 
 *
 *  Description: function for different phase ordering
 *  (O) SHORT* view_tab : View table with view acquisition order.
 *  (I) INT phase_order : Phase order variable.  Phase order types are:
 *           SEQUENTIAL 0
 *           CENTRIC 1
 *  (I) INT yviews : Number of views acquired in the scan.
 *
 *
*******************************/
STATUS
phase_ordering( SHORT *view_tab,
                const INT phase_order,
                const INT yviews, const INT yetl)
{
    INT i, j, num_trains, center;
    STATUS status = SUCCESS;

    num_trains = yviews/yetl;


    if(yetl >= 2)
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL: 
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (i*2)*yetl+j+1;
                        view_tab[(i*2+1)*yetl+j] = (i*2+1)*yetl+j+1; 
                    }
                }
                break;
            case PH_CENTRIC_LOW:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (yviews/2 - i - j*num_trains/2);
                        view_tab[(i*2+1)*yetl+j] = (yviews/2 + i + 1 + j*num_trains/2);
                    }
                }
                break;
            case PH_CENTRIC_HIGH:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = yviews/2 + i - j*num_trains/2 - num_trains/2 + 1;
                        view_tab[(i*2+1)*yetl+j] = yviews/2 - i + j*num_trains/2 + num_trains/2;
                    }
                }
                break;
        }
    }
    else
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL:
                {
                    for(i=0;i<yviews;i++)
                    {
                        view_tab[i]=i+1;
                    }
                }
                break;
            case PH_CENTRIC_LOW:
            case PH_CENTRIC_HIGH:
                center = yviews/2;

                for( i = 0, j = 0; i < yviews/ 2; ++i, j += 2 )
                {
                    view_tab[j % yviews] = center - i;
                    view_tab[(j + 1) % yviews] = center + i + 1;
                }
                break;
        }
    }
    return status;
}





/**
 *******************************************************************************************************
 @brief #### Not sure what this function does, but it exists in all product psds.
********************************************************************************************************/
void dummylinks(void) {
  epic_loadcvs( "thefile" ); /* for downloading CVs */
}




/**
 *******************************************************************************************************
 @brief #### RSP Init. To be inserted in the psdinit() function (or scan()) in the main sequence
********************************************************************************************************/
void GEReq_initRSP(void) {

  /* Initialize everything to a known state */
  setrfconfig((short) ks_rfconf);   /* ENBL_RHO1 + ENBL_THETA + ENBL_OMEGA + ENBL_OMEGA_FREQ_XTR1 = 141 */
  rspqueueinit(200);  /* Initialize to 200 entries */
  syncoff(&GEpass);   /* Deactivate sync during pass */
}

/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSSpSat.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
  *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSSpSat.e
* @brief This file contains Spatial Sat and should be `@inline`'d at the beginning of a KSFoundation PSD
********************************************************************************************************/

/*******************************************************************************************************
*******************************************************************************************************
*
*  KSSpSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/








/**
 *******************************************************************************************************
 @brief #### The ksspsat (spatial sat) pulse sequence module

 This is the spatial sat sequence module in ksspsat.e using the sequence objects in KSSPSAT_SEQUENCE with
 the sequence module name "ksspsat" (= ksspsat.seqctrl.description). On HOST, the minimum duration
of the sequence module is set by ks_eval_seqctrl_setminduration().

@param[in, out] ksspsat Pointer to KSSPSAT_SEQUENCE
@retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_pg(KSSPSAT_SEQUENCE *ksspsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  if (ksspsat->satlocation.active == KSSPSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksspsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* SelRF (including postgrad for spoiler) */
  loc.board = ksspsat->satlocation.gradboard;
  status = ks_pg_selrf(&ksspsat->selrf, loc, &ksspsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Optional spoiling using the postgrad trapezoid on the remaining two axes */
  if (ksspsat_params.spoilallaxes) {
    KS_SEQLOC tmploc = loc;
    tmploc.pos += ksspsat->selrf.grad.duration;
    switch (ksspsat->satlocation.gradboard) {
    case XGRAD:
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case YGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case ZGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    }
  }

  loc.pos += ksspsat->selrf.grad.duration + ksspsat->selrf.postgrad.duration + KS_RFSSP_POSTTIME;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (ksspsat->seqctrl.ssi_time must be > 0 and is added to ksspsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if ksspsat_params.satmode = KSSPSAT_OFF, then 2nd arg will be zero, making both ksspsat->seqctrl.min_duration and .duration = 0 */
  ksspsat->seqctrl.ssi_time = ksspsat_params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksspsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksspsat_pg() */



STATUS ksspsat_pulsegen() {
  int i;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    if (ksspsat[i].satlocation.active != KSSPSAT_OFF) {

      ksspsat_pg(&ksspsat[i]);

      switch (i) {
      case KSSPSAT_1:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat1, "seqKSSpSat1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat1, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat1 = %d\n", idx_seqKSSpSat1 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat1;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_2:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat2, "seqKSSpSat2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat2, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat2 = %d\n", idx_seqKSSpSat2 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat2;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_3:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat3, "seqKSSpSat3");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat3, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat3);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat3 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat3 = %d\n", idx_seqKSSpSat3 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat3;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat3;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat3;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_4:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat4, "seqKSSpSat4");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat4, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat4);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat4 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat4 = %d\n", idx_seqKSSpSat4 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat4;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat4;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat4;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_5:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat5, "seqKSSpSat5");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat5, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat5);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat5 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat5 = %d\n", idx_seqKSSpSat5 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat5;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat5;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat5;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_6:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat6, "seqKSSpSat6");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat6, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat6);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat6 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat6 = %d\n", idx_seqKSSpSat6 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat6;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat6;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat6;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      }

    }
  }

  return SUCCESS;
}





/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE

 This function sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE,
 incl. gradient amplitude changes, RF freq/phase for the current slice position.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void ksspsat_scan_seqstate(KSSPSAT_SEQUENCE *ksspsat, float rfphase) {
#ifdef IPG

  if (ksspsat->satlocation.active != KSSPSAT_OFF) {
    ks_scan_rotate(ksspsat->satlocation.loc);
    ks_scan_selrf_setfreqphase(&ksspsat->selrf, 0, ksspsat->satlocation.loc, rfphase);
  }

#endif
}




int ksspsat_scan_playsequences(int perform_slicetimeplot) {
  int i;
  int time = 0;
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {

    ksspsat_scan_seqstate(&ksspsat[i], rfphase);

    time += ks_scan_playsequence(&ksspsat[i].seqctrl);

    if (perform_slicetimeplot) {
      /* spatial sat not necessarily in the slice direction, so can't trust its thickness or direction.
        save it as 1000 mm thick at center (0) for now just to be able to mark it in time in the plot */
      ks_plot_slicetime(&ksspsat[i].seqctrl, 1, NULL, KS_NOTSET, KS_PLOT_STANDARD);
    }

  }

  return time;
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSChemSat.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
  *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSChemSat.e
* @brief This file contains FatSat (KSChemSat) and should be `@inline`'d at the beginning of a KSFoundation PSD
********************************************************************************************************/

/*******************************************************************************************************
*******************************************************************************************************
*
*  KSChemSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### The kschemsat (fatsat) pulse sequence module

 This is the fatsat sequence module in kschemsat.e using the sequence objects in KSCHEMSAT_SEQUENCE with
 the sequence module name "kschemsat" (= kschemsat.seqctrl.description). On HOST, the minimum duration
 of the sequence module is set by ks_eval_seqctrl_setminduration().

 @param[in,out] kschemsat Pointer to KSCHEMSAT_SEQUENCE
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS kschemsat_pg(KSCHEMSAT_SEQUENCE *kschemsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  /* return early if sat mode is off */
  if (kschemsat->params.satmode == KSCHEMSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (kschemsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* RF */
  status = ks_pg_rf(&kschemsat->rf, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->rf.rfwave.duration;

  /* Y spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Z spoiler */
  loc.board = ZGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->spoiler.duration;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (kschemsat->seqctrl.ssi_time must be > 0 and is added to kschemsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if kschemsat->params.satmode = KSCHEMSAT_OFF, then 2nd arg will be zero, making both kschemsat->seqctrl.min_duration and .duration = 0 */
  kschemsat->seqctrl.ssi_time = kschemsat->params.ssi_time;
  ks_eval_seqctrl_setminduration(&kschemsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* kschemsat_pg() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE

 This function sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE,
 incl. gradient amplitude and RF phase changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void kschemsat_scan_seqstate(KSCHEMSAT_SEQUENCE *kschemsat) {
#ifdef IPG
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  ks_scan_rf_setphase(&kschemsat->rf, INSTRALL, rfphase);

#endif
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSInversion.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSInversion.e
* @brief This file contains an inversion preparation module that should be `@inline`'d at the beginning
         of a KSFoundation PSD
********************************************************************************************************/




/*******************************************************************************************************
*******************************************************************************************************
*
*  KSInversion.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/

KS_MAT4x4 Mphysical_inversion = KS_MAT4x4_IDENTITY;




/**
 *******************************************************************************************************
 @brief #### Generation of the waveforms for the sequence objects in a KSINV_SEQUENCE

 Two KSINV_SEQUENCE structs are currently declared in KSInversion.e, `ksinv1` and `ksinv2`. By passing
 each one of them to this function, will generate the actual sequence on TGT. On HOST, the
 `seqctrl.min_duration` field is set and used by TI/TR calculations.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_pg(KSINV_SEQUENCE *ksinv) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;


  if (ksinv->params.irmode == KSINV_OFF)
    return SUCCESS;

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksinv->seqctrl.duration == 0)
    return SUCCESS;
#endif


  loc.pos = ksinv->params.startpos;

  if (loc.pos % GRAD_UPDATE_TIME) {
    return ks_error("%s: Start position of RF pulse must be divisible by GRAD_UPDATE_TIME (ksinv->params.rfstartpos = %d)", __FUNCTION__, ksinv->params.startpos);
  }
  if (loc.pos < KS_RFSSP_PRETIME) {
    return ks_error("%s: Start position of RF pulse must be at least %d [us] (ksinv->params.rfstartpos = %d)", __FUNCTION__, KS_RFSSP_PRETIME, ksinv->params.startpos);
  }

  /* RF */
  if (ksinv_slicecheck){
    loc.board = XGRAD;
  } else {
    loc.board = ZGRAD;
  }


  if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {

    if (ks_pg_selrf(&ksinv->selrfexc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;

    int mag_center_exc = loc.pos + ksinv->selrfexc.grad.ramptime + ksinv->selrfexc.rf.start2iso;

    /* now refocussing pulses*/
    /* we make sure that that delta_t_refoc/2 is a multiple of GRAD_UPDATE_TIME using the RUP_GRD function (division results are integer truncated) */
    int delta_t_refoc_half = RUP_GRD(ksinv->params.t2prep_TE/ ksinv->params.N_Refoc/ 2);

    /* first refocusing pulse*/
    loc.pos = mag_center_exc + delta_t_refoc_half - ksinv->selrfrefoc.grad.ramptime - ksinv->selrfrefoc.rf.start2iso - ksinv->selrfrefoc.pregrad.duration;
    if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    /* all other refocusing pulses*/
    int n;
    for (n = 1; n < ksinv->params.N_Refoc; n++) {
      loc.pos += 2*delta_t_refoc_half;
      if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
    }

    /***************************************************************************************************
     *  two different versions
     *  non adiabatic (+90)-(n*180)-(+90)
     *  adiabatic (+90)-(n*180)-(-90)-(180)
     *  the polarity of the flip angle of the flip pulse is set with loc.ampscale
     ***************************************************************************************************/

    loc.pos = mag_center_exc + ksinv->params.N_Refoc*delta_t_refoc_half*2 - ksinv->selrfflip.grad.ramptime - ksinv->selrfflip.rf.start2iso - ksinv->selrfflip.pregrad.duration;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      loc.ampscale = -1;
    } else {
      loc.ampscale = 1;
    }

    if (ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    
    /* Save absolute time in sequence for moment start, it is important to do that after 
    ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) because otherwise ksinv->seqctrl.momentstart would be overwritten as
    the "ROLE" of selrfflip is an excitation pulse, there is no ROLE for a flipup pulse yet */
    ksinv->seqctrl.momentstart = mag_center_exc;   

    loc.ampscale = 1; /* set it back to default */
    /* waveform overlap problems between selrfflip and selrfinv on DV25 --> 5*GRAD_UPDATE_TIME safety margin */
    loc.pos += ksinv->selrfflip.pregrad.duration + ksinv->selrfflip.grad.duration + 5*GRAD_UPDATE_TIME;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      if (ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
      loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;
    }
  } else {

    /* Save absolute time in sequence for moment start */
    ksinv->seqctrl.momentstart = loc.pos + ksinv->selrfinv.grad.ramptime + ksinv->selrfinv.rf.start2iso;

    status = ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl);
    if (status != SUCCESS) return status;

    loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;

  }

  /* Z spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&ksinv->spoiler, loc, &ksinv->seqctrl);
  if (status != SUCCESS) return status;
  loc.pos += ksinv->spoiler.duration;


 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksinv->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence module duration (ksinv->seqctrl.ssi_time must be > 0 and is added to ksinv->seqctrl.min_duration in ks_eval_seqctrl_setminduration()) */
  ksinv->seqctrl.ssi_time = ksinv->params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksinv->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif


  return SUCCESS;

} /* ksinv_pg() */




/**
 *******************************************************************************************************
 @brief #### Generation of all inversion-related sequence modules

 This function should be called directly from the `pulsegen()` function in a psd to create up to three
 sequence modules that can be used during scan.

 N.B.: If ksinvX.seqctrl.duration = 0, both ksinv_pg() and KS_SEQLENGTH() will return early avoiding this
 sequence module to be created. Similarly for the seqInvFillTR wait sequence.

 @return void
********************************************************************************************************/
void ksinv_pulsegen() {

  /* First (only) Inversion sequence module */
  ksinv_pg(&ksinv1);
   
    {
      if (ksinv1.seqctrl.duration > 0) {

        if (ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv1.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv1, "seqInv1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv1) failed", ksinv1.seqctrl.description);
          }  
          status = createseq(&seqInv1, ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time, off_seqInv1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv1) failed", ksinv1.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv1) failed", ksinv1.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv1 = %d\n", idx_seqInv1 );
          ksinv1.seqctrl.handle.index = idx_seqInv1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv1.seqctrl.handle.offset = off_seqInv1;
          ksinv1.seqctrl.handle.pulse = &seqInv1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv1.seqctrl.duration = 0 */

  /* 2nd Inversion sequence module */
  ksinv_pg(&ksinv2);
   
    {
      if (ksinv2.seqctrl.duration > 0) {

        if (ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv2.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv2, "seqInv2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv2) failed", ksinv2.seqctrl.description);
          }  
          status = createseq(&seqInv2, ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time, off_seqInv2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv2) failed", ksinv2.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv2) failed", ksinv2.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv2 = %d\n", idx_seqInv2 );
          ksinv2.seqctrl.handle.index = idx_seqInv2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv2.seqctrl.handle.offset = off_seqInv2;
          ksinv2.seqctrl.handle.pulse = &seqInv2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv2.seqctrl.duration = 0 */

  /* FillTR sequence for some inversion cases */
   
    {
      if (ksinv_filltr.duration > 0) {

        if (ksinv_filltr.duration - ksinv_filltr.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv_filltr.description);

        } else {

          STATUS status = pulsename(&seqInvFillTR, "seqInvFillTR");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInvFillTR) failed", ksinv_filltr.description);
          }  
          status = createseq(&seqInvFillTR, ksinv_filltr.duration - ksinv_filltr.ssi_time, off_seqInvFillTR);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInvFillTR) failed", ksinv_filltr.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInvFillTR );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInvFillTR) failed", ksinv_filltr.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInvFillTR = %d\n", idx_seqInvFillTR );
          ksinv_filltr.handle.index = idx_seqInvFillTR;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv_filltr.handle.offset = off_seqInvFillTR;
          ksinv_filltr.handle.pulse = &seqInvFillTR;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv_filltr.duration = 0 */

} /* ksinv_pulsegen() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of a KSINV_SEQUENCE during scanning

 This function sets the current state of all `ksinv` sequence objects being part of KSINV_SEQUENCE,
 specifically slice-dependent RF freq/phases changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] ksinv Pointer to KSINV_SEQUENCE
 @param[in] slice_info Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_scan_seqstate(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_info) {

  if (ksinv->params.irmode == KSINV_OFF || ksinv->seqctrl.duration == 0)
    return SUCCESS;

  if (slice_info != NULL) {

    ks_scan_rotate(*slice_info);

    if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
      ks_scan_rf_on(&ksinv->selrfexc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfexc, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfrefoc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfrefoc, INSTRALL, *slice_info, 90);

      ks_scan_rf_on(&ksinv->selrfinv.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfinv, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfflip.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfflip, INSTRALL, *slice_info, 0);

    } else {  
      ks_scan_rf_on(&ksinv->selrfinv.rf, 0);

      if (ksinv->selrfinv.sms_info.pulse_type == KS_SELRF_SMS_PINS_DANTE) {
        ks_scan_selrf_setfreqphase_pins(&ksinv->selrfinv, 0, *slice_info,
                                        ksinv->selrfinv.sms_info.mb_factor, ksinv->selrfinv.sms_info.slice_gap, 0.0);
      } else {
        ks_scan_selrf_setfreqphase(&ksinv->selrfinv, 0, *slice_info, 0);
      }
    }

  } else {

    ks_scan_rf_off(&ksinv->selrfinv.rf, 0);

  }

  return SUCCESS;

} /* ksinv_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Plays out one inversion slice in real time during scanning

  On TGT on the MR system (PSD_HW), this function sets up (ksepi_scan_seqstate()) and plays out one
  KSINV_SEQUENCE. The low-level function call `startseq()`, which actually starts the realtime sequence
  playout is called from within ks_scan_playsequence(), which in addition also returns the time to play
  out that sequence module (see time += ...).

  On HOST (in ksepi_eval_tr()) we call ksepi_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksepi_scan_scantime(), which returns the total time of the
  entire scan.

  @param[in] ksinv Pointer to KSINV_SEQUENCE
  @param[in] slice_pos Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
  @retval irtime Time taken in [us] to play out one inversion slice
********************************************************************************************************/
int ksinv_scan_irslice(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_pos) {
  SCAN_INFO slice_pos_updated;
  int time = 0;
  float tloc = 0.0;

  if (ksinv == NULL) {
    return 0;
  }

  if (ksinv->params.irmode != KSINV_OFF && ksinv->seqctrl.duration > 0) {

    if (slice_pos != NULL) {
      /* N.B.: Mphysical_inversion is an ipgexport KS_MAT4x4 variable that e.g. the main sequence can update in real time */
      ks_scan_update_slice_location(&slice_pos_updated, *slice_pos, Mphysical_inversion, NULL);
      tloc = slice_pos_updated.optloc;
      ksinv_scan_seqstate(ksinv, &slice_pos_updated);
    } else {
      ksinv_scan_seqstate(ksinv, slice_pos);
    }

    /* SMS offset */
    float offset = (ksinv->selrfinv.sms_info.slice_gap/ 2) * (ksinv->selrfinv.sms_info.mb_factor - 1);
    float sms_slice_positions[ksinv->selrfinv.sms_info.mb_factor];
    int slice = 0;
    for (slice = 0; slice < ksinv->selrfinv.sms_info.mb_factor; ++slice) {
      if (slice_pos != NULL)
        sms_slice_positions[slice] = tloc + ksinv->selrfinv.sms_info.slice_gap * (0.5 + slice - (ksinv->selrfinv.sms_info.mb_factor/ 2.0)) + offset;
      else
        sms_slice_positions[slice] = 0;
    }

    ks_plot_slicetime(&ksinv->seqctrl,
                      ksinv->selrfinv.sms_info.mb_factor,
                      sms_slice_positions,
                      ksinv->selrfinv.slthick,
                      slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

    time += ks_scan_playsequence(&ksinv->seqctrl);

  }

  return time;

} /* ksinv_scan_irslice() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slice_plan.nslices_per_pass` slices corresponding to one TR for inversion psds

 This function should replace the sliceloop function of a 2D psd when inversion is enabled. It will take
 over the sequence timing for one TR by playing out the inversion sequence module(s) and other sequence
 modules in an order that is subject to the inversion mode (`ksinvX.params.irmode`). The non-inversion
 sequence modules should be played out together in a 'core slice' function of the psd. This core slice
 function should have a wrapper function with standardized input arguments that conmplies with the
 function pointer (and core_nargs, core_args) passed to this function.

 @param[in] slice_plan  Pointer to the slice plan (KS_SLICE_PLAN) set up earlier using ks_calc_sliceplan() or similar
 @param[in] slice_positions Pointer to the SCAN_INFO array corresponding to the slice locations (typically `ks_scan_info`)
 @param[in] passindx  Pass index in range `[0, ks_slice_plan.npasses - 1]`
 @param[in] ksinv1    Pointer to KSINV_SEQUENCE corresponding to the 1st (or only) inversion. Cannot be NULL
 @param[in] ksinv2    Pointer to KSINV_SEQUENCE corresponding to an optional 2nd inversion. May be NULL
 @param[in] ksinv_filltr    Pointer to KS_SEQ_CONTROL for fillTR sequence for FLAIR block modes. May be NULL
 @param[in] ksinv_loop_mode If KSINV_LOOP_DUMMY, this function will pass in KS_NOTSET (-1) as the 2nd argument to 'play_coreslice'.
                       For this to work, the play_coreslice() function (usually the main sequence's coreslice),
                       must check if it's 2nd arg is KS_NOTSET, and if so shut off data collection in loaddab()
                       KSINV_LOOP_NORMAL: Slice excitation ON, Data acq. ON
                       KSINV_LOOP_DUMMY: Slice excitation ON, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_FIRST: Slice excitation ON for IR, OFF for coreslice, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_LAST: Slice excitation OFF for IR, ON for coreslice, Data acq. ON

 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval slicelooptime Time taken in [us] to play out `slice_plan.nslices_per_pass` slices
********************************************************************************************************/
int ksinv_scan_sliceloop(const KS_SLICE_PLAN *slice_plan, const SCAN_INFO *slice_positions, int passindx, 
                         KSINV_SEQUENCE *ksinv1, KSINV_SEQUENCE *ksinv2, KS_SEQ_CONTROL *ksinv_filltr, KSINV_LOOP_MODE ksinv_loop_mode,
                         int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {
  int time = 0;
  int i, sltimeinpass;
  int slloc, sltime_adjusted;
  const SCAN_INFO *slpos;

  if (ksinv1 == NULL) {
    ks_error("%s: 4th arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (ksinv1->params.irmode == KSINV_OFF) {
    return 0;  /* if the IR mode for the 1st IR is off, return quietly */
  }
  if (slice_plan == NULL) {
    ks_error("%s: 1st arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (slice_positions == NULL) {
    ks_error("%s: 2nd arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }

  if (play_coreslice == NULL) {
    ks_error("%s: 7th arg must be a function pointer to the coreslice function", __FUNCTION__);
    return KS_NOTSET;
  }


  if (ksinv1->params.irmode == KSINV_FLAIR_BLOCK || ksinv1->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
    /* For classic T2-FLAIR, we often end up with 2 sets of FLAIR+core per TR
       Here is a generalization, where number of sets is equal to:
       CEIL_DIV(slice_plan->nslices_per_pass, ksinv1->params.nflairslices), where slice_plan->nslices_per_pass = CEIL_DIV(slice_plan->nslices, slice_plan->npasses)
    */
   
    /* make sure nflairslices > 0, or else we will be stuck here as sltimeinpass will remain at 0 forever */
    if (ksinv1->params.nflairslices <= 0) {
      ks_error("%s: ksinv1.params.nflairslices must be > 0", __FUNCTION__);
      return -1;
    }

    sltimeinpass = 0;

    while (sltimeinpass < slice_plan->nslices_per_pass) {

      /*--------- 1st inversion sequence module as FLAIR block -----------*/
      for (i = 0; i < ksinv1->params.nflairslices; i++) {
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      for (i = 0; (i < ksinv1->params.nflairslices) && (sltimeinpass + i < slice_plan->nslices_per_pass); i++) {

        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;

        if (ksinv2 != NULL) {
          /*--------- optional 2nd inversion sequence module (DIR mode) attached to each coreslice playout -----------*/
          time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
        }

        /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
        time += play_coreslice(
                  slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                  (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : (sltimeinpass + i), /* if KS_NOTSET (-1), shut off data acquisition */
                  core_nargs, core_args);
      }

      sltimeinpass += ksinv1->params.nflairslices;

      if (ksinv_filltr != NULL) {
        /*--------- fillTR sequence module (to fill up to manual TR in CEIL_DIV(nslices_per_pass, ksinv1->params.nflairslices) chunks) -----------*/
        time += ks_scan_playsequence(ksinv_filltr);
        ks_plot_slicetime(ksinv_filltr, 1, NULL, KS_NOTSET, KS_PLOT_NO_EXCITATION); /* Add a filler to slicetime plot */
      }

    } /* while */


  } else {

    int sltime_start = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? (slice_plan->nslices_per_pass - ksinv1->params.nslicesahead) : 0;

    for (sltimeinpass = sltime_start; sltimeinpass < slice_plan->nslices_per_pass; sltimeinpass++) {

      /*--------- 1st inversion sequence module -----------*/
      if (ksinv1->params.irmode == KSINV_IR_SIMPLE || ksinv1->params.irmode == KSINV_IR_SLICEAHEAD)  {
        sltime_adjusted = (sltimeinpass + ksinv1->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;        
        slpos = ((ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_LAST) && (sltime_adjusted < ksinv1->params.nslicesahead)) ? NULL : slpos;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      /*--------- 2nd inversion sequence module -----------*/
      if (ksinv2 != NULL && (ksinv2->params.irmode == KSINV_IR_SIMPLE || ksinv2->params.irmode == KSINV_IR_SLICEAHEAD)) {
        sltime_adjusted = (sltimeinpass + ksinv2->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
      }

      /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
      slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass);
      slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
      slpos = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? NULL : slpos;
      time += play_coreslice(
                slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : sltimeinpass, /* if KS_NOTSET (-1), shut off data acquisition */
                core_nargs,
                core_args);

    } /* slice in pass */

  } /* else (not FLAIR-block) */

  return time;

} /* ksinv_scan_sliceloop() */
 
                         

int ksinv_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  KS_SLICE_PLAN slice_plan = KS_INIT_SLICEPLAN;
  slice_plan.nslices_per_pass = slperpass;
  SCAN_INFO *slice_positions = NULL;
  int passindx = 0;
  KSINV_SEQUENCE *ksinv1 = NULL;
  KSINV_SEQUENCE *ksinv2 = NULL;
  KS_SEQ_CONTROL *ksinv_filltr = NULL;
  KSINV_LOOP_MODE ksinv_loop_mode = KSINV_LOOP_NORMAL;
  int (*play_coreslice)(const SCAN_INFO *, int, int, void **) = 0;
  int core_nargs = 0;
  void **core_args = NULL;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain 7 or 9 elements: slice_positions, passindx, &ksinv1, &ksinv2, &ksinv_filltr, play_as_dummy, play_coreslice [, core_nargs, core_args]", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    slice_positions = (SCAN_INFO *) args[0];
  }
  if (nargs >= 2 && args[1] != NULL) {
    passindx = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    ksinv1 = (KSINV_SEQUENCE *) args[2];
  }
  if (nargs >= 4 && args[3] != NULL) {
    ksinv2 = (KSINV_SEQUENCE *) args[3];
  }
  if (nargs >= 5 && args[4] != NULL) {
    ksinv_filltr = (KS_SEQ_CONTROL *) args[4];
  }
  if (nargs >= 6 && args[5] != NULL) {
    ksinv_loop_mode = *((KSINV_LOOP_MODE *) args[5]);
  }
  if (nargs >= 7 && args[6] != NULL) {
    play_coreslice = (int (*)(const SCAN_INFO *, int, int, void **)) args[6];
  }
  if (nargs >= 8 && args[7] != NULL) {
    core_nargs = *((int *) args[7]);
  }
  if (nargs >= 9 && args[8] != NULL) {
    core_args = (void **) args[8];
  }

  return ksinv_scan_sliceloop(&slice_plan, slice_positions, passindx, ksinv1, ksinv2, ksinv_filltr, ksinv_loop_mode, play_coreslice, core_nargs, core_args); /* in [us] */

} /* ksfse_scan_sliceloop_nargs() */

/******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : ksfse_implementation.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file ksfse_implementation.e
* @brief This file contains the implementation details for the *ksfse* psd
********************************************************************************************************/




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: PULSEGEN - builing of the sequence from the sequence objects
 *
 *  HOST: Called in cveval() to dry-run the sequence to determine timings
 *  TGT:  Waveforms are being written to hardware and necessary memory automatically alloacted
 *
 *******************************************************************************************************
 *******************************************************************************************************/






/**
 *******************************************************************************************************
 @brief #### Sets the phase encoding amplitudes in the FSE train on hardware using the phase enc. table and shot index

 This function will quietly return early when called on HOST. On IPG, it will set the instruction amplitudes
 of the phase encoding gradients in the FSE train given the phase encoding table, the pointer to the
 single phase encoding object for all phase encodes in the echo train, and the shot index.

 The `shot` index must be in range [0, ceil(pe.numlinestoacq/etl)] and is used to select the current
 row of `etl` different amplitudes in `phaseenc_plan[][shot]`.

 The KS_PHASER object must have been placed out `2*etl` times in `ksfse_pg()` before calling this
 function. The `etl` dephasing gradients before each readout in the echo train correspond to even
 indices, i.e. 0,2,4,...,(2*etl-1), whereas the rephasing gradients after each readout correspond to
 odd indices. This is an effect of that all `ks_pg_***()` functions sort the instances of an object in
 time.

 If `shot < 0` (e.g. `shot = KS_NOTSET = -1`), all phase encoding amplitudes will be set to zero.

 @param[in] phaseenc_plan_ptr Pointer to the phase encoding table (KS_PHASEENCODING_PLAN) (2D & 3D)
 @param[in] phaser Pointer to a KS_PHASER ("ky")
 @param[in] zphaser Pointer to a KS_PHASER ("kz"). Pass in NULL for 2D
 @param[in] shot Which `shot` index to play out for this echo train.
                 `shot = KS_NOTSET` will set all phase encoding gradients to zero.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_etlphaseamps(KS_PHASEENCODING_PLAN *phaseenc_plan_ptr, KS_PHASER *phaser, KS_PHASER *zphaser, int shot) {
  int echo;
  KS_PHASEENCODING_COORD coord = KS_INIT_PHASEENCODING_COORD;

  if (phaseenc_plan_ptr->etl == KS_NOTSET) {
    return SUCCESS; /* we haven't set it up yet */
  }

  /* TODO: Check that #instance for phaser and zphaser is equal to phaseenc_plan_ptr->etl * 2 - 1.
    If 1 less that 2*etl, this indicates no fastrecovery. Don't need the last arg then */

  for (echo = 0; echo < phaseenc_plan_ptr->etl; echo++) {

    coord = ks_phaseencoding_get(phaseenc_plan_ptr, echo, shot);

    ks_scan_phaser_toline(phaser,   0 + 2 * echo, coord.ky); /* dephaser */
    ks_scan_phaser_fromline(phaser, 1 + 2 * echo, coord.ky); /* rephaser */

    if (zphaser != NULL) {
      ks_scan_phaser_toline(zphaser,  0 + 2 * echo, coord.kz); /* dephaser */
      ks_scan_phaser_fromline(zphaser, 1 + 2 * echo, coord.kz); /* rephaser */
    }

  } /* for echo in etl */

  return SUCCESS;

} /* ksfse_etlphaseamps() */




/**
 *******************************************************************************************************
 @brief #### 2DFSE: Updates the spoiler amplitude on hardware during scanning depending on current `etl` and `shot`

 This function updates the spoiler amplitude during scanning, and will return quietly if called on HOST.

 @param[in] phaseenc_plan_ptr Pointer to the phase encoding table (KS_PHASEENCODING_PLAN) (2D & 3D)
 @param[in] spoiler Pointer to the KS_TRAP spoiler object
 @param[in] res Phase encoding resolution
 @param[in] shot `shot` index in range `[0, ceil(pe.numlinestoacq/etl)]`.
 @return void
********************************************************************************************************/
void ksfse_spoilamp(KS_PHASEENCODING_PLAN *phaseenc_plan_ptr, KS_TRAP *spoiler, int res, int shot) {
  KS_PHASEENCODING_COORD coord = KS_INIT_PHASEENCODING_COORD;

  /* change spoil direction with respect to last phase encoding blip */
  if (shot >= 0) {
    int i = 1;
    double kspace_dist = 0.0;
    for (i = 0; i < phaseenc_plan_ptr->etl; i++) {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, i, shot);
      if (coord.ky != KS_NOTSET) {
        kspace_dist = ((res - 1.0)/ 2.0) - coord.ky;
      }
    }
    if (kspace_dist >= 0.0) {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, phaseenc_plan_ptr->etl - 1, shot);
      if (coord.ky == KS_NOTSET) {
        ks_scan_trap_ampscale(spoiler, 0, -1.0);
      } else {
        ks_scan_trap_ampscale(spoiler, 0, 1.0);
      }
    } else {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, phaseenc_plan_ptr->etl - 1, shot);
      if (coord.ky == KS_NOTSET) {
        ks_scan_trap_ampscale(spoiler, 0, 1.0);
      } else {
        ks_scan_trap_ampscale(spoiler, 0, -1.0);
      }
    }
  }

} /* ksfse_spoilamp() */



/**
 *******************************************************************************************************
 @brief #### The ksfse (main) pulse sequence

 This is the main pulse sequence in ksfse.e using the sequence objects in KSFSE_SEQUENCE with
 the sequence module name "ksfsemain" (= ksfse.seqctrl.description)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_pg(int start_time) {

  KS_SEQLOC tmploc = KS_INIT_SEQLOC;
  int readpos_start = KS_NOTSET;
  int spoiler_pos = KS_NOTSET;
  int i;

  if (start_time < KS_RFSSP_PRETIME) {
    return ks_error("%s: 1st arg (pos start) must be at least %d us", __FUNCTION__, KS_RFSSP_PRETIME);
  }


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;
  tmploc.pos = RUP_GRD(start_time + KS_RFSSP_PRETIME);
  tmploc.board = ZGRAD;

  /* N.B.: ks_pg_selrf()->ks_pg_rf() detects that ksfse.selrfexc is an excitation pulse
     (ksfse.selrfexc.rf.role = KS_RF_ROLE_EXC) and will also set ksfse.seqctrl.momentstart
     to the absolute position in [us] of the isocenter of the RF excitation pulse */
  if (ks_pg_selrf(&ksfse.selrfexc, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;


  /*******************************************************************************************************
   *  X dephaser (between 90 and 1st 180)
   *******************************************************************************************************/
  if (ksfse_slicecheck) {
    tmploc.pos = ksfse.seqctrl.momentstart + ksfse.selrfexc.rf.iso2end + ksfse.selrfexc.grad.ramptime;
    tmploc.board = ZGRAD;
  } else {
    tmploc.pos = ksfse.seqctrl.momentstart + ksfse.selrfexc.rf.iso2end;
    tmploc.board = XGRAD;
  }
  if (ks_pg_trap(&ksfse.readdephaser, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
  *  Generate the refocusing flip angles
  -------------------------------------------------------------------------------------------------------*/
  double flip_angles[512]; /* rad */

  if (ksfse_vfa) {

    STATUS status = ks_pg_fse_flip_angle_taperoff(flip_angles,
                                                  opetl,
                                                  ksfse.selrfref1st.rf.flip, ksfse.selrfref2nd.rf.flip, ksfse.selrfref.rf.flip,
                                                  80.0, /* degrees */
                                                  opflair != OPFLAIR_INTERLEAVED);
    if (status != SUCCESS) return ks_error("ks_pg_fse_flip_angle_taperoff failed");

    /* modify rfpulse-struct for SAR calcs. */
    ks_pg_mod_fse_rfpulse_structs(&ksfse.selrfref1st, &ksfse.selrfref2nd, &ksfse.selrfref,
                                  flip_angles,
                                  opetl);

  }



  /*******************************************************************************************************
  *  FSE train: Begin
  -------------------------------------------------------------------------------------------------------*/
  for (i = 0; i < opetl; i++) {

    /* Selective RF Refocus with left (pregrad.) and right (postgrad.) crushers */
    tmploc.board = ZGRAD;
    if (i == 0) {
      /* special case for 1st pulse with at least a smaller left crusher */
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref1st.rf.start2iso - ksfse.selrfref1st.grad.ramptime - ksfse.selrfref1st.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref1st.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref1st, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    } else if (i == 1) {
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref2nd.rf.start2iso - ksfse.selrfref2nd.grad.ramptime - ksfse.selrfref2nd.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref2nd.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref2nd, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    } else {
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref.rf.start2iso - ksfse.selrfref.grad.ramptime - ksfse.selrfref.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    }

    /* ksfse_esp dependent time at beginning of readout ramp */
    readpos_start = ksfse.seqctrl.momentstart + (i + 1) * ksfse_esp - ksfse.read.time2center;

    /*******************************************************************************************************
    *  Readouts
    *******************************************************************************************************/
    tmploc.pos = readpos_start;
    if (ksfse_slicecheck)
      tmploc.board = ZGRAD;
    else
      tmploc.board = XGRAD;
    if (ks_pg_readtrap(&ksfse.read, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /*******************************************************************************************************
    *  Phase encoding dephasers & rephasers
    *******************************************************************************************************/
    tmploc.board = YGRAD;
    tmploc.pos = readpos_start + ksfse.read.acqdelay - ksfse.phaseenc.grad.duration;
    if (ks_pg_phaser(&ksfse.phaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i */
      return FAILURE;
    tmploc.pos = readpos_start + ksfse.read.grad.duration - ksfse.read.acqdelay;
    if (ks_pg_phaser(&ksfse.phaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i + 1 */
      return FAILURE;

    /*******************************************************************************************************
    *  Z phase encoding dephasers & rephasers (3D)
    *******************************************************************************************************/
    if (ksfse.zphaseenc.grad.duration > 0) {
      tmploc.board = ZGRAD;
      tmploc.pos = readpos_start + ksfse.read.acqdelay - ksfse.zphaseenc.grad.duration;
      if (ks_pg_phaser(&ksfse.zphaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i */
        return FAILURE;
      tmploc.pos = readpos_start + ksfse.read.grad.duration - ksfse.read.acqdelay;
      if (ks_pg_phaser(&ksfse.zphaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i + 1 */
        return FAILURE;
    }

  } /* opetl */

  /*------------------------------------------------------------------------------------------------------
   *  FSE train: End
   *******************************************************************************************************/


  /*******************************************************************************************************
   * Phase encoding table
   * written to /usr/g/mrraw/ks_phaseencodingtable.txt (HW) or ./ks_phaseencodingtable.txt (SIM)
   *
   * Need to call this in ksfse_pg() so it is run both on HOST and TGT. This, since the phase table
   * is dynamically allocated in ks_phaseencoding_generate_2Dfse()->ks_phaseencoding_resize()
   *
   * For 3D, ks_phaseencoding_generate_2Dfse() just repeats the same ETL ky path for every kz. This is just
   * for testing, and a better ks_phaseencoding_generate_*** function would be needed to do optimal ky-kz
   * trajectory for 3D
   *******************************************************************************************************/
  if (ks_phaseencoding_generate_2Dfse(&ksfse.phaseenc_plan, "",
                                      &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL,
                                      opte, opetl, ksfse_esp) == FAILURE)
     return FAILURE;

  ks_phaseencoding_print(&ksfse.phaseenc_plan);

  /* set phase encoding amp as for the first shot in the scan loop so it is displayed in WTools MGDSim */
  ksfse_etlphaseamps(&ksfse.phaseenc_plan, &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL, 0);

  /*******************************************************************************************************
   * Post-ETL forced recovery: T1-w Optimization / T2 fast Recovery
   *******************************************************************************************************/
  if (ksfse_recovery) {

    int lastReadoutCenter = ksfse.seqctrl.momentstart + opetl * ksfse_esp;

    /* Place extra refocusing pulse */
    tmploc.board = ZGRAD;
    tmploc.pos = lastReadoutCenter + ksfse_esp/2 - ksfse.selrfrecoverref.rf.start2iso - ksfse.selrfrecoverref.grad.ramptime - ksfse.selrfrecoverref.pregrad.duration;
    tmploc.ampscale = (ksfse_vfa) ? flip_angles[opetl-1]/ ksfse.selrfrecoverref.rf.flip : 1;

    if (ks_pg_selrf(&ksfse.selrfrecoverref, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /* Place rewinder of previous readout in order to get back to the center of k-space */
    tmploc.pos = lastReadoutCenter + ksfse_esp - ksfse.selrfrecover.rf.start2iso - ksfse.readdephaser.duration;
    tmploc.ampscale = 1;
    if (ksfse_slicecheck) {
      tmploc.board = ZGRAD;
      tmploc.pos -= ksfse.selrfrecover.grad.ramptime;
    } else {
      tmploc.board = XGRAD;
    }
    if (ks_pg_trap(&ksfse.readdephaser, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /* Place excitation pulse */
    tmploc.board = ZGRAD;
    tmploc.pos = lastReadoutCenter + ksfse_esp - ksfse.selrfrecover.rf.start2iso - ksfse.selrfrecover.grad.ramptime - ksfse.selrfrecover.pregrad.duration;

    if (ksfse_recovery == KSFSE_RECOVERY_FAST) {
      tmploc.ampscale = -1;
    } else { /* = KSFSE_RECOVERY_T1WOPT */
      tmploc.ampscale = 1;
    }
    if (ks_pg_selrf(&ksfse.selrfrecover, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;
    tmploc.ampscale = 1;

    /* spoiler pos */
    spoiler_pos = tmploc.pos + ksfse.selrfrecover.pregrad.duration + ksfse.selrfrecover.grad.duration;

  } else {

    /* spoiler pos */
    spoiler_pos = ksfse.seqctrl.momentstart + opetl * ksfse_esp + ksfse.read.grad.duration - ksfse.read.time2center - ksfse.read.acqdelay + ksfse.phaseenc.grad.duration;

  } /* ksfse_recovery */

  /*******************************************************************************************************
   *  Gradient spoiler on Y
   *******************************************************************************************************/
  tmploc.board = YGRAD;
  tmploc.pos = spoiler_pos;
  tmploc.ampscale = 1;
  if (ks_pg_trap(&ksfse.spoiler, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;
  tmploc.pos += ksfse.spoiler.duration;
  ksfse_spoilamp(&ksfse.phaseenc_plan, &ksfse.spoiler, ksfse.phaseenc.res, 0);


 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksfse.seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  tmploc.pos = RUP_GRD(tmploc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence duration (ksfse.seqctrl.ssi_time must be > 0 and is added to ksfse.seqctrl.min_duration in ks_eval_seqctrl_setminduration() */
  ksfse.seqctrl.ssi_time = ksfse_eval_ssitime();
  ks_eval_seqctrl_setminduration(&ksfse.seqctrl, tmploc.pos); /* tmploc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksfse_pg() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: SCAN in @pg section (functions accessible to both HOST and TGT)
 *
 *  Here are functions related to the scan process (ksfse_scan_***) that have to be placed here in @pg
 *  (not @rsp) to make them also accessible on HOST in order to enable scan-on-host for TR timing
 *  in my_cveval()
 *
 *******************************************************************************************************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksfse sequence objects being part of KSFSE_SEQUENCE

 This function sets the current state of all ksfse sequence objects being part of KSFSE_SEQUENCE, incl.
 gradient amplitude changes, RF freq/phases and receive freq/phase based on current slice position and
 phase encoding indices.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] slice_info Position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @param[in] shot `shot` index in range `[0, ksfse.phaseenc_plan.num_shots - 1]`
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_scan_seqstate(SCAN_INFO slice_info, int shot) {
  int i;
  float rfphase = 0.0;
  KS_PHASEENCODING_COORD coord;

  ks_scan_rotate(slice_info);

  ks_scan_selrf_setfreqphase(&ksfse.selrfexc,    0,        slice_info, rfphase /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref1st, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref2nd, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref,    INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  if (ksfse_recovery) {
    ks_scan_selrf_setfreqphase(&ksfse.selrfrecoverref, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
    ks_scan_selrf_setfreqphase(&ksfse.selrfrecover, 0, slice_info, rfphase /* [deg] */);
  }

  /* FOV offsets (by changing freq/phase of ksfse.read) */
  if (shot >= 0) {
    for (i = 0; i < ksfse.phaseenc_plan.etl; i++) {

      coord = ks_phaseencoding_get(&ksfse.phaseenc_plan, i, shot);

      if (KS_3D_SELECTED) {
        float zfovratio = (opslquant * opslthick)/ opfov;
        float zchop_phase = 0.0;
        if (oparc && (coord.kz % 2)) {
          /* GEs ARC recon ignores RHF_ZCHOP bit in 'rhformat', but expects 3D data to be z-chopped for proper slice sorting.
          In GERequired.e:GEReq_predownload_setrecon_voldata(), RHF_ZCHOP is unset by default. In combination with
          that we do not do zchop for non-ARC scans (incl ASSET), this works well. But for ARC scans, we must zchop. That is,
          we add 180 phase to every odd kz encoded line, which is the same as a final z fftshift in the image domain */
          zchop_phase = 180.0;
        }
        ks_scan_offsetfov3D(&ksfse.read, i, slice_info, coord.ky, opphasefov, coord.kz, zfovratio, rfphase + zchop_phase);
      } else {
        ks_scan_offsetfov(&ksfse.read, i, slice_info, coord.ky, opphasefov, rfphase);
      }

    } /* etl */
  } /* shot > 0 */

  /* change phase encoding amplitudes */
  ksfse_etlphaseamps(&ksfse.phaseenc_plan, &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL, shot);

  /* change spoiler amplitude */
  ksfse_spoilamp(&ksfse.phaseenc_plan, &ksfse.spoiler, ksfse.phaseenc.res, shot);

  /* Turn off T1-w opt. in DDAs */
  if ((ksfse_recovery) && (shot < 0)) {
    ks_scan_rf_off(&ksfse.selrfrecover.rf, 0);
    ks_scan_rf_off(&ksfse.selrfrecoverref.rf, 0);
  }

  return SUCCESS;

} /* ksfse_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Sets all RF pulse amplitudes to zero

 @return void
********************************************************************************************************/
void ksfse_scan_rf_off() {
  ks_scan_rf_off(&ksfse.selrfexc.rf,    INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref1st.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref2nd.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref.rf,    INSTRALL);
  ks_scan_rf_off(&ksfse.selrfrecover.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfrecoverref.rf, INSTRALL);
} /* ksfse_scan_rf_off() */



/**
 *******************************************************************************************************
 @brief #### Sets all RF pulse amplitudes on

 @return void
********************************************************************************************************/
void ksfse_scan_rf_on() {
  ks_scan_rf_on(&ksfse.selrfexc.rf,    INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref1st.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref2nd.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref.rf,    INSTRALL);
  ks_scan_rf_on(&ksfse.selrfrecover.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfrecoverref.rf, INSTRALL);
}



/**
 *******************************************************************************************************
 @brief #### Plays out one slice in real time during scanning together with other active sequence modules

  On TGT on the MR system (PSD_HW), this function sets up (ksfse_scan_seqstate()) and plays out the
  core ksfse sequence with optional sequence modules also called in this function. The low-level
  function call `startseq()`, which actually starts the realtime sequence playout is called from within
  ks_scan_playsequence(), which in addition also returns the time to play out that sequence module (see
  time += ...).

  On HOST (in ksfse_eval_tr()) we call ksfse_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksfse_scan_scantime(), which returns the total time of the
  entire scan.

  After each call to ks_scan_playsequence(), ks_plot_slicetime() is called to add slice-timing
  information on file for later PNG/PDF-generation of the sequence. As scanning is performed in real-time
  and may fail if interrupted, ks_plot_slicetime() will return quietly if it detects both IPG (TGT)
  and PSD_HW (on the MR scanner). See predownload() for the PNG/PDF generation.

  @param[in] slice_pos Position of the slice to be played out (one element in the global
                      `ks_scan_info[]` array)
  @param[in] dabslice  0-based slice index for data storage
  @param[in] shot `shot` index (over ky and kz)
  @param[in] exc Excitation index in range `[0, NEX-1]`, where NEX = number of excitations (opnex)
  @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksfse_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, /* psd specific: */ int shot, int exc) {
  int i;
  int dabop, dabview, acqflag;
  int time = 0;
  float tloc = 0.0;
  KS_PHASEENCODING_COORD coord;

  if (slice_pos != NULL)
    tloc = slice_pos->optloc;


  /*******************************************************************************************************
  * SpSat sequence module
  *******************************************************************************************************/
  time += ksspsat_scan_playsequences(ks_perform_slicetimeplot);


  /*******************************************************************************************************
  * Chemsat sequence module
  *******************************************************************************************************/
  kschemsat_scan_seqstate(&kschemsat);
  time += ks_scan_playsequence(&kschemsat.seqctrl);
  ks_plot_slicetime(&kschemsat.seqctrl, 1, NULL, KS_NOTSET, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD); /* no slice location for fat sat */


  /*******************************************************************************************************
  * ksfse main sequence module
  *******************************************************************************************************/
  if (slice_pos != NULL) {
    ksfse_scan_rf_on();
    ksfse_scan_seqstate(*slice_pos, (ksfse_noph != PSD_ON) ? shot : KS_NOTSET); /* shot. if = KS_NOTSET, no phase encodes */
  } else {
    ksfse_scan_rf_off(); /* false slice, shut off RF pulses */
  }


  for (i = 0; i < ksfse.read.acq.base.ngenerated; i++) {
    /* N.B.: Looping over ksfse.read.acq.base.ngenerated corresponds to:
       HOST: No looping since ksfse.read.acq.base.ngenerated is 0 on HOST
       TGT: ETL.
       This protects calls to loaddab() on HOST
    */
    coord = ks_phaseencoding_get(&ksfse.phaseenc_plan, i, shot);

    /* data routing control */
    acqflag = (shot >= 0 && slice_pos != NULL && coord.ky >= 0 && dabslice >= 0) ? DABON : DABOFF; /* open or close data receiver */
    dabop = (exc <= 0) ? DABSTORE : DABADD; /* replace or add to data */

    if (KS_3D_SELECTED) {
      if (ks_scan_info[1].optloc > ks_scan_info[0].optloc)
        dabslice = (opslquant * opvquant - 1) - coord.kz;
      else
        dabslice = coord.kz;
    }

    dabview = (shot >= 0) ? coord.ky : KS_NOTSET;

    if (ksfse.phaseenc.R > 1 && ksfse.phaseenc.nacslines == 0 && dabview != KS_NOTSET) {
      /* ASSET case triggered by R > 1 and no ACS lines */
      dabview/= ksfse.phaseenc.R; /* store in compressed BAM without empty non-acquired lines */
    }

    loaddab(&ksfse.read.acq.echo[i], dabslice, 0, dabop, dabview + 1, acqflag, PSD_LOAD_DAB_ALL); /* see epicfuns.h for alternatives to loaddab() */

  } /* etl */

  time += ks_scan_playsequence(&ksfse.seqctrl);
  ks_plot_slicetime(&ksfse.seqctrl, 1, &tloc, opslthick, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

  return time; /* in [us] */

} /* ksfse_scan_coreslice() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksfse_scan_coreslice() with standardized input arguments

 KSInversion.e has functions (ksinv_eval_multislice(), ksinv_eval_checkTR_SAR() and
 ksinv_scan_sliceloop()) that expect a standardized function pointer to the coreslice function of a main
 sequence. When inversion mode is enabled for the sequence, ksinv_scan_sliceloop() is used instead of
 ksfse_scan_sliceloop() in ksfse_scan_acqloop(), and the generic ksinv_scan_sliceloop() function need a
 handle to the coreslice function of the main sequence.

 In order for these `ksinv_***` functions to work for any pulse sequence they need a standardized
 function pointer with a fixed set of input arguments. As different pulse sequences may need different
 number of input arguments (with different meaning) this ksfse_scan_coreslice_nargs() wrapper function
 provides the argument translation for ksfse_scan_coreslice().

 The function pointer must have SCAN_INFO and slice storage index (dabslice) as the first two input
 args, while remaining input arguments (to ksfse_scan_coreslice()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksfse_scan_coreslice().

 @param[in] slice_pos Pointer to the SCAN_INFO struct corresponding to the current slice to be played out
 @param[in] dabslice  0-based slice index for data storage
 @param[in] nargs Number of extra input arguments to ksfse_scan_coreslice() in range [0,2]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksfse_scan_coreslice()
 @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksfse_scan_coreslice_nargs(const SCAN_INFO *slice_pos, int dabslice, int nargs, void **args) {
  int shot = 0;
  int exc = 0;

  if (nargs < 0 || nargs > 2) {
    ks_error("%s: 4th arg (void **) must contain up to 2 elements in the following order: shot, exc", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 4th arg (void **) cannot be NULL if nargs (3rd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    shot = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    exc = *((int *) args[1]);
  }

  return ksfse_scan_coreslice(slice_pos, dabslice, /* psd specific: */ shot, exc); /* in [us] */

} /* ksfse_scan_coreslice_nargs() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slperpass` slices corresponding to one TR

 This function gets a spatial slice location index based on the pass index and temporal position within
 current pass. It then calls ksfse_scan_coreslice() to play out one coreslice (i.e. the main ksfse main
 sequence + optional sequence modules, excluding inversion modules).

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] passindx  Pass index in range [0, ks_slice_plan.npasses - 1]
 @param[in] shot `shot` index in range `[0,  ksfse.phaseenc_plan.num_shots - 1]`
 @param[in] exc Excitation index in range `[0, NEX-1]`, where NEX = number of excitations (opnex)
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksfse_scan_sliceloop(int slperpass, int passindx, int shot, int exc) {
  int time = 0;
  int slloc, sltimeinpass;
  SCAN_INFO centerposition = ks_scan_info[0]; /* first slice chosen here, need only rotation stuff */

  if (KS_3D_SELECTED) {
    int centerslice = opslquant/2;
    /* for future 3D multislab support, let passindx update centerposition */
    centerposition.optloc = (ks_scan_info[centerslice-1].optloc + ks_scan_info[centerslice].optloc)/2.0;
  }

  for (sltimeinpass = 0; sltimeinpass < slperpass; sltimeinpass++) {

    SCAN_INFO *current_slice = &centerposition;

    if (!KS_3D_SELECTED) { /* 2D */
      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, passindx, sltimeinpass);

      /* if slloc = KS_NOTSET, pass in NULL as first argument to indicate 'false slice' */
      current_slice = (slloc != KS_NOTSET) ? &ks_scan_info[slloc]: NULL;
    }

    time += ksfse_scan_coreslice(current_slice, sltimeinpass, shot, exc);

  }

  return time; /* in [us] */

} /* ksfse_scan_sliceloop() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksfse_scan_sliceloop() with standardized input arguments

 For TR timing heat/SAR calculations of regular 2D multislice sequences, GEReq_eval_TR(),
 ks_eval_mintr() and GEReq_eval_checkTR_SAR() use a standardized function pointer with a fixed set of
 input arguments to call the sliceloop of the main sequence with different number of slices to check
 current slice loop duration. As different pulse sequences may need different number of input arguments
 (with different meaning) this ksfse_scan_sliceloop_nargs() wrapper function provides the argument
 translation for ksfse_scan_sliceloop().

 The function pointer must have an integer corresponding to the number of slices to use as its first
 argument while the remaining input arguments (to ksfse_scan_sliceloop()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksfse_scan_sliceloop().

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] nargs Number of extra input arguments to ksfse_scan_sliceloop() in range [0,4]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksfse_scan_sliceloop()
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksfse_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  int passindx = 0;
  int shot = KS_NOTSET;   /* off */
  int exc = 0;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain up to 3 elements: passindx, shot, exc", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    passindx = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    shot = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    exc = *((int *) args[2]);
  }

  return ksfse_scan_sliceloop(slperpass, passindx, shot, exc); /* in [us] */

} /* ksfse_scan_sliceloop_nargs() */




/**
 *******************************************************************************************************
 @brief #### Plays out all phase encodes for all slices belonging to one pass

 This function traverses through all shots (`ksfse.phaseenc_plan.num_shots`) to be played out and runs the
 ksfse_scan_sliceloop() for each set of shots and excitation. If ksfse_dda > 0, dummy scans
 will be played out before the phase encoding begins.

 In the case of inversion, ksinv_scan_sliceloop() is called instead of ksfse_scan_sliceloop(), where
 the former takes a function pointer to ksfse_scan_coreslice_nargs() in order to be able to play out
 the coreslice in a timing scheme set by ksinv_scan_sliceloop().

 @param[in] passindx  0-based pass index in range `[0, ks_slice_plan.npasses - 1]`
 @retval passlooptime Time taken in [us] to play out all phase encodes and excitations for `slperpass`
                      slices. Note that the value is a `float` instead of `int` to avoid int overrange
                      at 38 mins of scanning
********************************************************************************************************/
float ksfse_scan_acqloop(int passindx) {
  float time = 0.0;
  int shot, exc;

  for (shot = -ksfse_dda; shot < ksfse.phaseenc_plan.num_shots; shot++) {

    /* shot < 0 means dummy scans, and is handled in ksfse_scan_coreslice(), ksfse_scan_seqstate() and ksfse_etlphaseamps() */

    if (shot == 0 && ksfse_dda > 0) {
      ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_DUMMY);
    }

    for (exc = 0; exc < (int) ceil(opnex); exc++) { /* ceil rounds up opnex < 1 (used for partial Fourier) to 1 */

      if (ksinv1.params.irmode != KSINV_OFF) {
        void *args[2] = {(void *) &shot, (void *) &exc}; /* pass on args via ksinv_scan_sliceloop() to ksfse_scan_coreslice() */
        int nargs = sizeof(args)/ sizeof(void *);
        time += (float) ksinv_scan_sliceloop(&ks_slice_plan, ks_scan_info, passindx, &ksinv1, &ksinv2, &ksinv_filltr,
                                              (shot < 0) ? KSINV_LOOP_DUMMY : KSINV_LOOP_NORMAL, ksfse_scan_coreslice_nargs, nargs, args);
      } else {
        time += (float) ksfse_scan_sliceloop(ks_slice_plan.nslices_per_pass, passindx, shot, exc);
      }

      ks_plot_slicetime_endofslicegroup("ksfse shots");

    } /* for exc */

    /* save a frame of the main sequence for later generation of an animated GIF (only in MgdSim, WTools) */
    if (shot >= 0) {
      ks_plot_tgt_addframe(&ksfse.seqctrl);
    }

  } /* for shot */

  ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_STANDARD);
  return time; /* in [us] */

} /* ksfse_scan_acqloop() */




/**
 *******************************************************************************************************
 @brief #### Plays out all volumes and passes of a single or multi-pass scan

 This function performs the entire scan and traverses through passes and volumes. For now, since
 `opmph = 0` as multiphase is controlled outside the psd via PSD_IOPT_DYNPL, opfphases will always be 1.
 For each `passindx` (in range `[0, ks_slice_plan.npasses-1]`), ksfse_scan_acqloop() will be called to
 acquire all data for the current set of slices belong to the current pass (acquisition). At the end of
 each pass, GEReq_endofpass() is called to trigger GE's recon and to dump Pfiles (if `autolock = 1`).

 @retval scantime Total scan time in [us] (`float` to avoid int overrange after 38 mins)
********************************************************************************************************/
float ksfse_scan_scanloop() {
  float time = 0.0;

  for (volindx = 0; volindx < opfphases; volindx++) { /* opfphases is # volumes (BUT: opfphases always 1 since opmph = 0) */

    for (passindx = 0; passindx < ks_slice_plan.npasses; passindx++) { /* acqs = passes */

      time += ksfse_scan_acqloop(passindx);

#ifdef IPG
      GEReq_endofpass();
#endif

    } /* end: acqs (pass) loop */

  } /* end: volume loop */

  return time; /* in [us] */

} /* ksfse_scan_acqloop() */





/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: SCAN in @rsp section (functions only accessible on TGT)
 *
 *******************************************************************************************************
 *******************************************************************************************************/

/**
 *******************************************************************************************************
 @brief #### Common initialization for prescan entry points MPS2 and APS2 as well as the SCAN entry point
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_scan_init(void) {

  GEReq_initRSP();

  /* Here goes code common for APS2, MPS2 and SCAN */

  ks_scan_switch_to_sequence(&ksfse.seqctrl);  /* switch to main sequence */
  scopeon(&seqcore); /* Activate scope for core */
  syncon(&seqcore);  /* Activate sync for core */
  setssitime(ksfse.seqctrl.ssi_time/ HW_GRAD_UPDATE_TIME);

  /* can we make these independent on global rsptrigger and rsprot in orderslice? */
  settriggerarray( (short) ks_slice_plan.nslices_per_pass, rsptrigger);

  return SUCCESS;

} /* ksfse_scan_init() */




/**
 *******************************************************************************************************
 @brief #### Prescan loop called from both APS2 and MPS2 entry points
 @retval STATUS `SUCCESS` or `FAILURE`
*******************************************************************************************************/
STATUS ksfse_scan_prescanloop(int nloops, int dda) {
  int i, echoindx, sltimeinpass, slloc;
  int centerecho = IMin(2, opetl-1, opte/ ksfse_esp);

  /* turn off receivers for all echoes */
  for (echoindx = 0; echoindx < ksfse.read.acq.base.ngenerated; echoindx++) {
    loaddab(&ksfse.read.acq.echo[echoindx], 0, 0, DABSTORE, 0, DABOFF, PSD_LOAD_DAB_ALL);
  }

  /* play dummy scans to get into steady state */
  for (i = -dda; i < nloops; i++) {

    /* loop over slices */
    for (sltimeinpass = 0; sltimeinpass < ks_slice_plan.nslices_per_pass; sltimeinpass++) {

      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, 0, sltimeinpass);

      if (slloc != KS_NOTSET) {
        /* modify sequence for next playout */
        ksfse_scan_rf_on();
        ksfse_scan_seqstate(ks_scan_info[slloc], KS_NOTSET); /* KS_NOTSET => no phase encodes */

      } else {
        ksfse_scan_rf_off();
      }

      /* data routing control */
      if (i >= 0) {
        /* turn on receiver for center echo */
        loaddab(&ksfse.read.acq.echo[centerecho], 0, 0, DABSTORE, 0, DABON, PSD_LOAD_DAB_ALL);
      }

      ks_scan_playsequence(&ksfse.seqctrl);

    } /* for slices */

  } /* for nloops */


  return SUCCESS;

} /* ksfse_scan_prescanloop() */

/*****************************************************************************************************
 * PULSEGEN (Executes when pressing Scan or Research->Download)
 *****************************************************************************************************/

STATUS pulsegen( void ) {

  GEReq_pulsegenBegin();

  /* Main sequence */
  ksfse_pg(ksfse_pos_start);
   
    {
      if (ksfse.seqctrl.duration > 0) {

        if (ksfse.seqctrl.duration - ksfse.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksfse.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqcore, "seqcore");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqcore) failed", ksfse.seqctrl.description);
          }  
          status = createseq(&seqcore, ksfse.seqctrl.duration - ksfse.seqctrl.ssi_time, off_seqcore);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqcore) failed", ksfse.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqcore );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqcore) failed", ksfse.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqcore = %d\n", idx_seqcore );
          ksfse.seqctrl.handle.index = idx_seqcore;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksfse.seqctrl.handle.offset = off_seqcore;
          ksfse.seqctrl.handle.pulse = &seqcore;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  

  /* Spatial Sat */
  ksspsat_pulsegen();

  /* ChemSat sequence module */
  kschemsat_pg(&kschemsat);
   
    {
      if (kschemsat.seqctrl.duration > 0) {

        if (kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", kschemsat.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSChemSat, "seqKSChemSat");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }  
          status = createseq(&seqKSChemSat, kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time, off_seqKSChemSat);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSChemSat) failed", kschemsat.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSChemSat );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSChemSat = %d\n", idx_seqKSChemSat );
          kschemsat.seqctrl.handle.index = idx_seqKSChemSat;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          kschemsat.seqctrl.handle.offset = off_seqKSChemSat;
          kschemsat.seqctrl.handle.pulse = &seqKSChemSat;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if kschemsat.seqctrl.duration = 0 */

  /* Inversion sequence modules */
  ksinv_pulsegen();

  GEReq_pulsegenEnd();

  buildinstr(); /* load the sequencer memory */

  return SUCCESS;

} /* pulsegen() */



/*****************************************************************************************************
 * RSP Functions
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/

/*****************************************************************************************************
 * MPS2: Manual Prescan ("Scan TR"). Should run the main sequence without phase encoding gradients
 * to determine receiver gains R1 (analog) and R2 (digital)
 *****************************************************************************************************/

STATUS mps2(void) {

  rspent = L_MPS2;
  strcpy(psdexitarg.text_arg, "mps2");

  if (ksfse_scan_init() == FAILURE)
    return rspexit();

  if (ksfse_scan_prescanloop(30000, ksfse_dda) == FAILURE)
    return rspexit();

  rspexit();

  return SUCCESS;

} /* mps2() */


/*****************************************************************************************************
 * APS2: Auto Prescan ("Scan TR"). Should run the main sequence without phase encoding gradients
 * to determine receiver gains R1 (analog) and R2 (digital)
 *****************************************************************************************************/

STATUS aps2(void) {

  rspent = L_APS2;
  strcpy(psdexitarg.text_arg, "aps2");

  if (ksfse_scan_init() == FAILURE)
    return rspexit();

  if (ksfse_scan_prescanloop(100, ksfse_dda) == FAILURE)
    return rspexit();

  rspexit();

  return SUCCESS;

} /* aps2() */


/*****************************************************************************************************
 * SCAN: Executed when pressing Scan. Runs the sequence
 * The code is halted at the function call startseq() and waits for the SSI interrupt at the of
 * each sequence playout
 *****************************************************************************************************/

STATUS scan(void) {

  rspent = L_SCAN;
  strcpy(psdexitarg.text_arg, "scan");

  if (ksfse_scan_init() == FAILURE)
    return rspexit();

  /* Scan hierarchy:

    Without inversion:
    ksfse_scan_scanloop() - Data for the entire scan
        ksfse_scan_acqloop() - All data for one set of slices that fit within one TR (one acquisition)
            ksfse_scan_sliceloop() - One set of slices that fit within one TR played out for one shot
                 ksfse_scan_coreslice() - One slice playout, with optional other sequence modules

    With inversion:
    ksfse_scan_scanloop() - Data for the entire scan
        ksfse_scan_acqloop() - All data for one set of slices that fit within one TR (one acquisition)
            ksinv_scan_sliceloop() - One set of slices that fit within one TR played out for one shot
                                     using the sliceloop in KSInversion.e. Note that ksinv_scan_sliceloop()
                                     takes over the TR timing from ksfse_scan_sliceloop() and uses a
                                     function pointer to ksfse_scan_coreslice_nargs() to execute the
                                     contents of ksfse_scan_coreslice().
  */
  ksfse_scan_scanloop();

  GEReq_endofscan();

  /* So we can see the sequence in plotter after scan completes */
  ks_scan_switch_to_sequence(&ksfse.seqctrl);

  rspexit();

  return SUCCESS;

}   /* scan() */








/* Include special CV download code */
#include "ksfse.cvcopy.c"

