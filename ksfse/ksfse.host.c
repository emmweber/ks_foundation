/*
 *  ksfse.host.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Feb 28 2018
 *  Time : 11:06:49
 */

#include <values.h>
#include <string.h>
#include "epic_macros.h"
#include "epic_struct.h"
#include "ksfse.global.h"
#include "pgen_tmpl.h"
#include "ksfse.allcv.h"
#include "ksfse.tgtex.h"
#include "ksfse.hostdecl.h"
#include "ksfse.tgtdecl.h"
#include "ksfse.exportstr.h"
#include "ksfse.runtime.h"
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: HOST functions and variables
 *
 *******************************************************************************************************
 *******************************************************************************************************/

#ifndef KS_PSD_USE_APX
#define KS_PSD_USE_APX 0
#endif 

#include "sar_pm.h" /* must be before grad_rf_XXXX.h */
#include "grad_rf_empty.h" /* declaration of rfpulse[] here must be before PShost */

static char supfailfmt[] = "Support routine %s failed";
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;

#include <stdlib.h>
#include <sysDep.h>
#include <sysDepSupport.h>      /* FEC : fieldStrength dependency libraries */

/* unless 24-25x */
#include "psdopt.h"
#include "physics.h"

MODEL_PARAMETERS_STRUCT model_parameters;
PURE_MIX_STRUCT pure_mix;

int anatomy_channel_compr_enable = PSD_OFF;
int anatomy_optimal_recon_enable = PSD_OFF;
int anatomy_self_uni_corr_enable = PSD_OFF;

int apps_channel_compr_enable = PSD_OFF;
int apps_self_uni_corr_enable = PSD_OFF;



#include <stdlib.h>

#include "epic_usercv.h"
#include "physics.h"

/* for psddebugcode2 */
#define PSDDEBUG_SCAN 1
#define PSDDEBUG_IPG  2
#define PSDDEBUG_RTIA 4
#define PSDDEBUG_GSPEC 8

int Is3DGWAllowed(int maxSliceGap2ThickPercent)
{
    if ( ( (PSD_2D == exist(opimode)) || (PSD_CINE == exist(opimode)) ) && 
           ( (exist(opslspace) > (float)maxSliceGap2ThickPercent/100*exist(opslthick)+__FLT_EPSILON__) ||
             (0 == exist(opcoax)) || (exist(opnumgroups) > 1) ) )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/* Structure definitions for prescan filters*/
FILTER_INFO echo1as_filt;
FILTER_INFO echo1mps1_filt;
FILTER_INFO echo1ftg_filt;
FILTER_INFO echo1xtg_filt;
FILTER_INFO echo1cfl;
FILTER_INFO echo1cfh;
FILTER_INFO echo1rcvn;
FILTER_INFO echo1rs_filt;
FILTER_INFO echo1dtg_filt;

/* defines for pimrsaps CVs from op_prescan.h */
#ifndef PSC_MAX_CONTROL_ARRAY
#define PSC_MAX_CONTROL_ARRAY 15
#endif

#define COILLOG_LOG_MAXSIZE 262144 /* quarter-Meg */

int* pimrs[PSC_MAX_CONTROL_ARRAY];

/* YMSmr09211 04/26/2006 YI */
SCAN_INFO cfh_info[MAX_PSC_VQUANT];
SCAN_INFO ps1scan_info[PRESCAN_ROT_MAX];
SCAN_INFO rsscan_info[RFSHIM_SLQ];

/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PShost                                *
 *                                                                   *
 * Write here the code unique to the Host PSD process.               *
 *********************************************************************/
#include <string.h>
#include "sar_limit_api.h"
#include "sar_pm.h" 

/*
 *  set_presscfh_mode
 *  
 *  Type: Private Function
 *  
 *  Description: Set the modes for presscfh
 * 			PRESSCFH_SLICE 1      
 * 			PRESSCFH_SLAB 2                                              
 * 			PRESSCFH_SHIMVOL 3
 * 			PRESSCFH_SHIMVOL_SLICE 4
 * 			PRESSCFH_NONE          5
 * 
 * */

STATUS
set_presscfh_mode (void)
{
    if(exist(oppscvquant) >= 1)
    {
        if (presscfh_override > 0) 
        {
            cvoverride(presscfh, presscfh_override, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else if (cfh_steam_flag == PSD_ON)
        {
            /* For STEAM CFH mode, force to use shim volume mode */
            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            switch(exist(opimode)) 
            {
                case PSD_2D:
                case PSD_CINE: 
                    if( (opplane == PSD_3PLANE) || ((exist(oprealtime) == PSD_ON)) || (exist(opcoax) == 0) )
                    {   /* For 3-Plane or Realtime or Radial mode use SHIMVOL Mode*/
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else if(exist(opassetcal) && existcv(opassetcal) 
                               && ( (1==exist(opasset)) || (exist(opasset) == ASSET_REG_CAL) ) && existcv(opasset)) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            }
                    else /* NON-RADIAL MODE */
                    {
                        int vidx;
                        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                        {
                            if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            } 
                            else 
                            {
                                cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                break;
                            }
                        }
                    }
                    break;
                case PSD_3D:
                case PSD_3DM:
                case PSD_ANGIO:
                    /* If Shim Volume is placed */
                    if( exist(opcoax) != 0 )      /* Non-Radial/Oblique MODE */
                    {
                        if( exist(opvquant) > 1 )     /* Multiple Slabs */
                        {
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                        else     /* Single Slab */
                        {
                            int vidx;
                            for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                            {
                                if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                                {
                                    cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                                } 
                                else 
                                {
                                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                    break;
                                }
                            }
                        }
                    }
                    else     /* Radial Case or Orthogonal Slabs */
                    {
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    break;
                default: 
                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
                    break;
            }
        } 
    }
    else
    {
        cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if(presscfh_debug) 
    {
        printf("\n The presscfh is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh);
        printf("\n The presscfh_ctrl is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE), \n",presscfh_ctrl);
        printf("\n The presscfh_override is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh_override);
        fflush(stdout);
    }
    return SUCCESS;
}

/*
 *  sr_derate
 *  
 *  Type: Private Function
 *  
 *  Description:
 *    update the ramp time for loggrad by *sr_derate_factor  
 *    @param[out] lgrad, logical gradient characteristics
 *    @param[in]  sc_derate_factor, SR derating factor ( >=1.0 ) 
 *
 */

STATUS
sr_derate (LOG_GRAD *lgrad, const float sr_derate_factor, const float amp_derate_factor)
{
    STATUS status = SUCCESS;

    if ((sr_derate_factor < 1.0) || (amp_derate_factor < 1.0))
    {
        status = FAILURE;
    }
    else
    {
        lgrad->xrt = (int)ceilf(lgrad->xrt*sr_derate_factor);
        lgrad->yrt = (int)ceilf(lgrad->yrt*sr_derate_factor);
        lgrad->zrt = (int)ceilf(lgrad->zrt*sr_derate_factor);
        lgrad->xft = (int)ceilf(lgrad->xft*sr_derate_factor);
        lgrad->yft = (int)ceilf(lgrad->yft*sr_derate_factor);
        lgrad->zft = (int)ceilf(lgrad->zft*sr_derate_factor);
        
        lgrad->tx_xyz = lgrad->tx_xyz/amp_derate_factor;
        lgrad->ty_xyz = lgrad->ty_xyz/amp_derate_factor;
        lgrad->tz_xyz = lgrad->tz_xyz/amp_derate_factor;
        lgrad->tx_xy = lgrad->tx_xy/amp_derate_factor;
        lgrad->tx_xz = lgrad->tx_xz/amp_derate_factor;
        lgrad->ty_xy = lgrad->ty_xy/amp_derate_factor;
        lgrad->ty_yz = lgrad->ty_yz/amp_derate_factor;
        lgrad->tz_xz = lgrad->tz_xz/amp_derate_factor;
        lgrad->tz_yz = lgrad->tz_yz/amp_derate_factor;
        lgrad->tx = lgrad->tx/amp_derate_factor;
        lgrad->ty = lgrad->ty/amp_derate_factor;
        lgrad->tz = lgrad->tz/amp_derate_factor;

        status = SUCCESS;
    }

    return status;
}

/*
 *  PS1cvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cvinit( void )
{
    INT index;

    /* initialize pulse widths */
    pw_rf1mps1  = _pw_rf1mps1.fixedflag ?  ((void)(rfpulse[RF1_APS1_SLOT].nom_pw), pw_rf1mps1) : rfpulse[RF1_APS1_SLOT].nom_pw;
    pw_rf2mps1  = _pw_rf2mps1.fixedflag ?  ((void)(rfpulse[RF2_APS1_SLOT].nom_pw), pw_rf2mps1) : rfpulse[RF2_APS1_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(0), res_rf1mps1) : 0;
    res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(0), res_rf2mps1) : 0;

    /* initialize amplitudes */
    a_rf1mps1  = _a_rf1mps1.fixedflag ?  ((void)(0.5), a_rf1mps1) : 0.5;
    a_rf2mps1  = _a_rf2mps1.fixedflag ?  ((void)(1.0), a_rf2mps1) : 1.0;

    /* initialize flip angles */
    flip_rf1mps1  = _flip_rf1mps1.fixedflag ?  ((void)(90), flip_rf1mps1) : 90;
    flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(180), flip_rf2mps1) : 180;

    /* initialize sinc cycles */
    cyc_rf1mps1  = _cyc_rf1mps1.fixedflag ?  ((void)(1), cyc_rf1mps1) : 1;
    cyc_rf2mps1  = _cyc_rf2mps1.fixedflag ?  ((void)(1), cyc_rf2mps1) : 1;

    /* initialize gscale values */
    gscale_rf1mps1  = _gscale_rf1mps1.fixedflag ?  ((void)(0.90909), gscale_rf1mps1) : 0.90909;
    gscale_rf2mps1  = _gscale_rf2mps1.fixedflag ?  ((void)(0.4545), gscale_rf2mps1) : 0.4545;

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_OFF == local_tg) )
    {
        for( index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = 0.0;
        }

        if (1==getAps1ModPlane()) /* Axial, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (2==getAps1ModPlane()) /* Sagittal, read=z */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (3==getAps1ModPlane()) /* Coronal, read=z */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (4==getAps1ModPlane()) /* Axial, read=y */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (5==getAps1ModPlane()) /* Sagittal, read=y */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[7] = 1.0;
        }
        if (6==getAps1ModPlane()) /* Coronal, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[7] = 1.0;
        }
    }
    else if((oppscvquant > 0) && (PSD_ON == local_tg))
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = psc_info[0].oppscrot[index]; /* use shim vol rot for local tg */ 
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }
    /* end aps1_mod changes (GE) */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&ps1loggrd, &phygrd, ps1scan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp0_ps1_newgeo=ps1_newgeo,&_temp0_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PS1cvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&ps1loggrd, PSsr_derate_factor, PSamp_derate_factor);

    return SUCCESS;
}

/*
 *  CFLcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcvinit( void )
{
    /* initialize pulse widths */
    pw_rf1cfl  = _pw_rf1cfl.fixedflag ?  ((void)(rfpulse[RF1_CFL_SLOT].nom_pw), pw_rf1cfl) : rfpulse[RF1_CFL_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1cfl  = _res_rf1cfl.fixedflag ?   ((void)(0), res_rf1cfl) : 0;

    /* initialize amplitudes */
    a_rf1cfl  = _a_rf1cfl.fixedflag ?  ((void)(0.5), a_rf1cfl) : 0.5;

    /* initialize flip angles */
    flip_rf1cfl  = _flip_rf1cfl.fixedflag ?  ((void)(90), flip_rf1cfl) : 90;

    /* initialize sinc cycles */
    cyc_rf1cfl  = _cyc_rf1cfl.fixedflag ?  ((void)(2), cyc_rf1cfl) : 2; /* MRIhc54366: increased from 1 */

    /* initialize gscale values */
    gscale_rf1cfl  = _gscale_rf1cfl.fixedflag ?  ((void)(0.90909), gscale_rf1cfl) : 0.90909;

    return SUCCESS;
}


/*
 *  RCVNcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcvinit( void )
{
    if (CFG_VAL_RECEIVER_RRF == cfreceivertype)
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(1024), rcvn_xres) : 1024;
    }
    else
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(4096), rcvn_xres) : 4096;
    }
    return SUCCESS;
}


/*
 *  CFHcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcvinit( void )
{
    /* initialize pulse widths */
    pw_rf0cfh  = _pw_rf0cfh.fixedflag ?  ((void)(rfpulse[RF0_CFH_SLOT].nom_pw), pw_rf0cfh) : rfpulse[RF0_CFH_SLOT].nom_pw;
    pw_rf1cfh  = _pw_rf1cfh.fixedflag ?  ((void)(rfpulse[RF1_CFH_SLOT].nom_pw), pw_rf1cfh) : rfpulse[RF1_CFH_SLOT].nom_pw;
    pw_rf2cfh  = _pw_rf2cfh.fixedflag ?  ((void)(rfpulse[RF2_CFH_SLOT].nom_pw), pw_rf2cfh) : rfpulse[RF2_CFH_SLOT].nom_pw;
    pw_rf3cfh  = _pw_rf3cfh.fixedflag ?  ((void)(rfpulse[RF3_CFH_SLOT].nom_pw), pw_rf3cfh) : rfpulse[RF3_CFH_SLOT].nom_pw; /* For presscfh MRIhc08321 */
    pw_rf4cfh  = _pw_rf4cfh.fixedflag ?  ((void)(rfpulse[RF4_CFH_SLOT].nom_pw), pw_rf4cfh) : rfpulse[RF4_CFH_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf0cfh  = _res_rf0cfh.fixedflag ?   ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC; /* Adiabatic pulse */
    res_rf1cfh  = _res_rf1cfh.fixedflag ?   ((void)(0), res_rf1cfh) : 0;
    res_rf2cfh  = _res_rf2cfh.fixedflag ?   ((void)(0), res_rf2cfh) : 0;
    res_rf3cfh  = _res_rf3cfh.fixedflag ?   ((void)(0), res_rf3cfh) : 0; /* For presscfh MRIhc08321 */
    res_rf4cfh  = _res_rf4cfh.fixedflag ?   ((void)(0), res_rf4cfh) : 0;

    /* initialize amplitudes */
    a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
    a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
    a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
    a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; /* For presscfh MRIhc08321 */
    a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0;

    /* initialize flip angles */
    flip_rf0cfh  = _flip_rf0cfh.fixedflag ?  ((void)(180), flip_rf0cfh) : 180;
    flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
    flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
    flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; /* For presscfh MRIhc08321 */
    flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180;

    /* initialize sinc cycles */
    cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(2), cyc_rf0cfh) : 2; /* Adiabatic pulse */
    cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
    cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
    cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; /* For presscfh MRIhc08321 */
    cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1;
    a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(0.0), a_gzrf4cfh) : 0.0;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(0.0), a_gxrf2cfh) : 0.0;/*For  presscfh MRIhc11621 */
    a_gzrf1cfh  = _a_gzrf1cfh.fixedflag ?  ((void)(0.0), a_gzrf1cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0.0), a_gzrf0cfh) : 0.0;/*For presscfh MRIhc11621 */


    /* initialize gscale values */
    gscale_rf1cfh  = _gscale_rf1cfh.fixedflag ?  ((void)(0.90909), gscale_rf1cfh) : 0.90909;

#ifdef PSD_CFH_CHEMSAT
    rfpulse[RFCSSAT_CFH_SLOT].pw = &pw_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].amp = &a_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].act_fa = &flip_rfcssatcfh;
#endif

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp1_pw_rf1cfh=pw_rf1cfh,&_temp1_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp2_a_rf1cfh=a_rf1cfh,&_temp2_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp3_flip_rf1cfh=flip_rf1cfh,&_temp3_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp4_res_rf1cfh=res_rf1cfh,&_temp4_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp5_wg_rf1cfh=wg_rf1cfh,&_temp5_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp6_pw_rf2cfh=pw_rf2cfh,&_temp6_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp7_a_rf2cfh=a_rf2cfh,&_temp7_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp8_flip_rf2cfh=flip_rf2cfh,&_temp8_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp9_res_rf2cfh=res_rf2cfh,&_temp9_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp10_wg_rf2cfh=wg_rf2cfh,&_temp10_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp11_pw_rf3cfh=pw_rf3cfh,&_temp11_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp12_a_rf3cfh=a_rf3cfh,&_temp12_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp13_flip_rf3cfh=flip_rf3cfh,&_temp13_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp14_res_rf3cfh=res_rf3cfh,&_temp14_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp15_wg_rf3cfh=wg_rf3cfh,&_temp15_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp16_pw_rf4cfh=pw_rf4cfh,&_temp16_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp17_a_rf4cfh=a_rf4cfh,&_temp17_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp18_flip_rf4cfh=flip_rf4cfh,&_temp18_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp19_res_rf4cfh=res_rf4cfh,&_temp19_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp20_wg_rf4cfh=wg_rf4cfh,&_temp20_wg_rf4cfh) : &wg_rf4cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464; /* 0.5/0.61*(60/90) */
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp21_pw_rf1cfh=pw_rf1cfh,&_temp21_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp22_a_rf1cfh=a_rf1cfh,&_temp22_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp23_flip_rf1cfh=flip_rf1cfh,&_temp23_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp24_res_rf1cfh=res_rf1cfh,&_temp24_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp25_wg_rf1cfh=wg_rf1cfh,&_temp25_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp26_pw_rf2cfh=pw_rf2cfh,&_temp26_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp27_a_rf2cfh=a_rf2cfh,&_temp27_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp28_flip_rf2cfh=flip_rf2cfh,&_temp28_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp29_res_rf2cfh=res_rf2cfh,&_temp29_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp30_wg_rf2cfh=wg_rf2cfh,&_temp30_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp31_pw_rf3cfh=pw_rf3cfh,&_temp31_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp32_a_rf3cfh=a_rf3cfh,&_temp32_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp33_flip_rf3cfh=flip_rf3cfh,&_temp33_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp34_res_rf3cfh=res_rf3cfh,&_temp34_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp35_wg_rf3cfh=wg_rf3cfh,&_temp35_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp36_pw_rf4cfh=pw_rf4cfh,&_temp36_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp37_a_rf4cfh=a_rf4cfh,&_temp37_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp38_flip_rf4cfh=flip_rf4cfh,&_temp38_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp39_res_rf4cfh=res_rf4cfh,&_temp39_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp40_wg_rf4cfh=wg_rf4cfh,&_temp40_wg_rf4cfh) : &wg_rf4cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 
    }
    return SUCCESS;
}



/*
 *  PScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScvinit( void )
{
    if( (exist(opimode) == PSD_SPECTRO) || (PSD_ON == pimrsapsflg) )
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(0), fastprescan) : 0;
    }
    else
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(cffastprescan), fastprescan) : cffastprescan;
    }

    /* Set the modes for presscfh */
    set_presscfh_mode();
    
    /* Fix to set CFH,CFL,APS1, FTG slice location to be axial mid slice to ensure
       the presence of signal when sample position is off iso center such as wrist scout scans */
    if (opplane == PSD_3PLANE)
    {
        PSslice_num  = _PSslice_num.fixedflag ?  ((void)((int)(opaxial_slice/2)), PSslice_num) : (int)(opaxial_slice/2);
    }
    else
    {  /* Start of code moved up from PSpredownload section below by SL */
        FLOAT minloc;
        FLOAT maxloc;         /* For MRIge45995 */
        FLOAT midloc;         /* For MRIge45995 */
        FLOAT minimum;        /* For MRIge45995 */
        FLOAT loc;
        INT index;

        /* search through the scan table to find the location nearest
           isocenter. Save the location information for prescan since
           graphic sat and different imaging techniques can alter the
           content and format of the rspinfo structure
        */

        minloc = MAXFLOAT;  /* For MRIge45995 */
        maxloc = -MAXFLOAT; /* For MRIge45995 */

        /* First to find the center of the prescribed region, MRIge45995 */
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (loc < minloc)
            {
                minloc = loc;
            }
            if (loc > maxloc)
            {
                maxloc = loc;
            }
        }
        midloc = 0.5*(minloc + maxloc);

        /* Find the slice most close to the center of the prescribed region, MRIge45995 */
        minimum = MAXFLOAT;
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (fabs(loc-midloc) < minimum)
            {
                minimum = fabs(loc-midloc);
                PSslice_num  = _PSslice_num.fixedflag ?  ((void)(index), PSslice_num) : index;
            }
        }
    } /* End of code moved up from PSpredownload section below */

    /* Comment from /vobs/scan/MrScan/SrxControl/SrxGeos.m on setting opcoax */
    /* slightly modified */

    /* This next section determines the value of the opcoax CV  */
    /* The rules are as follows:  */
    /*   */
    /* coaxial      N   Y   Y  */
    /* offcenter    -   N   Y  */
    /* ======================  */
    /* opcoax       0   1   2  */
    /*  */
    /* The decision of NOT coaxial is determined by the following three  */
    /* conditions: (graphic rx imaging option selected) AND (oblique   */
    /* prescription) AND ( (more than one group has been prescribed) OR (Number
     * of radial slices > 1 ) ).  */
    /*  */
    /* The decision of offcenter is made based on whether or not   */
    /* all of the slices have 0 offset in their phase and frequency  */
    /* directions.  If even one is not 0, then the prescription is  */
    /* said to be offcenter.  */

    /* Use the below in the PSD Code if the HDMR2 changes for MRIhc08321
     * need to be overridden. RBA for MRIhc08321.
     */
    
    
    PS1cvinit();
    CFLcvinit();
    CFHcvinit();
    RCVNcvinit();

    /* initialize field strength and PS variables */ /* vmx 05/02/95 YO */
    PSfield_strength  = _PSfield_strength.fixedflag ?   ((void)((int)cffield), PSfield_strength) : (int)cffield;
    if(PSfield_strength <= B0_5000)
    {
        PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        PSmt  = _PSmt.fixedflag ?  ((void)(0), PSmt) : 0;
    }
    else
    {
        if (aspir_flag || (PSD_ON == exist(opspecir)))
        {   /* turn OFF ASPIR/SPECIAL during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } else {
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        }

        PSmt  = _PSmt.fixedflag ?  ((void)(1), PSmt) : 1;
    }

    pimrs[0] = _pimrsaps1.fixedflag ? (_temp41_pimrsaps1=pimrsaps1,&_temp41_pimrsaps1) : &pimrsaps1;
    pimrs[1] = _pimrsaps2.fixedflag ? (_temp42_pimrsaps2=pimrsaps2,&_temp42_pimrsaps2) : &pimrsaps2;
    pimrs[2] = _pimrsaps3.fixedflag ? (_temp43_pimrsaps3=pimrsaps3,&_temp43_pimrsaps3) : &pimrsaps3;
    pimrs[3] = _pimrsaps4.fixedflag ? (_temp44_pimrsaps4=pimrsaps4,&_temp44_pimrsaps4) : &pimrsaps4;
    pimrs[4] = _pimrsaps5.fixedflag ? (_temp45_pimrsaps5=pimrsaps5,&_temp45_pimrsaps5) : &pimrsaps5;
    pimrs[5] = _pimrsaps6.fixedflag ? (_temp46_pimrsaps6=pimrsaps6,&_temp46_pimrsaps6) : &pimrsaps6;
    pimrs[6] = _pimrsaps7.fixedflag ? (_temp47_pimrsaps7=pimrsaps7,&_temp47_pimrsaps7) : &pimrsaps7;
    pimrs[7] = _pimrsaps8.fixedflag ? (_temp48_pimrsaps8=pimrsaps8,&_temp48_pimrsaps8) : &pimrsaps8;
    pimrs[8] = _pimrsaps9.fixedflag ? (_temp49_pimrsaps9=pimrsaps9,&_temp49_pimrsaps9) : &pimrsaps9;
    pimrs[9] = _pimrsaps10.fixedflag ? (_temp50_pimrsaps10=pimrsaps10,&_temp50_pimrsaps10) : &pimrsaps10;
    pimrs[10] = _pimrsaps11.fixedflag ? (_temp51_pimrsaps11=pimrsaps11,&_temp51_pimrsaps11) : &pimrsaps11;
    pimrs[11] = _pimrsaps12.fixedflag ? (_temp52_pimrsaps12=pimrsaps12,&_temp52_pimrsaps12) : &pimrsaps12;
    pimrs[12] = _pimrsaps13.fixedflag ? (_temp53_pimrsaps13=pimrsaps13,&_temp53_pimrsaps13) : &pimrsaps13;
    pimrs[13] = _pimrsaps14.fixedflag ? (_temp54_pimrsaps14=pimrsaps14,&_temp54_pimrsaps14) : &pimrsaps14;
    pimrs[14] = _pimrsaps15.fixedflag ? (_temp55_pimrsaps15=pimrsaps15,&_temp55_pimrsaps15) : &pimrsaps15;

    
    /* MRIhc15304: we will keep asfov as cv and fill it with the value
     * from coil. Some application (Spectro related) need to decide the
     * asfov based on the application (overriding the value decided by
     * coil). */ 
    asfov  = _asfov.fixedflag ?  ((void)(coilInfo[0].autoshimFov), asfov) : coilInfo[0].autoshimFov;

    /* 
     * Set the wait time for sethubindeximm.  A 100 ms delay is
     * sufficent to apply the settings on the driver module.  On systems
     * with an RRF receiver, a longer delay (250 ms) is needed for the
     * new receiver channel map to be loaded into the DRF. 
     */
    if( cfcoilswitchmethod & COIL_SWITCH_RSP_SETHUBINDEXIMM )
    {
        if( CFG_VAL_RECEIVER_RRF == cfreceivertype )
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(250000), csw_wait_sethubindeximm) : 250000;
        }
        else
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(100000), csw_wait_sethubindeximm) : 100000;
        }
    }

    return SUCCESS;
}   /* end PScvinit() */


/*
 *  FTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcvinit( void )
{
    a_rf1ftg     = _a_rf1ftg.fixedflag ?  ((void)(0.5), a_rf1ftg) : 0.5;
    a_rf2ftg     = _a_rf2ftg.fixedflag ?  ((void)(1.0), a_rf2ftg) : 1.0;
    a_rf3ftg     = _a_rf3ftg.fixedflag ?  ((void)(1.0), a_rf3ftg) : 1.0;
    pw_rf1ftg    = _pw_rf1ftg.fixedflag ?  ((void)((int)rfpulse[RF1_FTG_SLOT].nom_pw), pw_rf1ftg) : (int)rfpulse[RF1_FTG_SLOT].nom_pw;
    pw_rf2ftg    = _pw_rf2ftg.fixedflag ?  ((void)((int)rfpulse[RF2_FTG_SLOT].nom_pw), pw_rf2ftg) : (int)rfpulse[RF2_FTG_SLOT].nom_pw;
    pw_rf3ftg    = _pw_rf3ftg.fixedflag ?  ((void)((int)rfpulse[RF3_FTG_SLOT].nom_pw), pw_rf3ftg) : (int)rfpulse[RF3_FTG_SLOT].nom_pw;
    cyc_rf1ftg   = _cyc_rf1ftg.fixedflag ?  ((void)(1), cyc_rf1ftg) : 1;
    res_rf1ftg   = _res_rf1ftg.fixedflag ?  ((void)(800), res_rf1ftg) : 800;
    cyc_rf2ftg   = _cyc_rf2ftg.fixedflag ?  ((void)(1), cyc_rf2ftg) : 1;
    res_rf2ftg   = _res_rf2ftg.fixedflag ?  ((void)(800), res_rf2ftg) : 800;
    cyc_rf3ftg   = _cyc_rf3ftg.fixedflag ?  ((void)(1), cyc_rf3ftg) : 1;
    res_rf3ftg   = _res_rf3ftg.fixedflag ?  ((void)(800), res_rf3ftg) : 800;
    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;

    return SUCCESS;
} /* end FTGcvinit() */


/*
 *  XTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcvinit( void )
{   
    double coil_maxb1, coil_maxb1_gauss, fermi_b1; /* HCSDM00157626 */
    a_rf1xtg     = _a_rf1xtg.fixedflag ?  ((void)(0.5), a_rf1xtg) : 0.5;
    a_rf2xtg     = _a_rf2xtg.fixedflag ?  ((void)(1.0), a_rf2xtg) : 1.0;
    pw_rf1xtg    = _pw_rf1xtg.fixedflag ?  ((void)((int)rfpulse[RF1_XTG_SLOT].nom_pw), pw_rf1xtg) : (int)rfpulse[RF1_XTG_SLOT].nom_pw;
    pw_rf2xtg    = _pw_rf2xtg.fixedflag ?  ((void)((int)rfpulse[RF2_XTG_SLOT].nom_pw), pw_rf2xtg) : (int)rfpulse[RF2_XTG_SLOT].nom_pw;
    cyc_rf1xtg   = _cyc_rf1xtg.fixedflag ?  ((void)(1), cyc_rf1xtg) : 1;
    res_rf1xtg   = _res_rf1xtg.fixedflag ?  ((void)(0), res_rf1xtg) : 0;
    cyc_rf2xtg   = _cyc_rf2xtg.fixedflag ?  ((void)(1), cyc_rf2xtg) : 1;
    res_rf2xtg   = _res_rf2xtg.fixedflag ?  ((void)(800), res_rf2xtg) : 800;
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;

    a_rf3xtg  = _a_rf3xtg.fixedflag ?  ((void)(-1.0), a_rf3xtg) : -1.0; 
    a_rf4xtg  = _a_rf4xtg.fixedflag ?  ((void)(1.0), a_rf4xtg) : 1.0;
    res_rf3xtg  = _res_rf3xtg.fixedflag ?  ((void)(RES_FERMI_BLS), res_rf3xtg) : RES_FERMI_BLS;
    res_rf4xtg  = _res_rf4xtg.fixedflag ?  ((void)(res_rf3xtg), res_rf4xtg) : res_rf3xtg;
    pw_rf3xtg    = _pw_rf3xtg.fixedflag ?  ((void)(pw_bsrf), pw_rf3xtg) : pw_bsrf;
    pw_rf4xtg    = _pw_rf4xtg.fixedflag ?  ((void)(pw_rf3xtg), pw_rf4xtg) : pw_rf3xtg;
    
    flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW), flip_rf3xtg) : (FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW;  /* scale flip to keep its maxB1 constant */
    /* 630 degree flip, 4ms pw: max B1 = 0.071 */
    flip_rf4xtg  = _flip_rf4xtg.fixedflag ?  ((void)(flip_rf3xtg), flip_rf4xtg) : flip_rf3xtg;       

    fermi_b1 = 100*FA_FERMI_BLS/NOM_FA_RFMT*SAR_MAXB1_FERMI_BLS;

    /* Find the maximum predicted B1 for the current weight and coil */
    /* HCSDM00384210 */

    if( SDL_RFDerating_entry( &coil_maxb1_gauss, cffield, opweight, txCoilInfo[getTxIndex(coilInfo[0])], (GRADIENT_COIL_E) cfgcoiltype, L_SCAN ) != SUCCESS)
    {
        epic_error(0, "Support routine %s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "SDL_RFDerating");
        return FAILURE;
    }

    coil_maxb1 = coil_maxb1_gauss/UTESLA2GAUSS;
        
    if(fermi_b1 > coil_maxb1)  /* disable XTG */ 
    {
        xtg_disabled = PSD_ON;
        rfpulse[RF1_XTG_SLOT].num = 0;  
        rfpulse[RF1_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF2_XTG_SLOT].num = 0; 
        rfpulse[RF2_XTG_SLOT].activity = PSD_OFF;    
        rfpulse[RF3_XTG_SLOT].num = 0;  
        rfpulse[RF3_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF4_XTG_SLOT].num = 0; 
        rfpulse[RF4_XTG_SLOT].activity = PSD_OFF;    
    }
    else
    {
        xtg_disabled = PSD_OFF;
        rfpulse[RF1_XTG_SLOT].num = 1;
        rfpulse[RF1_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF2_XTG_SLOT].num = 1;
        rfpulse[RF2_XTG_SLOT].activity = PSD_XTG_ON;    
        rfpulse[RF3_XTG_SLOT].num = 1;
        rfpulse[RF3_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF4_XTG_SLOT].num = 1;
        rfpulse[RF4_XTG_SLOT].activity = PSD_XTG_ON;    
    }
    
    xtgtr  = _xtgtr.fixedflag ?  ((void)(200000), xtgtr) : 200000;
    
    xtg_dda  = _xtg_dda.fixedflag ?  ((void)(2), xtg_dda) : 2;
    XTGacq1  = _XTGacq1.fixedflag ?  ((void)(PSD_ON), XTGacq1) : PSD_ON;
        
    return SUCCESS;
} /* end XTGcvinit() */

/*
 *  AScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScvinit( void )
{
    INT asplane;
    INT ascell;
    SCAN_INFO total_asscan_info[6];
    INT total_asplane = 3;

    td0as  = _td0as.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0as) : GRAD_UPDATE_TIME;

    /* Create a pseudo scan_info table for obloptimize to work with.
       The rotation matrices for the planes are what is important. */
    if(oppscvquant == 2)
    {
        total_asplane = oppscvquant * 3;
    }
    for( asplane = 0; asplane < total_asplane; asplane++ )
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[asplane].oprot[ascell] = 0.0;
        }
    }

    /* Axial */
    total_asscan_info[0].oprot[0] = total_asscan_info[0].oprot[4] = total_asscan_info[0].oprot[8]
        = 1.0;
    /* Sagittal */
    total_asscan_info[1].oprot[2] = total_asscan_info[1].oprot[4] = total_asscan_info[1].oprot[6]
        = 1.0;
    /* Coronal */
    total_asscan_info[2].oprot[1] = total_asscan_info[2].oprot[5] = total_asscan_info[2].oprot[6]
        = 1.0;

    if (oppscvquant > 0)
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[0].oprot[ascell] = psc_info[0].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            if (oppscvquant == 2)
            {
                total_asscan_info[3].oprot[ascell] = psc_info[1].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            }
        }

        /* Create 2nd orthogonal plane from first shim vol matrix */
        total_asscan_info[1].oprot[0] = -total_asscan_info[0].oprot[2];
        total_asscan_info[1].oprot[1] = total_asscan_info[0].oprot[1];
        total_asscan_info[1].oprot[2] = total_asscan_info[0].oprot[0];
        total_asscan_info[1].oprot[3] = -total_asscan_info[0].oprot[5];
        total_asscan_info[1].oprot[4] = total_asscan_info[0].oprot[4];
        total_asscan_info[1].oprot[5] = total_asscan_info[0].oprot[3];
        total_asscan_info[1].oprot[6] = -total_asscan_info[0].oprot[8];
        total_asscan_info[1].oprot[7] = total_asscan_info[0].oprot[7];
        total_asscan_info[1].oprot[8] = total_asscan_info[0].oprot[6];
        /* Create 3rd orthogonal plane */
        total_asscan_info[2].oprot[0] = total_asscan_info[0].oprot[0];
        total_asscan_info[2].oprot[1] = total_asscan_info[0].oprot[2];
        total_asscan_info[2].oprot[2] = -total_asscan_info[0].oprot[1];
        total_asscan_info[2].oprot[3] = total_asscan_info[0].oprot[3];
        total_asscan_info[2].oprot[4] = total_asscan_info[0].oprot[5];
        total_asscan_info[2].oprot[5] = -total_asscan_info[0].oprot[4];
        total_asscan_info[2].oprot[6] = total_asscan_info[0].oprot[6];
        total_asscan_info[2].oprot[7] = total_asscan_info[0].oprot[8];
        total_asscan_info[2].oprot[8] = -total_asscan_info[0].oprot[7];

        if (oppscvquant == 2)
        {
            /* Create 2nd orthogonal plane for 2nd shim vol */
            total_asscan_info[4].oprot[0] = -total_asscan_info[3].oprot[2];
            total_asscan_info[4].oprot[1] = total_asscan_info[3].oprot[1];
            total_asscan_info[4].oprot[2] = total_asscan_info[3].oprot[0];
            total_asscan_info[4].oprot[3] = -total_asscan_info[3].oprot[5];
            total_asscan_info[4].oprot[4] = total_asscan_info[3].oprot[4];
            total_asscan_info[4].oprot[5] = total_asscan_info[3].oprot[3];
            total_asscan_info[4].oprot[6] = -total_asscan_info[3].oprot[8];
            total_asscan_info[4].oprot[7] = total_asscan_info[3].oprot[7];
            total_asscan_info[4].oprot[8] = total_asscan_info[3].oprot[6];
            /* Create 3rd orthogonal plane */
            total_asscan_info[5].oprot[0] = total_asscan_info[3].oprot[0];
            total_asscan_info[5].oprot[1] = total_asscan_info[3].oprot[2];
            total_asscan_info[5].oprot[2] = -total_asscan_info[3].oprot[1];
            total_asscan_info[5].oprot[3] = total_asscan_info[3].oprot[3];
            total_asscan_info[5].oprot[4] = total_asscan_info[3].oprot[5];
            total_asscan_info[5].oprot[5] = -total_asscan_info[3].oprot[4];
            total_asscan_info[5].oprot[6] = total_asscan_info[3].oprot[6];
            total_asscan_info[5].oprot[7] = total_asscan_info[3].oprot[8];
            total_asscan_info[5].oprot[8] = -total_asscan_info[3].oprot[7];
        }
    }
  
    as_newgeo  = _as_newgeo.fixedflag ?  ((void)(1), as_newgeo) : 1;
    if (FAILURE==obloptimize(&asloggrd, &phygrd, total_asscan_info, total_asplane, PSD_OBL,
                             0, PSD_OBL_RESTRICT, asobl_debug, _as_newgeo.fixedflag ? (_temp56_as_newgeo=as_newgeo,&_temp56_as_newgeo) : &as_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in AScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&asloggrd, PSassr_derate_factor, PSasamp_derate_factor);

    /* X Killer CVs */
    if (FAILURE==amppwgrad(asx_killer_area, asloggrd.tx_xz, 0.0, 0.0, asloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkas.fixedflag ? (_temp57_a_gxkas=a_gxkas,&_temp57_a_gxkas) : &a_gxkas, _pw_gxkasa.fixedflag ? (_temp58_pw_gxkasa=pw_gxkasa,&_temp58_pw_gxkasa) : &pw_gxkasa,
                           _pw_gxkas.fixedflag ? (_temp59_pw_gxkas=pw_gxkas,&_temp59_pw_gxkas) : &pw_gxkas, _pw_gxkasd.fixedflag ? (_temp60_pw_gxkasd=pw_gxkasd,&_temp60_pw_gxkasd) : &pw_gxkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkas"); 
        return FAILURE;
    }

    /* Z Killer CVs */
    if (FAILURE==amppwgrad(asz_killer_area, asloggrd.tz_xz, 0.0, 0.0, asloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkas.fixedflag ? (_temp61_a_gzkas=a_gzkas,&_temp61_a_gzkas) : &a_gzkas, _pw_gzkasa.fixedflag ? (_temp62_pw_gzkasa=pw_gzkasa,&_temp62_pw_gzkasa) : &pw_gzkasa,
                           _pw_gzkas.fixedflag ? (_temp63_pw_gzkas=pw_gzkas,&_temp63_pw_gzkas) : &pw_gzkas, _pw_gzkasd.fixedflag ? (_temp64_pw_gzkasd=pw_gzkasd,&_temp64_pw_gzkasd) : &pw_gzkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkas"); 
        return FAILURE;
    }

    /* rf1 cvs  */
    a_rf1as  = _a_rf1as.fixedflag ?  ((void)(1.0), a_rf1as) : 1.0;
    pw_rf1as  = _pw_rf1as.fixedflag ?  ((void)(rfpulse[RF1_AUTOSHIM].nom_pw), pw_rf1as) : rfpulse[RF1_AUTOSHIM].nom_pw;
    gscale_rf1as  = _gscale_rf1as.fixedflag ?  ((void)(.90909), gscale_rf1as) : .90909;
    cyc_rf1as  = _cyc_rf1as.fixedflag ?  ((void)(1), cyc_rf1as) : 1;
    res_rf1as  = _res_rf1as.fixedflag ?  ((void)(0), res_rf1as) : 0; /* initialized to zero for system safety check in cveval */

    /* gzrf1 cvs */
    pw_gzrf1as  = _pw_gzrf1as.fixedflag ?  ((void)(pw_rf1as), pw_gzrf1as) : pw_rf1as;
    flip_rf1as  = _flip_rf1as.fixedflag ?  ((void)(asflip), flip_rf1as) : asflip;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadas   = _tleadas.fixedflag ?    ((void)(RUP_GRD(24)), tleadas) : RUP_GRD(24);
    bw_rf1as  = _bw_rf1as.fixedflag ?      ((void)((int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000))), bw_rf1as) : (int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000));
    t_exaas   = _t_exaas.fixedflag ?     ((void)(pw_gzrf1asa+pw_rf1as/2), t_exaas) : pw_gzrf1asa+pw_rf1as/2;

    return SUCCESS;
} /* end AScvinit() */


/*
 *  RScvinit
 *  Description:
 *  CV init for RFShim 
 *  
 *  Type: Public Function
 *  
 */
STATUS
RScvinit( void )
{
    INT index;

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* BLS RF pulse */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10.0), flip_rf1rs) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_RFSHIM_SLOT].abswidth = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].effwidth = 0.6755;
    rfpulse[RFB_RFSHIM_SLOT].area = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].dtycyc = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].maxpw = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_RFSHIM_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_RFSHIM_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_RFSHIM_SLOT].nom_fa = 90.0;
    rfpulse[RFB_RFSHIM_SLOT].act_fa = _flip_rfbrs.fixedflag ? (_temp65_flip_rfbrs=flip_rfbrs,&_temp65_flip_rfbrs) : &flip_rfbrs;
    rfpulse[RFB_RFSHIM_SLOT].nom_pw = 2000;
    rfpulse[RFB_RFSHIM_SLOT].num = 1;

    pw_rfbrs  = _pw_rfbrs.fixedflag ?  ((void)(2000), pw_rfbrs) : 2000;
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(1000), res_rfbrs) : 1000;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    /* B1 Map rf1 */
    gscale_rf1rs  = _gscale_rf1rs.fixedflag ?  ((void)(1.0), gscale_rf1rs) : 1.0;
    a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(3200), pw_rf1rs) : 3200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(pw_rf1rs/RF_UPDATE_TIME), res_rf1rs) : pw_rf1rs/RF_UPDATE_TIME;
            cyc_rf1rs  = _cyc_rf1rs.fixedflag ?  ((void)(1), cyc_rf1rs) : 1;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rs_off90  = _rs_off90.fixedflag ?  ((void)(PSoff90), rs_off90) : PSoff90;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_RFSHIM_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = 3200;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = 90;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(1200), pw_rf1rs) : 1200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(RES_TBW6), res_rf1rs) : RES_TBW6;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;
    }

    /* Only support single slice RF Shim now */
    if ( PSD_ON == rsaxial_flag )
    {
        for( index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = 0.0;
        }

        if( (strstr(coilInfo[0].coilName,"Breast") != NULL) || (strstr(coilInfo[0].coilName,"breast") != NULL)
           || (strstr(coilInfo[0].coilName,"BREAST") != NULL) || (strstr(coilInfo[0].coilName,"Brst") != NULL)
           || isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD) ) 
        {
            /* Axial plane, Freq A/P for breast coil or Head Anatomy */
            rsscan_info[0].oprot[1] = rsscan_info[0].oprot[3] = rsscan_info[0].oprot[8] = 1.0;
        }
        else   /* Freq R/L */
        {
            rsscan_info[0].oprot[0] = rsscan_info[0].oprot[4] = rsscan_info[0].oprot[8] = 1.0;
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&rsloggrd, &phygrd, rsscan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp66_ps1_newgeo=ps1_newgeo,&_temp66_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for silent PSC */ 
    sr_derate(&rsloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* gzrf1 cvs */
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadrs   = _tleadrs.fixedflag ?    ((void)(RUP_GRD(24)), tleadrs) : RUP_GRD(24);

    return SUCCESS;
}  /* end RScvinit */

/* 
 *  DTGcvinit
 *  Description:
 *  CV init for Dynamic TG 
 *  
 *  Type: Public Function
 *  
 */
STATUS
DTGcvinit( void )
{

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180.0), flip_rfbdtg) : 180.0;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10.0), flip_rf1dtg) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_DYNTG_SLOT].abswidth = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].effwidth = 0.6755;
    rfpulse[RFB_DYNTG_SLOT].area = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].dtycyc = 1.0;
    rfpulse[RFB_DYNTG_SLOT].maxpw = 1.0;
    rfpulse[RFB_DYNTG_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_DYNTG_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_DYNTG_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_DYNTG_SLOT].nom_fa = 90.0;
    rfpulse[RFB_DYNTG_SLOT].act_fa = _flip_rfbdtg.fixedflag ? (_temp67_flip_rfbdtg=flip_rfbdtg,&_temp67_flip_rfbdtg) : &flip_rfbdtg;
    rfpulse[RFB_DYNTG_SLOT].nom_pw = 2000;
    rfpulse[RFB_DYNTG_SLOT].num = 1;


    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(1000), res_rfbdtg) : 1000;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;
    pw_rfbdtg  = _pw_rfbdtg.fixedflag ?  ((void)(2000), pw_rfbdtg) : 2000;

    /* B1 Map rf1 */
    a_rf1dtg  = _a_rf1dtg.fixedflag ?  ((void)(1.0), a_rf1dtg) : 1.0;
    gscale_rf1dtg  = _gscale_rf1dtg.fixedflag ?  ((void)(1.0), gscale_rf1dtg) : 1.0;
    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(3200), pw_rf1dtg) : 3200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(pw_rf1dtg/RF_UPDATE_TIME), res_rf1dtg) : pw_rf1dtg/RF_UPDATE_TIME;
            cyc_rf1dtg  = _cyc_rf1dtg.fixedflag ?  ((void)(1), cyc_rf1dtg) : 1;
            dtg_off90  = _dtg_off90.fixedflag ?  ((void)(PSoff90), dtg_off90) : PSoff90;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_DYNTG_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_DYNTG_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_DYNTG_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_DYNTG_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = 3200;
            rfpulse[RF1_DYNTG_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = 90;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(1200), pw_rf1dtg) : 1200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(RES_TBW6), res_rf1dtg) : RES_TBW6;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_DYNTG_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_DYNTG_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_DYNTG_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_DYNTG_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;
    }


    /* gzrf1 cvs */
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    /*******************/
    /* Starting point  */
    /*******************/
    tleaddtg   = _tleaddtg.fixedflag ?    ((void)(RUP_GRD(24)), tleaddtg) : RUP_GRD(24);

    return SUCCESS;
}  /* end DTGcvinit */

/*
 *  PS1cveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cveval( FLOAT *opthickPS )
{
    LONG bw_rf1mps1, bw_rf2mps1;    /* band widths of rf pulses */
    FLOAT area_pulse;
    FLOAT area_readrampmps1;
    FLOAT area_gxwmps1;
    FLOAT av_temp_float1 = 0;
    INT ps1_xrt;
    FLOAT ps1_tx;
    FLOAT ps1_tx_xz;
    FLOAT ps1_tz_xz;


    /* check for breast L/R coil */
    if( (strstr(coilInfo[0].coilName, "R_BREAST") != NULL) ||
        (strstr(coilInfo[0].coilName, "L_BREAST") != NULL) ||
        (strstr(coilInfo[0].coilName, "BreastL") != NULL) ||
        (strstr(coilInfo[0].coilName, "BreastR") != NULL) ||
        (strstr(coilInfo[0].coilName, "RtBreast") != NULL) ||
        (strstr(coilInfo[0].coilName, "LtBreast") != NULL) ||
        (strstr(coilInfo[0].coilName, "breast L") != NULL) ||
        (strstr(coilInfo[0].coilName, "breast R") != NULL) ||
        (strstr(coilInfo[0].coilName, "BrstL") != NULL) ||
        (strstr(coilInfo[0].coilName, "BrstR") != NULL) ||
        (strstr(coilInfo[0].coilName, "BREASTPA R") != NULL) ||
        (strstr(coilInfo[0].coilName, "BREASTPA L") != NULL) )
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_ON), ps1_rxcoil) : PSD_ON;  /* Flag for R or L breast coil for TG */
    }
    else
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_OFF), ps1_rxcoil) : PSD_OFF;
    }

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_ON == ps1_rxcoil) )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(getAps1ModFov()), mpsfov) : getAps1ModFov();
    }
    else
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(cfsystemmaxfov), mpsfov) : cfsystemmaxfov;
    }

    if(PSD_ON == local_tg)
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(TGopslthickx), mpsfov) : TGopslthickx;
    }

    ps1_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ps1_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ps1_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ps1_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);

    /* Z slice select for 90 pulse */
    bw_rf1mps1 = (LONG)(rfpulse[RF1_APS1_SLOT].nom_bw*rfpulse[RF1_APS1_SLOT].nom_pw/(float)pw_rf1mps1);

    if (FAILURE==ampslice(&av_temp_float1, bw_rf1mps1, ps1loggrd.tz, gscale_rf1mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1*10.0)/10.0;
    if (av_temp_float1 > *opthickPS)
    {
        *opthickPS = av_temp_float1;
    }

    if (0 == getAps1Mod()) {
        cvoverride(thickPS_mod, *opthickPS, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        float fov = FMax(2, getAps1ModSlThick(), av_temp_float1);
        cvoverride(thickPS_mod, fov, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(PSD_ON == local_tg)
    {
        pw_gyrf1mps1  = _pw_gyrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gyrf1mps1) : pw_rf1mps1;
        if(av_temp_float1 > TGopslthicky)
        {
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(av_temp_float1), TGopslthicky) : av_temp_float1;
        }

        if (FAILURE==ampslice(_a_gyrf1mps1.fixedflag ? (_temp68_a_gyrf1mps1=a_gyrf1mps1,&_temp68_a_gyrf1mps1) : &a_gyrf1mps1, bw_rf1mps1,TGopslthicky,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1mps1.");
            return FAILURE;
        }

        /* slice selection ramp */
        if (optramp(_pw_gyrf1mps1a.fixedflag ? (_temp69_pw_gyrf1mps1a=pw_gyrf1mps1a,&_temp69_pw_gyrf1mps1a) : &pw_gyrf1mps1a, a_gyrf1mps1, ps1loggrd.ty, ps1loggrd.yrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1mps1a.");
            return FAILURE;
        }
        pw_gyrf1mps1d  = _pw_gyrf1mps1d.fixedflag ?  ((void)(pw_gyrf1mps1a), pw_gyrf1mps1d) : pw_gyrf1mps1a;

        area_pulse = a_gyrf1mps1*(pw_gyrf1mps1/2 + PSoff90 + pw_gyrf1mps1d/2);
        if (amppwgz1(_a_gy1mps1.fixedflag ? (_temp70_a_gy1mps1=a_gy1mps1,&_temp70_a_gy1mps1) : &a_gy1mps1,_pw_gy1mps1.fixedflag ? (_temp71_pw_gy1mps1=pw_gy1mps1,&_temp71_pw_gy1mps1) : &pw_gy1mps1,_pw_gy1mps1a.fixedflag ? (_temp72_pw_gy1mps1a=pw_gy1mps1a,&_temp72_pw_gy1mps1a) : &pw_gy1mps1a,_pw_gy1mps1d.fixedflag ? (_temp73_pw_gy1mps1d=pw_gy1mps1d,&_temp73_pw_gy1mps1d) : &pw_gy1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }

        if(av_temp_float1 > TGopslthick)
        {
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(av_temp_float1), TGopslthick) : av_temp_float1;
        }

        thickPS_mod  = _thickPS_mod.fixedflag ?  ((void)(TGopslthick), thickPS_mod) : TGopslthick;
    }
    else
    {
        pw_gzrf1mps1  = _pw_gzrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gzrf1mps1) : pw_rf1mps1;
        if (FAILURE==ampslice(_a_gzrf1mps1.fixedflag ? (_temp74_a_gzrf1mps1=a_gzrf1mps1,&_temp74_a_gzrf1mps1) : &a_gzrf1mps1, bw_rf1mps1,thickPS_mod,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gzrf1mps1.");
            return FAILURE;
        }
        /* end aps1_mod changes (GE) */

        /* slice selection ramp */
        if (optramp(_pw_gzrf1mps1a.fixedflag ? (_temp75_pw_gzrf1mps1a=pw_gzrf1mps1a,&_temp75_pw_gzrf1mps1a) : &pw_gzrf1mps1a, a_gzrf1mps1, ps1loggrd.tz, ps1loggrd.zrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */ 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gzrf1mps1a.");
            return FAILURE;
        }
        pw_gzrf1mps1d  = _pw_gzrf1mps1d.fixedflag ?  ((void)(pw_gzrf1mps1a), pw_gzrf1mps1d) : pw_gzrf1mps1a;

        /* Z gradient refocus */
        /* available time not calculated, defaulted to 10ms */
        area_pulse = a_gzrf1mps1*(pw_gzrf1mps1/2 + PSoff90 + pw_gzrf1mps1d/2);
        if (amppwgz1(_a_gz1mps1.fixedflag ? (_temp76_a_gz1mps1=a_gz1mps1,&_temp76_a_gz1mps1) : &a_gz1mps1,_pw_gz1mps1.fixedflag ? (_temp77_pw_gz1mps1=pw_gz1mps1,&_temp77_pw_gz1mps1) : &pw_gz1mps1,_pw_gz1mps1a.fixedflag ? (_temp78_pw_gz1mps1a=pw_gz1mps1a,&_temp78_pw_gz1mps1a) : &pw_gz1mps1a,_pw_gz1mps1d.fixedflag ? (_temp79_pw_gz1mps1d=pw_gz1mps1d,&_temp79_pw_gz1mps1d) : &pw_gz1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }
    }

    /* Z gradient crushers for 180 pulse */
    /* Left crusher. Denoted by the "l" after the "2"  in "gzrf2lmps1" */
    if (amppwgrad(ps_crusher_area, ps1_tz_xz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzrf2lmps1.fixedflag ? (_temp80_a_gzrf2lmps1=a_gzrf2lmps1,&_temp80_a_gzrf2lmps1) : &a_gzrf2lmps1, _pw_gzrf2lmps1a.fixedflag ? (_temp81_pw_gzrf2lmps1a=pw_gzrf2lmps1a,&_temp81_pw_gzrf2lmps1a) : &pw_gzrf2lmps1a,
                  _pw_gzrf2lmps1.fixedflag ? (_temp82_pw_gzrf2lmps1=pw_gzrf2lmps1,&_temp82_pw_gzrf2lmps1) : &pw_gzrf2lmps1, _pw_gzrf2lmps1d.fixedflag ? (_temp83_pw_gzrf2lmps1d=pw_gzrf2lmps1d,&_temp83_pw_gzrf2lmps1d) : &pw_gzrf2lmps1d) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzrf2lmps1"); 
        return FAILURE;
    }
  
    /* Right crusher. Denoted by the "r" after the "2" in "gzrf2rmps1"*/
    /* This is identical to left crusher */
    pw_gzrf2rmps1  = _pw_gzrf2rmps1.fixedflag ?  ((void)(pw_gzrf2lmps1), pw_gzrf2rmps1) : pw_gzrf2lmps1;
    a_gzrf2rmps1  = _a_gzrf2rmps1.fixedflag ?   ((void)(a_gzrf2lmps1), a_gzrf2rmps1) : a_gzrf2lmps1;

    /* right crusher ramps */
    pw_gzrf2rmps1a  = _pw_gzrf2rmps1a.fixedflag ?  ((void)(pw_gzrf2lmps1a), pw_gzrf2rmps1a) : pw_gzrf2lmps1a;
    pw_gzrf2rmps1d  = _pw_gzrf2rmps1d.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2rmps1d) : pw_gzrf2lmps1d;

    /* Z slice select for 180 pulse */
    pw_gzrf2mps1  = _pw_gzrf2mps1.fixedflag ?  ((void)(pw_rf2mps1), pw_gzrf2mps1) : pw_rf2mps1;
    bw_rf2mps1 = (LONG)(rfpulse[RF2_APS1_SLOT].nom_bw*rfpulse[RF2_APS1_SLOT].nom_pw/(float)pw_rf2mps1);

    /* begin aps1_mod changes (GE) */
    if (FAILURE==ampslice(_a_gzrf2mps1.fixedflag ? (_temp84_a_gzrf2mps1=a_gzrf2mps1,&_temp84_a_gzrf2mps1) : &a_gzrf2mps1, bw_rf2mps1, thickPS_mod, gscale_rf2mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* match ramps so gradient can be bridged in pulsegen */
    pw_gzrf2mps1a  = _pw_gzrf2mps1a.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2mps1a) : pw_gzrf2lmps1d;
    pw_gzrf2mps1d  = _pw_gzrf2mps1d.fixedflag ?  ((void)(pw_gzrf2rmps1a), pw_gzrf2mps1d) : pw_gzrf2rmps1a;

    /* readout gradient */
    if (FAILURE==calcfilter( &echo1mps1_filt, 15.625, 256, OVERWRITE_NONE))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1mps1_filt");
        return FAILURE;
    }

    /* MRIge30642 */
    /* Need check on fov.  Otherwise causes dwnld failures w/0.8 G/cm. */ 
    if (ampfov(&av_temp_float1, echo1mps1_filt.bw, ps1_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1/ 10.0) * 10.0;
    if( av_temp_float1 > mpsfov )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(av_temp_float1), mpsfov) : av_temp_float1;
    }

    if (ampfov(_a_gxwmps1.fixedflag ? (_temp85_a_gxwmps1=a_gxwmps1,&_temp85_a_gxwmps1) : &a_gxwmps1, echo1mps1_filt.bw, mpsfov) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwmps1.");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmps1a.fixedflag ? (_temp86_pw_gxwmps1a=pw_gxwmps1a,&_temp86_pw_gxwmps1a) : &pw_gxwmps1a, a_gxwmps1, ps1_tx, ps1_xrt,
                TYPDEF)==FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxwmps1a.");
        return FAILURE;
    }
  
    pw_gxwmps1d  = _pw_gxwmps1d.fixedflag ?  ((void)(pw_gxwmps1a), pw_gxwmps1d) : pw_gxwmps1a;

    pw_gxwmps1  = _pw_gxwmps1.fixedflag ?  ((void)(echo1mps1_filt.tdaq), pw_gxwmps1) : echo1mps1_filt.tdaq;
  
    /* dephaser */
    area_gxwmps1 = a_gxwmps1*(pw_gxwmps1);
    area_readrampmps1 = 0.5*pw_gxwmps1a*a_gxwmps1;

    if (amppwgx1(_a_gx1mps1.fixedflag ? (_temp87_a_gx1mps1=a_gx1mps1,&_temp87_a_gx1mps1) : &a_gx1mps1, _pw_gx1mps1.fixedflag ? (_temp88_pw_gx1mps1=pw_gx1mps1,&_temp88_pw_gx1mps1) : &pw_gx1mps1, _pw_gx1mps1a.fixedflag ? (_temp89_pw_gx1mps1a=pw_gx1mps1a,&_temp89_pw_gx1mps1a) : &pw_gx1mps1a ,_pw_gx1mps1d.fixedflag ? (_temp90_pw_gx1mps1d=pw_gx1mps1d,&_temp90_pw_gx1mps1d) : &pw_gx1mps1d, TYPSPIN,
                 area_gxwmps1, (float)area_readrampmps1, 
                 (int)1000000, 1.0, MIN_PLATEAU_TIME, ps1_xrt, ps1_tx_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1mps1.");
        return FAILURE;
    }

    /* Y gradient is not used in MPS1 */

    return SUCCESS;
}

/*
 *  CFLcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcveval( FLOAT opthickPS )
{
    LONG bw_rf1cfl;
    FLOAT area_gz1cfl;

    cflloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&cflloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(2), cfl_dda) : 2;      /* BJM MRIge80347: Changed from 0 -> 2 for MGD, coil switch problem */
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(1), cfl_nex) : 1;
    }
    else
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(4), cfl_dda) : 4;
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(2), cfl_nex) : 2;
    }

    if(cffield == B0_2000) 
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(10.41666), echo1bwcfl) : 10.41666;
    } 
    else if(cffield == B0_15000)
    {
        /* MRIhc54366: accommodate B0 drift using larger receive bandwidth 
           with matched spectral resolution */
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(7.8125), echo1bwcfl) : 7.8125;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }
    else
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(15.625), echo1bwcfl) : 15.625;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }

    /* MRIhc54366: changed hard coded number of output points to CFLxres */
    if ( FAILURE==calcfilter( &echo1cfl, echo1bwcfl, CFLxres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfl_filt");
        return FAILURE;
    }

    /* MRIhc54366: dynamic CFL excitation pulse selection: */
    if(cyc_rf1cfl == 2)
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC2;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC2;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC2;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC2;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC2;
        rfpulse[RF1_CFL_SLOT].max_b1 = SAR_MAXB1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 2500;
    }
    else
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC1;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RF1_CFL_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 1250;
    }
    /* MRIhc54366: END pulse selection. */

    /* CFL acq duration needed for attenuator setting */
    cfl_tdaq = echo1cfl.tdaq;

    pw_gzrf1cfl  = _pw_gzrf1cfl.fixedflag ?  ((void)(pw_rf1cfl), pw_gzrf1cfl) : pw_rf1cfl;
    bw_rf1cfl = (LONG)(rfpulse[RF1_CFL_SLOT].nom_bw*rfpulse[RF1_CFL_SLOT].nom_pw/(float)pw_rf1cfl);

    /* MRIhc54366: new lower limit */
    opthickPS = (exist(opslthick) < 5.0) ? 5.0 : exist(opslthick);

    if ( FAILURE==ampslice(_a_gzrf1cfl.fixedflag ? (_temp91_a_gzrf1cfl=a_gzrf1cfl,&_temp91_a_gzrf1cfl) : &a_gzrf1cfl, bw_rf1cfl, opthickPS, gscale_rf1cfl, TYPDEF) ) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    if ( FAILURE==optramp(_pw_gzrf1cfla.fixedflag ? (_temp92_pw_gzrf1cfla=pw_gzrf1cfla,&_temp92_pw_gzrf1cfla) : &pw_gzrf1cfla, a_gzrf1cfl, cflloggrd.tz, cflloggrd.zrt, TYPDEF) )  
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfld  = _pw_gzrf1cfld.fixedflag ?  ((void)(pw_gzrf1cfla), pw_gzrf1cfld) : pw_gzrf1cfla;

    /* Find Params for refocusing pulse */
    area_gz1cfl =  a_gzrf1cfl *0.5* ( pw_gzrf1cfl + pw_gzrf1cfld);
    if ( FAILURE==amppwgz1(_a_gz1cfl.fixedflag ? (_temp93_a_gz1cfl=a_gz1cfl,&_temp93_a_gz1cfl) : &a_gz1cfl, _pw_gz1cfl.fixedflag ? (_temp94_pw_gz1cfl=pw_gz1cfl,&_temp94_pw_gz1cfl) : &pw_gz1cfl, _pw_gz1cfla.fixedflag ? (_temp95_pw_gz1cfla=pw_gz1cfla,&_temp95_pw_gz1cfla) : &pw_gz1cfla, _pw_gz1cfld.fixedflag ? (_temp96_pw_gz1cfld=pw_gz1cfld,&_temp96_pw_gz1cfld) : &pw_gz1cfld, 
                           area_gz1cfl, (INT)1000000, MIN_PLATEAU_TIME,
                           cflloggrd.zrt, cflloggrd.tz) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1cfl");
        return FAILURE;
    }

    /* Find Params for killer pulse */
    area_gykcfl  = _area_gykcfl.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfl) : amp_killer*pw_killer;
    if ( FAILURE==amppwgrad(area_gykcfl, cflloggrd.ty, 0.0, 0.0, cflloggrd.yrt,
                            MIN_PLATEAU_TIME, _a_gykcfl.fixedflag ? (_temp97_a_gykcfl=a_gykcfl,&_temp97_a_gykcfl) : &a_gykcfl, _pw_gykcfla.fixedflag ? (_temp98_pw_gykcfla=pw_gykcfla,&_temp98_pw_gykcfla) : &pw_gykcfla,
                            _pw_gykcfl.fixedflag ? (_temp99_pw_gykcfl=pw_gykcfl,&_temp99_pw_gykcfl) : &pw_gykcfl, _pw_gykcfld.fixedflag ? (_temp100_pw_gykcfld=pw_gykcfld,&_temp100_pw_gykcfld) : &pw_gykcfld) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfl");
        return FAILURE;
    }

    return SUCCESS;
}


/*
 *  RCVNcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcveval( void )
{
    rcvnloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&rcvnloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient before Receiver noise sequence */

    if ( FAILURE==amppwgrad( area_gxkrcvn, rcvnloggrd.tx_xyz, 0.0, 0.0, rcvnloggrd.xrt,
                             MIN_PLATEAU_TIME, _a_gxkrcvn.fixedflag ? (_temp101_a_gxkrcvn=a_gxkrcvn,&_temp101_a_gxkrcvn) : &a_gxkrcvn, _pw_gxkrcvna.fixedflag ? (_temp102_pw_gxkrcvna=pw_gxkrcvna,&_temp102_pw_gxkrcvna) : &pw_gxkrcvna,
                             _pw_gxkrcvn.fixedflag ? (_temp103_pw_gxkrcvn=pw_gxkrcvn,&_temp103_pw_gxkrcvn) : &pw_gxkrcvn, _pw_gxkrcvnd.fixedflag ? (_temp104_pw_gxkrcvnd=pw_gxkrcvnd,&_temp104_pw_gxkrcvnd) : &pw_gxkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gxkrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gykrcvn, rcvnloggrd.ty_xyz, 0.0, 0.0, rcvnloggrd.yrt,
                             MIN_PLATEAU_TIME, _a_gykrcvn.fixedflag ? (_temp105_a_gykrcvn=a_gykrcvn,&_temp105_a_gykrcvn) : &a_gykrcvn, _pw_gykrcvna.fixedflag ? (_temp106_pw_gykrcvna=pw_gykrcvna,&_temp106_pw_gykrcvna) : &pw_gykrcvna,
                             _pw_gykrcvn.fixedflag ? (_temp107_pw_gykrcvn=pw_gykrcvn,&_temp107_pw_gykrcvn) : &pw_gykrcvn, _pw_gykrcvnd.fixedflag ? (_temp108_pw_gykrcvnd=pw_gykrcvnd,&_temp108_pw_gykrcvnd) : &pw_gykrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gzkrcvn, rcvnloggrd.tz_xyz, 0.0, 0.0, rcvnloggrd.zrt,
                             MIN_PLATEAU_TIME, _a_gzkrcvn.fixedflag ? (_temp109_a_gzkrcvn=a_gzkrcvn,&_temp109_a_gzkrcvn) : &a_gzkrcvn, _pw_gzkrcvna.fixedflag ? (_temp110_pw_gzkrcvna=pw_gzkrcvna,&_temp110_pw_gzkrcvna) : &pw_gzkrcvna,
                             _pw_gzkrcvn.fixedflag ? (_temp111_pw_gzkrcvn=pw_gzkrcvn,&_temp111_pw_gzkrcvn) : &pw_gzkrcvn, _pw_gzkrcvnd.fixedflag ? (_temp112_pw_gzkrcvnd=pw_gzkrcvnd,&_temp112_pw_gzkrcvnd) : &pw_gzkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzkrcvn");
        return FAILURE;
    }

    if ( rcvn_flag == 1 )
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?    ((void)(IMax(2,20000,RUP_GRD(pw_gxkrcvna+pw_gxkrcvn+pw_gxkrcvnd+1000))), pre_rcvn_tr) : IMax(2,20000,RUP_GRD(pw_gxkrcvna+pw_gxkrcvn+pw_gxkrcvnd+1000));
    }
    else if(rcvn_flag == 2)  /* extra delay before rcvn */
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?  ((void)(1000000), pre_rcvn_tr) : 1000000;
    }

    if (existcv(oprbw))
    {
        echo1bwrcvn  = _echo1bwrcvn.fixedflag ?  ((void)(exist(oprbw)), echo1bwrcvn) : exist(oprbw);
    }

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW)), echo1bwrcvn) : FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW);

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW)), echo1bwrcvn) : FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW);

    if ( FAILURE==calcfilter( &echo1rcvn, echo1bwrcvn, rcvn_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rcvn");
        return FAILURE;
    }

    /* RCVN acq duration needed for attenuator setting */
    rcvn_tdaq = echo1rcvn.tdaq;

    /* Add 20ms dead time to prevent runtime errors */
    rcvn_tr  = _rcvn_tr.fixedflag ?       ((void)(IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR)), rcvn_tr) : IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR);

    /* To make sure RCVN loops enough to acquire 4K points */
    rcvn_loops  = _rcvn_loops.fixedflag ?       ((void)(IMax(2,2*(int)(4096/rcvn_xres),1)), rcvn_loops) : IMax(2,2*(int)(4096/rcvn_xres),1);

    return SUCCESS;
}

/*
 *  AScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScveval( void )
{
    /* DV26: Baseline used for Autoshim noise level thresholding */
    asbaseline  = _asbaseline.fixedflag ?  ((void)(8), asbaseline) : 8;
    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) ||
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(0), as_dda) : 0;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(62.5), echo1bwas) : 62.5;
        asxres  = _asxres.fixedflag ?  ((void)(128), asxres) : 128;
        asyres  = _asyres.fixedflag ?   ((void)(64), asyres) : 64;
        /* asres=128 and asyres=64 for all T fields */
    }
    else
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(4), as_dda) : 4;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(15.625), echo1bwas) : 15.625;
        asxres  = _asxres.fixedflag ?  ((void)(256), asxres) : 256;
        asyres  = _asyres.fixedflag ?  ((void)(128), asyres) : 128;
        te_as  = _te_as.fixedflag ?  ((void)(9000), te_as) : 9000;
        if (cffield == B0_15000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
        }
        else if (cffield == B0_10000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(30000), tr_as) : 30000;
        }
        else if (cffield == B0_2000) /* profile 05/22/95 NM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000; /* Profile 09/29/95 NM */
        }
        else if (cffield == B0_3500) /* MFO,Hino, Feb/02/00 MM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000;
        }
        else if (cffield == B0_5000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(35000), tr_as) : 35000;
        }
        else if (cffield == B0_40000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(32000), tr_as) : 32000;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else 
        {
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
    }

    /* MRIge21914 - moved deltf to @cv */

    /* Call the SDL function to compute fat-water separation. */
    deltf  = _deltf.fixedflag ?    ((void)(SDL_GetChemicalShift(cffield)), deltf) : SDL_GetChemicalShift(cffield);
    /* In phase delta TE will be used in MFO. Hino, Feb/02/00 MM */

    /* dixon time shift.  put it on grad boundary. */
    dix_timeas  = _dix_timeas.fixedflag ?   ((void)(RUP_GRD((int)(1000000/deltf))), dix_timeas) : RUP_GRD((int)(1000000/deltf));
    pw_sdixon2  = _pw_sdixon2.fixedflag ?    ((void)(GRAD_UPDATE_TIME+dix_timeas), pw_sdixon2) : GRAD_UPDATE_TIME+dix_timeas;

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    if (FAILURE==ampslice(_a_gzrf1as.fixedflag ? (_temp113_a_gzrf1as=a_gzrf1as,&_temp113_a_gzrf1as) : &a_gzrf1as, bw_rf1as, asslthick, gscale_rf1as, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1as.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1asa.fixedflag ? (_temp114_pw_gzrf1asa=pw_gzrf1asa,&_temp114_pw_gzrf1asa) : &pw_gzrf1asa, a_gzrf1as, asloggrd.tz_xyz, asloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1asa.");
        return FAILURE;
    }
    pw_gzrf1asd  = _pw_gzrf1asd.fixedflag ?  ((void)(pw_gzrf1asa), pw_gzrf1asd) : pw_gzrf1asa;

    /******************************************/
    /*   Calc area needed for z rephaser      */
    /******************************************/
    area_gz1as  = _area_gz1as.fixedflag ?     ((void)((off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as), area_gz1as) : (off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as;

    /* availible time for rephaser */
    avail_pwgz1as  = _avail_pwgz1as.fixedflag ?  ((void)(1000000), avail_pwgz1as) : 1000000;

    if ( FAILURE==amppwgz1(_a_gz1as.fixedflag ? (_temp115_a_gz1as=a_gz1as,&_temp115_a_gz1as) : &a_gz1as, _pw_gz1as.fixedflag ? (_temp116_pw_gz1as=pw_gz1as,&_temp116_pw_gz1as) : &pw_gz1as, _pw_gz1asa.fixedflag ? (_temp117_pw_gz1asa=pw_gz1asa,&_temp117_pw_gz1asa) : &pw_gz1asa, _pw_gz1asd.fixedflag ? (_temp118_pw_gz1asd=pw_gz1asd,&_temp118_pw_gz1asd) : &pw_gz1asd,
                           area_gz1as, avail_pwgz1as, MIN_PLATEAU_TIME,
                           asloggrd.zrt, asloggrd.tz_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1as.");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1as_filt, echo1bwas, asxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1as_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(_a_gxwas.fixedflag ? (_temp119_a_gxwas=a_gxwas,&_temp119_a_gxwas) : &a_gxwas, echo1as_filt.bw, asfov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwas.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwasa.fixedflag ? (_temp120_pw_gxwasa=pw_gxwasa,&_temp120_pw_gxwasa) : &pw_gxwasa, a_gxwas, asloggrd.tx_xyz, asloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwasa.");
        return FAILURE;
    }

    pw_gxwasd  = _pw_gxwasd.fixedflag ?  ((void)(pw_gxwasa), pw_gxwasd) : pw_gxwasa;
    pw_gxwas  = _pw_gxwas.fixedflag ?  ((void)(echo1as_filt.tdaq), pw_gxwas) : echo1as_filt.tdaq;

    avail_pwgx1as  = _avail_pwgx1as.fixedflag ?  ((void)(1000000), avail_pwgx1as) : 1000000;

    area_readrampas  = _area_readrampas.fixedflag ?  ((void)(0.5*pw_gxwasa*a_gxwas), area_readrampas) : 0.5*pw_gxwasa*a_gxwas;
    area_gxwas  = _area_gxwas.fixedflag ?  ((void)(pw_gxwas*a_gxwas), area_gxwas) : pw_gxwas*a_gxwas;

    if ( FAILURE==amppwgx1(_a_gx1as.fixedflag ? (_temp121_a_gx1as=a_gx1as,&_temp121_a_gx1as) : &a_gx1as, _pw_gx1as.fixedflag ? (_temp122_pw_gx1as=pw_gx1as,&_temp122_pw_gx1as) : &pw_gx1as, _pw_gx1asa.fixedflag ? (_temp123_pw_gx1asa=pw_gx1asa,&_temp123_pw_gx1asa) : &pw_gx1asa, _pw_gx1asd.fixedflag ? (_temp124_pw_gx1asd=pw_gx1asd,&_temp124_pw_gx1asd) : &pw_gx1asd,
                           (int)TYPGRAD, area_gxwas, area_readrampas,
                           avail_pwgx1as, 1.0, MIN_PLATEAU_TIME,
                           asloggrd.xrt, asloggrd.tx_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1as.");
        return FAILURE;
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(asyres), _endview_iampas.fixedflag ? (_temp125_endview_iampas=endview_iampas,&_temp125_endview_iampas) : &endview_iampas) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:autoshim");
        return FAILURE;
    } 
  
    endview_scaleas  = _endview_scaleas.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampas), endview_scaleas) : (float)max_pg_iamp/(float)endview_iampas;

    if ( FAILURE==amppwtpe(_a_gy1asa.fixedflag ? (_temp126_a_gy1asa=a_gy1asa,&_temp126_a_gy1asa) : &a_gy1asa, _a_gy1asb.fixedflag ? (_temp127_a_gy1asb=a_gy1asb,&_temp127_a_gy1asb) : &a_gy1asb, _pw_gy1as.fixedflag ? (_temp128_pw_gy1as=pw_gy1as,&_temp128_pw_gy1as) : &pw_gy1as, _pw_gy1asa.fixedflag ? (_temp129_pw_gy1asa=pw_gy1asa,&_temp129_pw_gy1asa) : &pw_gy1asa, _pw_gy1asd.fixedflag ? (_temp130_pw_gy1asd=pw_gy1asd,&_temp130_pw_gy1asd) : &pw_gy1asd,
                           asloggrd.ty_xyz/endview_scaleas,asloggrd.yrt,
                           (0.5 * (FLOAT)(asyres-1))/(asfov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:autoshim");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1ras  = _a_gy1ras.fixedflag ?  ((void)(a_gy1as), a_gy1ras) : a_gy1as;
    a_gy1rasa  = _a_gy1rasa.fixedflag ?  ((void)(a_gy1asa), a_gy1rasa) : a_gy1asa;
    a_gy1rasb  = _a_gy1rasb.fixedflag ?  ((void)(a_gy1asb), a_gy1rasb) : a_gy1asb;
    pw_gy1ras  = _pw_gy1ras.fixedflag ?  ((void)(pw_gy1as), pw_gy1ras) : pw_gy1as;
    pw_gy1rasa  = _pw_gy1rasa.fixedflag ?  ((void)(pw_gy1asa), pw_gy1rasa) : pw_gy1asa;
    pw_gy1rasd  = _pw_gy1rasd.fixedflag ?  ((void)(pw_gy1asd), pw_gy1rasd) : pw_gy1asd;

    if(1==fastprescan) 
    {

        te_as  = _te_as.fixedflag ?           
                                  
                               ((void)(RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2)), te_as) : RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2);

        tr_as  = _tr_as.fixedflag ?           
                                  
                             ((void)(RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000)), tr_as) : RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000);
    }

    return SUCCESS;
}   /* end AScveval() */


/*
 *  CFHfilter
 *  
 *  Type: Private Function
 *  
 *  Description: Separate function for CFH for inclusion in 
 *               in Spectroscopy volume localized CFH
 *  
 */
STATUS
CFHfilter( int xres )
{
    CFHxres  = _CFHxres.fixedflag ?  ((void)(xres), CFHxres) : xres;

    if(cffield <= B0_5000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.25), echo1bwcfh) : 0.25;
    }
    else if (cffield >= B0_30000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(1.0), echo1bwcfh) : 1.0;
    }
    else 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.50), echo1bwcfh) : 0.50;
    }

    if ( FAILURE==calcfilter( &echo1cfh, echo1bwcfh, CFHxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfh_filt");
        return FAILURE;
    }

    cfh_tdaq = echo1cfh.tdaq;

    return SUCCESS;
}

/*
 *  CFHcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcveval( FLOAT opthickPS )
{
    LONG bw_rf0cfh;
    LONG bw_rf1cfh;

    GRAD_PULSE psd_cfhrightcrush;
    GRAD_PULSE psd_cfhleftcrush;

    FLOAT area_gz1cfh;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For MRIhc11621 */
    /* For presscfh MRIhc08321 */
    if( presscfh == PRESSCFH_SLICE && PSfield_strength > B0_5000 && 
        cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    } 
    else if(presscfh == PRESSCFH_SLAB && PSfield_strength > B0_5000 &&
            cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.75), presscfh_slab_ratio) : 0.75;
    }
    else if( presscfh == PRESSCFH_SHIMVOL && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.5), presscfh_fov_ratio) : 0.5;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.5), presscfh_pfov_ratio) : 0.5;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    }
    else if( presscfh == PRESSCFH_SHIMVOL_SLICE && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL_SLICE, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(1.0), presscfh_fov_ratio) : 1.0;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(1.0), presscfh_pfov_ratio) : 1.0;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(1.0), presscfh_slab_ratio) : 1.0;
    }
    else
    { 
        cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
    }
    
    if(presscfh_debug) 
    {
        printf("\n CFHcveval : presscfh = %d,presscfh_ctrl = %d,presscfh_override = %d\n",presscfh,presscfh_ctrl,presscfh_override);
        fflush(stdout);
    }

    wg_cfh_rf3  = _wg_cfh_rf3.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD), wg_cfh_rf3) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD;
    wg_cfh_rf4  = _wg_cfh_rf4.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD), wg_cfh_rf4) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD;

    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(0), cfh_dda) : 0;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(1), cfh_nex) : 1;
    }
    else
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(4), cfh_dda) : 4;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(2), cfh_nex) : 2;
    }

    if(cffield == B0_15000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_1HT), cfh_ti) : CFHTI_1HT;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_1HT), eff_cfh_te) : CFHTE_1HT;
    }
    else if(cffield >= B0_30000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_3T), cfh_ti) : CFHTI_3T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_3T), eff_cfh_te) : CFHTE_3T;
    }

    CFHfilter(256);

    /* Initialize some grad structures 
       so we can use the psdsupport routine amppwlcrsh */
    psd_cfhleftcrush.attack = _pw_gzrf2lcfha.fixedflag ? (_temp131_pw_gzrf2lcfha=pw_gzrf2lcfha,&_temp131_pw_gzrf2lcfha) : &pw_gzrf2lcfha;
    psd_cfhleftcrush.decay = _pw_gzrf2lcfhd.fixedflag ? (_temp132_pw_gzrf2lcfhd=pw_gzrf2lcfhd,&_temp132_pw_gzrf2lcfhd) : &pw_gzrf2lcfhd;
    psd_cfhleftcrush.pw = _pw_gzrf2lcfh.fixedflag ? (_temp133_pw_gzrf2lcfh=pw_gzrf2lcfh,&_temp133_pw_gzrf2lcfh) : &pw_gzrf2lcfh;
    psd_cfhleftcrush.amp = _a_gzrf2lcfh.fixedflag ? (_temp134_a_gzrf2lcfh=a_gzrf2lcfh,&_temp134_a_gzrf2lcfh) : &a_gzrf2lcfh;
 
    psd_cfhrightcrush.attack = _pw_gzrf2rcfha.fixedflag ? (_temp135_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp135_pw_gzrf2rcfha) : &pw_gzrf2rcfha;
    psd_cfhrightcrush.decay = _pw_gzrf2rcfhd.fixedflag ? (_temp136_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp136_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd;
    psd_cfhrightcrush.pw = _pw_gzrf2rcfh.fixedflag ? (_temp137_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp137_pw_gzrf2rcfh) : &pw_gzrf2rcfh;
    psd_cfhrightcrush.amp = _a_gzrf2rcfh.fixedflag ? (_temp138_a_gzrf2rcfh=a_gzrf2rcfh,&_temp138_a_gzrf2rcfh) : &a_gzrf2rcfh;

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        psd_cfhrightcrush.attack = _pw_gzrf3rcfha.fixedflag ? (_temp139_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp139_pw_gzrf3rcfha) : &pw_gzrf3rcfha;
        psd_cfhrightcrush.decay = _pw_gzrf3rcfhd.fixedflag ? (_temp140_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp140_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd;
        psd_cfhrightcrush.pw = _pw_gzrf3rcfh.fixedflag ? (_temp141_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp141_pw_gzrf3rcfh) : &pw_gzrf3rcfh;
        psd_cfhrightcrush.amp = _a_gzrf3rcfh.fixedflag ? (_temp142_a_gzrf3rcfh=a_gzrf3rcfh,&_temp142_a_gzrf3rcfh) : &a_gzrf3rcfh;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp143_pw_rf1cfh=pw_rf1cfh,&_temp143_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp144_a_rf1cfh=a_rf1cfh,&_temp144_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp145_flip_rf1cfh=flip_rf1cfh,&_temp145_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp146_res_rf1cfh=res_rf1cfh,&_temp146_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp147_wg_rf1cfh=wg_rf1cfh,&_temp147_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp148_pw_rf2cfh=pw_rf2cfh,&_temp148_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp149_a_rf2cfh=a_rf2cfh,&_temp149_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp150_flip_rf2cfh=flip_rf2cfh,&_temp150_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp151_res_rf2cfh=res_rf2cfh,&_temp151_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp152_wg_rf2cfh=wg_rf2cfh,&_temp152_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp153_pw_rf3cfh=pw_rf3cfh,&_temp153_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp154_a_rf3cfh=a_rf3cfh,&_temp154_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp155_flip_rf3cfh=flip_rf3cfh,&_temp155_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp156_res_rf3cfh=res_rf3cfh,&_temp156_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp157_wg_rf3cfh=wg_rf3cfh,&_temp157_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp158_pw_rf4cfh=pw_rf4cfh,&_temp158_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp159_a_rf4cfh=a_rf4cfh,&_temp159_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp160_flip_rf4cfh=flip_rf4cfh,&_temp160_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp161_res_rf4cfh=res_rf4cfh,&_temp161_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp162_wg_rf4cfh=wg_rf4cfh,&_temp162_wg_rf4cfh) : &wg_rf4cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp163_pw_rf1cfh=pw_rf1cfh,&_temp163_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp164_a_rf1cfh=a_rf1cfh,&_temp164_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp165_flip_rf1cfh=flip_rf1cfh,&_temp165_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp166_res_rf1cfh=res_rf1cfh,&_temp166_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp167_wg_rf1cfh=wg_rf1cfh,&_temp167_wg_rf1cfh) : &wg_rf1cfh, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp168_pw_rf2cfh=pw_rf2cfh,&_temp168_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp169_a_rf2cfh=a_rf2cfh,&_temp169_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp170_flip_rf2cfh=flip_rf2cfh,&_temp170_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp171_res_rf2cfh=res_rf2cfh,&_temp171_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp172_wg_rf2cfh=wg_rf2cfh,&_temp172_wg_rf2cfh) : &wg_rf2cfh, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp173_pw_rf3cfh=pw_rf3cfh,&_temp173_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp174_a_rf3cfh=a_rf3cfh,&_temp174_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp175_flip_rf3cfh=flip_rf3cfh,&_temp175_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp176_res_rf3cfh=res_rf3cfh,&_temp176_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp177_wg_rf3cfh=wg_rf3cfh,&_temp177_wg_rf3cfh) : &wg_rf3cfh, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp178_pw_rf4cfh=pw_rf4cfh,&_temp178_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp179_a_rf4cfh=a_rf4cfh,&_temp179_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp180_flip_rf4cfh=flip_rf4cfh,&_temp180_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp181_res_rf4cfh=res_rf4cfh,&_temp181_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp182_wg_rf4cfh=wg_rf4cfh,&_temp182_wg_rf4cfh) : &wg_rf4cfh, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 

    }

    if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) 
    {
        /* it is assumed: 
         * (a) cubicle local shim volume 
         */

        FLOAT av;
        FLOAT dxv, dyv, dzv, dxs, dys, dzs, dxs0, dys0, dzs0; 
        FLOAT Dz=0.0;
        FLOAT al2=0.0;
        FLOAT al=0.0;
        FLOAT dxl=0.0;
        FLOAT dyl=0.0;
        FLOAT dzl=0.0;
        FLOAT rs[9], rv[9], rstrv[9];
        INT ii, vidx;
       
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            av = (psc_info[vidx].oppsclenx)/2.0;
            dxv = psc_info[vidx].oppscrloc;
            dyv = psc_info[vidx].oppscphasoff;
            dzv = psc_info[vidx].oppsctloc;

            dxs = scan_info[PSslice_num].oprloc    + scan_info[PSslice_num].oprloc_shift;
            dys = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            dzs = scan_info[PSslice_num].optloc    + scan_info[PSslice_num].optloc_shift;

            for( ii = 0; ii < 9; ii++ )
            {
                rs[ii] = scan_info[PSslice_num].oprot[ii];
                rv[ii] = psc_info[vidx].oppscrot[ii];
            }

            for( ii = 0; ii < 9; ii++ )
            {
                int ir, ic;
                ir = ii/ 3;
                ic = ii % 3;
                rstrv[ii] = rs[3*0+ir]*rv[3*0+ic] 
                    + rs[3*1+ir]*rv[3*1+ic] 
                    + rs[3*2+ir]*rv[3*2+ic]; 
            }

            if( presscfh_debug )
            {
                printf("rot for shim volume %d\n", vidx);
                printf("%8.2f %8.2f %8.2f\n", rv[0], rv[3], rv[6]);
                printf("%8.2f %8.2f %8.2f\n", rv[1], rv[4], rv[7]);
                printf("%8.2f %8.2f %8.2f\n", rv[2], rv[5], rv[8]);
                printf("rot for slice\n");
                printf("%8.2f %8.2f %8.2f\n", rs[0], rs[3], rs[6]);
                printf("%8.2f %8.2f %8.2f\n", rs[1], rs[4], rs[7]);
                printf("%8.2f %8.2f %8.2f\n", rs[2], rs[5], rs[8]);
            }

            dxs0 = rstrv[0]*dxv + rstrv[1]*dyv + rstrv[2]*dzv;
            dys0 = rstrv[3]*dxv + rstrv[4]*dyv + rstrv[5]*dzv;
            dzs0 = rstrv[6]*dxv + rstrv[7]*dyv + rstrv[8]*dzv;

            if( presscfh == PRESSCFH_SLICE ) 
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                if( fabs(dzs0 - dzs) >= av )
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                } else {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }
            } 
            else 
            {   /* presscfh == PRESSCFH_SLAB */
                FLOAT dzss, dzse, dzs0s, dzs0e;
                FLOAT dz1, dz2;
                dzss = scan_info[0].optloc + scan_info[0].optloc_shift;
                dzse = scan_info[opslquant*opvquant-1].optloc + scan_info[opslquant*opvquant-1].optloc_shift;
                dzs0s = dzs0 - av/2;
                dzs0e = dzs0 + av/2;

                /* find dz1 and dz2 */
                if( dzs0e - dzs0s < 0 ) 
                {
                    FLOAT temp;
                    temp = dzs0e;
                    dzs0e = dzs0s;
                    dzs0s = temp;
                }
                if( dzse - dzss < 0 ) 
                {
                    FLOAT temp;
                    temp = dzse;
                    dzse = dzss;
                    dzss = temp;
                }

                dz1 = dzs0s;
                dz2 = dzs0e;

                if( dzss > dz1 ) 
                { 
                    dz1 = dzss;
                }
                if( dzse < dz2 ) 
                {
                    dz2 = dzse;
                }

                if( dzss >= dz2 || dzse <= dz1 ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                }
                else
                {
                    dzs = dz1 + (dz2-dz1)/2;   
                    presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_slab_ratio*(dz2-dz1)), presscfh_slthick) : presscfh_slab_ratio*(dz2-dz1);
                    if( presscfh_slthick < opthickPS ) 
                    {
                        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                    }
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }         
            }

            if( presscfh_outrange == 0 ) 
            {
                Dz = dzs0 - dzs;
                al2 = av*av - Dz*Dz;
                if( al2 > 0 ) 
                {
                    al = sqrt(al2);
                } else {
                    al = 0;
                }
            }

            if( al >= presscfh_minfov_ratio*av ) 
            {
                dxl = dxs0;
                dyl = dys0;
                dzl = dzs;

                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_fov_ratio*al*2.0), presscfh_fov) : presscfh_fov_ratio*al*2.0;
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_pfov_ratio*al*2.0), presscfh_pfov) : presscfh_pfov_ratio*al*2.0;

                presscfh_info[vidx].oppsctloc = dzl;
                presscfh_info[vidx].oppscrloc = dxl;
                presscfh_info[vidx].oppscphasoff = dyl;
                for( ii = 0; ii < 9; ii++ ) 
                {
                    presscfh_info[vidx].oppscrot[ii] = scan_info[PSslice_num].oprot[ii]; 
                }
                presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov_ratio*al*2.0);
                presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov_ratio*al*2.0);
                presscfh_info[vidx].oppsclenz = (INT)presscfh_slthick;
            } 
            else 
            {
                presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
            }

            if( presscfh_debug ) 
            {
                printf("av, dxv, dyv, dzv: %8.2f, %8.2f, %8.2f, %8.2f\n", av, dxv, dyv, dzv);    
                printf("dxs, dys, dzs: %8.2f, %8.2f, %8.2f\n", dxs, dys, dzs);    
                printf("al, dxl, dyl, dzl: %8.2f, %8.2f, %8.2f, %8.2f\n", al, dxl, dyl, dzl);    
                printf("presscfh_slthick: %8.2f\n", presscfh_slthick);    
                printf("outrange: %d\n", presscfh_outrange);    
            }

            if( presscfh_outrange == 1 ) 
            {
                cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
                if(presscfh_debug) 
                {
                    printf("\nCFHcveval : THIS TURNS OUT TO BE PRESSCFH_NONE,but was initially %d\n",presscfh);
                    fflush(stdout);
                }
                break;
            }
        }
    } 

    if( (presscfh_ctrl == PRESSCFH_SHIMVOL ) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            presscfh_fov  = _presscfh_fov.fixedflag ?    ((void)(presscfh_fov_ratio*psc_info[vidx].oppsclenx), presscfh_fov) : presscfh_fov_ratio*psc_info[vidx].oppsclenx;
            presscfh_pfov  = _presscfh_pfov.fixedflag ?    ((void)(presscfh_pfov_ratio*psc_info[vidx].oppscleny), presscfh_pfov) : presscfh_pfov_ratio*psc_info[vidx].oppscleny;
            presscfh_slthick  = _presscfh_slthick.fixedflag ?    ((void)(presscfh_slab_ratio*psc_info[vidx].oppsclenz), presscfh_slthick) : presscfh_slab_ratio*psc_info[vidx].oppsclenz;

            presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov);
            presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov);
            presscfh_info[vidx].oppsclenz = (INT)(presscfh_slthick);

            if( presscfh_debug ) 
            {
                printf(": SHIM VOLUME %d presscfh=2; presscfh_fov=%8.2f\n", vidx, presscfh_fov);
                fflush(stdout);
            }
        }
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            if( presscfh_fov < presscfh_info[vidx].oppsclenx )
            {
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenx), presscfh_fov) : presscfh_info[vidx].oppsclenx;
            }
            if( presscfh_pfov < presscfh_info[vidx].oppscleny )
            {
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_info[vidx].oppscleny), presscfh_pfov) : presscfh_info[vidx].oppscleny;
            }
            if( presscfh_slthick < presscfh_info[vidx].oppsclenz )
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenz), presscfh_slthick) : presscfh_info[vidx].oppsclenz;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                if( presscfh_slice < opthickPS )
                {
                    presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;
                }
            }
        }

        presscfh_ir_slthick  = _presscfh_ir_slthick.fixedflag ?  ((void)(presscfh_slthick), presscfh_ir_slthick) : presscfh_slthick;

        rfpulse[RF3_CFH_SLOT].num = 1;
        rfpulse[RF3_CFH_SLOT].activity = PSD_CFH_ON;

        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;

            rfpulse[RF4_CFH_SLOT].num = 1;
            rfpulse[RF4_CFH_SLOT].activity = PSD_CFH_ON;
        }
        else
        {
            rfpulse[RF4_CFH_SLOT].num = 0; 
            rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
        }
    }
    else
    {
        rfpulse[RF3_CFH_SLOT].num = 0;
        rfpulse[RF3_CFH_SLOT].activity = PSD_PULSE_OFF;

        rfpulse[RF4_CFH_SLOT].num = 0; 
        rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* If inversion recovery image mode, Calcs for the Inversion pulse */
    if (PSD_ON == PSir)
    {
        res_rf0cfh  = _res_rf0cfh.fixedflag ?  ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC;  /* Adiabatic pulse */
        /* MRIge90312 -- use 1.5sec TR for IR cfh */
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(1500000), cfh_tr) : 1500000;
        gscale_rf0cfh  = _gscale_rf0cfh.fixedflag ?  ((void)(0.87), gscale_rf0cfh) : 0.87; /* Changed from .65 to .87 for adiabatic pulse */

        pw_gzrf0cfh    = _pw_gzrf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_gzrf0cfh) : pw_rf0cfh;

        /* Y Killer CVs */ /* YMSmr09211  04/26/2006 YI */
        if(amppwgrad(cfhir_killer_area, cfhloggrd.ty_yz, 0.0, 0.0, cfhloggrd.yrt,
                     MIN_PLATEAU_TIME, _a_gyrf0kcfh.fixedflag ? (_temp183_a_gyrf0kcfh=a_gyrf0kcfh,&_temp183_a_gyrf0kcfh) : &a_gyrf0kcfh, _pw_gyrf0kcfha.fixedflag ? (_temp184_pw_gyrf0kcfha=pw_gyrf0kcfha,&_temp184_pw_gyrf0kcfha) : &pw_gyrf0kcfha, _pw_gyrf0kcfh.fixedflag ? (_temp185_pw_gyrf0kcfh=pw_gyrf0kcfh,&_temp185_pw_gyrf0kcfh) : &pw_gyrf0kcfh, _pw_gyrf0kcfhd.fixedflag ? (_temp186_pw_gyrf0kcfhd=pw_gyrf0kcfhd,&_temp186_pw_gyrf0kcfhd) : &pw_gyrf0kcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgrad:gyrf0kcfh"); 
            return FAILURE;
        }

        rfpulse[RF0_CFH_SLOT].num = 1;
        rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON;
        bw_rf0cfh = (LONG)(5.12*cyc_rf0cfh/((FLOAT)pw_rf0cfh/(FLOAT)1000000)); /* adiabatic pulse */
 
        if(ampslice(_a_gzrf0cfh.fixedflag ? (_temp187_a_gzrf0cfh=a_gzrf0cfh,&_temp187_a_gzrf0cfh) : &a_gzrf0cfh, bw_rf0cfh, ((presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_ir_slthick),
                    gscale_rf0cfh, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gzrf0cfh.",EM_PSD_SUPPORT_FAILURE, 
                       EE_ARGS(1), STRING_ARG, "ampslice");
            return FAILURE;
        }
        /* Non Selective IR */
        if( (presscfh_ctrl != PRESSCFH_NONE) && presscfh_ir_noselect ) 
        {
            a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0), a_gzrf0cfh) : 0;
        }
        /* YMSmr09211  04/26/2006 YI */
        if(optramp(_pw_gzrf0cfha.fixedflag ? (_temp188_pw_gzrf0cfha=pw_gzrf0cfha,&_temp188_pw_gzrf0cfha) : &pw_gzrf0cfha,a_gzrf0cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gzrf0cfha.");
            return FAILURE;
        }
        pw_gzrf0cfhd  = _pw_gzrf0cfhd.fixedflag ?  ((void)(pw_gzrf0cfha), pw_gzrf0cfhd) : pw_gzrf0cfha;
    } else {
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(398000), cfh_tr) : 398000;
        rfpulse[RF0_CFH_SLOT].num = 0;
        rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* Calculations for the 90 pulse */
    pw_gzrf1cfh  = _pw_gzrf1cfh.fixedflag ?  ((void)(pw_rf1cfh), pw_gzrf1cfh) : pw_rf1cfh;
    bw_rf1cfh = (LONG)(rfpulse[RF1_CFH_SLOT].nom_bw*rfpulse[RF1_CFH_SLOT].nom_pw/(float)pw_rf1cfh);
       
    if (ampslice(_a_gzrf1cfh.fixedflag ? (_temp189_a_gzrf1cfh=a_gzrf1cfh,&_temp189_a_gzrf1cfh) : &a_gzrf1cfh, bw_rf1cfh, ( (presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_slthick),
                 gscale_rf1cfh, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    /* YMSmr09211  04/26/2006 YI */
    if (optramp(_pw_gzrf1cfha.fixedflag ? (_temp190_pw_gzrf1cfha=pw_gzrf1cfha,&_temp190_pw_gzrf1cfha) : &pw_gzrf1cfha, a_gzrf1cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfhd  = _pw_gzrf1cfhd.fixedflag ?  ((void)(pw_gzrf1cfha), pw_gzrf1cfhd) : pw_gzrf1cfha;

    /* Calculations for the 180 pulse */
    /* Have to rely on the PSD to keep these up to date - can't tell from
       here whether or not the PSD is a mempoid. */
    pw_gxrf2cfh  = _pw_gxrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gxrf2cfh) : pw_rf2cfh;
    pw_gyrf2cfh  = _pw_gyrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gyrf2cfh) : pw_rf2cfh;
    pw_gyrf3cfh  = _pw_gyrf3cfh.fixedflag ?  ((void)(pw_rf3cfh), pw_gyrf3cfh) : pw_rf3cfh; /* for presscfh */
    pw_gzrf4cfh  = _pw_gzrf4cfh.fixedflag ?  ((void)(pw_rf4cfh), pw_gzrf4cfh) : pw_rf4cfh; /* for presscfh-slice */ 

    /* Find amplitudes for the FOV selective traps */
    if (opcoax==1) 
    {
        /* If coaxial through isocenter */
        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,opfov/10.0)), cfh_fov) : FMin(2,40.0,opfov/10.0);
    } else {
        /* Otherwise open it up */
        cfh_fov  = _cfh_fov.fixedflag ?  ((void)(40.0), cfh_fov) : 40.0;
    }

    if(cfh_newmode) 
    {   /*override with new mode*/
        float cfh_new_fov = opspf ? (opphasefov*opfov/10.0) : (opfov/10.0);

        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,cfh_new_fov)), cfh_fov) : FMin(2,40.0,cfh_new_fov);
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground */
        cfh_fov  = _cfh_fov.fixedflag ?        ((void)((opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov)), cfh_fov) : (opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov);
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0);
        if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp191_pw_gxrf2cfha=pw_gxrf2cfha,&_temp191_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gxrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gxrf2cfh"); 
            return FAILURE;
        }
        pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
        pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
        target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */

        /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0)), a_gyrf3cfh) : 4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0);
        if (optramp(_pw_gyrf3cfha.fixedflag ? (_temp192_pw_gyrf3cfha=pw_gyrf3cfha,&_temp192_pw_gyrf3cfha) : &pw_gyrf3cfha, a_gyrf3cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gyrf3cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gyrf3cfh");
            return FAILURE;
        }
        pw_gyrf3cfha  = _pw_gyrf3cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha)), pw_gyrf3cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha);
        pw_gyrf3cfhd  = _pw_gyrf3cfhd.fixedflag ?  ((void)(pw_gyrf3cfha), pw_gyrf3cfhd) : pw_gyrf3cfha;
        target_cfh_crusher2  = _target_cfh_crusher2.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher2) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */

        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            /* Z SLICE Selective */
            a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0)), a_gzrf4cfh) : 4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0);
            if (optramp(_pw_gzrf4cfha.fixedflag ? (_temp193_pw_gzrf4cfha=pw_gzrf4cfha,&_temp193_pw_gzrf4cfha) : &pw_gzrf4cfha, a_gzrf4cfh, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gzrf4cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gzrf4cfh");
                return FAILURE;
            }
            pw_gzrf4cfha  = _pw_gzrf4cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha)), pw_gzrf4cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha);
            pw_gzrf4cfhd  = _pw_gzrf4cfhd.fixedflag ?  ((void)(pw_gzrf4cfha), pw_gzrf4cfhd) : pw_gzrf4cfha;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp194_a_gzrf2rcfh=a_gzrf2rcfh,&_temp194_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp195_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp195_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp196_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp196_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp197_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp197_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp198_a_gzrf3rcfh=a_gzrf3rcfh,&_temp198_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp199_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp199_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp200_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp200_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp201_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp201_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf3rcfha), pw_gzrf2lcfha) : pw_gzrf3rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf3rcfhd), pw_gzrf2lcfhd) : pw_gzrf3rcfhd;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp202_a_gzrf3rcfh=a_gzrf3rcfh,&_temp202_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp203_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp203_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp204_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp204_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp205_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp205_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }

            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp206_a_gzrf3lcfh=a_gzrf3lcfh,&_temp206_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp207_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp207_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp208_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp208_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp209_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp209_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4rcfh.fixedflag ? (_temp210_a_gzrf4rcfh=a_gzrf4rcfh,&_temp210_a_gzrf4rcfh) : &a_gzrf4rcfh, _pw_gzrf4rcfha.fixedflag ? (_temp211_pw_gzrf4rcfha=pw_gzrf4rcfha,&_temp211_pw_gzrf4rcfha) : &pw_gzrf4rcfha,
                              _pw_gzrf4rcfh.fixedflag ? (_temp212_pw_gzrf4rcfh=pw_gzrf4rcfh,&_temp212_pw_gzrf4rcfh) : &pw_gzrf4rcfh, _pw_gzrf4rcfhd.fixedflag ? (_temp213_pw_gzrf4rcfhd=pw_gzrf4rcfhd,&_temp213_pw_gzrf4rcfhd) : &pw_gzrf4rcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                              STRING_ARG, "amppwgrad:gzrf4rcfh"); 
                    return FAILURE;
                }

                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4lcfh.fixedflag ? (_temp214_a_gzrf4lcfh=a_gzrf4lcfh,&_temp214_a_gzrf4lcfh) : &a_gzrf4lcfh, _pw_gzrf4lcfha.fixedflag ? (_temp215_pw_gzrf4lcfha=pw_gzrf4lcfha,&_temp215_pw_gzrf4lcfha) : &pw_gzrf4lcfha,
                              _pw_gzrf4lcfh.fixedflag ? (_temp216_pw_gzrf4lcfh=pw_gzrf4lcfh,&_temp216_pw_gzrf4lcfh) : &pw_gzrf4lcfh, _pw_gzrf4lcfhd.fixedflag ? (_temp217_pw_gzrf4lcfhd=pw_gzrf4lcfhd,&_temp217_pw_gzrf4lcfhd) : &pw_gzrf4lcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gzrf4lcfh"); 
                    return FAILURE;
                }
            }
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp218_a_gzrf2rcfh=a_gzrf2rcfh,&_temp218_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp219_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp219_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp220_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp220_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp221_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp221_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }

            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp222_a_gzrf3lcfh=a_gzrf3lcfh,&_temp222_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp223_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp223_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp224_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp224_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp225_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp225_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }
        }
    } else {
        if (opspf == 0) 
        {
            /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp226_pw_gxrf2cfha=pw_gxrf2cfha,&_temp226_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gxrf2cfh.", 
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gxrf2cfh");
                return FAILURE;
            }
            pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
            pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */
        } 
        else 
        {
            /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gyrf2cfh  = _a_gyrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gyrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gyrf2cfha.fixedflag ? (_temp227_pw_gyrf2cfha=pw_gyrf2cfha,&_temp227_pw_gyrf2cfha) : &pw_gyrf2cfha, a_gyrf2cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gyrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gyrf2cfh");
                return FAILURE;
            }
            pw_gyrf2cfha  = _pw_gyrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha)), pw_gyrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha);
            pw_gyrf2cfhd  = _pw_gyrf2cfhd.fixedflag ?  ((void)(pw_gyrf2cfha), pw_gyrf2cfhd) : pw_gyrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */
        }

        /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
        if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp228_a_gzrf2rcfh=a_gzrf2rcfh,&_temp228_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp229_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp229_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                      _pw_gzrf2rcfh.fixedflag ? (_temp230_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp230_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp231_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp231_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gzrf2rcfh"); 
            return FAILURE;
        }

        pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
        pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
    }

    area_gz1cfh = (PSoff90 + pw_rf1cfh/2.0 + pw_gzrf1cfhd/2.0)*a_gzrf1cfh;
    /* YMSmr09211  04/26/2006 YI */
    if (amppwlcrsh(&psd_cfhleftcrush, &psd_cfhrightcrush,
                   area_gz1cfh, (float)0, cfhloggrd.tz_xz, 
                   MIN_PLATEAU_TIME, cfhloggrd.zrt, _dummy_pw.fixedflag ? (_temp232_dummy_pw=dummy_pw,&_temp232_dummy_pw) : &dummy_pw) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwlcrsh for gzrf2lcfh");
        return FAILURE;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        FLOAT area_g1 = (pw_gxrf2cfh + pw_gxrf2cfha)*a_gxrf2cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.tx, 0.0, 0.0, cfhloggrd.xrt,
                      MIN_PLATEAU_TIME, _a_gx1cfh.fixedflag ? (_temp233_a_gx1cfh=a_gx1cfh,&_temp233_a_gx1cfh) : &a_gx1cfh, _pw_gx1cfha.fixedflag ? (_temp234_pw_gx1cfha=pw_gx1cfha,&_temp234_pw_gx1cfha) : &pw_gx1cfha,
                      _pw_gx1cfh.fixedflag ? (_temp235_pw_gx1cfh=pw_gx1cfh,&_temp235_pw_gx1cfh) : &pw_gx1cfh, _pw_gx1cfhd.fixedflag ? (_temp236_pw_gx1cfhd=pw_gx1cfhd,&_temp236_pw_gx1cfhd) : &pw_gx1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gx1cfh"); 
            return FAILURE;
        }

        area_g1 = (pw_gyrf3cfh + pw_gyrf3cfhd)*a_gyrf3cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gy1cfh.fixedflag ? (_temp237_a_gy1cfh=a_gy1cfh,&_temp237_a_gy1cfh) : &a_gy1cfh, _pw_gy1cfha.fixedflag ? (_temp238_pw_gy1cfha=pw_gy1cfha,&_temp238_pw_gy1cfha) : &pw_gy1cfha,
                      _pw_gy1cfh.fixedflag ? (_temp239_pw_gy1cfh=pw_gy1cfh,&_temp239_pw_gy1cfh) : &pw_gy1cfh, _pw_gy1cfhd.fixedflag ? (_temp240_pw_gy1cfhd=pw_gy1cfhd,&_temp240_pw_gy1cfhd) : &pw_gy1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gy1cfh"); 
            return FAILURE;
        }
    }

    /* Find Params for killer pulse */ /* YMSmr09211  04/26/2006 YI */
    area_gykcfh  = _area_gykcfh.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfh) : amp_killer*pw_killer;
    if (amppwgrad(area_gykcfh, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                  MIN_PLATEAU_TIME, _a_gykcfh.fixedflag ? (_temp241_a_gykcfh=a_gykcfh,&_temp241_a_gykcfh) : &a_gykcfh, _pw_gykcfha.fixedflag ? (_temp242_pw_gykcfha=pw_gykcfha,&_temp242_pw_gykcfha) : &pw_gykcfha,
                  _pw_gykcfh.fixedflag ? (_temp243_pw_gykcfh=pw_gykcfh,&_temp243_pw_gykcfh) : &pw_gykcfh, _pw_gykcfhd.fixedflag ? (_temp244_pw_gykcfhd=pw_gykcfhd,&_temp244_pw_gykcfhd) : &pw_gykcfhd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfh");
        return FAILURE;
    }
    return SUCCESS;
}

/*
 *  PScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScveval( void )
{
    STATUS ps_status;
    FLOAT opthickPS;
    INT i,j; /* YMSmr09211  04/26/2006 YI */
    INT num_cfhlocs;

    /*********************************************************************
     * Generic SECTION
     *********************************************************************/
   
    /* Set the modes for presscfh */
    set_presscfh_mode();

    /* YMSmr09211  04/26/2006 YI */
    if( ( presscfh_ctrl == PRESSCFH_SHIMVOL ) || ( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        num_cfhlocs = exist(oppscvquant);
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = psc_info[i].oppscrot[j];
            }
        }
    }
    else
    {
        num_cfhlocs = IMax(2, 1, exist(oppscvquant));
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = scan_info[PSslice_num].oprot[j];
            }
        }
    }

    cfh_newgeo  = _cfh_newgeo.fixedflag ?  ((void)(1), cfh_newgeo) : 1;
    if (obloptimize(&cfhloggrd, &phygrd, cfh_info, num_cfhlocs,
                    PSD_OBL, 0, obl_method, cfhobl_debug, _cfh_newgeo.fixedflag ? (_temp245_cfh_newgeo=cfh_newgeo,&_temp245_cfh_newgeo) : &cfh_newgeo, cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"obloptimize failed in PScveval()",
                   EM_PSD_FUNCTION_FAILURE,2,STRING_ARG,"obloptimize",STRING_ARG,"PScveval()");
        return FAILURE; 

    }

    /* derate SR for quiet PSC */ 
    sr_derate(&cfhloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if (opimode == PSD_3D)  
    {
        opthickPS = 10.0;
    } 
    else 
    {
            opthickPS = (exist(opslthick) < 3.5) ? 3.5 : exist(opslthick);
        }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1cveval( &opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1cveval");
        return ps_status;
    }

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLcveval");
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNcveval( )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNcveval");
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHcveval");
        return ps_status;
    }

    /***********************************************************************
     * Programmable Prescan SECTION
     ***********************************************************************/

    /* Check for valid Optprescan entry points */
    if(pimrsapsflg) {
        int ipi;
        char strmrs[16] = "pimrsaps1";

        for (ipi = 0; ipi < PSC_MAX_CONTROL_ARRAY; ipi++) 
        {
            switch(*pimrs[ipi]) 
            {
            case MRSAPS_OFF: case MRSAPS_CFL: case MRSAPS_TG:
            case MRSAPS_CFH: case MRSAPS_TR: case MRSAPS_FSEPS:
            case MRSAPS_AWS: case MRSAPS_AVS: case MRSAPS_XTG:
            case MRSAPS_AS: case MRSAPS_FTG: case MRSAPS_RCVN:
                break;
            default:
                sprintf(strmrs, "pimrsaps%d", ipi + 1);
                epic_error(use_ermes, "%s is out of range.",
                           EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                           STRING_ARG, strmrs);
                return FAILURE;
            }
        }
    } /* end pimrsapsflg check */

    return SUCCESS;
}   /* end PScveval() */


/*
 *  FTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcveval( void )
{
    LONG bw_rf1ftg;
    LONG bw_rf2ftg;
    LONG bw_rf3ftg;
    FLOAT area_g1ftg;
    FLOAT area_g2ftg;
    FLOAT area_g2bftg;
    FLOAT area_g3ftg;
    FLOAT area_postgxw1ftg;
    FLOAT area_gxw1ftg;
    FLOAT area_gx1ftg;
    FLOAT area_gx2ftg;
    INT PosReadoutWindow;  /* Readout window location            */
    INT ftg_xrt;
    FLOAT ftg_tx;
    FLOAT ftg_tx_xz;
    FLOAT ftg_tz_xz;
    FLOAT ftg_tx_xyz;
    INT FTGtau1check1, FTGtau1check2, FTGtau1check3,
        FTGtau1check4, FTGtau1check5, FTGtau1check6, temp_FTGtau1;

    /* HCSDM00161809: for calculation of minimum FTGtau1 */
    FTGtau1  = _FTGtau1.fixedflag ?    ((void)(8192), FTGtau1) : 8192;
    FTGtau1check1   = FTGtau1;
    FTGtau1check2   = FTGtau1;
    FTGtau1check3   = FTGtau1;
    FTGtau1check4   = FTGtau1;
    FTGtau1check5   = FTGtau1;
    FTGtau1check6   = FTGtau1;
    temp_FTGtau1    = FTGtau1;
    
    ftg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ftg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ftg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ftg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    ftg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);

    FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

    FTGopslthickz1  = _FTGopslthickz1.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz1) : 4*FTGslthk;
    FTGopslthickz2  = _FTGopslthickz2.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz2) : 4*FTGslthk;
    FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(FTGslthk), FTGopslthickz3) : FTGslthk;
    gscale_rf1ftg   = _gscale_rf1ftg.fixedflag ?  ((void)(0.90909), gscale_rf1ftg) : 0.90909;
    gscale_rf2ftg   = _gscale_rf2ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf2ftg) : gscale_rf1ftg;
    gscale_rf3ftg   = _gscale_rf3ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf3ftg) : gscale_rf1ftg;
    pw_gzrf1ftg  = _pw_gzrf1ftg.fixedflag ?  ((void)(pw_rf1ftg), pw_gzrf1ftg) : pw_rf1ftg;
    pw_gzrf2ftg  = _pw_gzrf2ftg.fixedflag ?  ((void)(pw_rf2ftg), pw_gzrf2ftg) : pw_rf2ftg;
    pw_gzrf3ftg  = _pw_gzrf3ftg.fixedflag ?  ((void)(pw_rf3ftg), pw_gzrf3ftg) : pw_rf3ftg;

    /* 12/07/94 YI temporary change to avoid internal error with Vectra SGC coil */
    if( cfgradcoil == GCOIL_VECTRA )
    {
        FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(7), FTGopslthickz3) : 7;
    }
    
    bw_rf1ftg = (LONG)(4 * cyc_rf1ftg/ ((FLOAT)pw_rf1ftg/ (FLOAT)1000000));

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    if( ampslice(_a_gzrf1ftg.fixedflag ? (_temp246_a_gzrf1ftg=a_gzrf1ftg,&_temp246_a_gzrf1ftg) : &a_gzrf1ftg, bw_rf1ftg, FTGopslthickz1, gscale_rf1ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1ftg.");
        return FAILURE;
    }
    
    bw_rf2ftg = (LONG)(4 * cyc_rf2ftg/ ((FLOAT)pw_rf2ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf2ftg.fixedflag ? (_temp247_a_gzrf2ftg=a_gzrf2ftg,&_temp247_a_gzrf2ftg) : &a_gzrf2ftg, bw_rf2ftg, FTGopslthickz2, gscale_rf2ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2ftg.");
        return FAILURE;
    }
    
 
    bw_rf3ftg = (LONG)(4 * cyc_rf3ftg/ ((FLOAT)pw_rf3ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf3ftg.fixedflag ? (_temp248_a_gzrf3ftg=a_gzrf3ftg,&_temp248_a_gzrf3ftg) : &a_gzrf3ftg, bw_rf3ftg, FTGopslthickz3, gscale_rf3ftg, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf3ftg.");
        return FAILURE;
    }
    if( optramp(_pw_gzrf1ftga.fixedflag ? (_temp249_pw_gzrf1ftga=pw_gzrf1ftga,&_temp249_pw_gzrf1ftga) : &pw_gzrf1ftga, a_gzrf1ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1ftga.");
        return FAILURE;
    }    
    
    pw_gzrf1ftgd  = _pw_gzrf1ftgd.fixedflag ?  ((void)(pw_gzrf1ftga), pw_gzrf1ftgd) : pw_gzrf1ftga;

    if (optramp(_pw_gzrf2ftga.fixedflag ? (_temp250_pw_gzrf2ftga=pw_gzrf2ftga,&_temp250_pw_gzrf2ftga) : &pw_gzrf2ftga, a_gzrf2ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2ftga.");
        return FAILURE;
    }    
    
    pw_gzrf2ftgd  = _pw_gzrf2ftgd.fixedflag ?  ((void)(pw_gzrf2ftga), pw_gzrf2ftgd) : pw_gzrf2ftga;
 
 
    /* Find Params for first zgrad refocusing pulse */
    area_g1ftg = ( a_gzrf1ftg *.5* ( pw_gzrf1ftg + pw_gzrf1ftgd)
                   + a_gzrf2ftg *.5 * (pw_gzrf2ftga + pw_gzrf2ftg) );
    if( amppwgz1(_a_gz1ftg.fixedflag ? (_temp251_a_gz1ftg=a_gz1ftg,&_temp251_a_gz1ftg) : &a_gz1ftg, _pw_gz1ftg.fixedflag ? (_temp252_pw_gz1ftg=pw_gz1ftg,&_temp252_pw_gz1ftg) : &pw_gz1ftg, _pw_gz1ftga.fixedflag ? (_temp253_pw_gz1ftga=pw_gz1ftga,&_temp253_pw_gz1ftga) : &pw_gz1ftga, _pw_gz1ftgd.fixedflag ? (_temp254_pw_gz1ftgd=pw_gz1ftgd,&_temp254_pw_gz1ftgd) : &pw_gz1ftgd,
                 area_g1ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1ftg.");
        return FAILURE;
    }
    

    /* Find Params for refocusing pulse gz2ftg */
    area_g2ftg =  a_gzrf2ftg *.5* ( pw_gzrf2ftg + pw_gzrf2ftgd);
    if( amppwgz1(_a_gz2ftg.fixedflag ? (_temp255_a_gz2ftg=a_gz2ftg,&_temp255_a_gz2ftg) : &a_gz2ftg, _pw_gz2ftg.fixedflag ? (_temp256_pw_gz2ftg=pw_gz2ftg,&_temp256_pw_gz2ftg) : &pw_gz2ftg, _pw_gz2ftga.fixedflag ? (_temp257_pw_gz2ftga=pw_gz2ftga,&_temp257_pw_gz2ftga) : &pw_gz2ftga, _pw_gz2ftgd.fixedflag ? (_temp258_pw_gz2ftgd=pw_gz2ftgd,&_temp258_pw_gz2ftgd) : &pw_gz2ftgd,
                 area_g2ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE ) {
	epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz2ftg.");
	return FAILURE;
    }
 
    /* Find Params for refocusing pulse gz2btg */

    /* MRIge56170  AF  10/13/99 */
    if( optramp(_pw_gzrf3ftga.fixedflag ? (_temp259_pw_gzrf3ftga=pw_gzrf3ftga,&_temp259_pw_gzrf3ftga) : &pw_gzrf3ftga, a_gzrf3ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf3ftga.");
        return FAILURE;
    }

    area_g2bftg =  a_gzrf3ftg * .5 *(pw_gzrf3ftga + pw_gzrf3ftg);
    if( amppwgz1(_a_gz2bftg.fixedflag ? (_temp260_a_gz2bftg=a_gz2bftg,&_temp260_a_gz2bftg) : &a_gz2bftg, _pw_gz2bftg.fixedflag ? (_temp261_pw_gz2bftg=pw_gz2bftg,&_temp261_pw_gz2bftg) : &pw_gz2bftg, _pw_gz2bftga.fixedflag ? (_temp262_pw_gz2bftga=pw_gz2bftga,&_temp262_pw_gz2bftga) : &pw_gz2bftga, _pw_gz2bftgd.fixedflag ? (_temp263_pw_gz2bftgd=pw_gz2bftgd,&_temp263_pw_gz2bftgd) : &pw_gz2bftgd,
                 area_g2bftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, ":amppwgz1 for gz2bftg.");
        return FAILURE;
    }
    
    pw_gzrf3ftgd  = _pw_gzrf3ftgd.fixedflag ?  ((void)(pw_gzrf3ftga), pw_gzrf3ftgd) : pw_gzrf3ftga;
 
    /* Find Params for refocusing pulse */
    area_g3ftg =  a_gzrf3ftg *.5* ( pw_gzrf3ftg + pw_gzrf3ftgd);
    if( amppwgz1(_a_gz3ftg.fixedflag ? (_temp264_a_gz3ftg=a_gz3ftg,&_temp264_a_gz3ftg) : &a_gz3ftg, _pw_gz3ftg.fixedflag ? (_temp265_pw_gz3ftg=pw_gz3ftg,&_temp265_pw_gz3ftg) : &pw_gz3ftg, _pw_gz3ftga.fixedflag ? (_temp266_pw_gz3ftga=pw_gz3ftga,&_temp266_pw_gz3ftga) : &pw_gz3ftga, _pw_gz3ftgd.fixedflag ? (_temp267_pw_gz3ftgd=pw_gz3ftgd,&_temp267_pw_gz3ftgd) : &pw_gz3ftgd,
                 area_g3ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE )
    {

        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz3ftg.");
        return FAILURE;
    }
    
    if( calcfilter( &echo1ftg_filt, FTGecho1bw, FTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1ftg_filt");
        return FAILURE;
    }

    if( ampfov(_a_gxw1ftg.fixedflag ? (_temp268_a_gxw1ftg=a_gxw1ftg,&_temp268_a_gxw1ftg) : &a_gxw1ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1ftg.");
        return FAILURE;
 
    }
 
    pw_gxw1ftg  = _pw_gxw1ftg.fixedflag ?  ((void)(RUP_GRD((int)(echo1ftg_filt.tdaq)/4)), pw_gxw1ftg) : RUP_GRD((int)(echo1ftg_filt.tdaq)/4);

    area_gxw1ftg = 2.0*a_gxw1ftg*(float)(pw_gxw1ftg);
 
    if( amppwgx1(_a_gx1ftg.fixedflag ? (_temp269_a_gx1ftg=a_gx1ftg,&_temp269_a_gx1ftg) : &a_gx1ftg, _pw_gx1ftg.fixedflag ? (_temp270_pw_gx1ftg=pw_gx1ftg,&_temp270_pw_gx1ftg) : &pw_gx1ftg, _pw_gx1ftga.fixedflag ? (_temp271_pw_gx1ftga=pw_gx1ftga,&_temp271_pw_gx1ftga) : &pw_gx1ftga, _pw_gx1ftgd.fixedflag ? (_temp272_pw_gx1ftgd=pw_gx1ftgd,&_temp272_pw_gx1ftgd) : &pw_gx1ftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");
        return FAILURE;
    }
    
    if( amppwgx1(_a_gx2test.fixedflag ? (_temp273_a_gx2test=a_gx2test,&_temp273_a_gx2test) : &a_gx2test, _pw_gx2test.fixedflag ? (_temp274_pw_gx2test=pw_gx2test,&_temp274_pw_gx2test) : &pw_gx2test, _pw_gx2testa.fixedflag ? (_temp275_pw_gx2testa=pw_gx2testa,&_temp275_pw_gx2testa) : &pw_gx2testa, _pw_gx2testd.fixedflag ? (_temp276_pw_gx2testd=pw_gx2testd,&_temp276_pw_gx2testd) : &pw_gx2testd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");

        return FAILURE;
    }
    
 
    area_gxw1ftg = a_gxw1ftg*(float)(pw_gxw1ftg);
    if( amppwgx1(_a_gx1bftg.fixedflag ? (_temp277_a_gx1bftg=a_gx1bftg,&_temp277_a_gx1bftg) : &a_gx1bftg, _pw_gx1bftg.fixedflag ? (_temp278_pw_gx1bftg=pw_gx1bftg,&_temp278_pw_gx1bftg) : &pw_gx1bftg, _pw_gx1bftga.fixedflag ? (_temp279_pw_gx1bftga=pw_gx1bftga,&_temp279_pw_gx1bftga) : &pw_gx1bftga, _pw_gx1bftgd.fixedflag ? (_temp280_pw_gx1bftgd=pw_gx1bftgd,&_temp280_pw_gx1bftgd) : &pw_gx1bftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s call failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1:gx1btg");
    }

    if( optramp(_pw_gxw1ftga.fixedflag ? (_temp281_pw_gxw1ftga=pw_gxw1ftga,&_temp281_pw_gxw1ftga) : &pw_gxw1ftga, a_gxw1ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1ftga.");
        return FAILURE;
    }    
    
    pw_gxw1ftgd  = _pw_gxw1ftgd.fixedflag ?  ((void)(pw_gxw1ftga), pw_gxw1ftgd) : pw_gxw1ftga;
 
    area_postgxw1ftg = ( 3.0 * a_gxw1ftg * (float)(pw_gxw1ftg)
                         - 0.5 * a_gxw1ftg * (pw_gxw1ftga + pw_gxw1ftgd) );
    if( amppwgx1(_a_postgxw1ftg.fixedflag ? (_temp282_a_postgxw1ftg=a_postgxw1ftg,&_temp282_a_postgxw1ftg) : &a_postgxw1ftg, _pw_postgxw1ftg.fixedflag ? (_temp283_pw_postgxw1ftg=pw_postgxw1ftg,&_temp283_pw_postgxw1ftg) : &pw_postgxw1ftg, _pw_postgxw1ftga.fixedflag ? (_temp284_pw_postgxw1ftga=pw_postgxw1ftga,&_temp284_pw_postgxw1ftga) : &pw_postgxw1ftga,
                 _pw_postgxw1ftgd.fixedflag ? (_temp285_pw_postgxw1ftgd=pw_postgxw1ftgd,&_temp285_pw_postgxw1ftgd) : &pw_postgxw1ftgd, TYPSPIN, area_postgxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for postgxw1ftg.");
        return FAILURE;
    }
    
    if( ampfov(_a_gxw2ftg.fixedflag ? (_temp286_a_gxw2ftg=a_gxw2ftg,&_temp286_a_gxw2ftg) : &a_gxw2ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw2ftg.");
        return FAILURE;
    }
    
    pw_gxw2ftg  = _pw_gxw2ftg.fixedflag ?  ((void)(RUP_GRD((int)(4.0*(float)pw_gxw1ftg))), pw_gxw2ftg) : RUP_GRD((int)(4.0*(float)pw_gxw1ftg));
    if( optramp(_pw_gxw2ftga.fixedflag ? (_temp287_pw_gxw2ftga=pw_gxw2ftga,&_temp287_pw_gxw2ftga) : &pw_gxw2ftga, a_gxw2ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    { 
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw2ftga.");
 
        return FAILURE;
    }
    
    pw_gxw2ftgd  = _pw_gxw2ftgd.fixedflag ?  ((void)(pw_gxw2ftga), pw_gxw2ftgd) : pw_gxw2ftga;
 
    /* We want S1 to refocus tau1 ms after rf3.  The gx2tg refocusing
       pulse accomplishes this.  gxw2tg pulse can't start before the
       end of the gz3tg refocussing pulse (why bother collecting
       corrupt data? ). */
    area_gx1ftg = a_gx1ftg * (0.5 * (float)(pw_gx1ftga + pw_gx1ftgd) + pw_gx1ftg);
 
    /* Starting readout window position relative to center of rf3 */
    PosReadoutWindow = ( pw_rf3ftg/2 + pw_gzrf3ftgd + pw_gz3ftga
                         + pw_gz3ftg + pw_gz3ftgd );
 
    pw_gxw2ftgleft  = _pw_gxw2ftgleft.fixedflag ?  ((void)(RUP_GRD(echo1ftg_filt.tdaq/8)), pw_gxw2ftgleft) : RUP_GRD(echo1ftg_filt.tdaq/8);   /* 1/8th of readout window to left of S1 */

    area_gx2ftg = area_gx1ftg - a_gxw2ftg * (float)(pw_gxw2ftga/ 2 + pw_gxw2ftgleft);
 
    if( amppwgrad(area_gx2ftg, ftg_tx_xz,
                  0.0, 0.0, ftg_xrt,
                  MIN_PLATEAU_TIME, _a_gx2ftg.fixedflag ? (_temp288_a_gx2ftg=a_gx2ftg,&_temp288_a_gx2ftg) : &a_gx2ftg, _pw_gx2ftga.fixedflag ? (_temp289_pw_gx2ftga=pw_gx2ftga,&_temp289_pw_gx2ftga) : &pw_gx2ftga,
                  _pw_gx2ftg.fixedflag ? (_temp290_pw_gx2ftg=pw_gx2ftg,&_temp290_pw_gx2ftg) : &pw_gx2ftg, _pw_gx2ftgd.fixedflag ? (_temp291_pw_gx2ftgd=pw_gx2ftgd,&_temp291_pw_gx2ftgd) : &pw_gx2ftgd) == FAILURE ) {
        epic_error(use_ermes, "%s failed in fasttg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gx2ftg");
        return FAILURE;
    }
   
    if( (pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft
         > FTGtau1) || (pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft > FTGtau1) )
    {
        /* return FAILURE; */
    }
    
    /* HCSDM00161809: calculate minimum FTGtau1 */
    FTGtau1check1 = RUP_GRD(pw_rf1ftg/2+pw_gx1ftga+pw_gx1ftg+pw_gx1ftgd+pw_rf2ftg/2);
    FTGtau1check2 = RUP_GRD(pw_rf1ftg/2+pw_gzrf1ftgd+pw_gz1ftga+pw_gz1ftg+pw_gz1ftgd+pw_gzrf2ftga+pw_rf2ftg/2);
    FTGtau1check3 = RUP_GRD(pw_rf2ftg/2+pw_gx1bftga+pw_gx1bftg+pw_gx1bftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check4 = RUP_GRD(pw_rf2ftg/2+pw_gzrf2ftgd+pw_gz2ftga+pw_gz2ftg+pw_gz2ftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check5 = RUP_GRD(pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft);
    FTGtau1check6 = RUP_GRD(pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft);

    temp_FTGtau1 = IMax(7, FTGtau1, FTGtau1check1, FTGtau1check2, FTGtau1check3, FTGtau1check4, FTGtau1check5, FTGtau1check6);

    cvoverride(FTGtau1, temp_FTGtau1, PSD_FIX_OFF, PSD_EXIST_ON);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;
    
    strcpy(entry_point_table[L_FTG].epname, "fasttg");
 
    return SUCCESS;
}   /* end FTGcveval() */


/*
 *  XTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcveval( void )
{
    LONG bw_rf1xtg;
    LONG bw_rf2xtg;
    FLOAT area_g1xtg;
    FLOAT area_gxw1xtg;
    INT ta_180, tb_180;
    FLOAT area_gxw1rampxtg;
    INT xtg_xrt, xtg_yrt;
    FLOAT xtg_tx;
    FLOAT xtg_tx_xz;
    FLOAT xtg_tz_xz;
    FLOAT xtg_tx_xyz, xtg_ty_xyz, xtg_tz_xyz;
    FLOAT xtg_temp_float;
    INT temp_max_pw;
    INT XTGspf;

    XTGspf = (TGspf && (PSD_OFF == local_tg));
    XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), XTGfov) : FMin(2,480.0,cfsystemmaxfov);

    if(0 == getAps1Mod())
    {
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,opfov,XTGfov)), XTGfov) : FMin(2,opfov,XTGfov);
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMax(2,XTGfov,MINFOV_TG)), XTGfov) : FMax(2,XTGfov,MINFOV_TG);
    }

    xtg_xrt = (XTGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    xtg_yrt = (XTGspf ? ps1loggrd.xrt : ps1loggrd.yrt);
    xtg_tx = (XTGspf ? ps1loggrd.ty : ps1loggrd.tx);
    xtg_tx_xz = (XTGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    xtg_tz_xz = (XTGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    xtg_tz_xyz = ps1loggrd.tz_xyz;
    xtg_tx_xyz = (XTGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);
    xtg_ty_xyz = (XTGspf ? ps1loggrd.tx_xyz : ps1loggrd.ty_xyz);

    gscale_rf1xtg   = _gscale_rf1xtg.fixedflag ?  ((void)(0.90909), gscale_rf1xtg) : 0.90909;
    gscale_rf2xtg   = _gscale_rf2xtg.fixedflag ?  ((void)(gscale_rf1xtg), gscale_rf2xtg) : gscale_rf1xtg;

    pw_gzrf2xtg  = _pw_gzrf2xtg.fixedflag ?  ((void)(pw_rf2xtg), pw_gzrf2xtg) : pw_rf2xtg;

    XTGecho1bw  = _XTGecho1bw.fixedflag ?  ((void)(15.625), XTGecho1bw) : 15.625;

    bw_rf1xtg = (LONG)(4 * cyc_rf1xtg/ ((FLOAT)pw_rf1xtg/ (FLOAT)1000000));

    if(PSD_ON == local_tg)
    {
        pw_gyrf1xtg  = _pw_gyrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gyrf1xtg) : pw_rf1xtg;
        XTGfov  = _XTGfov.fixedflag ?  ((void)(TGopslthickx), XTGfov) : TGopslthickx;

        if( ampslice(_a_gyrf1xtg.fixedflag ? (_temp292_a_gyrf1xtg=a_gyrf1xtg,&_temp292_a_gyrf1xtg) : &a_gyrf1xtg, bw_rf1xtg, TGopslthicky, gscale_rf1xtg, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gyrf1xtga.fixedflag ? (_temp293_pw_gyrf1xtga=pw_gyrf1xtga,&_temp293_pw_gyrf1xtga) : &pw_gyrf1xtga, a_gyrf1xtg, ps1loggrd.ty, ps1loggrd.yrt, TYPDEF)
            == FAILURE ) {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1xtga.");
            return FAILURE;
        }    

        pw_gyrf1xtgd  = _pw_gyrf1xtgd.fixedflag ?  ((void)(pw_gyrf1xtga), pw_gyrf1xtgd) : pw_gyrf1xtga;

    }
    else
    {
        pw_gzrf1xtg  = _pw_gzrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gzrf1xtg) : pw_rf1xtg;

        if( ampslice(_a_gzrf1xtg.fixedflag ? (_temp294_a_gzrf1xtg=a_gzrf1xtg,&_temp294_a_gzrf1xtg) : &a_gzrf1xtg, bw_rf1xtg, TGopslthick, gscale_rf1xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1xtg.");
        return FAILURE;
    }

    if( optramp(_pw_gzrf1xtga.fixedflag ? (_temp295_pw_gzrf1xtga=pw_gzrf1xtga,&_temp295_pw_gzrf1xtga) : &pw_gzrf1xtga, a_gzrf1xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1xtga.");
        return FAILURE;
    }    

    pw_gzrf1xtgd  = _pw_gzrf1xtgd.fixedflag ?  ((void)(pw_gzrf1xtga), pw_gzrf1xtgd) : pw_gzrf1xtga;
    
    }

    bw_rf2xtg = (LONG)(4 * cyc_rf2xtg/ ((FLOAT)pw_rf2xtg/ (FLOAT)1000000));

    if( ampslice(_a_gzrf2xtg.fixedflag ? (_temp296_a_gzrf2xtg=a_gzrf2xtg,&_temp296_a_gzrf2xtg) : &a_gzrf2xtg, bw_rf2xtg, TGopslthick, gscale_rf2xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2xtg.");
        return FAILURE;
    }

    if (optramp(_pw_gzrf2xtga.fixedflag ? (_temp297_pw_gzrf2xtga=pw_gzrf2xtga,&_temp297_pw_gzrf2xtga) : &pw_gzrf2xtga, a_gzrf2xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2xtga.");
        return FAILURE;
    }    

    pw_gzrf2xtgd  = _pw_gzrf2xtgd.fixedflag ?  ((void)(pw_gzrf2xtga), pw_gzrf2xtgd) : pw_gzrf2xtga;

    /* Z CRUSHER CVs */ 
    if(PSD_ON == local_tg)
    {
        area_g1xtg = 0.0;
    }
    else
    {
        area_g1xtg = (PSoff90 + pw_gzrf1xtg/2.0 + pw_gzrf1xtgd/2.0)*a_gzrf1xtg;
    }
    area_xtgzkiller  = _area_xtgzkiller.fixedflag ?  ((void)(amp_killer*pw_killer+area_g1xtg), area_xtgzkiller) : amp_killer*pw_killer+area_g1xtg;
    if (amppwgrad(area_xtgzkiller, xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz2xtg.fixedflag ? (_temp298_a_gz2xtg=a_gz2xtg,&_temp298_a_gz2xtg) : &a_gz2xtg, _pw_gz2xtga.fixedflag ? (_temp299_pw_gz2xtga=pw_gz2xtga,&_temp299_pw_gz2xtga) : &pw_gz2xtga,
                  _pw_gz2xtg.fixedflag ? (_temp300_pw_gz2xtg=pw_gz2xtg,&_temp300_pw_gz2xtg) : &pw_gz2xtg, _pw_gz2xtgd.fixedflag ? (_temp301_pw_gz2xtgd=pw_gz2xtgd,&_temp301_pw_gz2xtgd) : &pw_gz2xtgd) == FAILURE) {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz2xtg"); 
        return FAILURE;
    }

    if (amppwgrad((area_xtgzkiller-area_g1xtg), xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz1xtg.fixedflag ? (_temp302_a_gz1xtg=a_gz1xtg,&_temp302_a_gz1xtg) : &a_gz1xtg, _pw_gz1xtga.fixedflag ? (_temp303_pw_gz1xtga=pw_gz1xtga,&_temp303_pw_gz1xtga) : &pw_gz1xtga,
                  _pw_gz1xtg.fixedflag ? (_temp304_pw_gz1xtg=pw_gz1xtg,&_temp304_pw_gz1xtg) : &pw_gz1xtg, _pw_gz1xtgd.fixedflag ? (_temp305_pw_gz1xtgd=pw_gz1xtgd,&_temp305_pw_gz1xtgd) : &pw_gz1xtgd) == FAILURE) {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz1xtg"); 
        return FAILURE;
    }

    /* use 16kHz, 256 xres */
    if( calcfilter( &echo1xtg_filt, XTGecho1bw, XTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1xtg_filt");
        return FAILURE;
    }
    
    if (ampfov(&xtg_temp_float, echo1xtg_filt.bw, xtg_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "xtg ampfov");
        return FAILURE;
    }

    xtg_temp_float = ceil(xtg_temp_float/ 10.0) * 10.0;
    if( xtg_temp_float > XTGfov )
    {
        XTGfov  = _XTGfov.fixedflag ?  ((void)(xtg_temp_float), XTGfov) : xtg_temp_float;
    }

    if( ampfov(_a_gxw1xtg.fixedflag ? (_temp306_a_gxw1xtg=a_gxw1xtg,&_temp306_a_gxw1xtg) : &a_gxw1xtg, echo1xtg_filt.bw, XTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1xtg.");
        return FAILURE;        
    }

    if( optramp(_pw_gxw1xtga.fixedflag ? (_temp307_pw_gxw1xtga=pw_gxw1xtga,&_temp307_pw_gxw1xtga) : &pw_gxw1xtga, a_gxw1xtg, xtg_tx,
                xtg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1xtga.");
        return FAILURE;
    }    

    pw_gxw1xtgd  = _pw_gxw1xtgd.fixedflag ?  ((void)(pw_gxw1xtga), pw_gxw1xtgd) : pw_gxw1xtga;
    
    pw_gxw1xtg  = _pw_gxw1xtg.fixedflag ?  ((void)(RUP_GRD((int)(echo1xtg_filt.tdaq))), pw_gxw1xtg) : RUP_GRD((int)(echo1xtg_filt.tdaq));
    
    area_gxw1xtg = a_gxw1xtg*(float)(pw_gxw1xtg);
    area_gxw1rampxtg = 0.5*a_gxw1xtg*(float)(pw_gxw1xtga);
    
    if( amppwgx1(_a_gx1bxtg.fixedflag ? (_temp308_a_gx1bxtg=a_gx1bxtg,&_temp308_a_gx1bxtg) : &a_gx1bxtg, _pw_gx1bxtg.fixedflag ? (_temp309_pw_gx1bxtg=pw_gx1bxtg,&_temp309_pw_gx1bxtg) : &pw_gx1bxtg, _pw_gx1bxtga.fixedflag ? (_temp310_pw_gx1bxtga=pw_gx1bxtga,&_temp310_pw_gx1bxtga) : &pw_gx1bxtga, _pw_gx1bxtgd.fixedflag ? (_temp311_pw_gx1bxtgd=pw_gx1bxtgd,&_temp311_pw_gx1bxtgd) : &pw_gx1bxtgd,
                 TYPSPIN, area_gxw1xtg, area_gxw1rampxtg,
                 1000000, 1.0, MIN_PLATEAU_TIME, xtg_xrt, xtg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1bxtg.");
        return FAILURE;
    }
    a_gx1bxtg  = _a_gx1bxtg.fixedflag ?  ((void)(-a_gx1bxtg), a_gx1bxtg) : -a_gx1bxtg;

    /* Find Params for killer pulse */
    if(PSD_ON == local_tg)
    {
        area_g1xtg = (PSoff90 + pw_gyrf1xtg/2.0 + pw_gyrf1xtgd/2.0)*a_gyrf1xtg;
    }
    else
    {
        area_g1xtg = 0.0;
    }
    area_xtgykiller  = _area_xtgykiller.fixedflag ?  ((void)(amp_killer*pw_killer), area_xtgykiller) : amp_killer*pw_killer;
    if (amppwgrad(area_xtgykiller-area_g1xtg, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgl.fixedflag ? (_temp312_a_gykxtgl=a_gykxtgl,&_temp312_a_gykxtgl) : &a_gykxtgl, _pw_gykxtgla.fixedflag ? (_temp313_pw_gykxtgla=pw_gykxtgla,&_temp313_pw_gykxtgla) : &pw_gykxtgla,
                  _pw_gykxtgl.fixedflag ? (_temp314_pw_gykxtgl=pw_gykxtgl,&_temp314_pw_gykxtgl) : &pw_gykxtgl, _pw_gykxtgld.fixedflag ? (_temp315_pw_gykxtgld=pw_gykxtgld,&_temp315_pw_gykxtgld) : &pw_gykxtgld) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgl");
        return FAILURE;
    }
    
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgr.fixedflag ? (_temp316_a_gykxtgr=a_gykxtgr,&_temp316_a_gykxtgr) : &a_gykxtgr, _pw_gykxtgra.fixedflag ? (_temp317_pw_gykxtgra=pw_gykxtgra,&_temp317_pw_gykxtgra) : &pw_gykxtgra,
                  _pw_gykxtgr.fixedflag ? (_temp318_pw_gykxtgr=pw_gykxtgr,&_temp318_pw_gykxtgr) : &pw_gykxtgr, _pw_gykxtgrd.fixedflag ? (_temp319_pw_gykxtgrd=pw_gykxtgrd,&_temp319_pw_gykxtgrd) : &pw_gykxtgrd) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgr");
        return FAILURE;
    }
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;
 
    if(PSD_ON == local_tg)
    {
        temp_max_pw = pw_gyrf1xtgd+pw_gykxtgla+pw_gykxtgl+pw_gykxtgld;
    }
    else
    {
        temp_max_pw = IMax(2,pw_gzrf1xtgd, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld);
    }
    ta_180 = pw_rf1xtg/2+pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd+temp_max_pw+pw_rf3xtg+rfupd+pw_gzrf2xtga+pw_gzrf2xtg/2;
    
    temp_max_pw = IMax(2,(pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd+pw_gxw1xtga), pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd);
    tb_180 = pw_gzrf2xtg/2+pw_gzrf2xtgd+pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd+temp_max_pw+pw_rf4xtg+rfupd+pw_gxw1xtg/2;
    XTGtau1  = _XTGtau1.fixedflag ?    ((void)(RUP_GRD(IMax(2,ta_180,tb_180))), XTGtau1) : RUP_GRD(IMax(2,ta_180,tb_180)); 
    
    strcpy(entry_point_table[L_XTG].epname, "expresstg");
 
    return SUCCESS;
}   /* end XTGcveval() */

/* 
 *  RScveval
 *  Description:
 *  CV eval for RFShim 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
RScveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1rs, area_gx1rs;
    FLOAT area_gxkbsrs, area_gxkrs;
    FLOAT area_gzkbsrs, area_gzkrs;
    FLOAT area_gx2rs;
    FLOAT temp_float;
    LONG bw_rf1rs;

    echo1bwrs  = _echo1bwrs.fixedflag ?  ((void)(31.25), echo1bwrs) : 31.25;
    rfshim_baseline  = _rfshim_baseline.fixedflag ?  ((void)(0), rfshim_baseline) : 0;
    rfshim_xres  = _rfshim_xres.fixedflag ?  ((void)(64), rfshim_xres) : 64;
    rfshim_yres  = _rfshim_yres.fixedflag ?  ((void)(64), rfshim_yres) : 64;
    rfshim_slthick  = _rfshim_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), rfshim_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if( (PSD_ON == rsaxial_flag) )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(460), rfshim_fov) : 460;
        if( isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD)  )
        {
            rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(280), rfshim_fov) : 280;  /* 28 cm FOV for head scans */
        }

    }

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* I/Q DD cal needs to double flip */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10), flip_rf1rs) : 10;
    rfshim_flipangle  = _rfshim_flipangle.fixedflag ?  ((void)(flip_rf1rs), rfshim_flipangle) : flip_rf1rs;

    rfshim_slquant  = _rfshim_slquant.fixedflag ?  ((void)(1), rfshim_slquant) : 1;
    rfshim_slquant  = _rfshim_slquant.fixedflag ?    ((void)(IMin(2,RFSHIM_SLQ,rfshim_slquant)), rfshim_slquant) : IMin(2,RFSHIM_SLQ,rfshim_slquant);

    pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(RUP_GRD(pw_rf1rs)), pw_rf1rs) : RUP_GRD(pw_rf1rs);

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            bw_rf1rs = (LONG)(4*cyc_rf1rs/((float)pw_rf1rs/(float)1000000));
            rs_iso_delay   = _rs_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw)), rs_iso_delay) : RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1rs = (LONG)(rfpulse[RF1_RFSHIM_SLOT].nom_bw*rfpulse[RF1_RFSHIM_SLOT].nom_pw/pw_rf1rs);
            rs_iso_delay  = _rs_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw))), rs_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw));
            break;
    }


    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    if (FAILURE==ampslice(_a_gzrf1rs.fixedflag ? (_temp320_a_gzrf1rs=a_gzrf1rs,&_temp320_a_gzrf1rs) : &a_gzrf1rs, bw_rf1rs, rfshim_slthick, gscale_rf1rs, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1rs.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1rsa.fixedflag ? (_temp321_pw_gzrf1rsa=pw_gzrf1rsa,&_temp321_pw_gzrf1rsa) : &pw_gzrf1rsa, a_gzrf1rs, rsloggrd.tz_xyz, rsloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1rsa.");
        return FAILURE;
    }
    pw_gzrf1rsd  = _pw_gzrf1rsd.fixedflag ?  ((void)(pw_gzrf1rsa), pw_gzrf1rsd) : pw_gzrf1rsa;

    /* Z BLS killer */
    area_gzkbsrs = 1.0E6*3.0*10.0/GAM/exist(rfshim_slthick);

    if (FAILURE==amppwgrad(area_gzkbsrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsrs.fixedflag ? (_temp322_a_gzkbsrs=a_gzkbsrs,&_temp322_a_gzkbsrs) : &a_gzkbsrs, _pw_gzkbsrsa.fixedflag ? (_temp323_pw_gzkbsrsa=pw_gzkbsrsa,&_temp323_pw_gzkbsrsa) : &pw_gzkbsrsa,
                           _pw_gzkbsrs.fixedflag ? (_temp324_pw_gzkbsrs=pw_gzkbsrs,&_temp324_pw_gzkbsrs) : &pw_gzkbsrs, _pw_gzkbsrsd.fixedflag ? (_temp325_pw_gzkbsrsd=pw_gzkbsrsd,&_temp325_pw_gzkbsrsd) : &pw_gzkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsrs");
        return FAILURE;
    }

    if (a_gzrf1rs>0.0)
    {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsrs)), a_gzkbsrs) : -1.0*fabsf(a_gzkbsrs);
    } else {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(fabsf(a_gzkbsrs)), a_gzkbsrs) : fabsf(a_gzkbsrs);
    }

    rst_exa  = _rst_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay)), rst_exa) : RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay);
    rst_exb  = _rst_exb.fixedflag ?  ((void)(rs_iso_delay), rst_exb) : rs_iso_delay;

    area_gz1rs = (rs_iso_delay + (pw_gzrf1rsd/ 2.0)) * a_gzrf1rs;
    if (area_gz1rs > 0.0)
    {
        area_gz1rs -= fabsf(area_gzkbsrs);
    }
    else
    {
        area_gz1rs += fabsf(area_gzkbsrs);
    }

    if (amppwgz1(_a_gz1rs.fixedflag ? (_temp326_a_gz1rs=a_gz1rs,&_temp326_a_gz1rs) : &a_gz1rs,_pw_gz1rs.fixedflag ? (_temp327_pw_gz1rs=pw_gz1rs,&_temp327_pw_gz1rs) : &pw_gz1rs,_pw_gz1rsa.fixedflag ? (_temp328_pw_gz1rsa=pw_gz1rsa,&_temp328_pw_gz1rsa) : &pw_gz1rsa,_pw_gz1rsd.fixedflag ? (_temp329_pw_gz1rsd=pw_gz1rsd,&_temp329_pw_gz1rsd) : &pw_gz1rsd,area_gz1rs,
                 (int)(1000000),MIN_PLATEAU_TIME,rsloggrd.zrt,rsloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1rs.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkrs = 980;

    if (FAILURE==amppwgrad(area_gzkrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkrs.fixedflag ? (_temp330_a_gzkrs=a_gzkrs,&_temp330_a_gzkrs) : &a_gzkrs, _pw_gzkrsa.fixedflag ? (_temp331_pw_gzkrsa=pw_gzkrsa,&_temp331_pw_gzkrsa) : &pw_gzkrsa,
                           _pw_gzkrs.fixedflag ? (_temp332_pw_gzkrs=pw_gzkrs,&_temp332_pw_gzkrs) : &pw_gzkrs, _pw_gzkrsd.fixedflag ? (_temp333_pw_gzkrsd=pw_gzkrsd,&_temp333_pw_gzkrsd) : &pw_gzkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkrs");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1rs_filt, echo1bwrs, rfshim_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rs_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1rs_filt.bw, rsloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > rfshim_fov )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(temp_float), rfshim_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwrs.fixedflag ? (_temp334_a_gxwrs=a_gxwrs,&_temp334_a_gxwrs) : &a_gxwrs, echo1rs_filt.bw, rfshim_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwrs.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwrsa.fixedflag ? (_temp335_pw_gxwrsa=pw_gxwrsa,&_temp335_pw_gxwrsa) : &pw_gxwrsa, a_gxwrs, rsloggrd.tx_xyz, rsloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwrsa.");
        return FAILURE;
    }

    pw_gxwrsd  = _pw_gxwrsd.fixedflag ?  ((void)(pw_gxwrsa), pw_gxwrsd) : pw_gxwrsa;
    pw_acqrs1  = _pw_acqrs1.fixedflag ?  ((void)(echo1rs_filt.tdaq), pw_acqrs1) : echo1rs_filt.tdaq;  /* one echo data */

    rd_ext_rs  = _rd_ext_rs.fixedflag ?  
                        ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_rs) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwrs  = _pw_gxwrs.fixedflag ?      ((void)(pw_acqrs1+e2_delay_rs+rd_ext_rs), pw_gxwrs) : pw_acqrs1+e2_delay_rs+rd_ext_rs;  /* total readout */

    /* X BLS killer */
    area_gxkbsrs = area_gzkbsrs;

    if (FAILURE==amppwgrad(area_gxkbsrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsrs.fixedflag ? (_temp336_a_gxkbsrs=a_gxkbsrs,&_temp336_a_gxkbsrs) : &a_gxkbsrs, _pw_gxkbsrsa.fixedflag ? (_temp337_pw_gxkbsrsa=pw_gxkbsrsa,&_temp337_pw_gxkbsrsa) : &pw_gxkbsrsa,
                           _pw_gxkbsrs.fixedflag ? (_temp338_pw_gxkbsrs=pw_gxkbsrs,&_temp338_pw_gxkbsrs) : &pw_gxkbsrs, _pw_gxkbsrsd.fixedflag ? (_temp339_pw_gxkbsrsd=pw_gxkbsrsd,&_temp339_pw_gxkbsrsd) : &pw_gxkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RFcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsrs");
        return FAILURE;
    }

    if (a_gxwrs>0.0)
    {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsrs)), a_gxkbsrs) : -1.0*fabsf(a_gxkbsrs);
    } else {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(fabsf(a_gxkbsrs)), a_gxkbsrs) : fabsf(a_gxkbsrs);
    }

    /* combine gxkbs and gx1 */
    area_gx1rs = area_gxkbsrs - (pw_gxwrs+pw_gxwrsa)/2.0*a_gxwrs;

    if (FAILURE==amppwgrad(area_gx1rs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1rs.fixedflag ? (_temp340_a_gx1rs=a_gx1rs,&_temp340_a_gx1rs) : &a_gx1rs, _pw_gx1rsa.fixedflag ? (_temp341_pw_gx1rsa=pw_gx1rsa,&_temp341_pw_gx1rsa) : &pw_gx1rsa,
                           _pw_gx1rs.fixedflag ? (_temp342_pw_gx1rs=pw_gx1rs,&_temp342_pw_gx1rs) : &pw_gx1rs, _pw_gx1rsd.fixedflag ? (_temp343_pw_gx1rsd=pw_gx1rsd,&_temp343_pw_gx1rsd) : &pw_gx1rsd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1rs.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkrs = 980;
    if (FAILURE==amppwgrad(area_gxkrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkrs.fixedflag ? (_temp344_a_gxkrs=a_gxkrs,&_temp344_a_gxkrs) : &a_gxkrs, _pw_gxkrsa.fixedflag ? (_temp345_pw_gxkrsa=pw_gxkrsa,&_temp345_pw_gxkrsa) : &pw_gxkrsa,
                           _pw_gxkrs.fixedflag ? (_temp346_pw_gxkrs=pw_gxkrs,&_temp346_pw_gxkrs) : &pw_gxkrs, _pw_gxkrsd.fixedflag ? (_temp347_pw_gxkrsd=pw_gxkrsd,&_temp347_pw_gxkrsd) : &pw_gxkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkrs");
        return FAILURE;
    }

    if(rfshim_etl >=2)
    {
        pw_gxw2rs  = _pw_gxw2rs.fixedflag ?  ((void)(pw_gxwrs), pw_gxw2rs) : pw_gxwrs;
        pw_gxw2rsa  = _pw_gxw2rsa.fixedflag ?  ((void)(pw_gxwrsa), pw_gxw2rsa) : pw_gxwrsa;
        pw_gxw2rsd  = _pw_gxw2rsd.fixedflag ?  ((void)(pw_gxwrsd), pw_gxw2rsd) : pw_gxwrsd;
        a_gxw2rs  = _a_gxw2rs.fixedflag ?  ((void)(a_gxwrs), a_gxw2rs) : a_gxwrs;

        area_gx2rs = -(pw_gxw2rs+(pw_gxw2rsa+pw_gxw2rsd)/2.0)*a_gxw2rs;

        if (FAILURE==amppwgrad(area_gx2rs, rsloggrd.tx_xy, 0.0, 0.0, rsloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2rs.fixedflag ? (_temp348_a_gx2rs=a_gx2rs,&_temp348_a_gx2rs) : &a_gx2rs, _pw_gx2rsa.fixedflag ? (_temp349_pw_gx2rsa=pw_gx2rsa,&_temp349_pw_gx2rsa) : &pw_gx2rsa,
                               _pw_gx2rs.fixedflag ? (_temp350_pw_gx2rs=pw_gx2rs,&_temp350_pw_gx2rs) : &pw_gx2rs, _pw_gx2rsd.fixedflag ? (_temp351_pw_gx2rsd=pw_gx2rsd,&_temp351_pw_gx2rsd) : &pw_gx2rsd ))
        {
            epic_error(use_ermes, "%s failed in RScveval.", EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2rs");
            return FAILURE;
        }

        rs_esp  = _rs_esp.fixedflag ?                
                                                
                                                  
                                                
                                                  ((void)(RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd))), rs_esp) : RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd));

    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(rfshim_yres), _endview_iamprs.fixedflag ? (_temp352_endview_iamprs=endview_iamprs,&_temp352_endview_iamprs) : &endview_iamprs) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:RFShim B1 map");
        return FAILURE;
    } 
  
    endview_scalers  = _endview_scalers.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamprs), endview_scalers) : (float)max_pg_iamp/(float)endview_iamprs;

    if ( FAILURE==amppwtpe(_a_gy1rsa.fixedflag ? (_temp353_a_gy1rsa=a_gy1rsa,&_temp353_a_gy1rsa) : &a_gy1rsa, _a_gy1rsb.fixedflag ? (_temp354_a_gy1rsb=a_gy1rsb,&_temp354_a_gy1rsb) : &a_gy1rsb, _pw_gy1rs.fixedflag ? (_temp355_pw_gy1rs=pw_gy1rs,&_temp355_pw_gy1rs) : &pw_gy1rs, _pw_gy1rsa.fixedflag ? (_temp356_pw_gy1rsa=pw_gy1rsa,&_temp356_pw_gy1rsa) : &pw_gy1rsa, _pw_gy1rsd.fixedflag ? (_temp357_pw_gy1rsd=pw_gy1rsd,&_temp357_pw_gy1rsd) : &pw_gy1rsd,
                           rsloggrd.ty_xyz/endview_scalers,rsloggrd.yrt,
                           (0.5 * (FLOAT)(rfshim_yres-1))/(rfshim_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:RFShim B1 map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rrs  = _a_gy1rrs.fixedflag ?  ((void)(a_gy1rs), a_gy1rrs) : a_gy1rs;
    a_gy1rrsa  = _a_gy1rrsa.fixedflag ?  ((void)(a_gy1rsa), a_gy1rrsa) : a_gy1rsa;
    a_gy1rrsb  = _a_gy1rrsb.fixedflag ?  ((void)(a_gy1rsb), a_gy1rrsb) : a_gy1rsb;
    pw_gy1rrs  = _pw_gy1rrs.fixedflag ?  ((void)(pw_gy1rs), pw_gy1rrs) : pw_gy1rs;
    pw_gy1rrsa  = _pw_gy1rrsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy1rrsa) : pw_gy1rsa;
    pw_gy1rrsd  = _pw_gy1rrsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy1rrsd) : pw_gy1rsd;

    a_gy2rs  = _a_gy2rs.fixedflag ?  ((void)(a_gy1rs), a_gy2rs) : a_gy1rs;
    a_gy2rsa  = _a_gy2rsa.fixedflag ?  ((void)(a_gy1rsa), a_gy2rsa) : a_gy1rsa;
    a_gy2rsb  = _a_gy2rsb.fixedflag ?  ((void)(a_gy1rsb), a_gy2rsb) : a_gy1rsb;
    pw_gy2rs  = _pw_gy2rs.fixedflag ?  ((void)(pw_gy1rs), pw_gy2rs) : pw_gy1rs;
    pw_gy2rsa  = _pw_gy2rsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy2rsa) : pw_gy1rsa;
    pw_gy2rsd  = _pw_gy2rsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy2rsd) : pw_gy1rsd;


    td0rs  = _td0rs.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+rffrequency_length[bd_index]-rfupa))), td0rs) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+rffrequency_length[bd_index]-rfupa));

    temp_time = IMax(2, pw_gzrf1rsd + pw_gz1rsa + pw_gz1rs + pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd);
    temp_time2 = IMax(3, pw_gx1rsa + pw_gx1rs + pw_gx1rsd + pw_gxwrsa, pw_gy1rsa + pw_gy1rs + pw_gy1rsd,
                      pw_gzkbsrsa + pw_gzkbsrs + pw_gzkbsrsd);

    min_rste  = _min_rste.fixedflag ?          ((void)(RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+pw_gxwrs/2.0)), min_rste) : RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+pw_gxwrs/2.0);

    temp_time = IMax(3, pw_gxwrsd + pw_gxkrsa + pw_gxkrs + pw_gxkrsd, pw_gy1rrsa + pw_gy1rrs + pw_gy1rrsd,
                     pw_gzkrsa + pw_gzkrs + pw_gzkrsd);

    tr_rs  = _tr_rs.fixedflag ?                ((void)(RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+psd_grd_wait+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp)), tr_rs) : RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+psd_grd_wait+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp);

    return SUCCESS;
} /* end RScveval */

/* 
 *  DTGcveval
 *  Description:
 *  CV eval for DynTG B1map 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
DTGcveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1dtg, area_gx1dtg;
    FLOAT area_gxkbsdtg, area_gxkdtg, area_gzkbsdtg, area_gzkdtg, area_gx2dtg;
    FLOAT temp_float;
    LONG bw_rf1dtg;


    dtgloggrd = loggrd; /* same as imaging loggrd */

    echo1bwdtg  = _echo1bwdtg.fixedflag ?  ((void)(31.25), echo1bwdtg) : 31.25;
    dynTG_baseline  = _dynTG_baseline.fixedflag ?  ((void)(0), dynTG_baseline) : 0;
    dynTG_xres  = _dynTG_xres.fixedflag ?  ((void)(64), dynTG_xres) : 64;
    dynTG_yres  = _dynTG_yres.fixedflag ?  ((void)(64), dynTG_yres) : 64;
    dynTG_slthick  = _dynTG_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), dynTG_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */
    dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMax(2,exist(opfov),80.0)), dynTG_fov) : FMax(2,exist(opfov),80.0);  /* limit to min FOV of 80mm */
    dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,dynTG_fov,(float)FOV_MAX)), dynTG_fov) : FMin(2,dynTG_fov,(float)FOV_MAX);

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180), flip_rfbdtg) : 180;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10), flip_rf1dtg) : 10;

    dynTG_flipangle  = _dynTG_flipangle.fixedflag ?  ((void)(flip_rf1dtg), dynTG_flipangle) : flip_rf1dtg;

    pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(RUP_GRD(pw_rf1dtg)), pw_rf1dtg) : RUP_GRD(pw_rf1dtg);

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            bw_rf1dtg = (LONG)(4*cyc_rf1dtg/((float)pw_rf1dtg/(float)1000000));
            dtg_iso_delay   = _dtg_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw)), dtg_iso_delay) : RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1dtg = (LONG)(rfpulse[RF1_DYNTG_SLOT].nom_bw*rfpulse[RF1_DYNTG_SLOT].nom_pw/pw_rf1dtg);
            dtg_iso_delay  = _dtg_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw))), dtg_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw));
            break;
    }

    if (exist(opslquant)<=DYNTG_SLQ)
    {
        if (1 == (exist(opslquant) % 2))
        {
            dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(exist(opslquant)), dynTG_slquant) : exist(opslquant);
        }
        else
        {
            dynTG_slquant  = _dynTG_slquant.fixedflag ?    ((void)(exist(opslquant)-1), dynTG_slquant) : exist(opslquant)-1;
        }
    }
    else
    {
        dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(DYNTG_SLQ), dynTG_slquant) : DYNTG_SLQ;
    }

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    if (FAILURE==ampslice(_a_gzrf1dtg.fixedflag ? (_temp358_a_gzrf1dtg=a_gzrf1dtg,&_temp358_a_gzrf1dtg) : &a_gzrf1dtg, bw_rf1dtg, dynTG_slthick, gscale_rf1dtg, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1dtg.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1dtga.fixedflag ? (_temp359_pw_gzrf1dtga=pw_gzrf1dtga,&_temp359_pw_gzrf1dtga) : &pw_gzrf1dtga, a_gzrf1dtg, dtgloggrd.tz_xyz, dtgloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1dtga.");
        return FAILURE;
    }
    pw_gzrf1dtgd  = _pw_gzrf1dtgd.fixedflag ?  ((void)(pw_gzrf1dtga), pw_gzrf1dtgd) : pw_gzrf1dtga;

    /* Z BLS killer */
    area_gzkbsdtg = 1.0E6*3.0*10.0/GAM/exist(dynTG_slthick);

    if (FAILURE==amppwgrad(area_gzkbsdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsdtg.fixedflag ? (_temp360_a_gzkbsdtg=a_gzkbsdtg,&_temp360_a_gzkbsdtg) : &a_gzkbsdtg, _pw_gzkbsdtga.fixedflag ? (_temp361_pw_gzkbsdtga=pw_gzkbsdtga,&_temp361_pw_gzkbsdtga) : &pw_gzkbsdtga,
                           _pw_gzkbsdtg.fixedflag ? (_temp362_pw_gzkbsdtg=pw_gzkbsdtg,&_temp362_pw_gzkbsdtg) : &pw_gzkbsdtg, _pw_gzkbsdtgd.fixedflag ? (_temp363_pw_gzkbsdtgd=pw_gzkbsdtgd,&_temp363_pw_gzkbsdtgd) : &pw_gzkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsdtg"); 
        return FAILURE;
    }

    if (a_gzrf1dtg>0.0)
    {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsdtg)), a_gzkbsdtg) : -1.0*fabsf(a_gzkbsdtg);
    } else {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(fabsf(a_gzkbsdtg)), a_gzkbsdtg) : fabsf(a_gzkbsdtg);
    }

    dtgt_exa  = _dtgt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay)), dtgt_exa) : RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay);
    dtgt_exb  = _dtgt_exb.fixedflag ?  ((void)(dtg_iso_delay), dtgt_exb) : dtg_iso_delay;

    area_gz1dtg = (dtg_iso_delay + (pw_gzrf1dtgd/ 2.0)) * a_gzrf1dtg;
    if (area_gz1dtg > 0.0)
    {
        area_gz1dtg -= fabsf(area_gzkbsdtg);
    }
    else
    {
        area_gz1dtg += fabsf(area_gzkbsdtg);
    }

    if (amppwgz1(_a_gz1dtg.fixedflag ? (_temp364_a_gz1dtg=a_gz1dtg,&_temp364_a_gz1dtg) : &a_gz1dtg,_pw_gz1dtg.fixedflag ? (_temp365_pw_gz1dtg=pw_gz1dtg,&_temp365_pw_gz1dtg) : &pw_gz1dtg,_pw_gz1dtga.fixedflag ? (_temp366_pw_gz1dtga=pw_gz1dtga,&_temp366_pw_gz1dtga) : &pw_gz1dtga,_pw_gz1dtgd.fixedflag ? (_temp367_pw_gz1dtgd=pw_gz1dtgd,&_temp367_pw_gz1dtgd) : &pw_gz1dtgd,area_gz1dtg,
                 (int)(1000000),MIN_PLATEAU_TIME,dtgloggrd.zrt,dtgloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1dtg.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkdtg = 980;

    if (FAILURE==amppwgrad(area_gzkdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkdtg.fixedflag ? (_temp368_a_gzkdtg=a_gzkdtg,&_temp368_a_gzkdtg) : &a_gzkdtg, _pw_gzkdtga.fixedflag ? (_temp369_pw_gzkdtga=pw_gzkdtga,&_temp369_pw_gzkdtga) : &pw_gzkdtga,
                           _pw_gzkdtg.fixedflag ? (_temp370_pw_gzkdtg=pw_gzkdtg,&_temp370_pw_gzkdtg) : &pw_gzkdtg, _pw_gzkdtgd.fixedflag ? (_temp371_pw_gzkdtgd=pw_gzkdtgd,&_temp371_pw_gzkdtgd) : &pw_gzkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkdtg"); 
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1dtg_filt, echo1bwdtg, dynTG_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1dtg_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1dtg_filt.bw, dtgloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > dynTG_fov )
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?  ((void)(temp_float), dynTG_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwdtg.fixedflag ? (_temp372_a_gxwdtg=a_gxwdtg,&_temp372_a_gxwdtg) : &a_gxwdtg, echo1dtg_filt.bw, dynTG_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwdtg.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwdtga.fixedflag ? (_temp373_pw_gxwdtga=pw_gxwdtga,&_temp373_pw_gxwdtga) : &pw_gxwdtga, a_gxwdtg, dtgloggrd.tx_xyz, dtgloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwdtga.");
        return FAILURE;
    }

    pw_gxwdtgd  = _pw_gxwdtgd.fixedflag ?  ((void)(pw_gxwdtga), pw_gxwdtgd) : pw_gxwdtga;
    pw_acqdtg1  = _pw_acqdtg1.fixedflag ?  ((void)(echo1dtg_filt.tdaq), pw_acqdtg1) : echo1dtg_filt.tdaq;  /* one echo data */

    rd_ext_dtg  = _rd_ext_dtg.fixedflag ?  
                           ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_dtg) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwdtg  = _pw_gxwdtg.fixedflag ?      ((void)(pw_acqdtg1+e2_delay_dtg+rd_ext_dtg), pw_gxwdtg) : pw_acqdtg1+e2_delay_dtg+rd_ext_dtg;  /* total readout */

    /* X BLS killer */
    area_gxkbsdtg = area_gzkbsdtg;

    if (FAILURE==amppwgrad(area_gxkbsdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsdtg.fixedflag ? (_temp374_a_gxkbsdtg=a_gxkbsdtg,&_temp374_a_gxkbsdtg) : &a_gxkbsdtg, _pw_gxkbsdtga.fixedflag ? (_temp375_pw_gxkbsdtga=pw_gxkbsdtga,&_temp375_pw_gxkbsdtga) : &pw_gxkbsdtga,
                           _pw_gxkbsdtg.fixedflag ? (_temp376_pw_gxkbsdtg=pw_gxkbsdtg,&_temp376_pw_gxkbsdtg) : &pw_gxkbsdtg, _pw_gxkbsdtgd.fixedflag ? (_temp377_pw_gxkbsdtgd=pw_gxkbsdtgd,&_temp377_pw_gxkbsdtgd) : &pw_gxkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsdtg"); 
        return FAILURE;
    }

    if (a_gxwdtg>0.0)
    {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsdtg)), a_gxkbsdtg) : -1.0*fabsf(a_gxkbsdtg);
    } else {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(fabsf(a_gxkbsdtg)), a_gxkbsdtg) : fabsf(a_gxkbsdtg);
    }

    /* combine gxkbs and gx1dtg */
    area_gx1dtg = area_gxkbsdtg - (pw_gxwdtg+pw_gxwdtga)/2.0*a_gxwdtg;

    if (FAILURE==amppwgrad(area_gx1dtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1dtg.fixedflag ? (_temp378_a_gx1dtg=a_gx1dtg,&_temp378_a_gx1dtg) : &a_gx1dtg, _pw_gx1dtga.fixedflag ? (_temp379_pw_gx1dtga=pw_gx1dtga,&_temp379_pw_gx1dtga) : &pw_gx1dtga,
                           _pw_gx1dtg.fixedflag ? (_temp380_pw_gx1dtg=pw_gx1dtg,&_temp380_pw_gx1dtg) : &pw_gx1dtg, _pw_gx1dtgd.fixedflag ? (_temp381_pw_gx1dtgd=pw_gx1dtgd,&_temp381_pw_gx1dtgd) : &pw_gx1dtgd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1dtg.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkdtg = 980;
    if (FAILURE==amppwgrad(area_gxkdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkdtg.fixedflag ? (_temp382_a_gxkdtg=a_gxkdtg,&_temp382_a_gxkdtg) : &a_gxkdtg, _pw_gxkdtga.fixedflag ? (_temp383_pw_gxkdtga=pw_gxkdtga,&_temp383_pw_gxkdtga) : &pw_gxkdtga,
                           _pw_gxkdtg.fixedflag ? (_temp384_pw_gxkdtg=pw_gxkdtg,&_temp384_pw_gxkdtg) : &pw_gxkdtg, _pw_gxkdtgd.fixedflag ? (_temp385_pw_gxkdtgd=pw_gxkdtgd,&_temp385_pw_gxkdtgd) : &pw_gxkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkdtg"); 
        return FAILURE;
    }

    /* echo train */
    if(dynTG_etl >= 2)
    {
        pw_gxw2dtg  = _pw_gxw2dtg.fixedflag ?  ((void)(pw_gxwdtg), pw_gxw2dtg) : pw_gxwdtg;
        pw_gxw2dtga  = _pw_gxw2dtga.fixedflag ?  ((void)(pw_gxwdtga), pw_gxw2dtga) : pw_gxwdtga;
        pw_gxw2dtgd  = _pw_gxw2dtgd.fixedflag ?  ((void)(pw_gxwdtgd), pw_gxw2dtgd) : pw_gxwdtgd;
        a_gxw2dtg  = _a_gxw2dtg.fixedflag ?  ((void)(a_gxwdtg), a_gxw2dtg) : a_gxwdtg;

        area_gx2dtg = -(pw_gxwdtg+(pw_gxwdtga+pw_gxwdtgd)/2.0)*a_gxwdtg;

        if (FAILURE==amppwgrad(area_gx2dtg, dtgloggrd.tx_xy, 0.0, 0.0, dtgloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2dtg.fixedflag ? (_temp386_a_gx2dtg=a_gx2dtg,&_temp386_a_gx2dtg) : &a_gx2dtg, _pw_gx2dtga.fixedflag ? (_temp387_pw_gx2dtga=pw_gx2dtga,&_temp387_pw_gx2dtga) : &pw_gx2dtga,
                               _pw_gx2dtg.fixedflag ? (_temp388_pw_gx2dtg=pw_gx2dtg,&_temp388_pw_gx2dtg) : &pw_gx2dtg, _pw_gx2dtgd.fixedflag ? (_temp389_pw_gx2dtgd=pw_gx2dtgd,&_temp389_pw_gx2dtgd) : &pw_gx2dtgd ))
        {
            epic_error(use_ermes, "%s failed in DTGcveval.",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2dtg"); 
            return FAILURE;
        }

        dtg_esp  = _dtg_esp.fixedflag ?                
                                        
                                            
                                        
                                          ((void)(RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd))), dtg_esp) : RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd));
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(dynTG_yres), _endview_iampdtg.fixedflag ? (_temp390_endview_iampdtg=endview_iampdtg,&_temp390_endview_iampdtg) : &endview_iampdtg) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:DynTG B1 map");
        return FAILURE;
    } 
  
    endview_scaledtg  = _endview_scaledtg.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampdtg), endview_scaledtg) : (float)max_pg_iamp/(float)endview_iampdtg;

    if ( FAILURE==amppwtpe(_a_gy1dtga.fixedflag ? (_temp391_a_gy1dtga=a_gy1dtga,&_temp391_a_gy1dtga) : &a_gy1dtga, _a_gy1dtgb.fixedflag ? (_temp392_a_gy1dtgb=a_gy1dtgb,&_temp392_a_gy1dtgb) : &a_gy1dtgb, _pw_gy1dtg.fixedflag ? (_temp393_pw_gy1dtg=pw_gy1dtg,&_temp393_pw_gy1dtg) : &pw_gy1dtg, _pw_gy1dtga.fixedflag ? (_temp394_pw_gy1dtga=pw_gy1dtga,&_temp394_pw_gy1dtga) : &pw_gy1dtga, _pw_gy1dtgd.fixedflag ? (_temp395_pw_gy1dtgd=pw_gy1dtgd,&_temp395_pw_gy1dtgd) : &pw_gy1dtgd,
                           dtgloggrd.ty_xyz/endview_scaledtg,dtgloggrd.yrt,
                           (0.5 * (FLOAT)(dynTG_yres-1))/(dynTG_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:DynTG map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rdtg  = _a_gy1rdtg.fixedflag ?  ((void)(a_gy1dtg), a_gy1rdtg) : a_gy1dtg;
    a_gy1rdtga  = _a_gy1rdtga.fixedflag ?  ((void)(a_gy1dtga), a_gy1rdtga) : a_gy1dtga;
    a_gy1rdtgb  = _a_gy1rdtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy1rdtgb) : a_gy1dtgb;
    pw_gy1rdtg  = _pw_gy1rdtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy1rdtg) : pw_gy1dtg;
    pw_gy1rdtga  = _pw_gy1rdtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy1rdtga) : pw_gy1dtga;
    pw_gy1rdtgd  = _pw_gy1rdtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy1rdtgd) : pw_gy1dtgd;

    a_gy2dtg  = _a_gy2dtg.fixedflag ?  ((void)(a_gy1dtg), a_gy2dtg) : a_gy1dtg;
    a_gy2dtga  = _a_gy2dtga.fixedflag ?  ((void)(a_gy1dtga), a_gy2dtga) : a_gy1dtga;
    a_gy2dtgb  = _a_gy2dtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy2dtgb) : a_gy1dtgb;
    pw_gy2dtg  = _pw_gy2dtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy2dtg) : pw_gy1dtg;
    pw_gy2dtga  = _pw_gy2dtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy2dtga) : pw_gy1dtga;
    pw_gy2dtgd  = _pw_gy2dtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy2dtgd) : pw_gy1dtgd;

    td0dtg  = _td0dtg.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+rffrequency_length[bd_index]-rfupa))), td0dtg) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+rffrequency_length[bd_index]-rfupa));

    temp_time = IMax(2, pw_gzrf1dtgd + pw_gz1dtga + pw_gz1dtg + pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd);
    temp_time2 = IMax(3, pw_gx1dtga + pw_gx1dtg + pw_gx1dtgd + pw_gxwdtga, pw_gy1dtga + pw_gy1dtg + pw_gy1dtgd,
                      pw_gzkbsdtga + pw_gzkbsdtg + pw_gzkbsdtgd);

    min_dtgte  = _min_dtgte.fixedflag ?          ((void)(RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+pw_gxwdtg/2.0)), min_dtgte) : RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+pw_gxwdtg/2.0); 

    temp_time = IMax(3, pw_gxwdtgd + pw_gxkdtga + pw_gxkdtg + pw_gxkdtgd, pw_gy1rdtga + pw_gy1rdtg + pw_gy1rdtgd,
                     pw_gzkdtga + pw_gzkdtg + pw_gzkdtgd);

    tr_dtg  = _tr_dtg.fixedflag ?                ((void)(RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+psd_grd_wait+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp)), tr_dtg) : RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+psd_grd_wait+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp);

    return SUCCESS;
} /* end DTGcveval */

/*
 *  RGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RGcvinit( void )
{
    return SUCCESS;
}


/*
 *  RGcveval
 *
 *  Type: Public Function
 *
 *  Description:
 *
 */
STATUS
RGcveval( void )
{
    if (PSD_ON == rgfeature_enable) 
    { 
        cvmod( opuser39, RG_CAL_MODE_MEASURED, RG_CAL_MODE_HIGH_FIXED, RG_CAL_MODE_HIGH_FIXED, 
               "Receiver Gain (0:Prescan Measured, 1:Predefined)", 0, "" );

        if ( (PSD_2D == exist(opimode)) &&
             ((PSD_SE == exist(oppseq)) || (PSD_IR == exist(oppseq))) &&
             (exist(opptsize) == 4) &&
             (exist(opslthick) <= 10) ) 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(_opuser39.defval), opuser39) : _opuser39.defval;
            activate_reserved_usercv(39);

            if( existcv(opuser39) && (exist(opuser39) != _opuser39.minval) &&
                (exist(opuser39) != _opuser39.maxval) )
            {
                epic_error(use_ermes, "%s must be 0 or 1", EM_PSD_CV_0_OR_1,
                           EE_ARGS(1), STRING_ARG, "UserCV39");

                return FAILURE;
            }

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)((int)rint(exist(opuser39))), oprgcalmode) : (int)rint(exist(opuser39));
        }
        else 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
            deactivate_reserved_usercv(39);

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
        }
    } 
    else 
    {
        opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
        deactivate_reserved_usercv(39);

        oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
    }

    return SUCCESS;
}   /* end RGcveval() */

/*
 *  PSfilter
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfilter( void )
{
    if (setfilter( &echo1cfl,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfl_fid  = _filter_cfl_fid.fixedflag ?  ((void)(echo1cfl.fslot), filter_cfl_fid) : echo1cfl.fslot;

    if (setfilter( &echo1rcvn,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_rcvn_fid  = _filter_rcvn_fid.fixedflag ?  ((void)(echo1rcvn.fslot), filter_rcvn_fid) : echo1rcvn.fslot;

    if (setfilter(&echo1cfh, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfh_fid  = _filter_cfh_fid.fixedflag ?  ((void)(echo1cfh.fslot), filter_cfh_fid) : echo1cfh.fslot;


    if (setfilter(&echo1mps1_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1mps1  = _filter_echo1mps1.fixedflag ?  ((void)(echo1mps1_filt.fslot), filter_echo1mps1) : echo1mps1_filt.fslot;

    if (setfilter(&echo1ftg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1ftg   = _filter_echo1ftg.fixedflag ?  ((void)(echo1ftg_filt.fslot), filter_echo1ftg) : echo1ftg_filt.fslot; /* 11/24/94 YI */
    filter_echo2ftg  = _filter_echo2ftg.fixedflag ?   ((void)(filter_echo1ftg), filter_echo2ftg) : filter_echo1ftg;

    if (setfilter(&echo1xtg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1xtg   = _filter_echo1xtg.fixedflag ?  ((void)(echo1xtg_filt.fslot), filter_echo1xtg) : echo1xtg_filt.fslot;

    if (setfilter(&echo1as_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1as  = _filter_echo1as.fixedflag ?  ((void)(echo1as_filt.fslot), filter_echo1as) : echo1as_filt.fslot;

    if (setfilter(&echo1rs_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter rs");
        return FAILURE;
    }
    filter_echo1rs  = _filter_echo1rs.fixedflag ?  ((void)(echo1rs_filt.fslot), filter_echo1rs) : echo1rs_filt.fslot;

    if (setfilter(&echo1dtg_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter dtg");
        return FAILURE;
    }
    filter_echo1dtg  = _filter_echo1dtg.fixedflag ?  ((void)(echo1dtg_filt.fslot), filter_echo1dtg) : echo1dtg_filt.fslot;

    return SUCCESS;
}   /* end PSfilter() */


/*
 *  PS1predownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1predownload( void )
{
    /* Set xmtaddAPS1 according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddAPS1 is too big.
       Add in coilatten, too. */
    xmtaddAPS1  = _xmtaddAPS1.fixedflag ?    ((void)(-200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten()), xmtaddAPS1) : -200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten();
    if (xmtaddAPS1 > cfdbmax)
    {
        ps1scale  = _ps1scale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0)), ps1scale) : (float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0);
        xmtaddAPS1  = _xmtaddAPS1.fixedflag ?  ((void)(cfdbmax), xmtaddAPS1) : cfdbmax;
    }
    else
    {
        ps1scale  = _ps1scale.fixedflag ?  ((void)(1.0), ps1scale) : 1.0;
    }
  
    if( (B0_30000 == cffield) && (PSD_XRMW_COIL == cfgcoiltype || PSD_VRMW_COIL == cfgcoiltype) )
    {
        /* MRIhc57081: Limit TG to coil peak B1 on MR750w */
        calcTGLimit(_tgcap.fixedflag ? (_temp396_tgcap=tgcap,&_temp396_tgcap) : &tgcap, _tgwindow.fixedflag ? (_temp397_tgwindow=tgwindow,&_temp397_tgwindow) : &tgwindow, maxB1Seq, txCoilInfo[getTxIndex(coilInfo[0])]);
    }
    else
    {
        /* Otherwise use defaults */
        tgcap  = _tgcap.fixedflag ?  ((void)(_tgcap.defval), tgcap) : _tgcap.defval;
        tgwindow  = _tgwindow.fixedflag ?  ((void)(_tgwindow.defval), tgwindow) : _tgwindow.defval;
    }

    if (setScale(L_APS1, RF_FREE, rfpulse, maxB1[L_APS1], 
                 ps1scale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale ps1");
        return FAILURE;
    }

    ia_rf1mps1  = _ia_rf1mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp))), ia_rf1mps1) : (int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp));
    ia_rf2mps1  = _ia_rf2mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp))), ia_rf2mps1) : (int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp));

    entry_point_table[L_APS1].epxmtadd = (short) rint((double)xmtaddAPS1);
    /* APS1 & MPS1 */
    strcpy(entry_point_table[L_APS1].epname,"aps1");
    entry_point_table[L_APS1].epfilter=(n8)filter_echo1mps1;

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_APS1],
                  L_APS1,
                  (int)RF_FREE,
                  rfpulse,
                  ps1_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ps1");
        return FAILURE;
    }

    {
        double pmfsrf[NUM_POWERMON_PORT];
        double pmfspw[NUM_POWERMON_PORT];
        double pmfsdc[NUM_POWERMON_PORT];

        /* Check for multiple Tx coils. This routine is optimized only
         * for single Tx coil. */ 
        if (1 != getNumTxCoils(coilInfo, opncoils))
        {
            epic_error( use_ermes,
                        "%s does not support more than one transmit coil",
                        EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                        "Prescan");
            return FAILURE;
        }
 
        if( cfpwrmontyp >= PMTYP_UPM ) 
        {
            if( SUCCESS != getActivePowerMonPeakLimits( pmfsrf, pmfspw,
                                                        pmfsdc, (int)cffield))
            {
                epic_error( use_ermes, "Support routine %s failed.",
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                            STRING_ARG, "getActivePowerMonPeakLimits" );
                return FAILURE;
            }
        }
        else
        {
            int i = 0;
            for( i = 0; i < NUM_POWERMON_PORT; ++i )
            {
                pmfsrf[i] = PMFULL;
                pmfspw[i] = PMFULL;
                pmfsdc[i] = PMFULL;
            }
        }

        /* for APS1, set amp values to full scale */
        /* Use the first Tx coil */
        switch(activePowerMonChannel(txCoilInfo[getTxIndex(coilInfo[0])]))
        {
            case PMCH_HEAD:
                entry_point_table[L_APS1].epamph = (n32)pmfsrf[PMCH_HEAD];
                break;
            case PMCH_BODY:
                entry_point_table[L_APS1].epampb = (n32)pmfsrf[PMCH_BODY];
                break;
            case PMCH_SPECTRO:
                entry_point_table[L_APS1].epamps = (n32)pmfsrf[PMCH_SPECTRO];
                break;
        }
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp398_min_seqgrad=min_seqgrad,&_temp398_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqmps1, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* If aps1_mod set to 1 and NOT breast R or L coil, use volRec coil to set TG */
    if ( (getAps1Mod() > 0) && (PSD_OFF == ps1_rxcoil) )
    {
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_APS1], 0);
        }
    }

    /* copy APS1 to MPS1 */
    entry_point_table[L_MPS1] = entry_point_table[L_APS1];

    strcpy(entry_point_table[L_MPS1].epname, "mps1");

    /* This is usually equal to the scan entry point.
       Make sure it is continuous for manual prescan */
    entry_point_table[L_MPS1].eppmtable.pmContinuousUpdate = 1;
    entry_point_table[L_MPS2].eppmtable.pmContinuousUpdate = 1;

    return SUCCESS;
}

/*
 *  CFLpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpredownload( void )
{
    /* Sample time for cfl */
    pitsp1 = echo1cfl.tdaq/echo1cfl.outputs;

    xmtaddCFL  = _xmtaddCFL.fixedflag ?    ((void)(-200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten()), xmtaddCFL) : -200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFL > cfdbmax)
    {
        cflscale  = _cflscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0)), cflscale) : (float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0);
        xmtaddCFL  = _xmtaddCFL.fixedflag ?  ((void)(cfdbmax), xmtaddCFL) : cfdbmax;
    }
    else
    {
        cflscale  = _cflscale.fixedflag ?  ((void)(1.0), cflscale) : 1.0;
    }

    if (setScale(L_CFL, RF_FREE, rfpulse, maxB1[L_CFL], 
                 cflscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfl");
        return FAILURE;
    }

    ia_rf1cfl  = _ia_rf1cfl.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp))), ia_rf1cfl) : (int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp));

    entry_point_table[L_CFL].epxmtadd = (short) rint((double)xmtaddCFL);

    entry_point_table[L_CFL].epprexres = (s16)CFLxres; /* MRIhc54366 */

    strcpy(entry_point_table[L_CFL].epname,"cfl");
    entry_point_table[L_CFL].epfilter=(n8)filter_cfl_fid;
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFL],
                  L_CFL,
                  (int)RF_FREE,
                  rfpulse,
                  cfl_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfl");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp399_min_seqgrad=min_seqgrad,&_temp399_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfl, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  RCVNpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpredownload( void )
{
    entry_point_table[L_RCVN] = entry_point_table[L_MPS2];

    xmtaddRCVN  = _xmtaddRCVN.fixedflag ?  ((void)(xmtaddCFL), xmtaddRCVN) : xmtaddCFL;
    entry_point_table[L_RCVN].epxmtadd = (short) rint((double)xmtaddRCVN);

    strcpy(entry_point_table[L_RCVN].epname,"rcvn");
    
    entry_point_table[L_RCVN].epfilter  = (n8)filter_rcvn_fid;
    entry_point_table[L_RCVN].epprexres = rcvn_xres;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp400_min_seqgrad=min_seqgrad,&_temp400_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqrcvn, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  CFHpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpredownload( void )
{
    /* Sample time for cfh */
    pitsp2 = echo1cfh.tdaq/echo1cfh.outputs;

    xmtaddCFH  = _xmtaddCFH.fixedflag ?    ((void)(-200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten()), xmtaddCFH) : -200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFH > cfdbmax)
    {
        cfhscale  = _cfhscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0)), cfhscale) : (float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0);
        xmtaddCFH  = _xmtaddCFH.fixedflag ?  ((void)(cfdbmax), xmtaddCFH) : cfdbmax;
    }
    else
    {
        cfhscale  = _cfhscale.fixedflag ?  ((void)(1.0), cfhscale) : 1.0;
    }

    if (setScale(L_CFH, RF_FREE, rfpulse, maxB1[L_CFH], 
                 cfhscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfh");
        return FAILURE;
    }

    ia_rf1cfh  = _ia_rf1cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp))), ia_rf1cfh) : (int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp));
    ia_rf2cfh  = _ia_rf2cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp))), ia_rf2cfh) : (int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp));
    if(presscfh_ctrl != PRESSCFH_NONE)
    {
        ia_rf3cfh  = _ia_rf3cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp))), ia_rf3cfh) : (int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp));
        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            ia_rf4cfh  = _ia_rf4cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp))), ia_rf4cfh) : (int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp));
        }
    }

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ia_rfcssatcfh = (int)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp));
    }
#endif
    if (PSD_ON == PSir)
    {
        ia_rf0cfh  = _ia_rf0cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp))), ia_rf0cfh) : (int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp));
    }

    if( (presscfh_ctrl != PRESSCFH_SHIMVOL) && (presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE) )
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES));
    }
    else
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES));
    }

    if( ( (opcoax != 0) && cfh_newmode ) || (presscfh != PRESSCFH_NONE) )
    {
        if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB )
        {
	    cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
        }
        else if(presscfh_ctrl == PRESSCFH_SHIMVOL)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            if((presscfh != presscfh_ctrl) && presscfh_debug)
            {
                printf("\n  presscfh %d changes to presscfh_ctrl %d \n",presscfh, presscfh_ctrl);
                fflush(stdout);
            }
        }
        else if (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            cfh_rf4freq  = _cfh_rf4freq.fixedflag ?          ((void)(GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES)), cfh_rf4freq) : GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES);
        }
        else
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?              
    ((void)((GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES))), cfh_rf2freq) : (GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES));
        /* factor 10 is because rloc/phasoff is in mm */
    }
    }
    else
    {
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground 
        */
        cfh_rf2freq  = _cfh_rf2freq.fixedflag ?  ((void)(0), cfh_rf2freq) : 0;
    }

    entry_point_table[L_CFH].epxmtadd = (short) rint((double)xmtaddCFH);
    strcpy(entry_point_table[L_CFH].epname,"cfh");
    entry_point_table[L_CFH].epfilter=(n8)filter_cfh_fid;
    entry_point_table[L_CFH].epprexres = (s16)CFHxres; /* MRIhc08633 */
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFH],
                  L_CFH,
                  (int)RF_FREE,
                  rfpulse,
                  cfh_tr) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfh");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp401_min_seqgrad=min_seqgrad,&_temp401_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfh, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    switch (getTxCoilType()) /* Only 0.5/0.2T will use. */ /* vmx 07/27/95 YO */
    {
        case TX_COIL_LOCAL:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((10.0/256.0)), cfh_ec_position) : (10.0/256.0);
            break;
        default:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((16.0/256.0)), cfh_ec_position) : (16.0/256.0);
            break;
    }

    return SUCCESS;
}

/*
 *  PSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpredownload( void )
{
    STATUS ps_status;
    INT i;
    INT j;
    INT index, vidx;
    
    /* Check for multiple Tx coils. This routine is optimized only for
     * single Tx coil. */
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "prescan");
        return FAILURE;
    }
    
    /***********************************************************************
     * Generic SECTION
     ***********************************************************************/

    if(PSD_ON == exist(oprtcgate)) {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_ON), phys_record_flag) : PSD_ON; /* flag for rt data recording */
    } else {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_OFF), phys_record_flag) : PSD_OFF;
    }

    /* go through entry point table and set frequency offset based on receiver */
    for( i = 0; i < ENTRY_POINT_MAX; i++ )
    {
        PSfreq_offset[i] = cfreceiveroffsetfreq;
    }

    pw_omegarf0cfh  = _pw_omegarf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_omegarf0cfh) : pw_rf0cfh; /* adiabatic pulse */

    PSslice_ind  = _PSslice_ind.fixedflag ?  ((void)(PSslice_num), PSslice_ind) : PSslice_num;  /* MRIge90312 -- for smart prescan */

    PStloc     = _PStloc.fixedflag ?       ((void)(scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift), PStloc) : scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift;
    PSrloc     = _PSrloc.fixedflag ?       ((void)(scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift), PSrloc) : scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift;
    PSphasoff  = _PSphasoff.fixedflag ?    ((void)(scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift), PSphasoff) : scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift;

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_OFF == local_tg) )
    {
        cvunlock(PStloc_mod);
        cvunlock(PSrloc_mod);
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(getAps1ModPsTloc()), PStloc_mod) : getAps1ModPsTloc();
        PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(getAps1ModPsRloc()), PSrloc_mod) : getAps1ModPsRloc();
        PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(0), PSphasoff_mod) : 0; /* phase offset is not used */
        if(PSD_AXIAL == opplane)  /* To handle table delta */
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            if(2 == opentry)    /* Feet First */
            {
                PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(-PStloc), PStloc_mod) : -PStloc;
            }
        }
    }
    else if(PSD_ON == local_tg)  /* using shim vol to do localized XTG */
    {
        if(oppscvquant > 0)  /* use shim vol */
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(psc_info[0].oppsctloc), PStloc_mod) : psc_info[0].oppsctloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(psc_info[0].oppscrloc), PSrloc_mod) : psc_info[0].oppscrloc;    
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(psc_info[0].oppscphasoff), PSphasoff_mod) : psc_info[0].oppscphasoff;    
        }
        else
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(PSrloc), PSrloc_mod) : PSrloc;
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(PSphasoff), PSphasoff_mod) : PSphasoff;
        }
    }
    else  /* use imaging locs */
    { 
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
        PSrloc_mod  = _PSrloc_mod.fixedflag ?      ((void)(opspf?PSphasoff:PSrloc), PSrloc_mod) : opspf?PSphasoff:PSrloc;    
    }
    /* end aps1_mod changes (GE) */

   /* Create rsp_psc_info table based on psc_info */
    for ( i=0; i < exist(oppscvquant); i ++) {
        rsp_psc_info[i].rsppsctloc = psc_info[i].oppsctloc;
        rsp_psc_info[i].rsppscrloc = psc_info[i].oppscrloc;
        rsp_psc_info[i].rsppscphasoff = psc_info[i].oppscphasoff;

        rsp_psc_info[i].rsppsclenx = psc_info[i].oppsclenx;
        rsp_psc_info[i].rsppscleny = psc_info[i].oppscleny;
        rsp_psc_info[i].rsppsclenz = psc_info[i].oppsclenz; 
    }

    /* Check the rotation matrix for rsp_psc_info */
    for (i=0; i< exist(oppscvquant); i++) {
        for (j=0; j<9; j++) {
            rsp_psc_info[i].rsppscrot[j] = hostToRspRotMat(psc_info[0].oppscrot[j]);
        }
    } 

    /* fill in the prescan rotation array for the prescan slice.
       PSrot is an ipgexport defined in epic.h  */

    /*
     * MRIge43971 BJM: loop over 2D PSrot array to be consistent with other
     *                 rotation matrices and since scalerotmats() expects a 2D
     *                 argument.
     */
    for (index = 0; index < 9; index++)
    {
        PSrot[0][index] = hostToRspRotMat(scan_info[PSslice_num].oprot[index]);
        PSrot_mod[0][index] = hostToRspRotMat(ps1scan_info[0].oprot[index]); 
        rsp_PSrot[0][index] = hostToRspRotMat(cfh_info[0].oprot[index]);


        /* set up rot for CFH */
        for( vidx = 1; vidx < oppscvquant; vidx++ )
        {
            rsp_PSrot[vidx][index] = hostToRspRotMat(cfh_info[vidx].oprot[index]);

        }
    }

    /* Scale Rot matrix for CFH */
    if(scalerotmats(rsp_PSrot, &cfhloggrd, &phygrd, IMax(2,1,exist(oppscvquant)), obl_debug) == FAILURE) /* YMSmr09211  04/26/2006 YI */
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }
    
    /* Scale Rot matrix for CFL */
    if(scalerotmats(PSrot, &loggrd, &phygrd, 1, obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for ps1 & FTG  & XTG */
    if(scalerotmats(PSrot_mod, &ps1loggrd, &phygrd, 1, obl_debug) == FAILURE) 
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    PStrigger  = _PStrigger.fixedflag ?  ((void)(TRIG_LINE), PStrigger) : TRIG_LINE;

    /* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
    pitr = 2000000;	        /* 1st pass prescan TR 	*/
    pichop = 0;		/* No chop		*/

    /* find minimum rfamp te time based on duty cycle */
    min180te  = _min180te.fixedflag ?    
                                 
                                ((void)(RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2), min180te) : RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1predownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1predownload");
        return ps_status;
    }


    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNpredownload");
        return ps_status;
    }

    /* xmtaddRef is used for calculating TG value to be stored in smart prescan DB wrt a
     * reference maxB1 used in TG entry point */
    xmtaddRef = -200*log10(cfmaxb1ref/100.0/maxB1Seq) + getCoilAtten();

    /* HCSDM00184619 : Tools PSD dont inline PSpreDwonload.
     * This should move to a routine which  psdIF can handle. */

    /* Copy coilInfo, volRecCoilInfo, txCoilInfo to target side */
    memcpy(coilInfo_tgt, coilInfo, sizeof(coilInfo));
    memcpy(volRecCoilInfo_tgt, volRecCoilInfo, sizeof(volRecCoilInfo));
    memcpy(txCoilInfo_tgt, txCoilInfo, sizeof(txCoilInfo));
    chksum_rampdir_tgt = chksum_rampdir;
    cframpdir_tgt = cframpdir;

    pidotg = doTG(psd_psctg);  /* set PSC TG control flag */

    return SUCCESS;

}   /* end PSpredownload() */


/*
 *  FTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpredownload( void )
{
    /* Set xmtaddFTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddFTG is too big.
       We are assuming that the pulse shapes used in CFH are the
       same as in scan. */
    xmtaddFTG  = _xmtaddFTG.fixedflag ?    ((void)(-200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten()), xmtaddFTG) : -200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddFTG > cfdbmax)
    {
        ftgscale  = _ftgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0)), ftgscale) : (float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0);
        xmtaddFTG  = _xmtaddFTG.fixedflag ?  ((void)(cfdbmax), xmtaddFTG) : cfdbmax;
    }
    else
    {
        ftgscale  = _ftgscale.fixedflag ?  ((void)(1.0), ftgscale) : 1.0;
    }

    if (setScale(L_FTG,RF_FREE,rfpulse,maxB1[L_FTG],ftgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale ftg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1ftg  = _ia_rf1ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp))), ia_rf1ftg) : (int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp));
    ia_rf2ftg  = _ia_rf2ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp))), ia_rf2ftg) : (int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp));
    ia_rf3ftg  = _ia_rf3ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp))), ia_rf3ftg) : (int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp));
    
    entry_point_table[L_FTG].epxmtadd = (short)rint((double)xmtaddFTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_FTG],
                  L_FTG,
                  (int)RF_FREE,
                  rfpulse,
                  ftgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ftg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddFTG), xmtadd) : xmtaddFTG;

    entry_point_table[L_FTG].epfilter = (n8)filter_echo1ftg; /* 11/24/94 YI */
    entry_point_table[L_FTG].epprexres = 256;
    
    FTGxmtadd  = _FTGxmtadd.fixedflag ?  ((void)(entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd), FTGxmtadd) : entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp402_min_seqgrad=min_seqgrad,&_temp402_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqftg, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* Use volRec coil for FTG */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_FTG], 0);
    } 

    return SUCCESS;
}   /* end FTGpredownload() */


/*
 *  XTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpredownload( void )
{
    {
        float trsarscale = 1.0;
        int xtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&xtg_maxseqsar, RF_FREE, rfpulse, L_XTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar xtg");
            return FAILURE;
        }

        if( isLowSarEnabled() )
        {
            trsarscale = 1.2;   /* HCSDM00381012: adding 20% tr to prevent UPM trip for low SAR */
        }

        if(xtgtr < (int)(xtg_maxseqsar*trsarscale))
        {
            xtgtr  = _xtgtr.fixedflag ?  ((void)(RUP_GRD((int)(xtg_maxseqsar*trsarscale))), xtgtr) : RUP_GRD((int)(xtg_maxseqsar*trsarscale));
        }
    }
    
    /* Set xmtaddXTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddXTG is too big. */
    xmtaddXTG  = _xmtaddXTG.fixedflag ?    ((void)(-200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten()), xmtaddXTG) : -200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten();

    if (xmtaddXTG > cfdbmax)
    {
        xtgscale  = _xtgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0)), xtgscale) : (float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0);
        xmtaddXTG  = _xmtaddXTG.fixedflag ?  ((void)(cfdbmax), xmtaddXTG) : cfdbmax;
    }
    else
    {
        xtgscale  = _xtgscale.fixedflag ?  ((void)(1.0), xtgscale) : 1.0;
    }

    if (setScale(L_XTG,RF_FREE,rfpulse,maxB1[L_XTG],xtgscale) == FAILURE)  
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale xtg");
        return FAILURE;
    }  
    
    /* Set the amplitude scale factors. */
    ia_rf1xtg  = _ia_rf1xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp))), ia_rf1xtg) : (int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp));
    ia_rf2xtg  = _ia_rf2xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp))), ia_rf2xtg) : (int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp));
    ia_rf4xtg  = _ia_rf4xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp))), ia_rf4xtg) : (int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp));
    ia_rf3xtg  = _ia_rf3xtg.fixedflag ?  ((void)(-ia_rf4xtg), ia_rf3xtg) : -ia_rf4xtg;
    a_rf3xtg   = _a_rf3xtg.fixedflag ?  ((void)(-a_rf4xtg), a_rf3xtg) : -a_rf4xtg;
    
    entry_point_table[L_XTG].epxmtadd = (short)rint((double)xmtaddXTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_XTG],
                  L_XTG,
                  (int)RF_FREE,
                  rfpulse,
                  xtgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon xtg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddXTG), xmtadd) : xmtaddXTG;

    entry_point_table[L_XTG].epfilter = (n8)filter_echo1xtg; /* 11/24/94 YI */
    entry_point_table[L_XTG].epprexres = 256;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp403_min_seqgrad=min_seqgrad,&_temp403_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqxtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    if ( (2 == getAps1Mod()) && (PSD_OFF == local_tg) )
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_ON), xtg_volRecCoil) : PSD_ON;
    }
    else
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_OFF), xtg_volRecCoil) : PSD_OFF;
    }

    if(PSD_ON == xtg_volRecCoil)
    {
        /* Use volRec coil for XTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_XTG], 0);
        } 
    }

    return SUCCESS;
}   /* end XTGpredownload() */


/*
 *  ASpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpredownload( void )
{
    FLOAT asscale;
 
    /******************************************************************/
    /* Set xmtaddas according to maximum B1 and rescale for powermon, */
    /* adding additional (audio) scaling if xmtaddas is too big.      */
    /* We are assuming that the pulse shapes used in CFH are the      */
    /* same as in scan.                                               */
    /******************************************************************/

    strcpy(entry_point_table[L_AUTOSHIM].epname, "autoshim");

    xmtaddas  = _xmtaddas.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten()), xmtaddas) : -200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddas > cfdbmax) 
    {
        asscale = (float) pow(10.0, (cfdbmax - xmtaddas)/200.0);
        xmtaddas  = _xmtaddas.fixedflag ?  ((void)(cfdbmax), xmtaddas) : cfdbmax;
    } 
    else
    {
        asscale = 1.0;
    }

    if (setScale(L_AUTOSHIM, RF_FREE, rfpulse, maxB1[L_AUTOSHIM],
                 asscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale autoshim");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1as  = _ia_rf1as.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp))), ia_rf1as) : (int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp));

    entry_point_table[L_AUTOSHIM].epxmtadd=(short)rint((double)xmtaddas);
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_AUTOSHIM],
                  L_AUTOSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_as ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon autoshim");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp404_min_seqgrad=min_seqgrad,&_temp404_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqaushim, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_AUTOSHIM].epfilter = (n8)filter_echo1as;
    entry_point_table[L_AUTOSHIM].epprexres = asxres;
    
    /* Use volRec coil for autoshim */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_AUTOSHIM], 0);
    } 

    pidoshim = doAS(psd_pscshim);  /* set PSC AutoShim control flag */ 

    return SUCCESS;
}   /* end ASpredownload() */

/*
 *  RSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpredownload( void )
{
    FLOAT rsscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    {
        INT rs_maxseqsar = 0;

        if(FAILURE == maxseqsar(&rs_maxseqsar, RF_FREE, rfpulse, L_RFSHIM))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar RF Shim");
            return FAILURE;
        }
        if(tr_rs < rs_maxseqsar)
        {
            tr_rs  = _tr_rs.fixedflag ?  ((void)(RUP_GRD(rs_maxseqsar)), tr_rs) : RUP_GRD(rs_maxseqsar);
        }
    }

    DD_nCh  = _DD_nCh.fixedflag ?  ((void)(DD_channels), DD_nCh) : DD_channels;

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_RFSHIM].epname,  "RFshim");

    xmtaddrs  = _xmtaddrs.fixedflag ?    ((void)(-200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten()), xmtaddrs) : -200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddrs > cfdbmax) 
    {
        rsscale = (float) pow(10.0, (cfdbmax - xmtaddrs)/200.0);
        xmtaddrs  = _xmtaddrs.fixedflag ?  ((void)(cfdbmax), xmtaddrs) : cfdbmax;
    } 
    else
    {
        rsscale = 1.0;
    }

    if (setScale(L_RFSHIM, RF_FREE, rfpulse, maxB1[L_RFSHIM],
                 rsscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale B1Map");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbrs  = _ia_rfbrs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp)), ia_rfbrs) : max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp);
    ia_rfbrs_theta  = _ia_rfbrs_theta.fixedflag ?  ((void)(max_pg_iamp), ia_rfbrs_theta) : max_pg_iamp;
    ia_rf1rs  = _ia_rf1rs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp)), ia_rf1rs) : max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp);

    entry_point_table[L_RFSHIM].epxmtadd=(short)rint((double)xmtaddrs);

    if( powermon( &entry_point_table[L_RFSHIM],
                  L_RFSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_rs ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon DynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp405_min_seqgrad=min_seqgrad,&_temp405_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqrs, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_RFSHIM].epfilter = (n8)filter_echo1rs;
    entry_point_table[L_RFSHIM].epprexres = rfshim_xres;

    /* set up B1 Map slice orientation and location */
    for (j = 0; j < rfshim_slquant; j++)
    {
        if(PSD_ON == rsaxial_flag)
        {
            rsrsp_info[j].rsprloc = 0.0;
            rsrsp_info[j].rspphasoff = 0.0;
            rsrsp_info[j].rsptloc = 0.0;

            if( (strstr(coilInfo[0].coilName,"Breast") != NULL) || (strstr(coilInfo[0].coilName,"breast") != NULL)
                || (strstr(coilInfo[0].coilName,"BREAST") != NULL) || (strstr(coilInfo[0].coilName,"Brst") != NULL)) 
            {
                rsrsp_info[j].rsprloc = -120.0;  /* offset in A/P diresction for breast */
            }
        }
        else
        {
            rsrsp_info[j].rsprloc = scan_info[PSslice_num].oprloc + scan_info[PSslice_num].oprloc_shift;
            rsrsp_info[j].rspphasoff = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            rsrsp_info[j].rsptloc = scan_info[PSslice_num].optloc + scan_info[PSslice_num].optloc_shift;
        }

        for (i = 0; i < 9; i++)
        {
            rsrsprot[j][i] = hostToRspRotMat(rsscan_info[0].oprot[i]); /* use Rxed slice rot */ 
        }
    }

    scalerotmats(rsrsprot, &rsloggrd, &phygrd, rfshim_slquant, obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    rfshim_b1factor  = _rfshim_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs), rfshim_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs; 

    return SUCCESS;
}   /* end RSpredownload() */

/*
 *  DTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpredownload( void )
{
    FLOAT dtgscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    FLOAT *dynTG_loc = NULL;

    {
        INT dtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&dtg_maxseqsar, RF_FREE, rfpulse, L_DYNTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar dynamic tg");
            return FAILURE;
        }
        if(tr_dtg < dtg_maxseqsar)
        {
            tr_dtg  = _tr_dtg.fixedflag ?  ((void)(RUP_GRD(dtg_maxseqsar)), tr_dtg) : RUP_GRD(dtg_maxseqsar);
        }
    }

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_DYNTG].epname,  "DynTG");

    xmtadddtg  = _xmtadddtg.fixedflag ?    ((void)(-200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten()), xmtadddtg) : -200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten();
    if (xmtadddtg > cfdbmax) 
    {
        dtgscale = (float) pow(10.0, (cfdbmax - xmtadddtg)/200.0);
        xmtadddtg  = _xmtadddtg.fixedflag ?  ((void)(cfdbmax), xmtadddtg) : cfdbmax;
    } 
    else
    {
        dtgscale = 1.0;
    }

    if (setScale(L_DYNTG, RF_FREE, rfpulse, maxB1[L_DYNTG],
                 dtgscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale DynTG");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbdtg  = _ia_rfbdtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp)), ia_rfbdtg) : max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp);
    ia_rfbdtg_theta  = _ia_rfbdtg_theta.fixedflag ?  ((void)(max_pg_iamp), ia_rfbdtg_theta) : max_pg_iamp;
    ia_rf1dtg  = _ia_rf1dtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp)), ia_rf1dtg) : max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp);

    entry_point_table[L_DYNTG].epxmtadd=(short)rint((double)xmtadddtg);

    if( powermon( &entry_point_table[L_DYNTG],
                  L_DYNTG,
                  (int)RF_FREE,
                  rfpulse,
                  tr_dtg ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon dynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp406_min_seqgrad=min_seqgrad,&_temp406_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqdtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_DYNTG].epfilter = (n8)filter_echo1dtg;
    entry_point_table[L_DYNTG].epprexres = dynTG_xres;

    dynTG_loc =  (float*)AllocNode(dynTG_slquant*sizeof(float));
    if (NULL == dynTG_loc)
    {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "AllocNode for dynTG_loc" );
        return FAILURE;
    }

    dynTG_sliceloc(dynTG_loc, dynTG_slquant, exist(opslquant), 1);
    /* set up B1 Map slice orientation and location */
    for (j = 0; j < dynTG_slquant; j++)
    {
        int index0, index1;
        index0 = (int)dynTG_loc[j];
        if(index0<0)
        {
            index0=0;
        }
        index1 = index0+1;
        if(index1>=exist(opslquant))
        {
            index1=exist(opslquant)-1;
        }
        dtgrsp_info[j].rsprloc = scan_info[index0].oprloc + scan_info[index0].oprloc_shift;
        dtgrsp_info[j].rspphasoff = scan_info[index0].opphasoff + scan_info[index0].opphasoff_shift;
        dtgrsp_info[j].rsptloc = scan_info[index0].optloc + scan_info[index0].optloc_shift +
                                 (dynTG_loc[j]-(float)index0) *
                                     (scan_info[index1].optloc + scan_info[index1].optloc_shift - scan_info[index0].optloc - scan_info[index0].optloc_shift);

        if (obl_debug)
        {
            printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                   j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
        }

        for (i = 0; i < 9; i++)
        {
            dtgrsprot[j][i] = hostToRspRotMat(scan_info[index0].oprot[i]); /* use Rxed slice rot */ 
        }
    }

    FreeNode(dynTG_loc);

    scalerotmats(dtgrsprot, &dtgloggrd, &phygrd, dynTG_slquant, obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    dynTG_b1factor  = _dynTG_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg), dynTG_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg; 


    return SUCCESS;
}   /* end DTGpredownload() */

/* CoilSwitchGetTR (MRIhc15304)
 * 
 * Description:
 *   This function returns the TR for the coilSwitch SSP sequence based on
 *   the setRcvPortFlag as passed to CoilSwitchSetCoil.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  (O) return: TR in usec
 *  (I) setRcvPortFlag - flag to indicate that setrcvportimm will be
 *        executed when switching coils.  See CoilSwitchSetCoil
 */
int
CoilSwitchGetTR(const int setRcvPortFlag)
{
    int wait_rspimm = 0;
    
    /* When asynchronous RSP function calls are needed, the wait time is
     * extended to accomodate the worst case RSP time */
    if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
    {
        wait_rspimm = csw_wait_sethubindeximm;
    }

    if( setRcvPortFlag )
    {
        wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
    }

    return csw_tr + wait_rspimm;
}

/* doTG 
 *
 * Description:
 *  This function returns the doTG flag 
 *     PSD_CONTROL_PSC_SKIP -1: PSD force to skip TG
 *     APS_CONTROL_PSC       0: follow default smart prescan rules for TG
 *     PSD_CONTROL_PSC_RUN   1: force to run TG entry point for specific applications
 */
int
doTG(int psd_psc_control)
{
    int TG_control = psd_psc_control;
    if( ( exist(opdiffuse)
          || exist(opasl) 
          || (PSD_2D == exist(opimode) && PSD_SE == exist(oppseq) && PSD_OFF == exist(opfast)) 
          || (PSD_3D == exist(opimode) && PSD_SE == exist(oppseq) && exist(opinhance)) /* delta flow */ 
          || (PSD_SPECTRO == exist(opimode))
          || (PSD_OFF != exist(opflair)) || PSD_3PLANE == exist(opplane))
        && ((VALUE_SYSTEM_SVEM != value_system_flag) && (VALUE_SYSTEM_SVDM != value_system_flag))
        && (APS_CONTROL_PSC == TG_control) )
    {
        TG_control = PSD_CONTROL_PSC_RUN;
    }

    if((TG_control != PSD_CONTROL_PSC_SKIP) && (TG_control != PSD_CONTROL_PSC_RUN) && (TG_control != APS_CONTROL_PSC))
    {
        TG_control = APS_CONTROL_PSC;
    }

    return TG_control;
}

/* doAS
 *
 * Description:
 *  This function returns the doAS flag 
 *     PSD_CONTROL_PSC_SKIP    -1: PSD force to skip autoshim 
 *     APS_CONTROL_PSC          0: follows default smart prescan rules for AS 
 *     PSD_CONTROL_PSC_RUN      1: forces to run Autoshim entry point for specific applications
 *     PSD_CONTROL_PSC_SPECIAL  2: forces to run global Autoshim for specific applications (breast DWI) 
 */
int
doAS(int psd_psc_control)
{
    int AS_control = psd_psc_control;
    if( ( PSD_ON == pimrsapsflg
          || PSD_ON == exist(opepi)
          || PSD_ON == exist(opspiral)
          || PSD_SSFP == oppseq
          || PSD_ON == exist(opvrg)
          || exist(opfat) || exist(opfatcl)
          || exist(opspecir) || exist(opwater))
        && (APS_CONTROL_PSC == AS_control) )
    {
        AS_control = PSD_CONTROL_PSC_RUN;
    }  /* Auto Shim is required for MRS, EPI, Spiral, VERSE and fiesta and Chem Sat */

    if((AS_control != PSD_CONTROL_PSC_SKIP) && (AS_control != PSD_CONTROL_PSC_RUN) 
       && (AS_control != APS_CONTROL_PSC) && (AS_control != PSD_CONTROL_PSC_SPECIAL))
    {
        AS_control = APS_CONTROL_PSC;
    }

    return AS_control;
}



#include "InitAdvisories.h"

/*-------------------------------------------------------------------
 * PROCEDURE: InitAdvPnlCVs
 * INPUT: none
 * OUTPUT: none
 * RETURN: none
 * SYNOPSIS: This function sets the advisory panel minimum and maximum values
 *           for advisory panel cvs which are not set in cveval. This gives us
 *           the opportunity to start placing items into the 8.0 EPIC Advisory
 *           Panel popup as desired.
 *
 *           Example:
 *                 if (exist(opssfse)!=PSD_OFF && exist(opnex)!=0.5) {
 *                      avminnex = avmaxnex = 0.5;
 *                      return ADVISORY_FAILURE;
 *                 }
 *           The above will ensure that (Nex 0.5) appears in the popup as a valid choice.
 *
 *---------------------------------------------------------------------*/
void 
InitAdvPnlCVs( void )
{
 avmaxnecho = _opnecho.maxval;
 avmaxte = _opte.maxval;
 avmaxte2 = _opte2.maxval;
 avmaxti = _opti.maxval;
 avmaxtr = _optr.maxval;
 avmaxfov = _opfov.maxval;
 avmaxyres = _opyres.maxval;
 avmaxxres = _opxres.maxval;
 avmaxrbw = _oprbw.maxval; 
 avmaxrbw2 = _oprbw2.maxval;
 avmaxsldelay = _opsldelay.maxval;
 avmaxetl = _opetl.maxval;
 avmaxslicecnt = _opslicecnt.maxval;
 avmaxnshots = _opnshots.maxval;
 avmaxphasefov = _opphasefov.maxval;
 avmaxslthick = _opslthick.maxval;
 avmaxnex = _opnex.maxval;
 avmaxflip = _opflip.maxval;
 avminnecho = _opnecho.minval;
 avminte = _opte.minval;
 avminte2 = _opte2.minval;
 avminti = _opti.minval;
 avmintr = _optr.minval;
 avminfov = _opfov.minval;
 avmaxslquant = _opslquant.maxval;
 avminslquant = _opslquant.minval;
 avminrbw = _oprbw.minval; 
 avminrbw2 = _oprbw2.minval;
 avminsldelay  = _avminsldelay.fixedflag ?  ((void)(_opsldelay.minval), avminsldelay) : _opsldelay.minval;
 avminetl = _opetl.minval;
 avminyres = _opyres.minval;
 avminslicecnt = _opslicecnt.minval;
 avminxres = _opxres.minval;
 avminnshots = _opnshots.minval;
 avminphasefov = _opphasefov.minval;
 avminslthick = _opslthick.minval;
 avminnex = _opnex.minval;
 avminflip = _opflip.minval;
 avminslspace = _opslspace.minval;
 avmaxslspace = _opslspace.maxval;
 avminbspti = _opbspti.minval;
 avmaxbspti = _opbspti.maxval;
 avminvest = _opvest.minval;
 avmaxvest = _opvest.maxval;

 return;
}




/**
 *******************************************************************************************************
 @brief #### Mandatory GE function. Includes predownload.in

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS calcPulseParams(void) {

#include "predownload.in" /* include 'canned' predownload code */

  return SUCCESS;

} /* calcPulseParams() */




/**
 *******************************************************************************************************
 @brief #### Simulate scan locations in simulation (WTools)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS simscan(void) {

#ifndef PSD_HW

  int i, j;
  int num_slice;
  float z_delta;    /* change in z_loc between slices */
  float r_delta;    /* change in r_loc between slices */
  double alpha, beta, gamma; /* rotation angles about x, y, z respectively */

  num_slice = opslquant;

  r_delta = opfov/ num_slice;
  z_delta = opslthick + opslspace;

  ks_scan_info[0].optloc = - 0.5 * z_delta * (num_slice - 1);
  ks_scan_info[0].oprloc = 0;

  for (i = 1; i < 9; i++)
    ks_scan_info[0].oprot[i] = 0.0;

  switch (exist(opplane)) {
  case PSD_AXIAL:
    ks_scan_info[0].oprot[0] = 1.0;
    ks_scan_info[0].oprot[4] = 1.0;
    ks_scan_info[0].oprot[8] = 1.0;
    break;
  case PSD_SAG:
    ks_scan_info[0].oprot[2] = 1.0;
    ks_scan_info[0].oprot[4] = 1.0;
    ks_scan_info[0].oprot[6] = 1.0;
    break;
  case PSD_COR:
    ks_scan_info[0].oprot[2] = 1.0;
    ks_scan_info[0].oprot[6] = 1.0;
    ks_scan_info[0].oprot[7] = 1.0;
    break;
  case PSD_OBL:
    alpha = PI/ 4.0; /* rotation about x (applied first) */
    beta = 0;   /* rotation about y (applied 2nd) */
    gamma = 0;  /* rotation about z (applied 3rd) */
    ks_scan_info[0].oprot[0] = cos(gamma) * cos(beta);
    ks_scan_info[0].oprot[1] = cos(gamma) * sin(beta) * sin(alpha) -
                            sin(gamma) * cos(alpha);
    ks_scan_info[0].oprot[2] = cos(gamma) * sin(beta) * cos(alpha) +
                            sin(gamma) * sin(alpha);
    ks_scan_info[0].oprot[3] = sin(gamma) * cos(beta);
    ks_scan_info[0].oprot[4] = sin(gamma) * sin(beta) * sin(alpha) +
                            cos(gamma) * cos(alpha);
    ks_scan_info[0].oprot[5] = sin(gamma) * sin(beta) * cos(alpha) -
                            cos(gamma) * sin(alpha);
    ks_scan_info[0].oprot[6] = -sin(beta);
    ks_scan_info[0].oprot[7] = cos(beta) * sin(alpha);
    ks_scan_info[0].oprot[8] = cos(beta) * cos(alpha);
    break;
  }

  for (i = 1; i < num_slice; i++) {
    ks_scan_info[i].optloc = ks_scan_info[i - 1].optloc + z_delta;
    ks_scan_info[i].oprloc = i * r_delta;
    for (j = 0; j < 9; j++)
      ks_scan_info[i].oprot[j] = ks_scan_info[0].oprot[j];
  }

#endif /* ifdef SIM */

  return SUCCESS;

} /* simscan() */



/**
 *******************************************************************************************************
 @brief #### Initialize logical and physical gradient specifications

 This function calls inittargets() to get the physical gradient characteristics from the MR-system, 
 followed by a call to obloptimize() (slice angulation dependence) to get the logical gradient 
 specifications for the current slice angulation.

 The ramp times (loggrd.xrt/yrt/zrt) are quite conservative (and longer than the ramptimes for phygrd).
 Preliminary testing indicates that the difference between the loggrd and phygrad structs can be reduced 
 by a factor of two (not very scientific!) as a standard measure.

 For further control over the slewrate, the `srfact` argument is passed to ks_init_slewratecontrol(), 
 which can both slow down and increase the gradient slewrate.

 @param[out] loggrd The global logical gradient specification struct (dependent on slice angulation via
 global SCAN_INFO scan_info[] struct).

 @param[out] phygrd The global physical gradient struct
 @param[in] srfact
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_init_gradspecs(LOG_GRAD *loggrd, PHYS_GRAD *phygrd, float srfact) {
  int initnewgeo = 1;

  /* default gradient specs */
  inittargets(loggrd, phygrd);

  /* optimal loggrd based on current slice angulations */
  if (obloptimize(loggrd, phygrd, scan_info, exist(opslquant),
                  ((obl_method==PSD_OBL_RESTRICT) ? 4 /*oblique plane*/ : opphysplane), exist(opcoax), (int) obl_method,
                  exist(obl_debug), &initnewgeo, cfsrmode) == FAILURE) {
    return ks_error("ks_init_loggrd: obloptimize failed");
  }

  /* obloptimize() ramptimes too conservative, let's cut the difference
     between loggrd.xrt and phygrd.xrt in half */
  loggrd->xrt = (loggrd->xrt - phygrd->xrt)/ 2 + phygrd->xrt;
  loggrd->yrt = (loggrd->yrt - phygrd->yrt)/ 2 + phygrd->yrt;
  loggrd->zrt = (loggrd->zrt - phygrd->zrt)/ 2 + phygrd->zrt;

  /* reduce slewrate if srfact < 1 */
  if (ks_init_slewratecontrol(loggrd, phygrd, srfact) == FAILURE)
    return FAILURE;

  return SUCCESS;

} /* GEReq_init_gradspecs() */




/**
 *******************************************************************************************************
 @brief #### Sets up the menu for parallel imaging (ARC or ASSET) with max/min range

 @param[in] integeraccel Flag to make acceleration menu contain only integer acceleration factors
                          enums: KS_ARCMENU_FRACTACCEL (0), KS_ARCMENU_INTACCEL (1)
 @param[in] maxaccel     Maximum allowed acceleration factor for the sequence
 @retval    STATUS      `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_init_accelUI(int integeraccel, int maxaccel) {

  /* Acceleration menu */
  cfaccel_ph_maxstride = maxaccel;
  cvmax(opaccel_ph_stride, cfaccel_ph_maxstride);
  avminaccel_ph_stride = 1.0;
  avmaxaccel_ph_stride = cfaccel_ph_maxstride;
  piarccoilrestrict = 1; /* disable ARC option for single-channel coil (cf. epic.h) */

  if (KS_3D_SELECTED) { /* PSD_3D or PSD_3DM */
    cfaccel_sl_maxstride = maxaccel;
    cvmax(opaccel_sl_stride, cfaccel_sl_maxstride);
    avminaccel_sl_stride = 1.0;
    avmaxaccel_sl_stride = cfaccel_sl_maxstride;
  }

  if ((oparc || opasset == ASSET_SCAN) && maxaccel > 1) {
    if (integeraccel) {
      piaccel_phnub = 1 + maxaccel;
      piaccel_phval2 = 1.0;
      piaccel_phval3 = 2.0;
      piaccel_phval4 = 3.0;
      piaccel_phval5 = 4.0;
      piaccel_phval6 = 5.0;
      piaccel_phedit = 0; /* don't allow user to type in value */
    } else {
      piaccel_phnub = IMin(2, 6, maxaccel * 2);
      piaccel_phval2 = 1.0;
      piaccel_phval3 = 1.5;
      piaccel_phval4 = 2.0;
      piaccel_phval5 = 2.5;
      piaccel_phval6 = 3.0;
      piaccel_phedit = 1;
    }
    piaccel_ph_stride = 2.0;
    if (KS_3D_SELECTED) {
      if (integeraccel) {
        piaccel_slnub = 1 + maxaccel;
        piaccel_slval2 = 1.0;
        piaccel_slval3 = 2.0;
        piaccel_slval4 = 3.0;
        piaccel_slval5 = 4.0;
        piaccel_slval6 = 5.0;
        piaccel_sledit = 0; /* don't allow user to type in value */
      } else {
        piaccel_slnub = IMin(2, 6, maxaccel * 2);
        piaccel_slval2 = 1.0;
        piaccel_slval3 = 1.5;
        piaccel_slval4 = 2.0;
        piaccel_slval5 = 2.5;
        piaccel_slval6 = 3.0;
        piaccel_sledit = 1;
      }
      piaccel_sl_stride = 1.0;
    } else {
      piaccel_slnub = 0;
    }
  } else {
    piaccel_phnub = 0;
    piaccel_slnub = 0;
    cvoverride(opaccel_ph_stride, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
    cvoverride(opaccel_sl_stride, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
  }

  return SUCCESS;

} /* GEReq_init_accelUI() */





/**
 *******************************************************************************************************
 @brief #### Calculate the number of slices per TR and TR padding time (2D imaging)

 This function calculates the number of slices that can fit in one TR (optr) based on the duration and
 occurences of the sequence modules in the sequence collection (KS_SEQ_COLLECTION) determined by calling
 the sequence sliceloop (wrapper) function.

 As the number of arguments to the sequence's sliceloop is psd-dependent, the function pointer
 `play_loop` must be a wrapper function to the sliceloop function taking standardized input arguments
 `(int) nargs` and `(void **) args`. This sliceloop wrapper function must be on the form:
 `int sliceloop_nargs(int slperpass, int nargs, void **args);`
 returning the duration in [us] to play out `slperpass` number of slices.
 If the sliceloop function does not need any additional input arguments, `nargs = 0`, and `args = NULL`.

 The minimum allowed TR is determined by ks_eval_mintr(), which honors SAR/heating limitations. If
 `opautotr = 1`, `optr` will be updated here, otherwise if `optr` is too short, an error will be returned
 to the operator.

 The calling function can specify the minimum acqs that are allowed, as well as a minimum and maximum TR
 interval. Setting `maxtr = 0` disables the upper TR limit. Setting `requested_minacqs <= 1`, disables
 the min acqs requirement.

 This function should be called at the end of cveval() after all sequence modules have been set up and
 dry-runned on host by calling each sequence module's `****_pg()` function. See also the documentation for
 KS_SEQ_CONTROL and KS_SEQ_COLLECTION.

 @param[out] slperpass Number of slices that can fit within each TR
 @param[out] timetoadd_perTR The total time in[us] that must be distributed manually to one or more
             sequence modules after the call to GEReq_eval_TR() in order to meet the desired TR
 @param[in] requested_minacqs The desired minimum number of acquisitions (passes)
 @param[in] mintr Lowest allowed TR in [us]
 @param[in] maxtr Highest allowed TR in [us]. 0: Disabled
 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] play_loop Function pointer to (the wrapper function to) the sliceloop function of the sequence
 @param[in] nargs Number of extra input arguments to the sliceloop wrapper function.
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's sliceloop function
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_TRrange(int *slperpass, int *timetoadd_perTR, int requested_minacqs, int mintr, int maxtr, KS_SEQ_COLLECTION *seqcollection,
                                 int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {
  STATUS status;
  int numacqs = 0;
  int i;
  int numrfexclocations = (KS_3D_SELECTED) ? exist(opvquant) : exist(opslquant);
  int slicetime;
  int nslices_perTR = KS_NOTSET;
  int nslices_shortest_scantime = KS_NOTSET;
  int lowest_scantime = KS_NOTSET;
  int singleslice_time = KS_NOTSET;
  int requested_maxslices = KS_NOTSET;
  int maxslices_time = KS_NOTSET;

  /* if another function has already performed TR timing calcs, don't do it again */
  if (seqcollection->evaltrdone == TRUE) {
    return SUCCESS;
  }
  
  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  if (mintr < 0 || maxtr < 0) {
    return ks_error("%s: min/max TR cannot be negative", __FUNCTION__);
  } else if ((maxtr > 0) && (maxtr <= mintr)) {
    return ks_error("%s: max TR must be > minTR, or 0 (disabled)", __FUNCTION__);
  }

  /* make sure seqctrl.duration at least equal to seqctrl.min_duration */
  status = ks_eval_seqcollection_durations_atleastminimum(seqcollection);
  if (status != SUCCESS) return FAILURE;

  singleslice_time = ks_eval_mintr(1, seqcollection, ks_gheatfact, play_loop, nargs, args);
  if (singleslice_time <= 0) return FAILURE;

  if ((maxtr > 0) && (maxtr < singleslice_time)) {
    return ks_error("%s: Max TR must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }
  if ((mintr > 0) && (mintr < singleslice_time)) {
    return ks_error("%s: Min TR must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }
    if ((maxtr > 0) && ((maxtr - mintr) < singleslice_time)) {
    return ks_error("%s: The TR interval must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }

  /* #acqs cannot exceed #slices. If sequential scanning, #acqs = #slices */
  if (requested_minacqs < 1) {
    requested_minacqs = 1;
  } else if ((requested_minacqs > numrfexclocations) || (opirmode == TRUE)) {
    requested_minacqs = numrfexclocations;
  }
  requested_maxslices = CEIL_DIV(numrfexclocations, requested_minacqs);
  maxslices_time = ks_eval_mintr(requested_maxslices, seqcollection, ks_gheatfact, play_loop, nargs, args);



  if (opautotr) {  /* AutoTR: User selected pitrval2 = PSD_MINIMUMTR */

    if (maxtr > 0 || mintr > 0) { /* in-range autoTR */

      /* Check which combination that results in the lowest scan time, and max/min # slices in range */
      for (i = 1; i <= numrfexclocations; i++) {
        numacqs = CEIL_DIV(numrfexclocations, i);
        slicetime = ks_eval_mintr(i, seqcollection, ks_gheatfact, play_loop, nargs, args);
        if (slicetime >= mintr && (maxtr == 0 || slicetime <= maxtr) && (numacqs >= requested_minacqs)) {
          if (lowest_scantime == KS_NOTSET) {
            nslices_shortest_scantime = i;
            lowest_scantime = slicetime * numacqs;
          } else if (slicetime * numacqs <= lowest_scantime * 1.01) {
            /* 1.01 to avoid round-off effects of slicetime and to slightly favor fewer acqs and longer TRs
            when the scantime is nearly identical */
            nslices_shortest_scantime = i;
            lowest_scantime = slicetime * numacqs;
          }
        }
      }

      if (lowest_scantime == KS_NOTSET) {
        /* failed to find solution within the interval, the range is probably too high for the set
           of slices.  Need to add padding to reach mintr. This
             is done by setting optr = avmintr = mintr (see also timetoadd_perTR below)*/
        if (maxslices_time < mintr) {
          nslices_perTR = requested_maxslices;
          avmintr = mintr;
        } else {
          return ks_error("%s: Programming error", __FUNCTION__);
        }
      } else {
        nslices_perTR = nslices_shortest_scantime;
        avmintr = ks_eval_mintr(nslices_perTR, seqcollection, ks_gheatfact, play_loop, nargs, args);
      }

    } else { /* minimum TR (using requested_minacqs) */

      nslices_perTR = requested_maxslices;
      avmintr = ks_eval_mintr(nslices_perTR, seqcollection, ks_gheatfact, play_loop, nargs, args);

    }

    avmaxtr = avmintr;
    cvoverride(optr, avmintr, PSD_FIX_ON, PSD_EXIST_ON);

  } else { /* Manual TR */

    avmintr = singleslice_time;
    avmaxtr = _optr.maxval;

    /* how many slices can we MAXIMALLY fit in one TR ? */
    if (opirmode == 1) { /* sequential */
      nslices_perTR = 1;
    } else {
      if (existcv(optr)) {
        if (optr < avmintr)
          return ks_error("%s: Increase the TR to %.1f ms", __FUNCTION__, avmintr/ 1000.0);
        if ((mintr > 0) && (optr < mintr))
          return ks_error("%s: Increase the TR to %.1f ms", __FUNCTION__, mintr/ 1000.0);
        if ((maxtr > 0) && (optr > maxtr))
          return ks_error("%s: Decrease the TR to %.1f ms", __FUNCTION__, maxtr/ 1000.0);
      }      
      nslices_perTR = ks_eval_maxslicespertr(exist(optr), seqcollection, ks_gheatfact, play_loop, nargs, args);
      nslices_perTR = IMax(2, 1, nslices_perTR); /* safeguard against < 1 */
    }

  } /* Auto/Manual TR */


  /* how many acqs (runs) do we need to get all prescribed slices ? */
  numacqs = CEIL_DIV(numrfexclocations, nslices_perTR);

  /* how many slices SHOULD we play out per pass (keeping numrfexclocations and numacqs)?
     This may be less than nslices_perTR depending on divisibility */
  *slperpass = CEIL_DIV(numrfexclocations, numacqs); /* round up */

  /* run once more with the actual number of slices per TR, mostly so that ks_eval_gradrflimits() will set the
  description of `optr` correctly */
  ks_eval_mintr(*slperpass, seqcollection, ks_gheatfact, play_loop, nargs, args);

  /* run before each call to function pointer `play_loop()` (next line) to set all `seqctrl.ninst` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);

  /* Update seqcollection.seqctrl[*].ninst given '*slperpass' number of slices
     time [us] for one sequence playout incl. the SSI time and necessary dead time to
     make up the expected TR. To be used in KS_SEQLENGTH() in pulsegen() */
  *timetoadd_perTR = exist(optr) - play_loop(*slperpass, nargs, args);

  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;

  /* Flag that we have completed this function */
  seqcollection->evaltrdone = TRUE;



  /* Set UI and advisory panel variables */
  avail_image_time = RDN_GRD(exist(optr));
  act_tr = avail_image_time;
  ihtr  = _ihtr.fixedflag ?  ((void)(act_tr), ihtr) : act_tr; /* image header TR */

  avminslquant = 1;
  if (KS_3D_SELECTED == FALSE) {
  avmaxslquant = nslices_perTR; /* UI value ("Max # Slices:") */
  avmaxacqs = numacqs; /* UI value ("# of Acqs:") */
  } else {
    avmaxslquant = 2048;
    avmaxacqs = 1;
  }

  return SUCCESS;

} /* GEReq_eval_TRrange() */




STATUS GEReq_eval_TR(int *slperpass, int *timetoadd_perTR, int requested_minacqs, KS_SEQ_COLLECTION *seqcollection,
                                 int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {
 
  return GEReq_eval_TRrange(slperpass, timetoadd_perTR, requested_minacqs, 0, 0, seqcollection, play_loop, nargs, args);


} /* GEReq_eval_TR() */




/**
 *******************************************************************************************************
 @brief #### Performs RF scaling of all RF pulses in the KS_SEQ_COLLECTION and Prescan
 
 RF scaling is a complicated process across RF pulses in scan (multiple sequence modules) and prescan, 
 where the desired flip angles should be met partly using the maxB1 info for each RF pulse and scale
 it relative to the prescan result. This is done via a combination of scan and prescan attenuation factors 
 (xmtaddScan) in the `entry_point_table[]`, an extra global scaling factor, and change of the (instruction)
 amplitude of each RF pulse.

 This function performs all these tasks using a KS_SEQ_COLLECTION as input. The sequence collection struct
 contains one KS_SEQ_CONTROL struct for each sequence module, which via the field `gradrf.rfptr[]` has
 access to all KS_RF objects in the sequence module. As the `***_pg()` function for each sequence module
 should have been called prior to this function, the number of occurrences of each RF pulse is known.
 Moreover, the rfstat specification for every RF pulse is located in:
 seqcollection->seqctrl[]->gradrf->rfptr[]->rf.rfpulse
 which is used by ks_eval_seqcollection2rfpulse() to rewrite the global `rfpulse[]` struct array required
 by GE's RF scaling functions peakB1() and setScale().

 At the end of this function, the seqcollection mode is locked, preventing accidental addition of new
 sequence modules to the seqcollection using ks_eval_addtoseqcollection(). Moreover, each sequence module
 will have its `rfscalingdone` field set to TRUE to signal to ks_pg_rf() that the RF pulse belonging to 
 that sequence module has indeed been RF scaled properly. This extra safety mechanism makes it difficult
 to use ks_pg_rf() without first passing through this function and have the seqcollection struct set up.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_rfscaling(KS_SEQ_COLLECTION *seqcollection) {
  int i;
  STATUS status;


  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  /* use global rfpulse[] array (that is also featuring in Prescan.e) */
  for (i = 0; i < KS_MAXUNIQUE_RF; i++) {
    rfpulse[i].activity = 0;
  }

  /* Update the global RF pulse array rfpulse[] with the contents of the RF pulses in the sequence modules.
     This also includes resetting all .activity fields to zero for the first KS_MAXUNIQUE_RF elements in rfpulse[] */
  status = ks_eval_seqcollection2rfpulse(rfpulse, seqcollection);
  if (status != SUCCESS) return status;


  /* find the peak B1 for each entry point and the max B1 across all entry points */
#if EPIC_RELEASE >= 24
  status = findMaxB1Seq(&maxB1Seq, maxB1, MAX_ENTRY_POINTS, rfpulse, RF_FREE);
  if (status != SUCCESS) {
    return ks_error("%s: findMaxB1Seq() failed", __FUNCTION__);
  }
#else
  {
    int entry;
    maxB1Seq = 0.0;
    for (entry = 0; entry < MAX_ENTRY_POINTS; entry++) {
      status = peakB1(&maxB1[entry], entry, RF_FREE, rfpulse);
      if (status != SUCCESS) {
        return ks_error("%s: peakB1() failed", __FUNCTION__);
      }
      if (maxB1[entry] > maxB1Seq) {
        maxB1Seq = maxB1[entry];
      }
    } /* for */
  }
#endif

  /* RF: How much do we need to attenuate the RF pulses in scan. */
  double my_xmtaddScan = -200 * log10(maxB1[L_SCAN]/ maxB1Seq) + getCoilAtten();
  if (my_xmtaddScan > cfdbmax) {
    extraScale  = _extraScale.fixedflag ?       ((void)((float)pow(10.0,(cfdbmax-my_xmtaddScan)/200.0)), extraScale) : (float)pow(10.0,(cfdbmax-my_xmtaddScan)/200.0); /* N.B.: 'extraScale' is declared as CV in Prescan.e */
    my_xmtaddScan = cfdbmax;
  } else {
    extraScale  = _extraScale.fixedflag ?  ((void)(1.0), extraScale) : 1.0;
  }

  /* RF: Scale the rfpulse amplitudes */
  status = setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], extraScale);
  if (status != SUCCESS) {
    return ks_error("%s: setScale failed", __FUNCTION__);
  }

  /* fill entry_point_table */
  status = entrytabinit(entry_point_table, (int)ENTRY_POINT_MAX);
  if (status != SUCCESS) {
    return ks_error("%s: entrytabinit() failed", __FUNCTION__);
  }
  strcpy( entry_point_table[L_SCAN].epname, "scan");
  entry_point_table[L_SCAN].epxmtadd = (short)rint( (double) my_xmtaddScan);
  entry_point_table[L_SCAN].epstartrec = rhdab0s;
  entry_point_table[L_SCAN].ependrec = rhdab0e;
  entry_point_table[L_SCAN].epfastrec = 0;
  entry_point_table[L_APS2] = entry_point_table[L_MPS2] = entry_point_table[L_SCAN];
  strcpy(entry_point_table[L_APS2].epname, "aps2");
  strcpy(entry_point_table[L_MPS2].epname, "mps2");

  /* Prescan: Final RF scaling of the Prescan entries, using the maxB1[] and maxB1Seq values computed above */
{ /* Start of code inlined from Prescan.e PSpredownload */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                         PSpredownload                             *
     *                                                                   *
     * Write here the code unique to the Host PSD process. All code to   *
     * be executed in predownload() must be written here.                *
     *********************************************************************/
    if (FAILURE==PSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==FTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==XTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ASpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==RSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==DTGpredownload())
    {
        return FAILURE;
    }

} /* End of code inlined from Prescan.e PSpredownload */


  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;

  /* Flag each sequence module that RF scaling has been done */
  for (i = 0; i < seqcollection->numseq; i++) {
    seqcollection->seqctrlptr[i]->rfscalingdone = TRUE;
  }

  return SUCCESS;

} /* GEReq_eval_rfscaling() */




/**
 *******************************************************************************************************
 @brief #### Checks that sequence modules sum up to TR, honoring SAR/heating limits
 
 This function is called by GEReq_eval_checkTR_SAR() (non-inversion use) and ksinv_eval_checkTR_SAR()
 (inversion use) to check that the sequence modules played out in the slice loop sum up to the specified
 TR (optr) accounting for SAR/heating limits. Moreover, the SAR values are updated in the UI, and the 
 CV ks_sarcheckdone is set to TRUE. This CV is set to FALSE in GEReq_cvinit() and check whether it is
 TRUE in GEReq_predownload() to make sure SAR calculation have been performed before scanning.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] intended_time Usually repetition time (optr) if this function was called from 
            GEReq_eval_checkTR_SAR(), but should correspond to the intended time to play the corresponding
            number of sequence instances now set in seqcollection[]->seqctrl.ninst
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_checkTR_SAR_calcs(KS_SEQ_COLLECTION *seqcollection, int intended_time) {
  KS_SAR sar;
  int duration_withinlimits;
  int nettime;
  STATUS status;

  if (seqcollection->evaltrdone == FALSE) {
    return ks_error("%s: Please call GEReq_eval_TR() before calling this function", __FUNCTION__);
  }

  /* Print out the sequence collection time table. In simulation it appears in the WTools main window */
#ifdef PSD_HW
    FILE *fp = fopen("/usr/g/mrraw/seqcollection.txt", "w");
    ks_print_seqcollection(seqcollection, fp);
    fclose(fp);
#else
    ks_print_seqcollection(seqcollection, stderr);
#endif

  /*
  The duration based on the sequence collection struct, which is the product .nseqinstances and .duration fields in each sequence
  modules, summed over all sequence modules.
  The .nseqinstances field becomes > 0 by the call to: GEReq_eval_TR()->ks_eval_mintr()->play_loop()->ks_scan_playsequence()
  The .duration field is initially set to .min_duration by GEReq_eval_TR()->ks_eval_seqcollection_durations_atleastminimum(), but the
  .duration field of at least one sequence module should have been set larger than its .min_duration based on the amount of
  timetoadd_perTR returned by GEReq_eval_TR()  */
  nettime = ks_eval_seqcollection_gettotalduration(seqcollection);
  if (nettime <= 0) {
    
    return FAILURE;
  }

  /* duration_withinlimits = nettime + grad/RF SAR/heat penalty time */
  duration_withinlimits = ks_eval_gradrflimits(&sar, seqcollection, ks_gheatfact);
  if (duration_withinlimits == KS_NOTSET) {
    return FAILURE;
  }

  /* Make sure the global RF pulse array rfpulse[] is updated with the contents of the RF pulses in the sequence modules.
     This also includes resetting all .activity fields to zero for the first KS_MAXUNIQUE_RF elements in rfpulse[] */
  status = ks_eval_seqcollection2rfpulse(rfpulse, seqcollection);
  if (status != SUCCESS) return status;


  /* report to UI */
  piasar = (float) sar.average;
  picasar = (float) sar.coil;
  pipsar = (float) sar.peak;
#if EPIC_RELEASE >= 24
  pib1rms = (float) sar.b1rms;
#endif

  if (existcv(opslquant) == FALSE) {
    /* if #slices has not been set yet, hold on complaining */
    return SUCCESS;
  }

  if (nettime < duration_withinlimits) {
    return ks_error("%s: Duration of seq. modules (%d) < grad/rf limits (%d)", __FUNCTION__, nettime, duration_withinlimits);
  }
  if (nettime < intended_time) {
    return ks_error("%s: Duration of seq. modules (%d) < %d", __FUNCTION__, nettime, intended_time);
  }

  if (nettime - intended_time > MAX_TR_OVERSHOOT) {
    /* small excess in nettime is expected due to roundups of .duration to nearest 4us, but we cannot accept too much */
    /* return */ ks_error("%s: Duration of seq. modules (%d) %d us too long", __FUNCTION__, nettime, nettime - intended_time);
  }

#if EPIC_RELEASE > 27 || (EPIC_RELEASE == 27 && EPIC_PATCHNUM > 1)
  status = setupPowerMonitor(&entry_point_table[L_SCAN], sar.average);
#else  
  status = setupPowerMonitor(&entry_point_table[L_SCAN], L_SCAN, RF_FREE, rfpulse,
                             nettime, sar.average, sar.coil, sar.peak);
#endif                             
  if (status != SUCCESS) {
    return ks_error("%s: setupPowerMonitor failed", __FUNCTION__);
  }

  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;


  /* Flag that SAR check has been done */
  ks_sarcheckdone = TRUE;

  return SUCCESS;

} /* GEReq_eval_checkTR_SAR_calcs() */




/**
 *******************************************************************************************************
 @brief #### Runs the slice loop and validates TR and SAR/hardware limits

 This function first makes sure that the `.nseqinstances` field for each sequence module in the sequence
 collection corresponds to the number of times played out in the sequence's sliceloop function.

 In simulation (WTools), ks_print_seqcollection() will print out a table of the sequence modules in
 the sequence collection in the WToolsMgd window.

 Finally, GEReq_eval_checkTR_SAR_calcs() is called to check that the TR is correct and within SAR/hardware
 limits.

 N.B.: For inversion sequences, ksinv_eval_checkTR_SAR() is used to do the same thing, with the difference
 that ksinv_scan_sliceloop() is used instead.

 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] nslices Number of slices in TR
 @param[in] play_loop Function pointer to (the wrapper function to) the sliceloop function
 @param[in] nargs Number of extra input arguments to the sliceloop wrapper function.
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                       the sliceloop function
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_checkTR_SAR(KS_SEQ_COLLECTION *seqcollection, int nslices, int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {

  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  /* set all `seqctrl.nseqinstances` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);
  play_loop(nslices, nargs, args); /* => seqctrl.nseqinstances = # times each seq. module has been played out */

  return GEReq_eval_checkTR_SAR_calcs(seqcollection, optr);

} /* GEReq_eval_checkTR_SAR() */




/**
 *******************************************************************************************************
 @brief #### Sets mandatory global GE arrays for data acquisition

 The following global GE arrays are set based on slperpass (arg 1) and global op** variables:
    - `data_acq_order[]`: Critical for scanning
    - `rsp_info[]`: Copied from scan_info[] (the graphically prescibed slices), for conformance. Is a 
       temporally sorted version
       of scan_info[] with integer rotation matrices. Not needed for scanning.
    - `rsptrigger[]`: Set to TRIG_INTERN for now.

    data_acq_order[] is only available on HOST, why this function also copies data_acq_order[] to 
    ks_data_acq_order[], which is an `ipgexport` array accessible on both HOST and TGT. This can be used
    by ks_scan_getsliceloc() to be independent on rsp_info[] during scan.

 The slice plan is stored as a text file ("ks_sliceplan.txt") in the current directory in simulation and in
 /usr/g/mrraw on the MR scanner by calling ks_print_sliceplan().

 @param[in] slice_plan The current slice plan (KS_SLICE_PLAN) set up for the sequence (see ks_calc_sliceplan())
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_store_sliceplan(KS_SLICE_PLAN slice_plan) {
  int i, j, time;

  if (CEIL_DIV(slice_plan.nslices, slice_plan.nslices_per_pass) != slice_plan.npasses) {
    return ks_error("%s: inconsistent slice plan - #acqs", __FUNCTION__);
  }

  if (!KS_3D_SELECTED && slice_plan.nslices != exist(opslquant)) {
    return ks_error("%s: inconsistent slice plan - #slices", __FUNCTION__);
  }

  /* initialize rsp_info, rtsprot and rsptrigger */
  for (i = 0; i < DATA_ACQ_MAX; i++) {
    rsp_info[i].rsptloc = 0;
    rsp_info[i].rsprloc = 0;
    rsp_info[i].rspphasoff = 0;
    rsptrigger[i] = TRIG_INTERN;
    for (j = 0; j < 9; j++)
      rsprot[i][j] = 0;
  }

  /* copy to global data_acq_order, which must be correct for main sequence or scan will not start */
  for (i = 0; i < slice_plan.nslices; i++) {
    data_acq_order[i].slloc = slice_plan.acq_order[i].slloc;
    data_acq_order[i].slpass = slice_plan.acq_order[i].slpass;
    data_acq_order[i].sltime = slice_plan.acq_order[i].sltime;
  } /* for slice locations */

  for (i = slice_plan.nslices; i < SLICE_FACTOR*DATA_ACQ_MAX; i++) {
    data_acq_order[i].slloc = 0;
    data_acq_order[i].slpass = 0;
    data_acq_order[i].sltime = 0;
  } /* for rest of data_acq_order */

  time = 0;
  for (i = 0; i < slice_plan.npasses; ++i) {
    for (j = 0; j < slice_plan.nslices_per_pass; ++j) {
      int slloc = ks_scan_getsliceloc(&slice_plan, i, j);
      if (slloc == KS_NOTSET) {continue;}

      rsp_info[time].rsptloc = scan_info[slloc].optloc;
      rsp_info[time].rsprloc = scan_info[slloc].oprloc;
      rsp_info[time].rspphasoff = scan_info[slloc].opphasoff;

      scale(&scan_info[slloc].oprot, &rsprot[time], 1, &loggrd, &phygrd, 0);

      /* Future: here we could change to a variable to support gating. TRIG_ECG, TRIG_AUX etc */
      rsptrigger[time] = TRIG_INTERN;

      ++time;
    }
  }

  STATUS status = calcChecksumScanInfo(&chksum_scaninfo, scan_info, slice_plan.nslices, psdcrucial_debug);
  if (status != SUCCESS) {
    epic_error(1, "PSD data integrity violation detected in PSD, Please try again or restart the system.",
               EM_PSD_PSDCRUCIAL_DATA_FAILURE, EE_ARGS(1), SYSLOG_ARG);
    return status;
  }

  /* Save acquisition table to disk for debugging */
#ifdef PSD_HW
  FILE *daqfp = fopen("/usr/g/mrraw/ks_sliceplan.txt", "w");
#else
  FILE *daqfp = fopen("./ks_sliceplan.txt", "w");
#endif

  ks_print_sliceplan(slice_plan, daqfp);

  fclose(daqfp);


  /* set GE acqs and slquant1 CVs for look and feel */
  _slquant1.fixedflag = 0;
  _acqs.fixedflag = 0;
  slquant1  = _slquant1.fixedflag ?  ((void)(slice_plan.nslices_per_pass), slquant1) : slice_plan.nslices_per_pass;
  acqs  = _acqs.fixedflag ?  ((void)(slice_plan.npasses), acqs) : slice_plan.npasses;
  /* prescan */
  picalmode = 0;
  pislquant = slquant1;

  return SUCCESS;

}



/**
 *******************************************************************************************************
 @brief #### Sets mandatory global GE arrays for data acquisition (3D imaging)

 The following global GE arrays are set based on slperpass (arg 1) and global op** variables:
    - `data_acq_order[]`: Critical for scanning
    - `rsp_info[]`: Copied from scan_info[] (the graphically prescibed slices), for conformance. Is a 
       temporally sorted version
       of scan_info[] with integer rotation matrices. Not needed for scanning.
    - `rsptrigger[]`: Set to TRIG_INTERN for now.

    data_acq_order[] is only available on HOST, why this function also copies data_acq_order[] to 
    ks_data_acq_order[], which is an `ipgexport` array accessible on both HOST and TGT. This can be used
    by ks_scan_getsliceloc() to be independent on rsp_info[] during scan.

 
 GEReq_predownload_store_sliceplan3D() has different input args compared to the 2D version. Here,
 a temporary slice plan is created based on slices_in_slab and slabs in order to create the proper
 content of data_acq_order[]. Note that it wouldn't have worked to pass ks_slice_plan for 3D. This is because
 we need a ks_slice_plan that is consistent with RF excitations for 2D, 3D, 3DMS in each sequence's 
 looping structure in scan. For 3D, this very ks_slice_plan can then not also create the proper data_acq_order
 array here. This is why we pass in slices_in_slab and slabs instead and create e temp slice plan solely
 for the purpose of data_acq_order.

 @param[in] slices_in_slab Number of slices in a slab
 @param[in] slabs Number slabs
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_store_sliceplan3D(int slices_in_slab, int slabs) {
  KS_SLICE_PLAN slice_plan;

  /* TODO: unclear for 3D MS, inteleaved and sequential */
  ks_calc_sliceplan_interleaved(&slice_plan, slices_in_slab * slabs, slices_in_slab, 1);

  return GEReq_predownload_store_sliceplan(slice_plan);

  }


/**
 *******************************************************************************************************
 @brief #### Assigns a global filter slot for a main sequence

 This function must be called in predownload() after GE's initfilter() function, which resets all filter
 slots for scan and prescan entry points. The initfilter() function is called in GEReq_cvinit().

 Given the FILTER_INFO of the acquisition window for the main pulse sequence (arg 1), this function 
 assigns a new slot number (that matches one of the hardware slots in the data receive chain.

 The `.epfilter` and `.epprexres` of GE's global struct array `entry_point_table[]` is also set.

 @param[in] filt Pointer to FILTER_INFO struct (`.filt` field in KS_READ)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setfilter(FILTER_INFO *filt) {

  setfilter(filt, SCAN);

  entry_point_table[L_SCAN].epfilter = (unsigned char) filt->fslot;
  entry_point_table[L_SCAN].epprexres = filt->outputs;


  /* APS2 & MPS2 */
  entry_point_table[L_APS2] = entry_point_table[L_MPS2] = entry_point_table[L_SCAN];  /* copy scan into APS2 & MPS2 */
  strcpy(entry_point_table[L_APS2].epname, "aps2");
  strcpy(entry_point_table[L_MPS2].epname, "mps2");

  return SUCCESS;

} /* GEReq_predownload_setfilter() */




/**
 *******************************************************************************************************
 @brief #### Generates the vrgf.param file for rampsampling correction

 When the `.rampsampling` field of a KS_READTRAP is set to 1, 1D gridding in the frequency encoding 
 direction is necessary before FFT to obtain an equidistant k-space. 
 GE's product reconstruction uses a file (`vrgf.param`) for this, which is generated by this function.

 See also GEReq_predownload_setrecon_readphase(), which sets VRGF-specific global variables.

 @param[in] readtrap
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_genVRGF(const KS_READTRAP * const readtrap) {
  FILE *fpVRGF;
  float beta = 1.0;
  float alpha = 2.0/ (beta + 1.0);
#ifdef SIM
  fpVRGF = fopen("./vrgf.param", "w");
#else
  fpVRGF = fopen("/usr/g/bin/vrgf.param", "w");
#endif

  /* based on: /ESE.../.../psdsupport/genVRGF.c  */

  /* NOTE: The static file /usr/g/bin/vrgf.param2, i.e. with a trailing "2", containing the following 
     must exist on the system in order for the executable /usr/g/bin/vrgf to generate vrgf.dat from 
     the vrgf.param we are about to write:
     VRGFNORM=   1
     GAIN=     1.0
     VRGFWN=     1
     ALPHA=   0.46
     BETA=     1.0
     VRGFODS=  0.0
     VRGFCC=     0
     VRGFGS=     1
     VRGFSGG=    0
     VRGFBWF= -1.0
  */


  fprintf(fpVRGF, "VRGFIP=    %d\n", readtrap->acq.filt.outputs);
  fprintf(fpVRGF, "VRGFOP=    %d\n", readtrap->res);
  fprintf(fpVRGF, "PERIOD=    %f\n", readtrap->acq.filt.tsp);
  fprintf(fpVRGF, "WAVE_CHOICE=  %d\n", 1);
  fprintf(fpVRGF, "G1=        %d\n", 1);
  fprintf(fpVRGF, "G2=        %f\n", readtrap->grad.amp);
  fprintf(fpVRGF, "G3=        %f\n", (readtrap->grad.plateautime/ 2)/ 1.0e6);
  fprintf(fpVRGF, "G4=        %f\n", readtrap->grad.ramptime/ 1.0e6);
  fprintf(fpVRGF, "G5=        %f\n", alpha);
  fprintf(fpVRGF, "G6=        %f\n", beta);
  fprintf(fpVRGF, "G7=        %f\n", 0.0);
  fprintf(fpVRGF, "G8=        %f\n", readtrap->acq.rbw * 1.0e3);
  fprintf(fpVRGF, "G9=        %f\n", 0.0);

  if (fclose(fpVRGF) != 0) {
    ks_error("Can't close vrgf.param");
  }

  return SUCCESS;

} /* GEReq_predownload_genVRGF() */




/**
 *******************************************************************************************************
 @brief #### Generates the rowflip.param file for KS_EPI

 GE's reconstruction (and data dumping) of EPI data (where every other readout is negative) needs to
 know which k-space lines that have been acquired with a negative gradient to perform a row flip
 on these lines before proceeding with Pfile writing and FFT processing.

 @param[in] epi Pointer to KS_EPI
 @param[in] blipsign KS_EPI_POSBLIPS or KS_EPI_NEGBLIPS
 @param[in] assetflag Flag for ASSET mode or not (0: off, 2: ASSET_SCAN (on))
 @param[in] dorowflip If 0, write just ones to let rowflipping process for Pfiles being executed without actual flipping
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_genrowflip(KS_EPI *epi, int blipsign, int assetflag, int dorowflip) {
  FILE *rowflipfp;
  int i = 0;
  int j = 0;
  int kyview = 0;
  int view1st, viewskip;
  int readsign = 1;
  int rowskip, res;
#ifdef SIM
  rowflipfp = fopen("./rowflip.param", "w");
#else
  rowflipfp = fopen("/usr/g/bin/rowflip.param", "w");
#endif

  fprintf(rowflipfp, "# EPI recon control\n");
  fprintf(rowflipfp, "#\n");
  fprintf(rowflipfp, "# ky line number/flip operation\n");
  fprintf(rowflipfp, "%d %d\n", 0, 1);

  if (assetflag == ASSET_SCAN) {
    rowskip = 1;
    res = epi->blipphaser.res/ epi->blipphaser.R;
  } else {
    rowskip = epi->blipphaser.R;
    res = epi->blipphaser.res;
  }

  for (i = 0; i < epi->etl; i++) {
    for (j = 0; j < rowskip; j++) {
      kyview = i * rowskip + j;
      readsign = (i % 2) ? -1 : 1;
      if (blipsign == KS_EPI_POSBLIPS && (epi->etl % 2 == 0)) {
        readsign *= -1;
      }
      fprintf(rowflipfp, "%d %d\n", kyview + 1, (dorowflip) ? readsign : 1);
    }
  }
  for (kyview = i * rowskip + j; kyview < res; kyview++)
    fprintf(rowflipfp, "%d %d\n", kyview + 1, 1);

  fprintf(rowflipfp, "#\n#\n#intleave 1stview skip gpol bpol gy1f rfpol tf nechoes init_echo_pol\n" );

  for (j = 0; j < rowskip; j++) {
    if (blipsign == KS_EPI_POSBLIPS && (epi->etl % 2 == 0)) {
      view1st = (assetflag == ASSET_SCAN) ? (epi->blipphaser.numlinestoacq - 1) : (epi->blipphaser.linetoacq[(epi->blipphaser.numlinestoacq - 1)] + j);
      viewskip = -rowskip;
    } else {
      view1st = (assetflag == ASSET_SCAN) ? 0 : (epi->blipphaser.linetoacq[0] + j);
      viewskip = rowskip;
    }
    fprintf(rowflipfp, "%d %d %d %d %d %d %d %d %d %d\n", j, view1st + 1, viewskip, 1, blipsign, 0 /* max int dephaser */, 1 /* rfpol*/, 0 /* tf */, epi->etl, 1);
  }

  fprintf(rowflipfp, "# esp (usec)\n");
  fprintf(rowflipfp, "%d \n", epi->read.grad.duration);
  fprintf(rowflipfp, "# tsp (usec)\n");
  fprintf(rowflipfp, "%f \n", epi->read.acq.filt.tsp);
  fprintf(rowflipfp, "# input samples\n");
  fprintf(rowflipfp, "%d \n", epi->read.acq.filt.outputs);
  fprintf(rowflipfp, "# readout amplitude (G/cm)\n");
  fprintf(rowflipfp, "%f \n", epi->read.grad.amp);
  fprintf(rowflipfp, "# Row FT size\n");
  fprintf(rowflipfp, "%d \n", epi->read.res);
  fprintf(rowflipfp, "# rhhnover \n");
  fprintf(rowflipfp, "%d \n", epi->blipphaser.nover);
  fprintf(rowflipfp, "# etl\n");
  fprintf(rowflipfp, "%d \n", epi->etl);
  fprintf(rowflipfp, "# number of interleaves\n");
  fprintf(rowflipfp, "%d \n", epi->blipphaser.R);
  fprintf(rowflipfp, "# low pass filter setting (kHz), or -1 for std. rcvr.\n");
  fprintf(rowflipfp, "%d \n", -1);
  fprintf(rowflipfp, "# total number of images\n");
  fprintf(rowflipfp, "%d \n", opslquant);
  fprintf(rowflipfp, "# end of file");

  fclose(rowflipfp);

  return SUCCESS;

} /* GEReq_predownload_genrowflip() */





/*******************************************************************************************************
 ************************************ Modify rh/ih/pi/op vars for recon           **********************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Writes a kacq_yz.txt.***** file for use with GE's product ARC recon

 If phaser.R > 1, a file is written to disk with phase encoding steps in an ARC accelerated
 scan ("kacq_yz.txt.*****"). This function has been adapted from GE's ARC.e, but supports only 2D
 (i.e. 1D-acceleration)
 
 @param[in]  readtrap Pointer to readout trapezoid. Used to determine k-space peak along kx
 @param[in]  phaser   Pointer to phase encoding object (KS_PHASER) with acceleration
 @param[in]  zphaser   Pointer to z phase encoding object (KS_PHASER) with acceleration. NULL for 2D
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_writekacq(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser) {

  FILE *fp;
  CHAR kacqFilename[BUFSIZ];
  int view;
  int arc_kx_peak_pos = 0; /* sample point units */
  int arc_ky_peak_pos = -1;
  const CHAR kacqArcFilename[BUFSIZ] = "kacq_yz.txt";
  int num_echoes = 1; /* we don't understand what a value > 1 would mean. cf. ARC.e */
  int echo_index, slice;
  int numzencodes = (zphaser != NULL) ? zphaser->numlinestoacq : 1;

#ifdef PSD_HW
  const CHAR kacqPath[BUFSIZ] = "/usr/g/psddata/";
  const CHAR kacqRawPath[BUFSIZ] = "/usr/g/mrraw/";
  sprintf(kacqFilename, "%s%s.%d", kacqPath, kacqArcFilename, rhkacq_uid);
#else
  const CHAR kacqPath[BUFSIZ] = "./";
  const CHAR kacqRawPath[BUFSIZ] = "./";
  sprintf(kacqFilename, "%s%s", kacqPath, kacqArcFilename);
#endif

  fp = fopen(kacqFilename, "w");

  /* position of k-space center in sample points along kx
     time2center - acqdelay is the time in [us] from start of acq window to the center of k-space
     acq.filt.tsp is the time in [us] for one sample point (with or without ramp sampling */
  arc_kx_peak_pos = (readtrap->time2center - readtrap->acqdelay)/ readtrap->acq.filt.tsp;

  /* disabled flag ? */
  arc_ky_peak_pos = -1;

  /* kacq header */
  fprintf(fp, "GE_KTACQ\t201\t0\n");
  fprintf(fp, "num_sampling_patterns\t%d\n", num_echoes);
  fprintf(fp, "num_mask_patterns\t%d\n", 0);
  fprintf(fp, "kx_peak_pos\t%d\n", arc_kx_peak_pos);
  /* fprintf(fp, "ky_peak_pos\t%d\n", arc_ky_peak_pos); */
  fprintf(fp, "---\n");

  /* Reconstruction schedule */
  fprintf(fp, "# Reconstruction schedule\n");
  fprintf(fp, "# t, Echo, Cal Table, Cal Pass, Accel Table, Accel Pass, Mask Table\n");
  fprintf(fp, "RECON_SCHEDULE\t%d\t%d\n", num_echoes, 7);
  fprintf(fp, "---\n");
  for (echo_index = 0; echo_index < num_echoes; echo_index++) {
    fprintf(fp,"%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 0, echo_index, -1, 0, echo_index, 0, -1);
  }

  /* Accelerated sampling pattern */
for (echo_index = 0; echo_index < num_echoes; echo_index++) {

  fprintf(fp, "# Sampling Pattern 0 (Accel)\n");
  fprintf(fp, "# View Offset, Pass Offset, ky, kz\n");

    fprintf(fp, "SAMPLING_PATTERN\t%d\t%d\n", phaser->numlinestoacq * numzencodes, 4);
    fprintf(fp, "max_stride\t%d\t%d\n", phaser->R, (zphaser != NULL) ? zphaser->R : 1);
  int dimy;
  if (phaser->nover != 0)
    dimy = phaser->res/ 2 + abs(phaser->nover); /* half nex */
  else
    dimy = phaser->res;
    fprintf(fp, "pattern_dimensions\t%d\t%d\n", dimy, (zphaser != NULL) ? exist(opslquant) : 1);
  fprintf(fp, "---\n");
    for (slice = 0; slice < numzencodes; slice++) {
  for (view = 0; view < phaser->numlinestoacq; view++) {
        if (zphaser != NULL)
          fprintf(fp, "%d\t%d\t%d\t%d\n", phaser->linetoacq[view] + 1 + (zphaser->linetoacq[view] * num_echoes + echo_index) * rhdayres, 0, phaser->linetoacq[view], zphaser->linetoacq[slice]);
        else
          fprintf(fp, "%d\t%d\t%d\t%d\n", phaser->linetoacq[view] + 1 + echo_index * rhdayres, 0, phaser->linetoacq[view], 0);
  }
    }

  } /* echo */

  fclose(fp);

  /* Automatically copy kacq file to a unique filename in
     /usr/g/mrraw if autolock is on */
  if (autolock == TRUE) {
    /* Copy file by reading to and writing from a buffer */
    CHAR kacqMrrawFilename[BUFSIZ];
    CHAR kacqRawFilename[BUFSIZ];
    FILE *srcFile = NULL;
    FILE *dstFile = NULL;
    size_t elemRead, elemWritten;
    size_t bufSz = 8192;
    char buf[8192];

    sprintf(kacqRawFilename, "%s.%d", kacqArcFilename, rhkacq_uid);
    sprintf(kacqMrrawFilename, "%s%s", kacqRawPath, kacqRawFilename);

    srcFile = fopen(kacqFilename, "rb");
    dstFile = fopen(kacqMrrawFilename, "wb");

    elemRead = bufSz;
    while (elemRead == bufSz) {
      elemRead = fread(buf, sizeof(char), bufSz, srcFile);
      elemWritten = fwrite(buf, sizeof(char), elemRead, dstFile);
    }
    fclose(srcFile);
    fclose(dstFile);

  } /* autolock */

    return SUCCESS;

} /* GEReq_predownload_setrecon_writekacq() */




/**
 *******************************************************************************************************
 @brief #### Sets rh*** variables related to parallel imaging acceleration

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] phaser   Pointer to KS_PHASER (phase)
 @param[in] zphaser   Pointer to KS_PHASER (slice). NULL for 2D
 @param[in] datadestination Value to assign to `rhexecctrl` (c.f. epic.h)
   
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_accel(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser, int datadestination) {
  STATUS status;

  /* make sure we will be able to set all these CVs */
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;

  if (phaser->R <= 1 && (zphaser == NULL || zphaser->R <= 1)) {
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
    rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(1.0), rhassetsl_R) : 1.0;
    return SUCCESS;
  }

  rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* once more, just in case */

  if (datadestination & RHXC_XFER_IM) {
    /* if we are going to use GE recon (RHXC_XFER_IM = 8) */

    if (phaser->nacslines > 0) { /* ARC */

      /* ARC uses full BAM, i.e. stores the acquired lines at their proper locations in k-space with zero lines in between */
      rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
      rhdayres  = _rhdayres.fixedflag ?              ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);

      rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC; /* tell recon we are doing ARC only if we have ACS lines  */
      status = GEReq_predownload_setrecon_writekacq(readtrap, phaser, zphaser);
      if (status != SUCCESS) return status;

    } else { /* ASSET */

      /* ASSET uses compressed BAM, i.e. stores only the acquired lines */
      rhhnover  = _rhhnover.fixedflag ?   ((void)(abs(phaser->nover)/phaser->R), rhhnover) : abs(phaser->nover)/phaser->R;
      rhnframes  = _rhnframes.fixedflag ?            ((void)((phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R)), rhnframes) : (phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R);
      rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;

      rhasset  = _rhasset.fixedflag ?  ((void)(ASSET_SCAN), rhasset) : ASSET_SCAN; /* if we don't have ACS lines, we will need to recon the data using some external calibration */
    }

  } else {

    /* store data as ARC (full BAM) */
    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
    rhdayres  = _rhdayres.fixedflag ?               ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);

    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0; /* we are going to do the reconstruction offline */
  }

  rhasset_R  = _rhasset_R.fixedflag ?   ((void)(1.0/phaser->R), rhasset_R) : 1.0/phaser->R; /* inverse of acceleration factor */
  rhassetsl_R  = _rhassetsl_R.fixedflag ?         ((void)((zphaser!=NULL)?(1.0/zphaser->R):1), rhassetsl_R) : (zphaser!=NULL)?(1.0/zphaser->R):1;

  return SUCCESS;

} /* GEReq_predownload_setrecon_accel() */



void  GEReq_predownload_setrecon_phase(const KS_PHASER * const phaser, const float readfov, const int datadestination) {
  /* make sure we will be able to set all these CVs */
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;

  if (phaser->nover != 0) { /* partial Fourier ky */
    rhnframes  = _rhnframes.fixedflag ?   ((void)(phaser->res/2), rhnframes) : phaser->res/2;
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPFRACTNEX), rhtype) : rhtype|RHTYPFRACTNEX;
  } else {
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->res), rhnframes) : phaser->res;
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
  }

  rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
  rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;


  rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(datadestination), rhexecctrl) : datadestination;
  if (op3dgradwarp && !(rhexecctrl & RHXC_XFER_IM)) {
    /* 3D gradwarp requires at least one of the following bits set:
       #define RHXC_XFER_IM                    0x0008  8 (GE online recon)
       #define RHXC_SAVE_IM                    0x0010  16
    */
    (rhexecctrl) |= RHXC_SAVE_IM; /* parentheses around rhexecctrl prevents EPIC preprocessor to add fixedflag check */
  }

  rhphasescale  = _rhphasescale.fixedflag ?   ((void)(phaser->fov/readfov), rhphasescale) : phaser->fov/readfov;
  if (phaser->R <= 1) {
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
    return;
  }

  rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* once more, just in case */

  if (datadestination & RHXC_XFER_IM) {
    /* if we are going to use GE recon (RHXC_XFER_IM = 8) */
    if (phaser->nacslines > 0) { /* ARC */
      /* ARC uses full BAM, i.e. stores the acquired lines at their proper locations in k-space with zero lines in between */
      rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
      rhdayres  = _rhdayres.fixedflag ?              ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);
      rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC; /* tell recon we are doing ARC only if we have ACS lines  */
    } else { /* ASSET */
      /* ASSET uses compressed BAM, i.e. stores only the acquired lines */
      rhhnover  = _rhhnover.fixedflag ?   ((void)(abs(phaser->nover)/phaser->R), rhhnover) : abs(phaser->nover)/phaser->R;
      rhnframes  = _rhnframes.fixedflag ?            ((void)((phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R)), rhnframes) : (phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R);
      rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;
      rhasset  = _rhasset.fixedflag ?  ((void)(ASSET_SCAN), rhasset) : ASSET_SCAN; /* if we don't have ACS lines, we will need to recon the data using some external calibration */
    }
  } else {
    /* store data as ARC (full BAM) */
    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
    rhdayres  = _rhdayres.fixedflag ?               ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0; /* we are going to do the reconstruction offline */
  }

  rhasset_R  = _rhasset_R.fixedflag ?   ((void)(1.0/phaser->R), rhasset_R) : 1.0/phaser->R; /* inverse of acceleration factor */
} /* GEReq_predownload_setrecon_phase() */



void GEReq_predownload_setrecon_readwave(const KS_READWAVE* const readwave, const int yres, int imsize_policy, int datadestination) {
  int max_xy;

  /* make sure we will be able to set all these CVs */
  _rhfrsize.fixedflag = FALSE;
  _rhdaxres.fixedflag = FALSE;
  _rhvrgf.fixedflag = FALSE;
  _rhvrgfxres.fixedflag = FALSE;

  /* raw data freq (x) size (works for both non-VRGF and VRGF) */
  rhfrsize  = _rhfrsize.fixedflag ?  ((void)(readwave->acq.filt.outputs), rhfrsize) : readwave->acq.filt.outputs;
  rhdaxres  = _rhdaxres.fixedflag ?  ((void)(readwave->acq.filt.outputs), rhdaxres) : readwave->acq.filt.outputs;

  /* ramp sampling */
  rhvrgf  = _rhvrgf.fixedflag ?  ((void)(readwave->rampsampling), rhvrgf) : readwave->rampsampling;
  rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(readwave->res), rhvrgfxres) : readwave->res;

  piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0; /* 1 causes scan to spawn the vrgf process upon download */
  rhtype1  = _rhtype1.fixedflag ?    ((void)(~(RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1&~(RHTYP1FVRGF+RHTYP1PCORVRGF);
  rhuser32  = _rhuser32.fixedflag ?  ((void)(0.0), rhuser32) : 0.0;
  rhuser33  = _rhuser33.fixedflag ?  ((void)(0.0), rhuser33) : 0.0;
  rhuser34  = _rhuser34.fixedflag ?  ((void)(0.0), rhuser34) : 0.0;
  rhuser35  = _rhuser35.fixedflag ?  ((void)(0.0), rhuser35) : 0.0;
  
  /* image size */
  max_xy = IMax(2, readwave->res, yres);

  rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1; /* enable reduced image size, so we are in control */
  if (imsize_policy == KS_IMSIZE_MIN256) {
    max_xy = (max_xy > 256) ? 512 : 256; /* final image size is either 512 or 256 */
  } else if (imsize_policy == KS_IMSIZE_POW2) {
    max_xy = ks_calc_nextpow2((unsigned int) max_xy); /* round up to nearest power of 2 if imsize_policy = KS_IMSIZE_POW2 */
  }

  /* recon image size with optional zerofilling */
  if (opzip512 && max_xy < 512) {
    max_xy = 512;
  } else if (opzip1024 && max_xy < 1024) {
    max_xy = 1024;
  }
  rhimsize  = _rhimsize.fixedflag ?  ((void)(max_xy), rhimsize) : max_xy;
  rhrcxres  = _rhrcxres.fixedflag ?  ((void)(rhimsize), rhrcxres) : rhimsize;
  rhrcyres  = _rhrcyres.fixedflag ?  ((void)(rhimsize), rhrcyres) : rhimsize;

  /* freq. partial Fourier */
  if (abs(readwave->nover) > 0) {
    /* fractional echo (partial Fourier kx) */
    pitfeextra = rhfrsize * abs(readwave->nover)/ (float)(readwave->res/2 + abs(readwave->nover));
  } else {
    pitfeextra = 0;
  }
  rhfeextra  = _rhfeextra.fixedflag ?  ((void)(pitfeextra), rhfeextra) : pitfeextra;
  rhheover  = _rhheover.fixedflag ?  ((void)(readwave->nover), rhheover) : readwave->nover;

  /* chopping control */
  rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPCHP), rhtype) : rhtype|RHTYPCHP; /* ( |= 1) no chopping processing needed in recon */

  /* 3D recon flag */
  if(opimode == PSD_3D || opimode == PSD_3DM)
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYP3D), rhtype) : rhtype|RHTYP3D;
  else
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYP3D), rhtype) : rhtype&~RHTYP3D;



} /* GEReq_predownload_setrecon_readwave() */


/**
 *******************************************************************************************************
 @brief #### Sets required global rh*** variables for Cartsian imaging

 For Cartesian pulse sequences, using one KS_READTRAP and one KS_PHASER (each of which may have multiple
 instances), the required rh*** variables are set based on the content of the sequence objects 
 KS_READTRAP (arg 1) and KS_PHASER (arg 2). The fields in each sequence object, including e.g. partial 
 Fourier and rampsampling, controls the setting of GE's rh*** variables. In addition, the third argument
 specifies the desired upsampling policy for small matrix sizes.

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] phaser Pointer to KS_PHASER
 @param[in] zphaser Pointer to KS_PHASER (slice). NULL for 2D
 @param[in] imsize_policy Choose between `KS_IMSIZE_NATIVE`, `KS_IMSIZE_POW2`, `KS_IMSIZE_MIN256`
 @param[in] datadestination Value for the rhexecctrl variable. Bitmasks for: KS_SAVEPFILES (dump Pfiles) and KS_GERECON (product recon)
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_readphase(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser, int imsize_policy, int datadestination) {
  int max_xy;

  /* make sure we will be able to set all these CVs */
  _rhfrsize.fixedflag = FALSE;
  _rhdaxres.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhvrgf.fixedflag = FALSE;
  _rhvrgfxres.fixedflag = FALSE;
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;

  /* raw data freq (x) size (works for both non-VRGF and VRGF) */
  rhfrsize  = _rhfrsize.fixedflag ?  ((void)(readtrap->acq.filt.outputs), rhfrsize) : readtrap->acq.filt.outputs;
  rhdaxres  = _rhdaxres.fixedflag ?  ((void)(readtrap->acq.filt.outputs), rhdaxres) : readtrap->acq.filt.outputs;

  /* ramp sampling */
  rhvrgf  = _rhvrgf.fixedflag ?  ((void)(readtrap->rampsampling), rhvrgf) : readtrap->rampsampling;
  rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(readtrap->res), rhvrgfxres) : readtrap->res;

  if (readtrap->rampsampling) {
    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(1), piforkvrgf) : 1; /* 1 causes scan to spawn the vrgf process upon download */
    rhtype1  = _rhtype1.fixedflag ?    ((void)((RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1|(RHTYP1FVRGF+RHTYP1PCORVRGF); /* VRGF and VRGFafterPC */

    /* write vrgf.param */
    GEReq_predownload_genVRGF(readtrap);

    /* VRGF (rampsampling): Store shape of the read lobe to determine the k-space travel along kx (freq. dir.) for offline VRGF correction */
    rhuser32  = _rhuser32.fixedflag ?  ((void)(readtrap->acq.filt.tsp), rhuser32) : readtrap->acq.filt.tsp; /* time between sample points [often 2us] */
    rhuser33  = _rhuser33.fixedflag ?  ((void)(readtrap->grad.amp), rhuser33) : readtrap->grad.amp; /* Readout gradient amplitude */
    rhuser34  = _rhuser34.fixedflag ?     ((void)((float)(readtrap->grad.plateautime/2)/1.0e6), rhuser34) : (float)(readtrap->grad.plateautime/2)/1.0e6; /* half plateau time */
    rhuser35  = _rhuser35.fixedflag ?    ((void)((float)(readtrap->grad.ramptime)/1.0e6), rhuser35) : (float)(readtrap->grad.ramptime)/1.0e6; /* attack/decay time */
  } else {
    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0; /* 1 causes scan to spawn the vrgf process upon download */
    rhtype1  = _rhtype1.fixedflag ?    ((void)(~(RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1&~(RHTYP1FVRGF+RHTYP1PCORVRGF);
    rhuser32  = _rhuser32.fixedflag ?  ((void)(0.0), rhuser32) : 0.0;
    rhuser33  = _rhuser33.fixedflag ?  ((void)(0.0), rhuser33) : 0.0;
    rhuser34  = _rhuser34.fixedflag ?  ((void)(0.0), rhuser34) : 0.0;
    rhuser35  = _rhuser35.fixedflag ?  ((void)(0.0), rhuser35) : 0.0;
  }


  /* image size */
  if (phaser != NULL) {
    max_xy = IMax(2, readtrap->res, phaser->res);
  } else {
    max_xy = readtrap->res;
  }

  rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1; /* enable reduced image size, so we are in control */
  if (imsize_policy == KS_IMSIZE_MIN256) {
    max_xy = (max_xy > 256) ? 512 : 256; /* final image size is either 512 or 256 */
  } else if (imsize_policy == KS_IMSIZE_POW2) {
    max_xy = ks_calc_nextpow2((unsigned int) max_xy); /* round up to nearest power of 2 if imsize_policy = KS_IMSIZE_POW2 */
  }

  /* recon image size with optional zerofilling */
  if (opzip512 && max_xy < 512) {
    max_xy = 512;
  } else if (opzip1024 && max_xy < 1024) {
    max_xy = 1024;
  }
  rhimsize  = _rhimsize.fixedflag ?  ((void)(max_xy), rhimsize) : max_xy;
  rhrcxres  = _rhrcxres.fixedflag ?  ((void)(rhimsize), rhrcxres) : rhimsize;
  rhrcyres  = _rhrcyres.fixedflag ?  ((void)(rhimsize), rhrcyres) : rhimsize;

  /* freq. partial Fourier */
  if (abs(readtrap->nover) > 0) {
    /* fractional echo (partial Fourier kx) */
    pitfeextra = rhfrsize - readtrap->res/ 2;
  } else {
    pitfeextra = 0;
  }
  rhfeextra  = _rhfeextra.fixedflag ?  ((void)(pitfeextra), rhfeextra) : pitfeextra;

  /* chopping control */
  rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPCHP), rhtype) : rhtype|RHTYPCHP; /* ( |= 1) no chopping processing needed in recon */

  /* 3D recon flag */
  if (KS_3D_SELECTED)
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYP3D), rhtype) : rhtype|RHTYP3D;
  else
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYP3D), rhtype) : rhtype&~RHTYP3D;

  /* phase encoding (see also GEReq_predownload_setrecon_accel(), which may override these values) */
  if (phaser != NULL) {
    if (phaser->nover != 0) { /* partial Fourier ky */
      rhnframes  = _rhnframes.fixedflag ?   ((void)(phaser->res/2), rhnframes) : phaser->res/2;
      rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPFRACTNEX), rhtype) : rhtype|RHTYPFRACTNEX;
    } else {
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->res), rhnframes) : phaser->res;
      rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
    }

    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;

    rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(datadestination), rhexecctrl) : datadestination;
    if (op3dgradwarp && !(rhexecctrl & RHXC_XFER_IM)) {
      /* 3D gradwarp requires at least one of the following bits set:
         #define RHXC_XFER_IM                    0x0008  8 (GE online recon)
         #define RHXC_SAVE_IM                    0x0010  16
      */
      (rhexecctrl) |= RHXC_SAVE_IM; /* parentheses around rhexecctrl prevents EPIC preprocessor to add fixedflag check */
    }

#if EPIC_RELEASE >= 26
    if (datadestination & RHXC_XFER_IM) {
      rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~8192), rhdacqctrl) : rhdacqctrl&~8192; /* enable GE's Orchestra Live recon */
    } else {
      rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(8192), rhdacqctrl) : rhdacqctrl|8192; /* disable GE's Orchestra Live recon */
    }
#endif

    /* Set up ARC/ASSET flags if R > 1 otherwise shut them off */
    GEReq_predownload_setrecon_accel(readtrap, phaser, zphaser, datadestination);

    rhphasescale  = _rhphasescale.fixedflag ?   ((void)(phaser->fov/readtrap->fov), rhphasescale) : phaser->fov/readtrap->fov;

  } /* phaser != NULL */

} /* GEReq_predownload_setrecon_readphase() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation
 
 Uses the global UI CVs `opnecho`, `opnex`, `opte` and `opte2`

 @param[in] tsp Dwell time in [us], i.e. the duration of one sample (which is also 1/rBW)
 @param[in] readdur Duration in [us] of the readout window
 @param[in] time2center Time in [us] to the center of the echo
 @param[in] echogap Gap between two echoes
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations(int tsp, int readdur, int time2center, int echogap) {

  int duration1, duration2;
  int echo_timeoffset2evenecho, echo_timeoffset2oddecho;
  int roundinglimit = 40000;

  /* rBW annotation */
  ihvbw1  = _ihvbw1.fixedflag ?     ((void)(1.0e3/(tsp*2.0)), ihvbw1) : 1.0e3/(tsp*2.0);
  ihvbw2  = _ihvbw2.fixedflag ?  ((void)(ihvbw1), ihvbw2) : ihvbw1;
  ihvbw3  = _ihvbw3.fixedflag ?  ((void)(ihvbw1), ihvbw3) : ihvbw1;
  ihvbw4  = _ihvbw4.fixedflag ?  ((void)(ihvbw1), ihvbw4) : ihvbw1;
  ihvbw5  = _ihvbw5.fixedflag ?  ((void)(ihvbw1), ihvbw5) : ihvbw1;
  ihvbw6  = _ihvbw6.fixedflag ?  ((void)(ihvbw1), ihvbw6) : ihvbw1;
  ihvbw7  = _ihvbw7.fixedflag ?  ((void)(ihvbw1), ihvbw7) : ihvbw1;
  ihvbw8  = _ihvbw8.fixedflag ?  ((void)(ihvbw1), ihvbw8) : ihvbw1;
  ihvbw9  = _ihvbw9.fixedflag ?  ((void)(ihvbw1), ihvbw9) : ihvbw1;
  ihvbw10  = _ihvbw10.fixedflag ?  ((void)(ihvbw1), ihvbw10) : ihvbw1;
  ihvbw11  = _ihvbw11.fixedflag ?  ((void)(ihvbw1), ihvbw11) : ihvbw1;
  ihvbw12  = _ihvbw12.fixedflag ?  ((void)(ihvbw1), ihvbw12) : ihvbw1;
  ihvbw13  = _ihvbw13.fixedflag ?  ((void)(ihvbw1), ihvbw13) : ihvbw1;
  ihvbw14  = _ihvbw14.fixedflag ?  ((void)(ihvbw1), ihvbw14) : ihvbw1;
  ihvbw15  = _ihvbw15.fixedflag ?  ((void)(ihvbw1), ihvbw15) : ihvbw1;
  ihvbw16  = _ihvbw16.fixedflag ?  ((void)(ihvbw1), ihvbw16) : ihvbw1;

  /* NEX annotation */
  ihnex  = _ihnex.fixedflag ?  ((void)(opnex), ihnex) : opnex;

  /* TE */
  ihte1  = _ihte1.fixedflag ?        ((void)((opte>roundinglimit)?ks_calc_roundupms(opte):opte), ihte1) : (opte>roundinglimit)?ks_calc_roundupms(opte):opte;

  duration1 = (readdur - time2center) * 2 + echogap; /* 2x (time from k-space center to edge for 1st echo) + additional echo gap */
  duration2 = time2center * 2 + echogap; /* 2x (time from start to k-space center for 1st echo) + additional echo gap */

  if ((eeff == 1 && oeff == 0) || (eeff == 0 && oeff == 1) || (acq_type == TYPSPIN)) { /* alternating readout gradient polarity across echoes (like often in GRE), or SpinEcho */
    echo_timeoffset2evenecho = duration1; /* between 1 and 2, 3 and 4 etc. */
    echo_timeoffset2oddecho  = duration2; /* between 2 and 3, 4 and 5 etc. */
  } else { /* same readout gradient polarity across echoes */
    /* we have a GRE sequence, and there are likely flyback gradients
       between each readout to allow for the readout gradient polarity to have the same sign for all echoes */
    echo_timeoffset2evenecho = readdur + echogap; /* between 1 and 2, 3 and 4 etc. */
    echo_timeoffset2oddecho  = readdur + echogap; /* between 2 and 3, 4 and 5 etc. */
  }

  if (opnecho == 2) {
    if (pite2nub && existcv(opte2) && opte2 > 0) { /* use opte2 if the button is visible and it was selected */
      ihte2  = _ihte2.fixedflag ?  ((void)(opte2), ihte2) : opte2;
    } else {
      /* partial Fourier note: 2nd readout will have its relative k-space center mirrored */
      ihte2  = _ihte2.fixedflag ?    ((void)(opte+echo_timeoffset2evenecho), ihte2) : opte+echo_timeoffset2evenecho;
    }
  } else if (opnecho > 2) {
    int pos = opte + echo_timeoffset2evenecho;
    ihte2  = _ihte2.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte2) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte3  = _ihte3.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte3) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte4  = _ihte4.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte4) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte5  = _ihte5.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte5) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte6  = _ihte6.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte6) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte7  = _ihte7.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte7) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte8  = _ihte8.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte8) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte9  = _ihte9.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte9) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte10  = _ihte10.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte10) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte11  = _ihte11.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte11) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte12  = _ihte12.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte12) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte13  = _ihte13.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte13) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte14  = _ihte14.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte14) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte15  = _ihte15.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte15) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte16  = _ihte16.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte16) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos;
  }

  /* rhte/rhte2 end up in the raw section of the rawdata header (rdb_hdr_te, rdb_hdr_te2)
     while opte/opte in the image section (te,te2). For opnecho > 2, the te2 field is sometimes 0, why
     we also need to rely on rdb_hdr_te2 for offline reconstruction */
  rhte  = _rhte.fixedflag ?  ((void)(ihte1), rhte) : ihte1;
  rhte2  = _rhte2.fixedflag ?  ((void)(ihte2), rhte2) : ihte2;


  /* Flip Angle */
  ihflip  = _ihflip.fixedflag ?  ((void)(opflip), ihflip) : opflip;

} /* GEReq_predownload_setrecon_annotations() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation based on a KS_READTRAP
 
 This is a wrapper function to GEReq_predownload_setrecon_annotations() using a KS_READTRAP

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] echogap Gap between two echoes
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations_readtrap(KS_READTRAP *readtrap, int echogap) {

  GEReq_predownload_setrecon_annotations(readtrap->acq.filt.tsp, readtrap->grad.duration, readtrap->time2center, echogap);

} /* GEReq_predownload_setrecon_annotations_readtrap() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation based on a KS_EPI
 
 This is a wrapper function to GEReq_predownload_setrecon_annotations() using a KS_EPI

 @param[in] epi Pointer to KS_EPI
 @param[in] echogap Gap between two EPI trains
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations_epi(KS_EPI *epi, int echogap) {
  int maxtime_dephasers = IMax(2, epi->readphaser.duration, epi->blipphaser.grad.duration);
  int maxtime_rephasers = IMax(2, epi->readphaser.duration, epi->blipphaser.grad.duration);
  int halfkspace_duration = ((epi->read.grad.duration + epi->read_spacing) * epi->etl/ 2) - epi->read_spacing/ 2;
  /* time for extra lines beyond half-kspace for partial Fourier in ky */
  int overscan_duration = ((epi->read.grad.duration + epi->read_spacing) * (epi->blipphaser.nover/ epi->blipphaser.R)) - epi->read_spacing/ 2;
  int epiduration, time2center;

  if (opautote == PSD_MINTE) {
    epiduration = (maxtime_dephasers + overscan_duration + halfkspace_duration + maxtime_rephasers);
    time2center = maxtime_dephasers + overscan_duration;
  } else {
    epiduration = (maxtime_dephasers + 2 * halfkspace_duration + maxtime_rephasers);
    time2center = maxtime_dephasers + halfkspace_duration;
  }
  GEReq_predownload_setrecon_annotations(epi->read.acq.filt.tsp, epiduration, time2center, echogap);


} /* GEReq_predownload_setrecon_annotations_epi() */




/**
 *******************************************************************************************************
 @brief #### Sets rh*** variables related to multi-volume imaging

 The combination of rh*** variables allow for 50,000 image planes in GE's database.

 However, Pfile data stops writing after 512 planes. To store more than 512 image planes as rawdata, 
 RDS (Raw Data Server) or multivolume Pfiles can be used instead. It is possible that other mechanisms 
 will be available through GE's upcoming Orchestra Live in the future.

 @param[in] numvols    Number of volumes (`opfphases`)
 @param[in] slice_plan The slice plan (KS_SLICE_PLAN), set up using ks_calc_sliceplan() or similar
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_voldata(int numvols, const KS_SLICE_PLAN slice_plan) {
  int numechoes;

  if (numvols < 1)
    numvols = 1;

  /* GE's CVs for #slices/TR and #passes (acqs) */
  _slquant1.fixedflag = 0;
  _acqs.fixedflag = 0;
  slquant1  = _slquant1.fixedflag ?  ((void)(slice_plan.nslices_per_pass), slquant1) : slice_plan.nslices_per_pass;
  acqs  = _acqs.fixedflag ?  ((void)(slice_plan.npasses), acqs) : slice_plan.npasses;
  /* prescan */
  picalmode = 0;
  pislquant = slquant1;

  /* rhscnframe and rhpasframe are used when scanning in auto-pass mode w/o specific pass-packets (like GEendpass).
  To enable auto-pass mode, set rhtype1 |= RHTYP1AUTOPASS and set these variables to the proper value.
  It is unclear how this would work with partial Fourier and ARC, and has not been tested. */
  rhscnframe  = _rhscnframe.fixedflag ?   /* rhnslices*ceil(opnex)*rhdayres */((void)(0), rhscnframe) : 0;
  rhpasframe  = _rhpasframe.fixedflag ?   /* slquant1*ceil(opnex)*rhdayres */((void)(0), rhpasframe) : 0;
  rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP1AUTOPASS), rhtype1) : rhtype1&~RHTYP1AUTOPASS; /* diable auto-pass. I.e. require the use of pass packets (which is standard anyway) in scan to dump Pfiles */

  /* raw size */
  numechoes = IMax(2, rhnecho, opnecho);
  if (!KS_3D_SELECTED) {
    rhrawsize = slquant1 * numechoes * (2 * rhptsize) * rhdaxres * rhdayres;
  } else {
    rhrawsize = opslquant * numechoes * (2 * rhptsize) * rhdaxres * rhdayres;
  }

  {
    char tmpstr[100];
    sprintf(tmpstr, "rhrawsize = %d bytes/channel (KSFoundation)", (int) rhrawsize);
    cvdesc(rhrawsizeview, tmpstr);
  }

  /* Volumes & total size */
  rhnphases  = _rhnphases.fixedflag ?  ((void)(numvols), rhnphases) : numvols;  /* must be = numvols (not numvols*acqs=#pfiles !!)
         - if 1 when numvols >1:
         Prep Action failed: error please try again. ErrorLog="The integer value for ps_to_rs[0] in the header = 0 "
         - if numvols*acqs when acqs > 1 and numvols == 1:
         Scan failed (after few secs, no images)  */
  rhnpasses  = _rhnpasses.fixedflag ?    ((void)(rhnphases*slice_plan.npasses), rhnpasses) : rhnphases*slice_plan.npasses;  /* must be == # volumes (Pfiles) dumped or system hangs and needs rebooting ! */
  rhreps     = _rhreps.fixedflag ?  ((void)(rhnphases), rhreps) : rhnphases;
  if (!KS_3D_SELECTED) {
    rhnslices  = _rhnslices.fixedflag ?    ((void)(slice_plan.nslices*rhnphases), rhnslices) : slice_plan.nslices*rhnphases;
  } else {
    rhnslices  = _rhnslices.fixedflag ?      ((void)(opslquant*opvquant*rhnphases), rhnslices) : opslquant*opvquant*rhnphases;
  }
  rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase */

  rhtype1  = _rhtype1.fixedflag ?   ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* zerofill BAM for clean Pfiles */
  rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_ZCHOP), rhformat) : rhformat&~RHF_ZCHOP; /* no z chopping by default */
  rhformat  = _rhformat.fixedflag ?  ((void)(RHF_SINGLE_PHASE_INFO), rhformat) : rhformat|RHF_SINGLE_PHASE_INFO;

  /* Gradwarp Mode */
  rhuser47  = _rhuser47.fixedflag ?  ((void)(cfgradcoil), rhuser47) : cfgradcoil;
  
  /* copy useful variables to raw header for recon */
  /* rhuser32-35 are reserved for off-line VRGF correction (Karolinska) */
  rhuser48  = _rhuser48.fixedflag ?  ((void)(pitscan), rhuser48) : pitscan; /* scan time */

} /* GEReq_predownload_setrecon_voldata() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function that set up rh*** variable for a KS_EPI object using other functions

 Calls GEReq_predownload_setrecon_readphase(), GEReq_predownload_setrecon_voldata() and 
 GEReq_predownload_setrecon_annotations_epi(), and GEReq_predownload_genrowflip(). Additionally, 
 some rh*** variables are overridden for EPI.

 @param[in] epi             Pointer to KS_EPI
 @param[in] numvols2store   Number of volumes to store (including calibration vols such as ghostcorr)
 @param[in] slice_plan      The slice plan (KS_SLICE_PLAN) set up using ks_slice_plan() or similar
 @param[in] echogap         Gap between two EPI trains in [us]
 @param[in] blipsign        KS_EPI_POSBLIPS or KS_EPI_NEGBLIPS
 @param[in] datadestination Value passed on to GEReq_predownload_setrecon_readphase() to set rhexecctrl
 @param[in] multishotflag   0: Parallel imaging mode 1: Multishot mode
 @param[in] ghostcorrflag   Integrated refscan (Nyquist ghost correction). 0:Off, 1:On
 @param[in] imsize_policy   Choice between `KS_IMSIZE_NATIVE`, `KS_IMSIZE_POW2`, `KS_IMSIZE_MIN256`
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_epi(KS_EPI *epi, int numvols2store, const KS_SLICE_PLAN slice_plan, int echogap, int blipsign, int datadestination, int multishotflag, int ghostcorrflag, int imsize_policy) {

#if EPIC_RELEASE >= 26  
        if (datadestination & RHXC_XFER_IM) {
          return ks_error("%s: Online recon not supported for KS_EPI data on DV26 or later", __FUNCTION__); 
        }
#endif

  GEReq_predownload_setrecon_readphase(&epi->read, &epi->blipphaser, NULL, imsize_policy, datadestination); /* also sets rhasset when R > 1 */
  GEReq_predownload_setrecon_voldata(numvols2store, slice_plan); /* opfphases = number of volumes */
  GEReq_predownload_setrecon_annotations_epi(epi, echogap);


  /* EPI specific rh* vars  */
  rhileaves  = _rhileaves.fixedflag ?  ((void)(epi->blipphaser.R), rhileaves) : epi->blipphaser.R;
  rhkydir  = _rhkydir.fixedflag ?        ((void)((blipsign==KS_EPI_POSBLIPS)?2:0), rhkydir) : (blipsign==KS_EPI_POSBLIPS)?2:0;
  rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase */

  if (multishotflag > 0) {
    /* .R for multi-shot. Override values set in GEReq_predownload_setrecon_readphase()->GEReq_predownload_setrecon_accel() */
    _rhasset.fixedflag = FALSE;
    _rhasset_R.fixedflag = FALSE;
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
  }

  /* Turn on row-flipping if ETL > 1 */
  if (epi->etl > 1) {
    rhformat  = _rhformat.fixedflag ?  ((void)(RHF_USE_FLIPTABLE), rhformat) : rhformat|RHF_USE_FLIPTABLE;
    if (datadestination & RHXC_XFER_IM) {
      /* Online recon: Single-shot w/ or w/o ASSET */
      GEReq_predownload_genrowflip(epi, blipsign, rhasset, TRUE);
    } else {
      /* Offline recon, say we do rowflip in rhformat, because otherwise GERecon('EPI.ComputeCoefficients') does not
      work (requires RHF_USE_FLIPTABLE to be set).
      But let's not set any negative entries in the file for offline use to avoid rowflipping to actually occur:
      DV26+: This file is ignored for scan archives
      Pre DV26: We don't want the rows to be flipped correctly in the Pfile currently since we don't understand
      why the lines are flipped wrong for mulitshot EPI. We deal with rowflipping ourselves in the recon
      */
      GEReq_predownload_genrowflip(epi, blipsign, rhasset, FALSE);      
    }
  } else {
    rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_USE_FLIPTABLE), rhformat) : rhformat&~RHF_USE_FLIPTABLE;
  }

  /* fermi filter */
  rhfermr  = _rhfermr.fixedflag ?  ((void)(opxres/2), rhfermr) : opxres/2;


  /* override flip control set in GEReq_predownload()->{@inline loadrheader.e rheaderinit} 
  N.B.: ks_scan_epi_loadecho() changes the view indices based on the blipsign argument. Hence, 
  there is no need to inform recon that k-space data should be flipped (as opposed to the product
  epi.e/epi2.e, which use oepf = 1 when pepolar = 1) */
  eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
  eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
  oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
  oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;
  set_echo_flip(_rhdacqctrl.fixedflag ? (_temp407_rhdacqctrl=rhdacqctrl,&_temp407_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff); /* clear bit 1 - flips image in phase dir */

#if EPIC_RELEASE >= 26
    rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(8192), rhdacqctrl) : rhdacqctrl|8192; /* disable Orchestra recon */
#endif

  /* save echo spacing value into rhesp */
  rhesp  = _rhesp.fixedflag ?  ((void)(epi->read.grad.duration), rhesp) : epi->read.grad.duration;



  /* default but see below */
  rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(1), rhpctemporal) : 1;
  rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0;
  rhref  = _rhref.fixedflag ?  ((void)(0), rhref) : 0;
  rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1&~RHTYP1DIFFUSIONEPI;

  /* Nyquist ghost correction using integrated ref scan combined with online recon (RHXC_XFER_IM) requires diffusion mode
     so here we pretend we are doing this */
  if (ghostcorrflag) {

    rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1|RHTYP1DIFFUSIONEPI; 

  #if EPIC_RELEASE < 26
    if (datadestination & RHXC_XFER_IM) {

        if ((multishotflag > 0) && (epi->blipphaser.R > 1)) {
      
          /* GE's online recon cannot do this type of ghost correction for multi-shot */
          return ks_error("%s: GhostCal+OnlineRecon requires single-shot", __FUNCTION__);
      
        } else {

          if (opdiffuse != KS_EPI_DIFFUSION_ON) {
            /* we have a non-diffusion EPI scan (e.g. SE-EPI or GE-EPI) that we want to use with GE's integrated
            refscan (rhref = 5), which only allows single-shot DW-EPI
            DV26 Update: The new Orchestra recon does not accept normal DAB packets, only HyperDAB packets (loadhsdab())
            which is not supported by the use of KS_EPI objects. This means that as of DV26+, GE's online recon cannot be used
            to recon EPI data with KS_EPI (i.e. not ksepi.e) */
            cvoverride(opdiffuse, KS_EPI_DIFFUSION_PRETEND_FOR_RECON, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(optensor, 16, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(rhnumdifdirs, 1, PSD_FIX_ON, PSD_EXIST_ON); /* Prep Action Failed if 0 */
            cvoverride(opdifnumdirs, 0, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opdifnumt2, opfphases, PSD_FIX_ON, PSD_EXIST_ON);
          }                

          rhref  = _rhref.fixedflag ?  ((void)(5), rhref) : 5;/* inform GE's product recon that we want this type of ghost correction */

        } /* Online recon prior to DV26 */
   }
  #endif

  }



  return SUCCESS;

} /* GEReq_predownload_setrecon_epi() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cvinit()

 In the beginning of `cvinit()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cvinit();
 if (status != SUCCESS) return status;
 \endcode

 This function sets up various global GE stuff, including e.g. the gradient specs. The gradient specs
 are controlled by `ks_srfact` and `ks_qfact`. `ks_srfact` Should have a value that will allow scanning on
 all MR systems without PNS effects. Also, `ks_srfact` does not affect the EPI train in ksepi.e, since it
 controls the slewrate and gradient max separately. `ks_qfact` is supposed to be 1 by default, with the 
 purpose to from an optimal setting reduce the slewrate to reduce the acoustic noise. A default value of
 1.0 will make the system perform best but with high acoustic noise. A value of about 8-10 may be a good
 trade-off between acoustic noise reduction and reasonable image quality.

 In this function, `ks_sarcheckdone` is set to FALSE. This CV is checked in GEReq_predownload() and 
 ks_pg_rf(), which both will complain if it is not has been set to TRUE. GEReq_eval_checkTR_SAR_calcs() 
 sets this CV to TRUE.

 It is important that an error returned from GEReq_cvinit() also results in an error in `cvinit()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cvinit(void) {

  /* ART: Acoustic noise reduction
    Imaging option button "Acoustic reduction":
      - PSD_IOPT_MILDNOTE in sequence_iopts[]
      - Sets CV opsilent = TRUE
    When acoustic noise reduction (ART) imaging option is checked, enable the ART tab in the UI too
    by forcing cfnumartlevels = 2
    - "Moderate" radio button on ART tab: CV opsilentlevel = 1
    - "High" radio button on ART tab: CV opsilentlevel = 2
   */
  cvoverride(cfnumartlevels, 2, PSD_FIX_OFF, PSD_EXIST_ON);
  pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels;
  
  if (opsilent) {
    _ks_qfact.existflag = TRUE;
    if (opsilentlevel == 1) {
      /* moderate */
      ks_qfact  = _ks_qfact.fixedflag ?  ((void)(8), ks_qfact) : 8;
    } else {
      /* high */
      ks_qfact  = _ks_qfact.fixedflag ?  ((void)(20), ks_qfact) : 20;
    }
  } else {
    ks_qfact  = _ks_qfact.fixedflag ?  ((void)(1), ks_qfact) : 1;
  }


  {
    { /* Start of code inlined from vmx.e SysParmInit */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            cvdef(opfov, FOV_MAX_VMX);
            cvmax(opfov, FOV_MAX_VMX);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_VMX), opfov) : FOV_MAX_VMX;
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        else
        {
            cvdef(opfov, cfsystemmaxfov);
            cvmax(opfov, cfsystemmaxfov);
            opfov  = _opfov.fixedflag ?  ((void)(cfsystemmaxfov), opfov) : cfsystemmaxfov;

            cvdef(asfov, cfsystemmaxfov);
            cvmax(asfov, cfsystemmaxfov);
            asfov  = _asfov.fixedflag ?  ((void)(cfsystemmaxfov), asfov) : cfsystemmaxfov;
           
            cvdef(tgfov, cfsystemmaxfov);
            cvmax(tgfov, cfsystemmaxfov);
            tgfov  = _tgfov.fixedflag ?  ((void)(cfsystemmaxfov), tgfov) : cfsystemmaxfov;
            
            cvmax(opmonfov, cfsystemmaxfov);
            
            cvmax(rhscanfov, cfsystemmaxfov * FOV_MAX_SCALE);

            cvmax(rhdispfov, cfsystemmaxfov * FOV_MAX_SCALE);
        }
        if(cffield == 2000)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
        }
        if(cffield <= 2000)
        {
            _opcfsel.fixedflag = 0;
            opcfsel  = _opcfsel.fixedflag ?  ((void)(PSD_CFPK), opcfsel) : PSD_CFPK;
            _opcfsel.existflag = 1;
            _opcfsel.fixedflag = 1;
        }
        if(cffield == 2000)
        {
            /* Maximum integrated (B1)^2 per pulse (uT^2sec) */
            txCoilInfo[getTxIndex(coilInfo[0])].maxB1Squared = 8.0; 
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode  = _psddebugcode.fixedflag ?  ((void)(value), psddebugcode) : value;
            }
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE2");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode2  = _psddebugcode2.fixedflag ?  ((void)(value), psddebugcode2) : value;
            }
        }

#ifdef VMX_VERSION_MFO
        debug_scan = (int)((psddebugcode2 & 1/*PSDDEBUG_SCAN*/)!=0);
        debug = (int)((psddebugcode2 & 2/*PSDDEBUG_IPG*/)!=0);
#endif
        debug_grad_spec  = _debug_grad_spec.fixedflag ?    /*PSDDEBUG_GSPEC*/((void)((int)((psddebugcode2&8)!=0)), debug_grad_spec) : (int)((psddebugcode2&8)!=0);
        if(cffield <= 3500)pisupnub = 0;

        switch (cfsrmode)
        {
            case PSD_SR50:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_HDE), value_system_flag) : VALUE_SYSTEM_HDE;
                break;
            case PSD_SR100:
                if(cffield == 15000 && PSD_VRMW_COIL != cfgcoiltype)
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                }
                else
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
                }
                break;
            default:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
        }

        if( VALUE_SYSTEM_HDE == value_system_flag )
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_ON), val15_lock) : PSD_ON;
        }
        else
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }

       /* SVBranch HCSDM00357453 Mild Note */
        if (PSD_OFF == cfnumartlevels)
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_OFF), mild_note_support) : PSD_OFF;
        }
        else
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_ON), mild_note_support) : PSD_ON;
        }
        pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels; /* This parameter will be used by host to manage ART UI */

        if( (VALUE_SYSTEM_HDE == value_system_flag)  ||
            (VALUE_SYSTEM_SVEM == value_system_flag) ||
            (VALUE_SYSTEM_SVDM == value_system_flag) ||
            (VALUE_SYSTEM_SVDMP == value_system_flag) )
        {

            rectfov_npw_support  = _rectfov_npw_support.fixedflag ?  ((void)(PSD_ON), rectfov_npw_support) : PSD_ON;
        }
        else
        {
            rectfov_npw_support  = _rectfov_npw_support.fixedflag ?  ((void)(PSD_OFF), rectfov_npw_support) : PSD_OFF;
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }
        /* Update default values based on the system configuration */
        configSystem();

        /* SVBranch HCSDM00107762 */
        if( (VALUE_SYSTEM_SVEM == value_system_flag)  ||
            (VALUE_SYSTEM_SVDM == value_system_flag) )
        {
             cfcoilswitchmethod   = _cfcoilswitchmethod.fixedflag ?  ((void)(COIL_SWITCH_RSP_SETHUBINDEXIMM), cfcoilswitchmethod) : COIL_SWITCH_RSP_SETHUBINDEXIMM;
        }

        /* Set flags for scan volume shift */
        set_vol_shift_cvs();

    } /* End of code inlined from vmx.e SysParmInit */

  }

  EpicConf();

  /* set gradient limitations (calling GEs obloptimize() & further ramptime modifications) */
  GEReq_init_gradspecs(&loggrd, &phygrd, ks_srfact/ ks_qfact);

  /* resets all filter #. From this point, ok to call setfilter() */
  initfilter();

  /* setsysparams() sets psd_grd_wait and psd_rf_wait for the system */
  setsysparms();
#ifdef SIM
  /* In simulation, we don't want them to confuse the timing in WTools */
  _psd_grd_wait.fixedflag = 0;
  _psd_rf_wait.fixedflag = 0;
  psd_grd_wait  = _psd_grd_wait.fixedflag ?  ((void)(0), psd_grd_wait) : 0;
  psd_rf_wait  = _psd_rf_wait.fixedflag ?  ((void)(0), psd_rf_wait) : 0;
#endif

#include "cvinit.in"  /* Runs the code generated by macros in preproc.*/

  /* GE CVs that could use a wider min/max range: */
  cvmax(rhfrsize, 32768);
  cvmax(rhdaxres, 32768);
  cvmax(opphasefov, 5); /* to allow larger FOV in phase enc dir that freq */
  cvmax(rhnslices, 50000); /* 50,000, which is 5x of RHF_MAX_IMAGES_MULTIPHASE = 10000 */
  cvmax(rhreps, 2048); /* max 2048 vols */
  cvmax(rhnphases, 2048); /* max 2048 vols */
  cvmax(opfphases, 2048); /* max 2048 vols */
  cvmax(opyres, 1024); /* max 1024 yres */
  cvmax(opslthick, 200); /* max 200 mm slice thickness */
  cvmax(optr, 60000000); /* max 60s TR */
  cvmax(ihtr, 60000000);
  cvmax(rhref, 5); /* Allow 1st-volume ghost correction as GE's diffusion EPI (only works for single shot) */
  cvmax(opbval, 30000);
  cvmax(opileave, 1);

  /* activate Advisory panel */
  piadvise = PSD_ON;
  piadvmin  = (1 << PSD_ADVTE); /* TE Advisory on */
  piadvmin |= (1 << PSD_ADVTR);  /* TR Advisory on */
  piadvmin |= (1 << PSD_ADVRCVBW);/* rBW Advisory on */
  piadvmin |= (1 << PSD_ADVFOV);/* FOV Advisory on */
  piadvmax = piadvmin;

  {
    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        if(  (NON_VALUE_SYSTEM != value_system_flag)
          || ((PSD_VRMW_COIL == cfgcoiltype) && (B0_15000 == cffield)) )
        {
            pipscshimtgnub = PSD_OFF;  /* Hide the UI for value or k15 config */
        }
        else
        {
            pipscshimtgnub = PSD_ON;
            if(PSD_SPECTRO == exist(opimode))
            {
                pipscshimtgnub = PSD_OFF;
            }
        }

        local_tg  = _local_tg.fixedflag ?  ((void)(exist(oppscshimtg)), local_tg) : exist(oppscshimtg);

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
        RScvinit();
        DTGcvinit();
    } /* End of code inlined from Prescan.e PScvinit */

  }


  /* KSFoundation indicator variable for completed SAR checks (c.f. GEReq_eval_checkTR_SAR_calcs(), which sets it to TRUE) */
  ks_sarcheckdone = FALSE;

 /* GE's psd_name seems not be available on TGT, to let's copy this one */
#if EPIC_RELEASE > 27 || (EPIC_RELEASE == 27 && EPIC_PATCHNUM > 1)
/* #if EPIC_RELEASE >= 27 */
/* Since RX27R02, GE's psd_name no longer exists */
{
  strcpy(ks_psdname, get_psd_name());
}
#else
  strcpy(ks_psdname, psd_name);
#endif


  return SUCCESS;

} /* GEReq_cvinit() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cveval()

 In the beginning of `cveval()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cveval();
 if (status != SUCCESS) return status;
 \endcode

 This function up various global GE stuff, and copies also the struct array `scan_info`, holding the
 prescribed slice locations to `ks_scan_info`, the latter which can also be accessible on TGT.

 Simulation (WTools): If we have ks_simscan = 1 (default), simscan() will have make up slice locations in
 ks_scan_info based on opslthick, opslspace and opslquant. Note, GE clears scan_info between cvcheck() 
 and predownload() when in simulation. Hence, we now have the opposite case, i.e. we have some slice info
 data in ks_scan_info but nothing in scan_info.

 It is important that an error returned from GEReq_cveval() also results in an error in `cveval()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cveval(void) {

  {
    { /* Start of code inlined from vmx.e SysParmEval */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        if(cffield == 2000)
        {
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            avmaxfov = FOV_MAX_PROFILE;
        }

        if( (exist(opimode) != PSD_3D) && (exist(opimode) != PSD_3DM)
           && (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP)
           && (cffield <= B0_5000) ) 
        {
            if( exist(opslthick) < MINTHICK_VMX )
            { 
                epic_error(use_ermes, "Increase the slice thickness to %.1f",
                           EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, MINTHICK_VMX);
                return FAILURE;
            }
        }

        /* PURE */
        pipure = coilInfo[0].pureCompatible;

        /* PURE Mix */
        strcpy(model_parameters.psd_name, psd_name);
        model_parameters.irmode = exist(opirmode);
        model_parameters.pure_support = pipure;
        model_parameters.cffield = cffield;

        if (FAILURE == getPUREMixCompatibility(model_parameters, coilInfo, exist(opanatomy), &pipure, &pure_mix))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getPUREMixCompatibility");
            return FAILURE;
        }

        if (B0_30000 == cffield)
        {
            if (PURE2 == exist(oppure) && pure_mix.enable)
            {
                cvmod(opuser40, -100.0, 100.0, 0.0, "PURE compensation", 0, "");
                opuser40  = _opuser40.fixedflag ?  ((void)(_opuser40.defval), opuser40) : _opuser40.defval;
                activate_reserved_usercv(40);

                if ((_opuser40.minval > exist(opuser40)) ||
                    (_opuser40.maxval < exist(opuser40)))
                {
                    cvoverride(opuser40, _opuser40.defval, PSD_FIX_ON, PSD_EXIST_ON);
                    epic_error(use_ermes, "%s is out of range.",
                               EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "PURE compensation");
                    return FAILURE;
                }
            }
            else
            {
                cvmod(opuser40, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 40", 0, "");
                cvoverride(opuser40, _opuser40.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                deactivate_reserved_usercv(40);
            }
        }

        if (isDVSystem() && (B0_15000 == cffield) &&
                 (PSD_PURE_COMPATIBLE_1 & pipure) &&
                 (!strncmp("memp_pure", psd_name, 9) || !strncmp("fse_pure", psd_name, 8)))
        {   
            pipure = PSD_PURE_COMPATIBLE_2;
        }   

        if ((PSD_SPECTRO == exist(opimode)) ||
            (PSD_3PLANE == exist(opplane)) ||
            (PSD_ON == exist(opassetcal)) || (PSD_ON == exist(oppurecal)) ||
            ((PSD_ON == exist(oprealtime)) && (PSD_OFF == exist(opfluorotrigger))) ||
	    (PSD_ON == exist(opmultistation)) )
        {
            pipure = 0;
        }

        if( psd_board_type == PSDCERD || psd_board_type == PSDDVMR )
        {
            
            if( cftpssize <= 0 )
            {
                if (VALUE_SYSTEM_HDE == value_system_flag) {
                    cftpssize = 133954560;
                }else {
                    cftpssize = 1670381568.0;
                }
            }
        }

        /* MRIhc41001 - maximum attenuation available for PSD
         * (xmtadd) usage is the hardware maximum minus 200 for
         * TG. (ampCal is unused and coil attenuation is included
         * in xmtadd.
         */
        cfdbmax = IMax(2, 0, cfrfMaxAttenuation - 200);

        /* Dynamic Plan */
        if( (exist(opdynaplan) == PSD_ON) && existcv(opdynaplan) ) {
            if(checkOptionKey( SOK_MPHVAR )){
                epic_error( use_ermes,
                            "%s is not available without the option key.",
                            EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                            STRING_ARG, "Multi-Phase (variable delays)" );
                return FAILURE;
            }
            if( (exist(opfmri) == PSD_ON) && existcv(opfmri) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"fMRI");
                return FAILURE;
            }
            if( (exist(opectricks) == PSD_ON) && existcv(opectricks) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"ECTRICKS");
                return FAILURE;
            }
            if( (exist(opmph) == PSD_ON) && existcv(opmph) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Multi Phase");
                return FAILURE;
            }
            if( (exist(opcgate) == PSD_ON) && existcv(opcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Cardiac Gating");
                return FAILURE;
            }
            if( (exist(oprtcgate) == PSD_ON) && existcv(oprtcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Respiratory Triggering");
                return FAILURE;
            }
            if( (exist(oprealtime) == PSD_ON) && existcv(oprealtime) && (exist(opfluorotrigger) == PSD_OFF) && existcv(opfluorotrigger) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Realtime");
                return FAILURE;
            }
            /* MRIhc08845  08/03/2005 YI */
            if( (exist(opcosmic) == PSD_ON) && existcv(opcosmic) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"COSMIC");
                return FAILURE;
            }
            if( (exist(opswift) == PSD_ON) && existcv(opswift) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"SWIFT");
                return FAILURE;
            }
            if( (exist(opmerge) == PSD_ON) && existcv(opmerge) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"MERGE");
                return FAILURE;
            }
            /* MRIhc09973  09/07/2005 YI */
            if( (exist(opplane) == PSD_3PLANE) && existcv(opplane) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Localizer");
                return FAILURE;
            }
            if( (exist(optensor) > PSD_OFF) && existcv(optensor) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"TENSOR");
                return FAILURE;
            }
            if(NON_VALUE_SYSTEM == value_system_flag){
                if( (2 == exist(opnecho)) && (PSD_3D != exist(opimode)) && 
                    ((PSD_GE == exist(oppseq)) ||
                     (PSD_SPGR == exist(oppseq))) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"FGRE Dual Echo");
                    return FAILURE;
                }
                /* MRIhc09972  09/06/2005 YI */
                if( ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq))) && (exist(opimode) == PSD_2D) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"Fast TOF");
                    return FAILURE;
                }
                if( (exist(opdiffuse) == PSD_ON) && existcv(opdiffuse) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"DWI");
                    return FAILURE;
                }
            }
        } /* End of Dynamic Plan */

        /* HCSDM00323513 */
        if (opslquant*opvquant > SLTAB_MAX)
        {
            avmaxslquant = (int)(SLTAB_MAX/(IMax(2,opvquant,1)));
            epic_error(use_ermes,"Maximum slice quantity is %-d",
                       EM_PSD_SLQUANT_OUT_OF_RANGE, 1, INT_ARG, avmaxslquant);
            return ADVISORY_FAILURE;
        }

        /* Update default values based on the system configuration */
        configSystem();

        /* HCSDM00338330: moved 3DGW enable/disable control from Host.  */
        /* 3DGW is disabled when one of the following conditions is met */
        /* << 2D or Cine imaging mode >>                                */
        /*    - gap / thickness > maxSliceGap2ThickPercent/100          */
        /*    - non-coaxial                                             */
        /*    - multi group                                             */
        /* << 3D imaging mode >>                                        */
        /*    - multi slab                                              */
        if( FALSE == Is3DGWAllowed(0) )
        {
            pi3dgradwarpnub  = _pi3dgradwarpnub.fixedflag ?  ((void)(0), pi3dgradwarpnub) : 0;
            cvdef(pi3dgradwarpnub, 0);
        }

        fov_freq_scale   = _fov_freq_scale.fixedflag ?  ((void)(scan_info[0].opfov_freq_scale), fov_freq_scale) : scan_info[0].opfov_freq_scale;
        fov_phase_scale  = _fov_phase_scale.fixedflag ?  ((void)(scan_info[0].opfov_phase_scale), fov_phase_scale) : scan_info[0].opfov_phase_scale;
        slthick_scale    = _slthick_scale.fixedflag ?  ((void)(scan_info[0].opslthick_scale), slthick_scale) : scan_info[0].opslthick_scale;

    } /* End of code inlined from vmx.e SysParmEval */

    { /* Start of code inlined from Prescan.e PScveval */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScveval                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cveval() must be written here.                     *
         *********************************************************************/

        /* MRIhc49539: check current nucleus against coil DB: */
        n32 psd_nucleus = specnuc;

        if(psd_nucleus != coilInfo[0].rxNucleus)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD", STRING_ARG, "the selected coil");
            return FAILURE; 
        }
         
        TGspf  = _TGspf.fixedflag ?        ((void)(((0==getAps1Mod())&&opspf)), TGspf) : ((0==getAps1Mod())&&opspf);
    	read_axis = TGspf ? YGRAD : XGRAD;
        if(read_axis == XGRAD)
        {
            killer_axis = YGRAD;
        }
        else
        {
            killer_axis = XGRAD;
        }

        local_tg  = _local_tg.fixedflag ?  ((void)(exist(oppscshimtg)), local_tg) : exist(oppscshimtg);

        /* set up axis for XTG */
        if(local_tg && oppscvquant > 0)
        {
            tg_read_axis = XGRAD;
            tg_killer_axis = YGRAD;
        }
        else
        {
            tg_read_axis = read_axis;
            tg_killer_axis = killer_axis;
        }

        TGopslthick  = _TGopslthick.fixedflag ?  ((void)(10.0), TGopslthick) : 10.0;

        if((PSD_ON == local_tg) && (oppscvquant >0)) /* use shim vol for TG */
        {
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(psc_info[0].oppsclenx), TGopslthickx) : psc_info[0].oppsclenx;
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(psc_info[0].oppscleny), TGopslthicky) : psc_info[0].oppscleny;
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(psc_info[0].oppsclenz), TGopslthick) : psc_info[0].oppsclenz;


            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMin(2,TGopslthickx,cfsystemmaxfov)), TGopslthickx) : FMin(2,TGopslthickx,cfsystemmaxfov);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMin(2,TGopslthicky,cfsystemmaxfov)), TGopslthicky) : FMin(2,TGopslthicky,cfsystemmaxfov);
            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMin(2,TGopslthick,cfsystemmaxfov)), TGopslthick) : FMin(2,TGopslthick,cfsystemmaxfov);

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,MINFOV_TG)), TGopslthick) : FMax(2,TGopslthick,MINFOV_TG);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }
        else if(PSD_ON == local_tg)
        {
            fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.8), fov_scaling) : 0.8;
            if(PSD_ON == opfus)
            {
                fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.5), fov_scaling) : 0.5;
            }
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(opslthick*opslquant*fov_scaling), TGopslthick) : opslthick*opslquant*fov_scaling;
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(get_act_freq_fov()*fov_scaling), TGopslthickx) : get_act_freq_fov()*fov_scaling;  /* use scan Rx */
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(get_act_phase_fov()*fov_scaling), TGopslthicky) : get_act_phase_fov()*fov_scaling;  /* use scan Rx */

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,20.0)), TGopslthick) : FMax(2,TGopslthick,20.0);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }


        if (psddebugcode)
        {
            psd_dump_coil_info();
        }

        if (FAILURE==PScveval())
        {
            return FAILURE;
        }
        if (FAILURE==FTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==XTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AScveval())
        {
            return FAILURE;
        }
        if (FAILURE==RGcveval())
        {
            return FAILURE;
        }

        if (FAILURE==RScveval())
        {
            return FAILURE;
        }
        if (FAILURE==DTGcveval())
        {
            return FAILURE;
        }

    } /* End of code inlined from Prescan.e PScveval */


    { /* Start of code inlined from loadrheader.e rheadereval */
        /* HSI addition for 128kHz bandwidth frequency fov truncation */
        /* Added additional check for CERD board to avoid 10% reduction in
           FOV when close to upper bound of filter. - GFN/JAP - 23/Sep/1997 */
        if ( (existcv(oprbw))          &&
             (exist(oprbw) >  60)      &&
             (existcv(psd_board_type)) && 
             (exist(psd_board_type) != PSDCERD) &&
             (exist(psd_board_type) != PSDDVMR) &&
             (exist(oppseq) != PSD_3PLANELOC) ) {
            rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.1), rhfreqscale) : 1.1;
            dfg  = _dfg.fixedflag ?  ((void)(1), dfg) : 1;
            dfscale = 2;
        }
        else { 
            rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.0), rhfreqscale) : 1.0;
            dfg  = _dfg.fixedflag ?  ((void)(2), dfg) : 2;
            dfscale = 1;
        }
    } /* End of code inlined from loadrheader.e rheadereval */

  }

 InitAdvPnlCVs();

#ifdef PSD_HW
 /* MR scanner (hardware): copy scan_info to ks_scan_info, so we can use this data on TGT */
 memcpy(ks_scan_info, scan_info, opslquant*sizeof(SCAN_INFO));
#else
  /* WTools (sim) */
  if (ks_simscan)
    simscan();
#endif

  return SUCCESS;

} /* GEReq_cveval() */


/**
 *******************************************************************************************************
 @brief #### Mandatory APx functions for PSDs from DV26

 DV26 requires getAPxAlgorithm() and getAPxParam() functions to exist in each PSD.
 Empty getAPxAlgorithm() and getAPxParam() functions are declared below in GERequired.e to allow
 compilation on DV26. If a PSD wants to use this new functionality in DV26 it should add the following
 line:
 #define KS_PSD_USE_APX 1
 in its @global section, so that KS_PSD_USE_APX is not set to 0 here, and hence getAPxAlgorithm() and
 getAPxParam() wont be redeclared here in GERequired.e.
********************************************************************************************************/
#if (KS_PSD_USE_APX == 0) && (EPIC_RELEASE >= 26)
void getAPxParam(optval *min,
            optval   *max,
            optdelta *delta,
            optfix   *fix,
            float    coverage,
            int      algorithm) {
    /* Need to be filled when APx is supported in this PSD */
}

int getAPxAlgorithm(optparam *optflag, int *algorithm) {
    return APX_CORE_NONE;
}
#endif



/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cvcheck()

 In the beginning of `cvcheck()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cveval();
 if (status != SUCCESS) return status;
 \endcode

 It is important that an error returned from GEReq_cvcheck() also results in an error in `cvcheck()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cvcheck(void) {

  if (existcv(optr) && optr < avmintr) {
    epic_error(use_ermes, "The minimum TR is %-d ms", EM_PSD_TR_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintr/ 1000));
    return ADVISORY_FAILURE;
  }
  if ((exist(opte) < avminte) && existcv(opte)) {
    epic_error(use_ermes, "The minimum TE is %-d ms", EM_PSD_TE_OUT_OF_RANGE1, 1, INT_ARG, (avminte/ 1000));
    return ADVISORY_FAILURE;
  }
  if ((exist(opte) > avmaxte) && existcv(opte)) {
    epic_error(use_ermes, "The maximum TE is %-d ms", EM_PSD_TE_OUT_OF_RANGE1, 1, INT_ARG, (avmaxte/ 1000));
    return ADVISORY_FAILURE;
  }

  return SUCCESS;

} /* GEReq_cvcheck() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of predownload()

 In the beginning of `predownload()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_predownload();
 if (status != SUCCESS) return status;
 \endcode

 This function up various global GE stuff related to recon and data filters. Also, `ks_sarcheckdone` is
 checked to make sure that GEReq_eval_checkTR_SAR_calcs() has been called to monitor SAR/heating limits.

 It is important that an error returned from GEReq_predownload() also results in an error in `predownload()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload(void) {

  {
    { /* Start of code inlined from vmx.e PreDownLoad */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e PreDownLoad */

  }

  nex  = _nex.fixedflag ?  ((void)(ceil(opnex)), nex) : ceil(opnex); /* nex is used in rheaderinit instead of opnex, so must set it here. otherwise prescan fails */

  /* UsePgenOnHost() (Imakefile) likes calling calcPulseParams() at this spot, containing "predownload.in" */
  calcPulseParams();

 {
    { /* Start of code inlined from loadrheader.e rheaderinit */

        /*
          rawdata   0=NOREC, 1=NPPROC
          eepf      1 for even echo phase flip
          oepf      1 for odd echo phase flip
          eeff      1 for even echo freq flip
        */

        eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
        eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;

        pinex = nex; /* initialize for pinex so APS can use it */

        if( nex == 1 )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else if( (((int)exist(opnex))%2) && (exist(opnex) > 2) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else if( (((int)exist(opnex))%2==0) && (exist(opnex)>5) && (nex%2) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
        }

        if( opimode == PSD_CINE )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
            if  ( ( (((int)exist(opnex))%2) && (exist(opnex) > 2) ) ||
                  ( (((int)exist(opnex))%2==0) && (exist(opnex)>5)
                    && (nex%2) ) || (nex < 2) )
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_ON), cine_choplet) : PSD_ON;
            else
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_OFF), cine_choplet) : PSD_OFF;
        }

        if( rhbline )
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
        }
        else
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
        }

        rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        if( (nex > 1) && (opimode != PSD_CINE) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( (((int)exist(opnex))%2) && (exist(opnex) > 2) )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (((int)exist(opnex))%2 == 0) && (exist(opnex) > 5) && (nex%2) )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (opimode == PSD_CINE) && (!cine_choplet) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( opimode == PSD_CINE )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCINE), rhtype) : rhtype+RHTYPCINE;
        }
        if( oppseq == PSD_GE || 
            oppseq == PSD_TOF || oppseq == PSD_TOFSP ||
            oppseq == PSD_PC  || oppseq == PSD_PCSP ||
            oppseq == PSD_3PLANELOC )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPGR), rhtype) : rhtype+RHTYPGR;
        }
        if( fn == 0.5 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTNEX), rhtype) : rhtype+RHTYPFRACTNEX;
        }
        if( opimode == PSD_3D )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP3D), rhtype) : rhtype+RHTYP3D;
        }
        if( (nop == 2) && (oppomp == PSD_OFF) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPNPW), rhtype) : rhtype+RHTYPNPW;
        }
        if( pitfeextra > 0 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTECHO), rhtype) : rhtype+RHTYPFRACTECHO;
        }
        if( fn == 0.75 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP75NEX), rhtype) : rhtype+RHTYP75NEX;
        }
        if( oppomp )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPPOMP), rhtype) : rhtype+RHTYPPOMP;
        }

        rhnecho  = _rhnecho.fixedflag ?  ((void)(opnecho), rhnecho) : opnecho;

        if( (opimode == PSD_CINE)
            && ((oppseq == PSD_PC) || (oppseq == PSD_PCSP)) )
        {
            rhnslices  = _rhnslices.fixedflag ?          ((void)(opslquant*(2+2*(exist(opflaxall)==1))), rhnslices) : opslquant*(2+2*(exist(opflaxall)==1));
        }
        else if( opcgate )
        {
            rhnslices  = _rhnslices.fixedflag ?    ((void)(opslquant*opphases), rhnslices) : opslquant*opphases;
        }
        else
        {
            rhnslices  = _rhnslices.fixedflag ?  ((void)(opslquant), rhnslices) : opslquant;
        }

        rhptsize  = _rhptsize.fixedflag ?  ((void)(opptsize), rhptsize) : opptsize;



     rhnavs  = _rhnavs.fixedflag ?      ((void)(IMax(2,(INT)(nex/2),(INT)1)), rhnavs) : IMax(2,(INT)(nex/2),(INT)1);

        rhformat  = _rhformat.fixedflag ?  ((void)(0), rhformat) : 0;
        if (nofermi)
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_FERMI), rhformat) : rhformat|RHF_NO_FERMI;
        }
        else
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_FERMI), rhformat) : rhformat&~RHF_NO_FERMI;
        }

        if (nograd == PSD_OFF) /* use 2d or 3d gradwarp */
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_GRADWARP), rhformat) : rhformat&~RHF_NO_GRADWARP;
            if ((op3dgradwarp == PSD_ON) && (exist(opslquant)>1)) /* do 3d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP13DGRADWARP), rhtype1) : rhtype1|RHTYP13DGRADWARP;
            }
            else   /* do 2d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            }
        }
        else  /* no gradwarp */
        {
            rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_GRADWARP), rhformat) : rhformat|RHF_NO_GRADWARP;
        }
                
            
        if( opimode == PSD_3D )
        {
            if( zchop )
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_ZCHOP), rhformat) : rhformat|RHF_ZCHOP;
            }
            else
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_YCHOP), rhformat) : rhformat|RHF_YCHOP;
            }
        }

        rhapp  = _rhapp.fixedflag ?         
                      ((void)(((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger))), rhapp) : ((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger));

        if( (acq_type == TYPGRAD) && (opimode != PSD_CINE) )
        {
            eeff  = _eeff.fixedflag ?  ((void)(1), eeff) : 1;
        }
        else
        {
            eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        }

        if( (acq_type == TYPSPIN) && (opexor == PSD_OFF) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(1), eepf) : 1;
        }
        else if( (acq_type == TYPSPIN) && (opexor == PSD_ON) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }
        else
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }

        /* set bit0 in rhdacqctrl with rawdata */
        if( rawdata )
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(RHDC_RAWDATA), rhdacqctrl) : rhdacqctrl|RHDC_RAWDATA; 
        }
        else
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~(RHDC_RAWDATA)), rhdacqctrl) : rhdacqctrl&~(RHDC_RAWDATA);
        }

        set_echo_flip(_rhdacqctrl.fixedflag ? (_temp408_rhdacqctrl=rhdacqctrl,&_temp408_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

        rhexecctrl  = _rhexecctrl.fixedflag ?      
                        ((void)(RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter), rhexecctrl) : RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter;

        /* Begin RTIA comment --- RJF */

        /*
          For RTIA, we don't need the images to be routed to TIR.
          Neither do we want them to be displayed in autoview.
          Here is the bit definitions for rhexecctrl.

          RDB_AUTO_DISPLAY               0x0001    1 
          RDB_AUTO_LOCK                  0x0002    2 
          RDB_AUTO_PERM                  0x0004    4 
          RDB_XFER_IM                    0x0008    8 
          RDB_SAVE_IM                    0x0010    16 
          RDB_TAPE_LOCK                  0x0020    32 
          RDB_INTERMEDIATE               0x0040    64 
          RDB_OVERRIDE_BROADCAST         0x0080    128 
          RDB_OVERRIDE_IMG_INSTALL       0x0100    256 
          RDB_OVERRIDE_AUTODISPLAY       0x0200    512 
          RDB_RTD_XFER_IM_REMOTE         0x0400    1024 
          RDB_RTD_SCAN                   0x0800    2048 
          RDB_REF_SCAN                   0x1000    4096 
          RDB_DONT_WRITE_OR_INSTALL      0x2000    8192 
          RDB_RTD_XFER_ALL_IM_PER_PASS   0x4000    16384 
          RDB_XFER_IMG_RIR               0x8000    32768 
        */
        /*  End RTIA comment */

        /* Begin RTIA */

        if( (oprealtime == PSD_ON) || (opfluorotrigger == PSD_ON) )
        { 
            rhexecctrl  = _rhexecctrl.fixedflag ?        ((void)(RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR), rhexecctrl) : RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR; 
            
            if ( (saveinter == PSD_ON) && (track_flag == PSD_ON) )
            { /*for realtime imaging, enable saving intermediate images*/
                rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_INTERMEDIATE), rhexecctrl) : rhexecctrl|RHXC_INTERMEDIATE;
            }

            /* Added for Enabling Autoview for RTIA debug */
#ifdef RTIA_AUTOVIEW_ENABLE
            rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_AUTO_DISPLAY), rhexecctrl) : rhexecctrl|RHXC_AUTO_DISPLAY; 
#endif
        }

        /* MRIge66773 */
        if( opfluorotrigger == PSD_ON )
        {
            rhexecctrl  = _rhexecctrl.fixedflag ?    ((void)(RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)), rhexecctrl) : rhexecctrl|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock);
        }
 
        /* End RTIA */
        rhvquant  = _rhvquant.fixedflag ?  ((void)(opvquant), rhvquant) : opvquant;
        rhslblank  = _rhslblank.fixedflag ?  ((void)(pislblank), rhslblank) : pislblank;
        rhzeroph  = _rhzeroph.fixedflag ?         ((void)((eg_phaseres*nop/2)*(opphasefov)+0.5), rhzeroph) : (eg_phaseres*nop/2)*(opphasefov)+0.5;
        if( pitfeextra > 0 )
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(8), rhnwin) : 8;
        }
        else
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(0), rhnwin) : 0;
        }

        if( (pitfeextra > 0) || ((fn == 0.5) && (nop == 2)) )
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(4), rhntran) : 4;
        }
        else
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(2), rhntran) : 2;
        }

        if (APODIZE_STRONG == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(3.0), fermi_w_factor) : 3.0;
        }
        else if (APODIZE_MEDIUM == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }
        else
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(1.0), fermi_r_factor) : 1.0;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }

        rhfermr  = _rhfermr.fixedflag ?      ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres);
        rhfermw  = _rhfermw.fixedflag ?      ((void)(fermi_wc*fermi_w_factor*(float)10.0), rhfermw) : fermi_wc*fermi_w_factor*(float)10.0;

        /* JAH: MRIge68280 -- need to use this more robust means of defining
           the eccentricity of the fermi filter so the radius in the X and Y
           directions need not be equal or based on data acquisition or
           reconstruction sizes as determined in recon. */
        /* KVA: MRIge73462 Square pixel rhferme addition */

        if( (PSD_ON == opspiral) || (PSD_ON == exist(opsilentmr)) || 
            (PSD_SPECTRO == opimode) )
        {
            rhferme  = _rhferme.fixedflag ?  ((void)(1.0), rhferme) : 1.0;
        }
        else if( (PSD_ON == opepi) || (PSD_ON == opsquare) )
        {
            rhferme  = _rhferme.fixedflag ?    ((void)(opxres/(opyres*nop)), rhferme) : opxres/(opyres*nop);
        }
        else
        {
            rhferme  = _rhferme.fixedflag ?      ((void)(opxres/(opyres*opphasefov*nop)), rhferme) : opxres/(opyres*opphasefov*nop);
        }

        rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs), rhnpasses) : acqs;

        rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
        rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

        /* PURE */
        /*MRIge91361 add rhpure for PURE*/
        if (exist(oppurecal))
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE_CAL), rhpure) : PURE_CAL;
        }
        else
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(exist(oppure)), rhpure) : exist(oppure);
        }

        /*MRIge93538 set rhpurefilter to 1 as default*/
        rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(1), rhpurefilter) : 1;

        {
            int attribute_result_int = 0;
            float attribute_result_float = 0.0;

            /* PURE 2 */
            if(isDVSystem() && ((B0_15000 == cffield) && (!strncmp("memp_pure", psd_name, 9) || !strncmp("fse_pure", psd_name, 8))))
            {                   
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) || /* Turn on MSK PURE Mix for all products*/ 
                    isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES))

            {               
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else
            {
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(exist(cfpure_filtering_mode)), rhpure_filtering_mode) : exist(cfpure_filtering_mode);
            }
            rhpure_lambda  = _rhpure_lambda.fixedflag ?  ((void)(coilInfo[0].pureLambda), rhpure_lambda) : coilInfo[0].pureLambda;
            rhpure_tuning_factor_surface  = _rhpure_tuning_factor_surface.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorSurface), rhpure_tuning_factor_surface) : coilInfo[0].pureTuningFactorSurface;
            rhpure_tuning_factor_body  = _rhpure_tuning_factor_body.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorBody), rhpure_tuning_factor_body) : coilInfo[0].pureTuningFactorBody;

            /* PURE Blur */
            rhpure_blur_enable  = _rhpure_blur_enable.fixedflag ?        ((void)(getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0), rhpure_blur_enable) : getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0;
            rhpure_blur  = _rhpure_blur.fixedflag ?        ((void)(getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0), rhpure_blur) : getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0;

            /* PURE Mix */
            strcpy(model_parameters.psd_name, psd_name);
            model_parameters.flip = exist(opflip);
            model_parameters.irmode = exist(opirmode);
            model_parameters.obplane = exist(opobplane);
            model_parameters.plane = exist(opplane);
            model_parameters.tr = exist(optr);
            model_parameters.xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(xtg_volRecCoil), xtg_volRecCoil) : xtg_volRecCoil;
            model_parameters.pure_support = pipure;
            model_parameters.cffield = cffield;

            pure_mix.enable = 0;
            pure_mix.tuning_factor_surface = rhpure_tuning_factor_surface;
            pure_mix.tuning_factor_body = rhpure_tuning_factor_body;
            pure_mix.blur_enable = rhpure_blur_enable;
            pure_mix.blur = rhpure_blur;

            if (B0_30000 == cffield || PSD_PURE_COMPATIBLE_2==pipure) /* 3.0 T DV platform */
            {
                if (FAILURE == getPUREMixParameters(model_parameters, coilInfo, exist(opanatomy), &pure_mix, _pure_mix_tx_scale.fixedflag ? (_temp409_pure_mix_tx_scale=pure_mix_tx_scale,&_temp409_pure_mix_tx_scale) : &pure_mix_tx_scale))
                {
                    epic_error(use_ermes, "Support routine %s failed.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "getPUREMixParameters");
                    return FAILURE;
                }
            }

            if (pure_mix.enable)
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(pure_mix.lambda), rhpure_mix_lambda) : pure_mix.lambda;
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(pure_mix.tuning_factor_surface), rhpure_mix_tuning_factor_surface) : pure_mix.tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(pure_mix.tuning_factor_body), rhpure_mix_tuning_factor_body) : pure_mix.tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(pure_mix.blur_enable), rhpure_mix_blur_enable) : pure_mix.blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(pure_mix.blur), rhpure_mix_blur) : pure_mix.blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)));
                rhpure_mix_otsu_class_qty  = _rhpure_mix_otsu_class_qty.fixedflag ?  ((void)(pure_mix.otsu_class_qty), rhpure_mix_otsu_class_qty) : pure_mix.otsu_class_qty;
                rhpure_mix_exp_wt  = _rhpure_mix_exp_wt.fixedflag ?  ((void)(pure_mix.exp_wt), rhpure_mix_exp_wt) : pure_mix.exp_wt;
                rhpure_mix_erode_dist  = _rhpure_mix_erode_dist.fixedflag ?  ((void)(pure_mix.erode_dist), rhpure_mix_erode_dist) : pure_mix.erode_dist;
                rhpure_mix_dilate_dist  = _rhpure_mix_dilate_dist.fixedflag ?  ((void)(pure_mix.dilate_dist), rhpure_mix_dilate_dist) : pure_mix.dilate_dist;
                rhpure_mix_aniso_blur  = _rhpure_mix_aniso_blur.fixedflag ?  ((void)(pure_mix.aniso_blur), rhpure_mix_aniso_blur) : pure_mix.aniso_blur;
                rhpure_mix_aniso_erode_dist  = _rhpure_mix_aniso_erode_dist.fixedflag ?  ((void)(pure_mix.aniso_erode_dist), rhpure_mix_aniso_erode_dist) : pure_mix.aniso_erode_dist;
                rhpure_mix_aniso_dilate_dist  = _rhpure_mix_aniso_dilate_dist.fixedflag ?  ((void)(pure_mix.aniso_dilate_dist), rhpure_mix_aniso_dilate_dist) : pure_mix.aniso_dilate_dist;
            }
            else
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(rhpure_lambda), rhpure_mix_lambda) : rhpure_lambda;
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(rhpure_tuning_factor_surface), rhpure_mix_tuning_factor_surface) : rhpure_tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(rhpure_tuning_factor_body), rhpure_mix_tuning_factor_body) : rhpure_tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(rhpure_blur_enable), rhpure_mix_blur_enable) : rhpure_blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(rhpure_blur), rhpure_mix_blur) : rhpure_blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?                  ((void)((isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",psd_name,9)||!strncmp("fse_pure",psd_name,8)))?1.0:0.0), rhpure_mix_alpha) : (isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",psd_name,9)||!strncmp("fse_pure",psd_name,8)))?1.0:0.0;
                rhpure_mix_otsu_class_qty  = _rhpure_mix_otsu_class_qty.fixedflag ?  ((void)(2), rhpure_mix_otsu_class_qty) : 2;
                rhpure_mix_exp_wt  = _rhpure_mix_exp_wt.fixedflag ?  ((void)(1.0), rhpure_mix_exp_wt) : 1.0;
                rhpure_mix_erode_dist  = _rhpure_mix_erode_dist.fixedflag ?  ((void)(0), rhpure_mix_erode_dist) : 0;
                rhpure_mix_dilate_dist  = _rhpure_mix_dilate_dist.fixedflag ?  ((void)(1), rhpure_mix_dilate_dist) : 1;
                rhpure_mix_aniso_blur  = _rhpure_mix_aniso_blur.fixedflag ?  ((void)(0), rhpure_mix_aniso_blur) : 0;
                rhpure_mix_aniso_erode_dist  = _rhpure_mix_aniso_erode_dist.fixedflag ?  ((void)(0), rhpure_mix_aniso_erode_dist) : 0;
                rhpure_mix_aniso_dilate_dist  = _rhpure_mix_aniso_dilate_dist.fixedflag ?  ((void)(0), rhpure_mix_aniso_dilate_dist) : 0;
            }
        }

        if( truenex <= 0 )
        {
            /* PSDs which do not use truenex, as tools, and Spectro,
               will use nex. Truenex is used in Odd Nex NPW cases */
            truenex  = _truenex.fixedflag ?  ((void)(nex), truenex) : nex;
        }

        /* Set NEX for unacquired encodes for when zero-fill BAM is enabled */
        rhnex_unacquired  = _rhnex_unacquired.fixedflag ?  ((void)((int)(ceil(truenex))), rhnex_unacquired) : (int)(ceil(truenex));

        if( opimode==PSD_CINE )
        {
            rhrawsize = (n64)opclocs * (n64)opnecho * (n64)rhfrsize
                * (n64)((oppseq == PSD_PC || oppseq == PSD_PCSP) ?
                        (2 + (opflaxall == 1 ? 2 : 0)) : 1)
                * (n64)(2*rhptsize) * (n64)opcphases
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((float)(1 - rawdata) + (truenex * (float)rawdata)));

        }
        else
        {
            rhrawsize = (n64)slquant1 * (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));

            /*a MRIge91983 - RDP - minimal acquisition size (single coil, single slice, 50 views) */
            if (rotateflag == 2)
            {
                rhrawsize = (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                    * (n64)ceil((float)(1 + (rhbline * rawdata) + 50 + rhhnover)
                                * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));
            }
        }


     if( oppomp )
     {
         if( opxres == 512 )
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(1024), rhrcyres) : 1024;
         }
         else
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(512), rhrcyres) : 512;
         }
     }
     else
     {
         rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
     }

        if( ((exist(opzip512) == PSD_ON) && (existcv(opzip512)) )
            || (exist(opxres) > 256) )
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(512), rhrcxres) : 512;           /* 512 ZIP or standard 512 recon */
        }
        else 
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(256), rhrcxres) : 256;           /* Standard 256 recon */
        }

        rhmethod  = _rhmethod.fixedflag ?  ((void)(oppomp), rhmethod) : oppomp;
        rhdaxres  = _rhdaxres.fixedflag ?  ((void)(opxres), rhdaxres) : opxres;

        rhrcctrl  = _rhrcctrl.fixedflag ?            
                          ((void)(recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG), rhrcctrl) : recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG;
        if( cfcompress < 100 )
        {
            rhrcctrl  = _rhrcctrl.fixedflag ?  ((void)(RHRCCOMP), rhrcctrl) : rhrcctrl+RHRCCOMP;
        }

        if ( opimode==PSD_CINE )
        {
            rhcphases  = _rhcphases.fixedflag ?  ((void)(opcphases), rhcphases) : opcphases;
            /*have to convert this from uSec to Sec */
            rhctr  = _rhctr.fixedflag ?  ((void)((FLOAT)optr/1000000.0), rhctr) : (FLOAT)optr/1000000.0;
            rhcrrtime  = _rhcrrtime.fixedflag ?  ((void)(60.0/(FLOAT)opchrate), rhcrrtime) : 60.0/(FLOAT)opchrate; /* also in Sec */
        }

        /* Support choice of gradient coil for twin gradient coils (Gili) */
        rhgradmode  = _rhgradmode.fixedflag ?  ((void)(opgradmode), rhgradmode) : opgradmode;

        rhte  = _rhte.fixedflag ?  ((void)(opte), rhte) : opte;
        rhte2  = _rhte2.fixedflag ?  ((void)(opte2), rhte2) : opte2;
        
        rhscancent  = _rhscancent.fixedflag ?  ((void)(piscancenter), rhscancent) : piscancenter;
       
        if(PSD_MINTE == exist(opautote))
        {
          /* EPI - MinTE with ramp sampling will be a problem hence not supported
             SSFSE - MinTE but full acquisition is done , disabled temporarily */
          if((PSD_ON == exist(opepi)) || (PSD_ON == exist(opssfse)) || (PSD_ON == exist(opspiral)))
            rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
          else if((PSD_3D == exist(opimode)) && (PSD_ON == exist(opdixon)))
            rhfeextra  = _rhfeextra.fixedflag ?       ((void)((int)((fnecho_lim-0.5)*rhfrsize+0.5)), rhfeextra) : (int)((fnecho_lim-0.5)*rhfrsize+0.5);
          else
           rhfeextra  = _rhfeextra.fixedflag ?    ((void)(rhfrsize-exist(opxres)/2), rhfeextra) : rhfrsize-exist(opxres)/2;
        }
        else
        {
          rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
        }

        rh3dgw_interptype  = _rh3dgw_interptype.fixedflag ?  ((void)(RH3DGW_BICUBIC_INTERP), rh3dgw_interptype) : RH3DGW_BICUBIC_INTERP; 

    } /* End of code inlined from loadrheader.e rheaderinit */

{ /* Start of code inlined from Prescan.e PSfilter */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                            PSfilter                               *
     *                                                                   *
     * Write here the code unique to the Host PSD process.               *
     *********************************************************************/
    /* PS filter must be called with no arguments. num_filter_slot 
       is a CV which comes from individual PSDs, which get incremented 
       in the PSD so that Prescan filter generation takes place for 
       the next slot in psd_filter_spec. - RJF 13/Oct/1998 */
    /* vmx 10/13/94 YI */
    PSfilter();
    /* end vmx */

    if(psddebugcode)
    {
        dump_runtime_filter_info(psd_filt_spec);
    }
} /* End of code inlined from Prescan.e PSfilter */

  }

  /* Set rhkacq_uid for ARC support and linking plots */
  int uid;
  struct tm now;
  time_t now_epoch = time(NULL);
  /* Generate unique ID for this scan for naming kacq files and
     debug files.  Use the current date and time (MMDDHHMMSS).
     Cannot include the year because this is larger than a
     signed 32-bit integer */
  localtime_r(&now_epoch, &now);
  uid = now.tm_sec +
        now.tm_min  * 100 +
        now.tm_hour * 10000 +
        now.tm_mday * 1000000 +
        (now.tm_mon + 1) * 100000000;
  rhkacq_uid  = _rhkacq_uid.fixedflag ?  ((void)(uid), rhkacq_uid) : uid;


 /* Check that SAR calculations have been performed */
  if (ks_sarcheckdone != TRUE) {
#ifdef SIM
    if (existcv(optr) == TRUE && existcv(opte) == TRUE && existcv(opslquant) == TRUE) {
      /* In simulation (WTools), predownload is called every time a CV is changed but
      ks_sarcheckdone will not be set to TRUE in GEReq_eval_checkTR_SAR_calcs() unless
      optr, opte and opslquant have all been set (existcv() != FALSE). Hence, in simulation,
      we cannot throw an error before these have been set */
      return ks_error("%s: Missing call to GEReq_eval_checkTR_SAR()", __FUNCTION__);
    }
#else
    return ks_error("%s: Missing call to GEReq_eval_checkTR_SAR()", __FUNCTION__);
#endif
  }

 return SUCCESS;

} /* GEReq_predownload() */




#ifndef sys_psdiopt_h
#define sys_psdiopt_h
#include "psdiopt.h"
#endif
#ifndef _SYSCHECK_
#define _SYSCHECK_
STATUS syscheck(INT *p_syscheck_limit, int *p_status_flag)
{
    /* Variables to hold the minseq  values. These are local to syscheck*/
    INT syscheck_min_seqgrad = 0;
    INT syscheck_min_seqrfamp = 0; 

    /* Flag to turn on or off syscheck logging */
    int syschecklog_on = 0;

    /* The file pointer to enable or disable RF check with the help of a file*/
    FILE *fp_rfon;
    FILE *fp_syschecklog_on;

    int iopt_num=0;/* Imaging option Num*/

    char im_opt_name[128];/* Imaging option String*/
    char logValues[1024];

    INT seq_entry_index = 0;

    char path[128] = "/usr/g/service/log/";
    char filename[64] = "psd_syscheck_error.log";
    char macro_name[32];
    float tolerance_percentage = 0.0;
    const int TOLERANCE_LIMIT = 5;
    int syscheck_limit = 0;
    float syscheck_limit_tolerance = 0.0;
    int debug_syscheck;
    debug_syscheck = (getenv("DEBUG_SYSCHECK")!='\0');

if(debug_syscheck){
        printf(" Calling minseq from macro\n");
        fflush(stdout);
        }
    strcpy(macro_name,"SYSCHECK_MINSEQ_PGOH");
    if (FAILURE == minseq(&syscheck_min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seq_entry_index, tsamp,
                                avail_image_time,
                                use_ermes, seg_debug ) )
             {
        log_error(path,filename,1,"%s %d %d  %d","Minseq failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        if(debug_syscheck){
            printf(" Minseq failed in syscheck \n");
            fflush(stdout);
        }
        *p_status_flag=1;
    }
    else
    {
        if(debug_syscheck){
            printf("minseq completed successfully with values\n syscheck_min_seqgrad : %d\n",syscheck_min_seqgrad);
            fflush(stdout);
        }
    }
    /****** To include Rf calculation based on the choice made ****/

    fp_rfon = fopen("/usr/g/bin/.RFCHECKON","r");
    if(fp_rfon !=NULL)
    {
       if(debug_syscheck){
           printf("Calling minseqrfamp from macro\n");
           fflush(stdout);
       }
       if(minseqrfamp(&syscheck_min_seqrfamp,(int)RF_FREE,rfpulse,L_SCAN) == FAILURE)
         {
             log_error(path,filename,1,"%s \n file:%s line:%d Error no:%d","Minseqrfamp failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
             if(debug_syscheck){
                 printf(" Minseqrfamp failed in syscheck\n");
                 fflush(stdout);
             }
             *p_status_flag= 1;
         }
         else
         {
            if(debug_syscheck){
                printf("Completed minseqrfamp successfully with syscheck_min_seqrfamp %d\n",syscheck_min_seqrfamp);
                fflush(stdout);
            }
        }
    }

    /** to check for the environment variable whether logging has to be done or not ***/

    fp_syschecklog_on = fopen("/usr/g/bin/.SYSCHECKLOGON","r");
    syschecklog_on =((getenv("SYSCHECKLOGON")!='\0') || (fp_syschecklog_on!=NULL));
    /*** if RF check is on include the min_seqrfamp for syscheck_safety_limit and for comparison with optr ***/

        if(fp_rfon !=NULL)
        {
            if(debug_syscheck){
                printf("\nRF included");
                fflush(stdout);
            }
            syscheck_limit = IMax(2,syscheck_min_seqgrad,syscheck_min_seqrfamp);
        }
        else
        {
           if(debug_syscheck){
               printf("\nRf calculation not included");
               fflush(stdout);
           }
           syscheck_limit = syscheck_min_seqgrad;
        }
        /*** Calculate the tolerance percentage to allow a maximum of 5% tolerance before comparision***/
        tolerance_percentage = 1-(TOLERANCE_LIMIT * 0.01);
        if(psd_tol_value!=0){
            if((((oppseq == PSD_GE) || (oppseq == PSD_SPGR) || (oppseq == PSD_TOF) || (oppseq == PSD_TOFSP) || (oppseq == PSD_SSFP)) &&
                (opfast == PSD_ON) && (opimode == PSD_3D) && ((opirprep == PSD_ON) || ((opgirmode == PSD_GIRMANUAL) && (opnumgir > 0)))) ||
               (((oppseq == PSD_GE) || (oppseq == PSD_SPGR)) && (opimode == PSD_2D) && (oprealtime == PSD_ON) && (opfast == PSD_ON))){
                if(debug_syscheck){
                    printf("Special case for syscheck considered");
                    printf(" VALUE OF PSD_TOL_VALUE = %d",psd_tol_value);
                    fflush(stdout);
                }
            }
            else{
                if(debug_syscheck){
                    printf("Not allowing a tolerance.Not a  special cases");
                }
                cvoverride(psd_tol_value,0,PSD_FIX_ON,PSD_EXIST_ON);
           }
        }
        syscheck_limit_tolerance = (syscheck_limit * tolerance_percentage) - psd_tol_value;
        *p_syscheck_limit = (int)(syscheck_limit_tolerance);
        /*** Compare the optr with the minseq values if found less than max of minseq values,log an error ***/
        /*** MRIhc37381: Bypass the optr check for Phase Contrast to avoid the download failure ***/
        /*** MRIhc42193: remove the code added by MRIhc37381, enable syscheck for Phase Contrast ***/
        if( (exist(optr)) < (*p_syscheck_limit) || (optr) < (*p_syscheck_limit ) )
        {
            log_error(path,filename,1,"%s \nfile:%s line:%d","ERROR : PSD SAFETY CHECK ERROR!!! ILLEGAL OPTR DETECTED IN SYSCHECK!!!",__FILE__,__LINE__);
            *p_status_flag = 2;
            if(debug_syscheck){
                printf("Illegal optr  value found %d\n",exist(optr));
                fflush(stdout);
            }
        }
        else
        {
            /**** Log a positive message for no error case *****/
            log_error(path,filename,1,"%s", "SAFETY CHECK RAN SUCCESSFULLY!OPTR VALUES FOUND SAFE!");
            *p_status_flag = 0;
        }
        if(((*p_status_flag ==0) && (syschecklog_on)) || (*p_status_flag ==2))
        {
            sprintf(logValues,"\noptr : %d\ntmin : %d\t\ttmin_total : %d\nmin_seqgrad : %d\tsyscheck_min_seqgrad : %d\nsyscheck_safety_limit : %d",exist(optr),tmin,tmin_total,min_seqgrad,syscheck_min_seqgrad,*p_syscheck_limit);
            log_error(path,filename,0,"%s %s","Values found:",logValues);
            if(fp_rfon!=NULL)
            {
                sprintf(logValues,"min_seqrfamp : %d\t syscheck_min_seqrfamp : %d\n",min_seqrfamp,syscheck_min_seqrfamp);
                log_error(path,filename,0,"%s",logValues);
            }
        }
            /************** Log the PSD name & IOPT selected *****/
            log_error(path,filename,0,"%s %s ","PSD:",psd_name);
            for(iopt_num = 0;iopt_num < PSD_NUM_IOPTS; iopt_num++){
                if(is_iopt_selected(iopt_num)){
                return_iopt_name(iopt_num,im_opt_name);
                log_error(path,filename,0,"%s %s","Imaging Option :",im_opt_name);
            }
        }

    log_error(path,filename,0,"%s",macro_name);
    if((*p_status_flag) != 0)
    {
        return FAILURE;
    }
    else
    {
        return SUCCESS;
    }
}
#endif
/***************************************************************/

/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: PULSEGEN functions
 *                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
 *
 *******************************************************************************************************
 *******************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1  = _temp_res_rf2mps1.fixedflag ?  ((void)(res_rf2mps1), temp_res_rf2mps1) : res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(rfpulseInfo[RF2_APS1_SLOT].newres), res_rf2mps1) : rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(temp_res_rf2mps1), res_rf2mps1) : temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl  = _temp_res_rf1cfl.fixedflag ?  ((void)(res_rf1cfl), temp_res_rf1cfl) : res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(rfpulseInfo[RF1_CFL_SLOT].newres), res_rf1cfl) : rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cflloggrd.zbeta), pg_beta) : cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(temp_res_rf1cfl), res_rf1cfl) : temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( rcvn_flag == 1 )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;
    INT min_ssp;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        short *temp_wave_space; /* temporary waveform space for rf scaling */
        short *wave_space; /* temporary waveform space for rf scaling */

        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    INT new_res;                  /* temp holder for new pulse resolution */

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	    /* Scale the pulse, and then move to the reserved memory */
	    temp_wave_space = (short *)AllocNode(res_gzrf0cfh*sizeof(short));
	    uextwave(temp_wave_space, res_gzrf0cfh, grad_zrf0cfh);
	    wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres/2*sizeof(short));
	    stretchpulse((int)res_gzrf0cfh,(int)rfpulseInfo[RF0_CFH_SLOT].newres/2,
			 temp_wave_space,wave_space);
	    /* res_gz$[slsel_name] = rfpulseInfo[$[rf_slot]].newres/2; */
	    new_res = rfpulseInfo[RF0_CFH_SLOT].newres/2;
	    /* Copy over original pulse data */
	    movewaveimm(wave_space, &gzrf0cfh, (int)0, new_res, TOHARDWARE);
	    FreeNode(wave_space);
	    FreeNode(temp_wave_space);
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(1.0), cyc_rf0cfh) : 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

	/* Create some RHO waveform space, scale the pulse, and then move
	 * the local memory to the reserved RHO memory, and set pulsepointers
	 * to new stretched pulse
	 */
	temp_wave_space = (short *)AllocNode(res_rf0cfh*sizeof(short));
	uextwave(temp_wave_space, res_rf0cfh, rf_rf0cfh);
	wave_space = (short *)AllocNode(rfpulseInfo[RF0_CFH_SLOT].newres*sizeof(short));
	stretchpulse((int)res_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		     temp_wave_space,wave_space);
	/* res_$[slsel_name] = rfpulseInfo[$[rf_slot]].newres; */
	new_res = rfpulseInfo[RF0_CFH_SLOT].newres;
        /* Copy over original pulse data */
	movewaveimm(wave_space, &rf0cfh, (int)0, new_res, TOHARDWARE);
	FreeNode(wave_space);
	FreeNode(temp_wave_space);
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {

    short *stretched_wave_space;  /* temporary waveform space */
    short *wave_space;            /* temporary waveform space for
                                     stretched RF pulse */
    INT old_res;                  /* temp holder for old pulse resolution */
    INT new_res;                  /* temp holder for new pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    old_res =  res_omegarf0cfh;
    new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

    n_omegarf0cfh  = _n_omegarf0cfh.fixedflag ?  ((void)(1), n_omegarf0cfh) : n_omegarf0cfh+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
        if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON ) {

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

            /* Allocate memory for original RF pulse */
            wave_space = (short *)AllocNode(old_res*sizeof(short));
            /* Read RF pulse from file and store to wave_space */
            uextwave(wave_space, old_res, fileloc_omegarf0cfh);

            /* Allocate memory for stretched RF pulse */
            stretched_wave_space = (short *)AllocNode(new_res*sizeof(short));
            
            stretchpulse(old_res, new_res, wave_space, stretched_wave_space);
            
            /* Move stretched pulse immediately into reserved memory */
            movewaveimm(stretched_wave_space, &omegarf0cfh,
                        (int)0, new_res, TOHARDWARE);
            
             /* Free memory allocated for original RF pulse */
            FreeNode(wave_space);
            /* Free memory allocated for stretched RF pulse */
            FreeNode(stretched_wave_space);
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(new_res), res_omegarf0cfh) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(old_res), res_omegarf0cfh) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */

  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh  = _temp_res_rf1cfh.fixedflag ?  ((void)(res_rf1cfh), temp_res_rf1cfh) : res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(rfpulseInfo[RF1_CFH_SLOT].newres), res_rf1cfh) : rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(temp_res_rf1cfh), res_rf1cfh) : temp_res_rf1cfh;
  }


    min_ssp = RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH);

    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                  + IMax(2, min_ssp,
                         (pw_gzrf1cfhd + pw_gzrf2lcfha
                          + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                  + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                  + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                           + IMax(2, min_ssp,
                                  (pw_gzrf1cfhd + pw_gzrf2lcfha
                                   + pw_gzrf2lcfh + pw_gzrf2lcfhd));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                    IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                    + presscfh_wait_rf12;

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = 0.5 * pw_rf3cfh
                        + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                        + presscfh_wait_rf23;
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = 0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                        + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                        + presscfh_wait_rf34;

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh  = _res_rf2cfh.fixedflag ?  ((void)(rfpulseInfo[RF2_CFH_SLOT].newres), res_rf2cfh) : rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr  = _csw_tr.fixedflag ?          
           ((void)(15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi), csw_tr) : 15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr  = _csw_tr.fixedflag ?  ((void)(RUP_GRD(1000)), csw_tr) : RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg  = _temp_res_rf1ftg.fixedflag ?  ((void)(res_rf1ftg), temp_res_rf1ftg) : res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(rfpulseInfo[RF1_FTG_SLOT].newres), res_rf1ftg) : rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(temp_res_rf1ftg), res_rf1ftg) : temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg  = _temp_res_rf2ftg.fixedflag ?  ((void)(res_rf2ftg), temp_res_rf2ftg) : res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(rfpulseInfo[RF2_FTG_SLOT].newres), res_rf2ftg) : rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(temp_res_rf2ftg), res_rf2ftg) : temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg  = _temp_res_rf3ftg.fixedflag ?  ((void)(res_rf3ftg), temp_res_rf3ftg) : res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(rfpulseInfo[RF3_FTG_SLOT].newres), res_rf3ftg) : rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(temp_res_rf3ftg), res_rf3ftg) : temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGz1XTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
        postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gyrf1xtgd + pw_gykxtgla);
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

        postemp = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)+pw_gykxtgla);
    }

    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, postemp-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);

 
    postemp = RUP_GRD(pendall(&gykxtgl,0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(postemp) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf3xtg);
   }
 

    PosGz1XTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                        pw_rf2xtg/2-pw_gzrf2xtga-pw_gz1xtgd-pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0)-pw_rf1xtg/2+XTGtau1-
                     pw_rf2xtg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg  = _temp_res_rf2xtg.fixedflag ?  ((void)(res_rf2xtg), temp_res_rf2xtg) : res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(rfpulseInfo[RF2_XTG_SLOT].newres), res_rf2xtg) : rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(temp_res_rf2xtg), res_rf2xtg) : temp_res_rf2xtg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1XTG = pendall(&gzrf2xtg, 0)+pw_gz2xtga;

           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGz1XTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    postemp = RUP_GRD(pendall(&gz2xtg, 0));
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(postemp) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(postemp) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    postemp = RUP_GRD(pendall(&rf4xtg, 0)+pw_gykxtgra);
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, postemp-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);

    
    postemp = RUP_GRD(pendall(&rf2xtg,0)-pw_rf2xtg/2+XTGtau1-pw_gxw1xtg/2
                      -pw_gxw1xtga-pw_gx1bxtgd-pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + 
                                   2*XTGtau1 - pw_gxw1xtg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga)){
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0)));

         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);

     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as  = _temp_res_rf1as.fixedflag ?  ((void)(res_rf1as), temp_res_rf1as) : res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(rfpulseInfo[RF1_AUTOSHIM].newres), res_rf1as) : rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(asloggrd.zbeta), pg_beta) : asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(temp_res_rf1as), res_rf1as) : temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    rfdisable_add = YES;
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }


    rfdisable_add = NO;
        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(TR_PASS3D-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(TR_PASS3D), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *wave_space_theta;
    short *temp_wave_space;
    short *temp_wave_space2;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay  = _DD_delay.fixedflag ?  ((void)(2000), DD_delay) : 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(temp_res), res_rf1rs) : temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     rffrequency_length[bd_index]-rfupa+rfupd );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

    temp_res = res_rfbrs;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    strcpy(ext_filename,"bloch_siegert_abs.rho");
    /* Set new resolution and stretch external pulse */
    temp_wave_space = (short *)AllocNode(res_rfbrs*sizeof(short));
    temp_wave_space2 = (short *)AllocNode(res_thetarfbrs*sizeof(short));
    uextwave(temp_wave_space, res_rfbrs, ext_filename);
    uextwave(temp_wave_space2, res_thetarfbrs, "bloch_siegert_abs.pha");

    /* Stretch rf pw if needed */
    if (rfpulseInfo[RFB_RFSHIM_SLOT].change==PSD_ON)
    {
        res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(rfpulseInfo[RFB_RFSHIM_SLOT].newres), res_rfbrs) : rfpulseInfo[RFB_RFSHIM_SLOT].newres;
        res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

        wave_space = (short *)AllocNode(res_rfbrs*sizeof(short));
        stretchpulse((int)temp_res, (int)res_rfbrs,temp_wave_space,wave_space);

        wave_space_theta = (short *)AllocNode(res_thetarfbrs*sizeof(short));
        stretchpulse((int)temp_res,(int)res_thetarfbrs,temp_wave_space2,wave_space_theta);

        FreeNode(temp_wave_space);
        FreeNode(temp_wave_space2);
    }
    else
    {
        wave_space = temp_wave_space;
        wave_space_theta = temp_wave_space2;
    }

      
  {
    pulsename(&rfbrs,"rfbrs");
    createreserve(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
		  res_rfbrs);
  }

    createinstr( &rfbrs, PosTemp+psd_rf_wait, pw_rfbrs, ia_rfbrs );
    addrfbits(&rfbrs, 0, PosTemp+psd_rf_wait, pw_rfbrs);
    movewaveimm(wave_space, &rfbrs, (int)0, res_rfbrs, TOHARDWARE);
    FreeNode(wave_space);
    setiamp(ia_rfbrs, &rfbrs, 0);

    /* BLOCHSIEGERT_ADIABATIC Theta Board */
      
  {
    pulsename(&thetarfbrs,"thetarfbrs");
    createreserve(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
		  res_thetarfbrs);
  }

    createinstr(&thetarfbrs, (LONG)(PosTemp+psd_rf_wait), pw_rfbrs,ia_rfbrs_theta);
    addrfbits(&thetarfbrs,0, (LONG)(PosTemp+psd_rf_wait), pw_rfbrs);
    movewaveimm(wave_space_theta, &thetarfbrs, (long)0, res_thetarfbrs, TOHARDWARE);
    FreeNode(wave_space_theta);
    setiamp(ia_rfbrs_theta, &thetarfbrs, 0);

    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(temp_res), res_rfbrs) : temp_res;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *wave_space_theta;
    short *temp_wave_space;
    short *temp_wave_space2;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(temp_res), res_rf1dtg) : temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     rffrequency_length[bd_index]-rfupa+rfupd );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

    temp_res = res_rfbdtg;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;

    strcpy(ext_filename,"bloch_siegert_abs.rho");
    /* Set new resolution and stretch external pulse */
    temp_wave_space = (short *)AllocNode(res_rfbdtg*sizeof(short));
    temp_wave_space2 = (short *)AllocNode(res_thetarfbdtg*sizeof(short));
    uextwave(temp_wave_space, res_rfbdtg, ext_filename);
    uextwave(temp_wave_space2, res_thetarfbdtg, "bloch_siegert_abs.pha");

    /* Stretch rf pw if needed */
    if (rfpulseInfo[RFB_DYNTG_SLOT].change==PSD_ON)
    {
        res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(rfpulseInfo[RFB_DYNTG_SLOT].newres), res_rfbdtg) : rfpulseInfo[RFB_DYNTG_SLOT].newres;
        res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;

        wave_space = (short *)AllocNode(res_rfbdtg*sizeof(short));
        stretchpulse((int)temp_res, (int)res_rfbdtg,temp_wave_space,wave_space);

        wave_space_theta = (short *)AllocNode(res_thetarfbdtg*sizeof(short));
        stretchpulse((int)temp_res,(int)res_thetarfbdtg,temp_wave_space2,wave_space_theta);

        FreeNode(temp_wave_space);
        FreeNode(temp_wave_space2);
    }
    else
    {
        wave_space = temp_wave_space;
        wave_space_theta = temp_wave_space2;
    }

      
  {
    pulsename(&rfbdtg,"rfbdtg");
    createreserve(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
		  res_rfbdtg);
  }

    createinstr( &rfbdtg, PosTemp+psd_rf_wait, pw_rfbdtg, ia_rfbdtg );
    addrfbits(&rfbdtg, 0, PosTemp+psd_rf_wait, pw_rfbdtg);
    movewaveimm(wave_space, &rfbdtg, (int)0, res_rfbdtg, TOHARDWARE);
    FreeNode(wave_space);
    setiamp(ia_rfbdtg, &rfbdtg, 0);

    /* BLOCHSIEGERT_ADIABATIC Theta Board */
      
  {
    pulsename(&thetarfbdtg,"thetarfbdtg");
    createreserve(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
		  res_thetarfbdtg);
  }

    createinstr(&thetarfbdtg, (LONG)(PosTemp+psd_rf_wait), pw_rfbdtg,ia_rfbdtg_theta);
    addrfbits(&thetarfbdtg,0, (LONG)(PosTemp+psd_rf_wait), pw_rfbdtg);
    movewaveimm(wave_space_theta, &thetarfbdtg, (long)0, res_thetarfbdtg, TOHARDWARE);
    FreeNode(wave_space_theta);
    setiamp(ia_rfbdtg_theta, &thetarfbdtg, 0);

    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(temp_res), res_rfbdtg) : temp_res;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}


/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of pulsegen()

 In the beginning of `pulsegen()` the following lines should be added:
 \code{.c}
 GEReq_pulsegenBegin();
 \endcode

 This function up various global GE stuff related to pulsegen()
********************************************************************************************************/
void GEReq_pulsegenBegin(void) {

  sspinit(psd_board_type);

  {
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */

  }
} /* GEReq_pulsegenBegin() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the end of pulsegen()

 In the end of `pulsegen()`, but before `buildinstr()`, the following lines should be added:
 \code{.c}
 GEReq_pulsegenEnd();
 \endcode

 This function up prescan pulsegen and adds a PASSPACK sequence ("GEendpass"), which is used to dump
 rawdata and mark the end of scan. See GEReq_endofpass() and GEReq_endofscan() and how they are used
 in a psd.
********************************************************************************************************/
void GEReq_pulsegenEnd(void) {

#ifdef IPG
  {
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();

  }

/* pass sequence to dump Pfiles */
 
  {
    pulsename(&GEendpass,"GEendpass");
    createpass(&GEendpass,(long)(pw_passpacket-1000));
  }

  
  {
    pulsename(&GEpass,"GEpass");
    createseq(&GEpass,pw_passpacket, off_GEpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_GEpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_GEpass = %d\n", idx_GEpass );
#endif
  }


#endif
} /* GEReq_pulsegenEnd() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to trigger data (Pfile) writing and reconstruction

 After calling this function, the parent function must switch back to the previous/main sequence 
 using ks_scan_playsequence() (or *boffset()*).
********************************************************************************************************/
void GEReq_endofpass() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABPASS, &GEendpass, 2 ); /* end of pass */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofpass() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofscan() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABSCAN, &GEendpass, 2 ); /* end of scan */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofscan() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofpassandscan() {
  #ifdef IPG
    boffset(off_GEpass);
    setwamp(SSPD + DABPASS + DABSCAN, &GEendpass, 2 ); /* end of scan */
    startseq(0, (short) MAY_PAUSE);
  #endif
  } /* GEReq_endofscan() */
  
  

/*****************************************************************************************************
 * RSP Variables
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSSpSat.e: HOST functions and variables
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Resets the KSSPSAT_PARAMS struct (arg 1) to KSSPSAT_INIT_PARAMS
 @param[out] params Pointer to the ksspsat params struct used to steer the behavior of this spsat
                    sequence module
 @return void
********************************************************************************************************/
void ksspsat_init_params(KSSPSAT_PARAMS *params) {
  KSSPSAT_PARAMS defparams = KSSPSAT_INIT_PARAMS;
  *params = defparams;
}



/**
 *******************************************************************************************************
 @brief #### Resets the KSSPSAT_SEQUENCE struct (arg 1) to KSSPSAT_INIT_SEQUENCE

 As KSSPSAT_INIT_SEQUENCE contains KSSPSAT_PARAMS, which sets the field `.satmode = KSSPSAT_OFF`,
 calling ksspsat_init_sequence() will disable the `ksspsat` sequence module (i.e. turn off spsat)

 @param[out] ksspsat Pointer to KSSPSAT_SEQUENCE
 @return void
********************************************************************************************************/
void ksspsat_init_sequence(KSSPSAT_SEQUENCE *ksspsat) {
  KSSPSAT_SEQUENCE defseq = KSSPSAT_INIT_SEQUENCE;
  *ksspsat = defseq;
  strcpy(ksspsat->seqctrl.description, "ksspsat");
} /* ksspsat_init_sequence() */




/**
 *******************************************************************************************************
 @brief #### Copy CVs into a common params struct (KSSPSAT_PARAMS) used to steer this sequence module

 @param[out] params Pointer to the ksspsat params struct used to steer the behavior of this spsat
                    sequence module
 @return void
********************************************************************************************************/
void ksspsat_eval_copycvs(KSSPSAT_PARAMS *params) {

  /* RF */
  params->flip = ksspsat_flip;
  params->rftype = ksspsat_rftype;

  /* SELRF postgrad (acting as spoiler after each SAT RF) */
  params->spoilerscale = ksspsat_spoilerscale;

  params->ssi_time = ksspsat_ssi_time;

  params->oblmethod = ksspsat_oblmethod;

} /* ksspsat_eval_copycvs() */



/**
 *******************************************************************************************************
 @brief #### Get number of Graphical (GRx) Sat pulses that are active in the UI

 This function returns the number of graphical saturation pulses that have been explicitly placed out
 in the UI by the user. This includes both implicit and explicit sat bands. *Implicit* sat bands occur
 when the user selects a sat edge (S,I,A,P,R,L) of the FOV but does not click on the localizer image.
 Implicit sat bands are parallel to the logical axes and do not need a unique rotation matrix, and which
 FOV side to saturate is determined by the logical gradient axis choice (XGRAD, YGRAD, ZGRAD).

 @param[in] ksspsat Pointer to KSSPSAT_SEQUENCE
 @return numsats Number of GRx Sat pulses active in the UI
********************************************************************************************************/
int ksspsat_eval_numsats(KSSPSAT_SEQUENCE *ksspsat) {
  int i;
  int n = 0;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++)
    n += ksspsat[i].satlocation.active != KSSPSAT_OFF;

  return n;

} /* ksspsat_eval_numsats() */


/**
 *******************************************************************************************************
 @brief #### Get the FOV volume borders in mm from the isocenter

 @param[out] v Pointer to the KSSPSAT_VOLBORDER struct holding this information
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval_volborder(KSSPSAT_VOLBORDER *v) {
  int i, nslices;

  if (KS_3D_SELECTED)
    nslices = exist(opslquant) * exist(opvquant);
  else
    nslices = exist(opslquant);

  v->freq_min = scan_info[0].oprloc;
  v->freq_max = scan_info[0].oprloc;
  v->phase_min = scan_info[0].opphasoff;
  v->phase_max = scan_info[0].opphasoff;
  v->slice_min = scan_info[0].optloc;
  v->slice_max = scan_info[0].optloc;

  for (i = 1; i < nslices; i++) {
    if (scan_info[i].oprloc > v->freq_max)
      v->freq_max = scan_info[i].oprloc;
    else if (scan_info[i].oprloc < v->freq_min)
      v->freq_min = scan_info[i].oprloc;

    if (scan_info[i].opphasoff > v->phase_max)
      v->phase_max = scan_info[i].opphasoff;
    else if (scan_info[i].opphasoff < v->phase_min)
      v->phase_min = scan_info[i].opphasoff;

    if (scan_info[i].optloc > v->slice_max)
      v->slice_max = scan_info[i].optloc;
    else if (scan_info[i].optloc < v->slice_min)
      v->slice_min = scan_info[i].optloc;
  }

  v->freq_min -= exist(opfov)/ 2.0;
  v->freq_max += exist(opfov)/ 2.0;
  v->phase_min -= (exist(opfov) * exist(opphasefov))/ 2.0;
  v->phase_max += (exist(opfov) * exist(opphasefov))/ 2.0;
  v->slice_min -= exist(opslthick)/ 2.0;
  v->slice_max += exist(opslthick)/ 2.0;

  return SUCCESS;

} /* ksspsat_eval_volborder() */




/**
 *******************************************************************************************************
 @brief #### Populate the `satlocation` field of the KSSPSAT_PARAMS struct

 This function gets information from the UI regarding the sat pulses, whether they are implicit or
 explicit, their thickness and offset, and for explicit pulses also the rotation matrix.

 The user can select up to 6 sat band in total in the UI, which may be only implicit or explicit, or a
 mix of both. First, information on the implicit sat pulses is collected by checking for the CVs `opsatx`
 etc. (managed by the host interface, i.e. the UI). The UI maps `opsatx` to frequency encoding (despite
 that the sat is expressed in patient terms: Superior, Inferior, etc.), and correspondingly `opsaty` maps
 to the phase encoding direction and `opsatz` to the slice direction.

 When two oppositely placed implicit sat bands have different thickness, `opsatx` (and `opsaty`/`opsatz`)
 is set to KSSPSAT_PARA (4), indicating that two separate RF pulses should be played out. When two
 oppositely placed implicit sat bands have the same thickness, `opsatx` = KSSPSAT_HAD (3), which is an
 indication for that a single hadamard RF pulse should be used to saturate both sides. This is not yet
 supported, so for now both KSSPSAT_HAD and KSSPSAT_PARA will result in two separate RF pulses.

 If the user selects one of the sat band buttons (S,I,A,P,R,L), and then also clicks on the localizer
 image, the implicit sat (one of S,I,A,P,R,L) is now replaced with an explicit sat. The UI sets then the
 corresponding `opsatx/y/z` to 0, and sets instead one of the bits in the bitmask CV `opexsatmask`.

 Explicit sat bands receives the rotation information from the transpose of `eg_sat_rot` instead of the
 `scan_info` struct, slice selection is always ZGRAD, the thickness is taken from `opexsatthick1-6`, and
 the slice offset from `opexsatloc1-6`.

 @param[in,out] ksspsat Pointer to KSSPSAT_SEQUENCE
 @param[in] params Pointer to the ksspsat params struct used to steer the behavior of this spsat
                    sequence module
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval_satplacements_from_UI(KSSPSAT_SEQUENCE *ksspsat, KSSPSAT_PARAMS *params) {
  STATUS status;
  int i, j;
  float sat_info[6][9];


  /***************** IMPLICIT SAT (at the FOV edges) *****************/


  /* Determine FOV box */
  status = ksspsat_eval_volborder(&params->volborder);
  if (status != SUCCESS) return status;

  /* Init all sat bands to off state */
  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++)
    ksspsat[i].satlocation.active = KSSPSAT_OFF;

  /* Init all sat rotations to scan plane */
  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++)
    memcpy(ksspsat[i].satlocation.loc.oprot, scan_info[0].oprot, 9 * sizeof(float));

  /* Implicit sat thicknesses */
  ksspsat[KSSPSAT_1].satlocation.thickness = (float) exist(opdfsathick1);
  ksspsat[KSSPSAT_2].satlocation.thickness = (float) exist(opdfsathick2);
  ksspsat[KSSPSAT_3].satlocation.thickness = (float) exist(opdfsathick3);
  ksspsat[KSSPSAT_4].satlocation.thickness = (float) exist(opdfsathick4);
  ksspsat[KSSPSAT_5].satlocation.thickness = (float) exist(opdfsathick5);
  ksspsat[KSSPSAT_6].satlocation.thickness = (float) exist(opdfsathick6);


  /* Implicit Sat(s) - Frequency encoding direction */
  if (opsatx == KSSPSAT_POS || opsatx == KSSPSAT_PARA || opsatx == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_2].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_2].satlocation.loc.optloc = params->volborder.freq_max + ksspsat[KSSPSAT_2].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_2].satlocation.gradboard = XGRAD;
  }
  if (opsatx == KSSPSAT_NEG || opsatx == KSSPSAT_PARA || opsatx == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_1].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_1].satlocation.loc.optloc = params->volborder.freq_min - ksspsat[KSSPSAT_1].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_1].satlocation.gradboard = XGRAD;
  }

  /* Implicit Sat(s) - Phase encoding direction */
  if (opsaty == KSSPSAT_POS || opsaty == KSSPSAT_PARA || opsaty == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_4].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_4].satlocation.loc.optloc = params->volborder.phase_max + ksspsat[KSSPSAT_4].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_4].satlocation.gradboard = YGRAD;
  }
  if (opsaty == KSSPSAT_NEG || opsaty == KSSPSAT_PARA || opsaty == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_3].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_3].satlocation.loc.optloc = params->volborder.phase_min - ksspsat[KSSPSAT_3].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_3].satlocation.gradboard = YGRAD;
  }

  /* Implicit Sat(s) - Slice direction */
  if (opsatz == KSSPSAT_POS || opsatz == KSSPSAT_PARA || opsatz == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_6].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_6].satlocation.loc.optloc = params->volborder.slice_max + ksspsat[KSSPSAT_6].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_6].satlocation.gradboard = ZGRAD;
  }
  if (opsatz == KSSPSAT_NEG || opsatz == KSSPSAT_PARA || opsatz == KSSPSAT_HAD) {
    ksspsat[KSSPSAT_5].satlocation.active = KSSPSAT_IMPLICIT;
    ksspsat[KSSPSAT_5].satlocation.loc.optloc = params->volborder.slice_min - ksspsat[KSSPSAT_5].satlocation.thickness/ 2.0;
    ksspsat[KSSPSAT_5].satlocation.gradboard = ZGRAD;
  }



  /***************** EXPLICIT SAT (manually placed) *****************/


  /* matrix transpose */
  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    sat_info[i][0] = eg_sat_rot[i][0];
    sat_info[i][1] = eg_sat_rot[i][3];
    sat_info[i][2] = eg_sat_rot[i][6];
    sat_info[i][3] = eg_sat_rot[i][1];
    sat_info[i][4] = eg_sat_rot[i][4];
    sat_info[i][5] = eg_sat_rot[i][7];
    sat_info[i][6] = eg_sat_rot[i][2];
    sat_info[i][7] = eg_sat_rot[i][5];
    sat_info[i][8] = eg_sat_rot[i][8];
  }

  int exsat_mask = 1;
  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++, exsat_mask = exsat_mask << 1) {

    /* 0-5: I, S, P, A, L, R */
    if (opexsatmask & exsat_mask) {

      int freeslot = KS_NOTSET;

      for (j = 0; j < KSSPSAT_MAXNUMSAT; j++) {
        if (ksspsat[j].satlocation.active == KSSPSAT_OFF) {
          freeslot = j;
          break;
        }
      }
      if (freeslot == KS_NOTSET) {
        return ks_error("%s: No free slots for explicit sat", __FUNCTION__);
      }

      /* mark as explicit sat */
      ksspsat[freeslot].satlocation.active = KSSPSAT_EXPLICIT;

      /* copy rotation matrix from sat_info[][] array set up by the host interface (not the psd) */
      memcpy(ksspsat[freeslot].satlocation.loc.oprot, sat_info[i], 9 * sizeof(float));

      /* Always ZGRAD since we are setting the slice angle via the rotation matrix for explicit sat */
      ksspsat[freeslot].satlocation.gradboard = ZGRAD;

      /* Transmit location and thickness from CVs set by the host interface (not the psd) */
      if (i == KSSPSAT_1) {
        ksspsat[freeslot].satlocation.thickness = opexsathick1;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc1;
      } else if (i == KSSPSAT_2) {
        ksspsat[freeslot].satlocation.thickness = opexsathick2;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc2;
      } else if (i == KSSPSAT_3) {
        ksspsat[freeslot].satlocation.thickness = opexsathick3;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc3;
      } else if (i == KSSPSAT_4) {
        ksspsat[freeslot].satlocation.thickness = opexsathick4;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc4;
      } else if (i == KSSPSAT_5) {
        ksspsat[freeslot].satlocation.thickness = opexsathick5;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc5;
      } else if (i == KSSPSAT_6) {
        ksspsat[freeslot].satlocation.thickness = opexsathick6;
        ksspsat[freeslot].satlocation.loc.optloc = opexsatloc6;
      }

    }
  }


  return SUCCESS;

} /* ksspsat_eval_satplacements_from_UI() */




/**
 *******************************************************************************************************
 @brief #### Writes out the geometric information of the active sat bands to `spsat.txt`

 On the MR system (PSD_HW), this file will be located in `/usr/g/mrraw`, while in simulation it will be
 located in the current psd directory.

 @param[in] ksspsat Pointer to KSSPSAT_SEQUENCE
 @param[in] params Pointer to the ksspsat params struct used to steer the behavior of this spsat
                    sequence module
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval_satplacements_dump(KSSPSAT_SEQUENCE *ksspsat, KSSPSAT_PARAMS *params) {
  float *rot;
  int i;

#ifdef PSD_HW
  FILE *fp = fopen("/usr/g/mrraw/spsat.txt", "w");
#else
  FILE *fp = fopen("./spsat.txt", "w");
#endif

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    fprintf(fp, "Sat Pulse #%d: ", i);
    if (ksspsat[i].satlocation.active == KSSPSAT_OFF)
      fprintf(fp, "Off\n");
    else if (ksspsat[i].satlocation.active == KSSPSAT_EXPLICIT)
      fprintf(fp, "Explicit\n");
    else if (ksspsat[i].satlocation.active == KSSPSAT_IMPLICIT)
      fprintf(fp, "Implicit\n");

    fprintf(fp, "Grad: ");
    if (ksspsat[i].satlocation.gradboard == XGRAD)
      fprintf(fp, "XGRAD (Freq)");
    else if (ksspsat[i].satlocation.gradboard == YGRAD)
      fprintf(fp, "YGRAD (Phase)");
    else if (ksspsat[i].satlocation.gradboard == ZGRAD)
      fprintf(fp, "ZGRAD (Slice)");

    fprintf(fp, "\nThickness: %.2f\n", ksspsat[i].satlocation.thickness);
    fprintf(fp, "Location: %.2f\n", ksspsat[i].satlocation.loc.optloc);

    rot = ksspsat[i].satlocation.loc.oprot;
    fprintf(fp, "Rotation:\n");
    fprintf(fp, "%.3f %.3f %.3f\n%.3f %.3f %.3f\n%.3f %.3f %.3f\n\n", rot[0], rot[3], rot[6], rot[1], rot[4], rot[7], rot[2], rot[5], rot[8]);
  }

  fprintf(fp, "Volume borders:\n-  Freq: %.2f %.2f\n- Phase: %.2f %.2f\n- Slice: %.2f %.2f\n", params->volborder.freq_min, params->volborder.freq_max, params->volborder.phase_min, params->volborder.phase_max, params->volborder.slice_min, params->volborder.slice_max);

  rot = scan_info[0].oprot;
  fprintf(fp, "\nSlice rotation:\n");
  fprintf(fp, "%.3f %.3f %.3f\n%.3f %.3f %.3f\n%.3f %.3f %.3f\n\n", rot[0], rot[3], rot[6], rot[1], rot[4], rot[7], rot[2], rot[5], rot[8]);



  fclose(fp);

  return SUCCESS;

}




/**
 *******************************************************************************************************
 @brief #### Assigns a loggrd structure specific to the spatial saturation sequence module

 @param[out] satloggrd Pointer to LOG_GRAD
 @param[in] slice_info Pointer to SCAN_INFO, holding rotation information about current sat slice
 @param[in] satoblmethod PSD_OBL_RESTRICT or PSD_OBL_OPTIMAL
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval_loggrd(LOG_GRAD *satloggrd, SCAN_INFO *slice_info, int satoblmethod) {
  int initnewgeo = 1;

  /* copy loggrd from GERequired.e */
  *satloggrd = loggrd;

  if (obloptimize(satloggrd, &phygrd, slice_info, 1, ((satoblmethod == PSD_OBL_RESTRICT) ? 4 /*oblique plane*/ : opphysplane), exist(opcoax),
                  (int) satoblmethod, exist(obl_debug), &initnewgeo, cfsrmode) == FAILURE) {
    return ks_error("%s: obloptimize failed", __FUNCTION__);
  }

  return SUCCESS;

}




/**
 *******************************************************************************************************
 @brief #### Sets up the sequence objects for the spatial sat sequence module (KSSPSAT_SEQUENCE ksspsat)

 This spatial sat sequence module consists of an RF pulse (selectable via `ksspsat_params.rftype`.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval_setupobjects() {
  STATUS status;
  int i;

  status = ksspsat_eval_satplacements_from_UI(ksspsat, &ksspsat_params);
  if (status != SUCCESS) return status;

  if (ksspsat_debug) {
    status = ksspsat_eval_satplacements_dump(ksspsat, &ksspsat_params);
    if (status != SUCCESS) return status;
  }

  /* Fill in the struct ksspsat_params based on corresponding ksspsat_*** CVs (see CV section)
     The CVs should only be used to steer the content of field .params, which in turn should control further decisions */
  ksspsat_eval_copycvs(&ksspsat_params);

  if (! ksspsat_eval_numsats(ksspsat)) {
    return SUCCESS;
  }

  /* up to 6 (KSSPSAT_MAXNUMSAT) selective RF pulses */
  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {

    if (ksspsat[i].satlocation.active != KSSPSAT_OFF) {    
      char tmpstr[100];
      if (ksspsat_params.rftype == KSSPSAT_RF_COMPLEX) {
        ksspsat[i].selrf.rf = spsatc_satqptbw12; /* Complex Sat RF pulse. KSFoundation_GERF.h */
      } else {
        ksspsat[i].selrf.rf = spsat_dblsatl0; /* SLR Sat RF pulse. KSFoundation_GERF.h */
      }
      ksspsat[i].selrf.rf.flip = ksspsat_params.flip;
      ksspsat[i].selrf.slthick = ksspsat[i].satlocation.thickness;
      ksspsat[i].selrf.crusherscale = ksspsat_params.spoilerscale; /* as rf role is KS_RF_ROLE_SPSAT, only postgrad will be active */
      sprintf(tmpstr, "ksspsat%d_selrf", i+1);

      /* obloptimize sat (satloggrd declared in epic.h) */
      ksspsat_eval_loggrd(&satloggrd, &ksspsat[i].satlocation.loc, ksspsat_params.oblmethod);

      if (ks_eval_selrf_constrained(&ksspsat[i].selrf, tmpstr, ks_syslimits_ampmax(satloggrd), ks_syslimits_slewrate(satloggrd)) == FAILURE)
        return FAILURE;


      /* setup seqctrl with desired SSI time and zero duration. .min_duration will be set in ksspsat_pg() */
      ks_init_seqcontrol(&ksspsat->seqctrl);
      sprintf(tmpstr, "ksspsat%d", i+1);
      strcpy(ksspsat[i].seqctrl.description, tmpstr);

    } /* if active */


  } /* for KSSPSAT_MAXNUMSAT */


  return SUCCESS;

} /* ksspsat_eval_setupobjects() */




/**
 *******************************************************************************************************
 @brief #### Spatial Sat evaluation function, to be called from the cveval() function of the main sequence

 This function calls ksspsat_eval_setupobjects() to design the RF pulse and spoiler for this spatial sat
 sequence module. It then calls ksspsat_pg() to determine the (minimum) sequence module duration.
 Finally, the sequence module `ksspsat` is added to the sequence collection struct passed in from the
 cveval() function of the main sequence.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_eval(KS_SEQ_COLLECTION *seqcollection) {
  STATUS status;
  int i;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    ksspsat_init_sequence(&ksspsat[i]);
  }

  status = ksspsat_eval_setupobjects();
  if (status != SUCCESS) return status;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {

    if (ksspsat[i].satlocation.active != KSSPSAT_OFF) {

      status = ksspsat_pg(&ksspsat[i]);
      if (status != SUCCESS) return status;

      /* ks_eval_addtoseqcollection() will only add to collection if ksspsat.seqctrl.duration > 0 */
      status = ks_eval_addtoseqcollection(seqcollection, &ksspsat[i].seqctrl);
      if (status != SUCCESS) return status;

    } /* if active */

  }

  return status;

} /* ksspsat_eval() */




/*******************************************************************************************************
*******************************************************************************************************
*
*  KSSpSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/








/**
 *******************************************************************************************************
 @brief #### The ksspsat (spatial sat) pulse sequence module

 This is the spatial sat sequence module in ksspsat.e using the sequence objects in KSSPSAT_SEQUENCE with
 the sequence module name "ksspsat" (= ksspsat.seqctrl.description). On HOST, the minimum duration
of the sequence module is set by ks_eval_seqctrl_setminduration().

@param[in, out] ksspsat Pointer to KSSPSAT_SEQUENCE
@retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksspsat_pg(KSSPSAT_SEQUENCE *ksspsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  if (ksspsat->satlocation.active == KSSPSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksspsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* SelRF (including postgrad for spoiler) */
  loc.board = ksspsat->satlocation.gradboard;
  status = ks_pg_selrf(&ksspsat->selrf, loc, &ksspsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Optional spoiling using the postgrad trapezoid on the remaining two axes */
  if (ksspsat_params.spoilallaxes) {
    KS_SEQLOC tmploc = loc;
    tmploc.pos += ksspsat->selrf.grad.duration;
    switch (ksspsat->satlocation.gradboard) {
    case XGRAD:
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case YGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = ZGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    case ZGRAD:
      tmploc.board = XGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      tmploc.board = YGRAD; status = ks_pg_trap(&ksspsat->selrf.postgrad, tmploc, &ksspsat->seqctrl); if (status != SUCCESS) return status;
      break;
    }
  }

  loc.pos += ksspsat->selrf.grad.duration + ksspsat->selrf.postgrad.duration + KS_RFSSP_POSTTIME;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (ksspsat->seqctrl.ssi_time must be > 0 and is added to ksspsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if ksspsat_params.satmode = KSSPSAT_OFF, then 2nd arg will be zero, making both ksspsat->seqctrl.min_duration and .duration = 0 */
  ksspsat->seqctrl.ssi_time = ksspsat_params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksspsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksspsat_pg() */



STATUS ksspsat_pulsegen() {
  int i;

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {
    if (ksspsat[i].satlocation.active != KSSPSAT_OFF) {

      ksspsat_pg(&ksspsat[i]);

      switch (i) {
      case KSSPSAT_1:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat1, "seqKSSpSat1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat1, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat1) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat1 = %d\n", idx_seqKSSpSat1 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat1;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_2:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat2, "seqKSSpSat2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat2, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat2) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat2 = %d\n", idx_seqKSSpSat2 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat2;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_3:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat3, "seqKSSpSat3");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat3, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat3);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat3 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat3) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat3 = %d\n", idx_seqKSSpSat3 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat3;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat3;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat3;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_4:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat4, "seqKSSpSat4");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat4, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat4);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat4 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat4) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat4 = %d\n", idx_seqKSSpSat4 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat4;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat4;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat4;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_5:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat5, "seqKSSpSat5");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat5, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat5);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat5 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat5) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat5 = %d\n", idx_seqKSSpSat5 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat5;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat5;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat5;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      case KSSPSAT_6:
         
    {
      if (ksspsat[i].seqctrl.duration > 0) {

        if (ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksspsat[i].seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSSpSat6, "seqKSSpSat6");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }  
          status = createseq(&seqKSSpSat6, ksspsat[i].seqctrl.duration - ksspsat[i].seqctrl.ssi_time, off_seqKSSpSat6);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSSpSat6 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSSpSat6) failed", ksspsat[i].seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSSpSat6 = %d\n", idx_seqKSSpSat6 );
          ksspsat[i].seqctrl.handle.index = idx_seqKSSpSat6;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksspsat[i].seqctrl.handle.offset = off_seqKSSpSat6;
          ksspsat[i].seqctrl.handle.pulse = &seqKSSpSat6;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  
        break;
      }

    }
  }

  return SUCCESS;
}





/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE

 This function sets the current state of all ksspsat sequence objects being part of KSSPSAT_SEQUENCE,
 incl. gradient amplitude changes, RF freq/phase for the current slice position.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void ksspsat_scan_seqstate(KSSPSAT_SEQUENCE *ksspsat, float rfphase) {
#ifdef IPG

  if (ksspsat->satlocation.active != KSSPSAT_OFF) {
    ks_scan_rotate(ksspsat->satlocation.loc);
    ks_scan_selrf_setfreqphase(&ksspsat->selrf, 0, ksspsat->satlocation.loc, rfphase);
  }

#endif
}




int ksspsat_scan_playsequences(int perform_slicetimeplot) {
  int i;
  int time = 0;
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  for (i = 0; i < KSSPSAT_MAXNUMSAT; i++) {

    ksspsat_scan_seqstate(&ksspsat[i], rfphase);

    time += ks_scan_playsequence(&ksspsat[i].seqctrl);

    if (perform_slicetimeplot) {
      /* spatial sat not necessarily in the slice direction, so can't trust its thickness or direction.
        save it as 1000 mm thick at center (0) for now just to be able to mark it in time in the plot */
      ks_plot_slicetime(&ksspsat[i].seqctrl, 1, NULL, KS_NOTSET, KS_PLOT_STANDARD);
    }

  }

  return time;
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSChemSat.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
  *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSChemSat.e
* @brief This file contains FatSat (KSChemSat) and should be `@inline`'d at the beginning of a KSFoundation PSD
********************************************************************************************************/

/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSChemSat.e: HOST functions and variables
 *
 *******************************************************************************************************
 *******************************************************************************************************/

/**
 *******************************************************************************************************
 @brief #### Resets the KSCHEMSAT_PARAMS struct (arg 1) to KSCHEMSAT_INIT_PARAMS
 @param[out] params Pointer to the kschemsat params struct used to steer the behavior of this fatsat
                    sequence module
 @return void
********************************************************************************************************/
void kschemsat_init_params(KSCHEMSAT_PARAMS *params) {
  KSCHEMSAT_PARAMS defparams = KSCHEMSAT_INIT_PARAMS;
  *params = defparams;
}




/**
 *******************************************************************************************************
 @brief #### Resets the KSCHEMSAT_SEQUENCE struct (arg 1) to KSCHEMSAT_INIT_SEQUENCE

 As KSCHEMSAT_INIT_SEQUENCE contains KSCHEMSAT_PARAMS, which sets the field `.satmode = KSCHEMSAT_OFF`,
 calling kschemsat_init_sequence() will disable the `kschemsat` sequence module (i.e. turn off fatsat)

 @param[out] kschemsat Pointer to KSCHEMSAT_SEQUENCE
 @return void
********************************************************************************************************/
void kschemsat_init_sequence(KSCHEMSAT_SEQUENCE *kschemsat) {
  KSCHEMSAT_SEQUENCE defseq = KSCHEMSAT_INIT_SEQUENCE;
  *kschemsat = defseq;
  strcpy(kschemsat->seqctrl.description, "kschemsat");
} /* kschemsat_init_sequence() */




/**
 *******************************************************************************************************
 @brief #### Copy CVs into a common params struct (KSCHEMSAT_PARAMS) used to steer this sequence module

 @param[out] params Pointer to the kschemsat params struct used to steer the behavior of this fatsat
                    sequence module
 @return void
********************************************************************************************************/
void kschemsat_eval_copycvs(KSCHEMSAT_PARAMS *params) {

  params->satmode = kschemsat_flag;

  /* RF */
  params->flip = kschemsat_flip;
  params->rfoffset = kschemsat_rfoffset;
  params->rftype = kschemsat_rftype;
  if (params->rftype == KSCHEMSAT_RF_SINC) {
    params->sincrf_bw = kschemsat_sinc_bw;
    params->sincrf_tbp = kschemsat_sinc_tbp;
  } else {
    params->sincrf_bw = KS_NOTSET;
    params->sincrf_tbp = KS_NOTSET;
  }

  /* Spoiler */
  params->spoilerarea = kschemsat_spoilerarea;

  /* SSI time */
  params->ssi_time = kschemsat_ssi_time;

} /* kschemsat_eval_copycvs() */




/**
 *******************************************************************************************************
 @brief #### Sets up the sequence objects for the chemsat sequence module (KSCHEMSAT_SEQUENCE kschemsat)

 This fatsat sequence module consists of an RF pulse (selectable via `.params.rftype` and a spoiler
 trapezoid gradient.

 @param[in,out] kschemsat Pointer to KSCHEMSAT_SEQUENCE
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS kschemsat_eval_setupobjects(KSCHEMSAT_SEQUENCE *kschemsat) {
  STATUS status;

  kschemsat_rfoffset  = _kschemsat_rfoffset.fixedflag ?  ((void)(0), kschemsat_rfoffset) : 0;
  if (opfat) {
    kschemsat_flag  = _kschemsat_flag.fixedflag ?  ((void)(KSCHEMSAT_FAT), kschemsat_flag) : KSCHEMSAT_FAT;
    kschemsat_rfoffset  = _kschemsat_rfoffset.fixedflag ?   ((void)(-(float)SDL_GetChemicalShift(cffield)), kschemsat_rfoffset) : -(float)SDL_GetChemicalShift(cffield);
  } else if (opwater) {
    kschemsat_flag  = _kschemsat_flag.fixedflag ?  ((void)(KSCHEMSAT_WATER), kschemsat_flag) : KSCHEMSAT_WATER;
  } else {
    kschemsat_flag  = _kschemsat_flag.fixedflag ?  ((void)(KSCHEMSAT_OFF), kschemsat_flag) : KSCHEMSAT_OFF;
  }

  if (cffield == 30000) {
    kschemsat_sinc_bw  = _kschemsat_sinc_bw.fixedflag ?  ((void)(KSCHEMSAT_DEFAULT_SINCRF_BW_3T), kschemsat_sinc_bw) : KSCHEMSAT_DEFAULT_SINCRF_BW_3T;
  } else {
    kschemsat_sinc_bw  = _kschemsat_sinc_bw.fixedflag ?  ((void)(KSCHEMSAT_DEFAULT_SINCRF_BW_15T), kschemsat_sinc_bw) : KSCHEMSAT_DEFAULT_SINCRF_BW_15T;
  }

  /* Fill in the struct kschemsat.sequence.params based on corresponding kschemsat_*** CVs (see CV section)
     The CVs should only be used to steer the content of field .params, which in turn should control further decisions */
  kschemsat_eval_copycvs(&kschemsat->params);

  if (kschemsat->params.satmode == KSCHEMSAT_OFF) {
    kschemsat_init_sequence(kschemsat);
    return SUCCESS;
  }

  /* RF */
  if (kschemsat->params.rftype == KSCHEMSAT_RF_SINC) {
    /* create a KS_RF using ks_eval_rf_sinc */
    status = ks_eval_rf_sinc(&kschemsat->rf, "kschemsat_rf", kschemsat->params.sincrf_bw, kschemsat->params.sincrf_tbp, kschemsat->params.flip, KS_RF_SINCWIN_HAMMING);
    if (status != SUCCESS) return status;
    kschemsat->rf.role = KS_RF_ROLE_CHEMSAT;
  } else {
    if (cffield == 30000)
      kschemsat->rf = chemsat_cs3t; /* KSFoundation_GERF.h */
    else
      kschemsat->rf = chemsat_csm; /* KSFoundation_GERF.h */
    kschemsat->rf.flip = kschemsat->params.flip;
    if (ks_eval_rf(&kschemsat->rf, "kschemsat_rf") == FAILURE)
      return FAILURE;
  }
  kschemsat->rf.cf_offset = kschemsat->params.rfoffset; /* Exciter offset in Hz */

  /* ks_print_rf(kschemsat->rf, stderr); fflush(stderr); */

  /* set up spoiler */
  kschemsat->spoiler.area = kschemsat->params.spoilerarea;
  status = ks_eval_trap(&kschemsat->spoiler, "kschemsat_spoiler");
  if (status != SUCCESS) return status;


  /* setup seqctrl with desired SSI time and zero duration. .min_duration will be set in kschemsat_pg() */
  ks_init_seqcontrol(&kschemsat->seqctrl);
  strcpy(kschemsat->seqctrl.description, "kschemsat");

  return SUCCESS;

} /* kschemsat_eval_setupobjects() */





/**
 *******************************************************************************************************
 @brief #### Chemsat evaluation function, to be called from the cveval() function of the main sequence

 This function calls kschemsat_eval_setupobjects() to design the RF pulse and spoiler for this fatsat
 sequence module. It then calls kschemsat_pg() to determine the (minimum) sequence module duration.
 Finally, the sequence module `kschemsat` is added to the sequence collection struct passed in from the
 cveval() function of the main sequence.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS kschemsat_eval(KS_SEQ_COLLECTION *seqcollection) {
  STATUS status;

  /* N.B.:
    - UI CV opfat = 1: FatSat (kschemsat_flag = KSCHEMSAT_FAT)
    - UI CV opwater = 1: WaterSat (kschemsat_flag = KSCHEMSAT_WATER)
    - UI CV opfat = opwater = 0: Off
  */
  status = kschemsat_eval_setupobjects(&kschemsat);
  if (status != SUCCESS) return status;

  /* kschemsat_pg() will return early if kschemsat.params.satmode == KSCHEMSAT_OFF => kschemsat.seqctrl.duration = 0 */
  status = kschemsat_pg(&kschemsat);
  if (status != SUCCESS) return status;

  /* ks_eval_addtoseqcollection() will only add to collection if kschemsat.seqctrl.duration > 0 */
  status = ks_eval_addtoseqcollection(seqcollection, &kschemsat.seqctrl);
  if (status != SUCCESS) return status;

  return status;

} /* kschemsat_eval() */




/*******************************************************************************************************
*******************************************************************************************************
*
*  KSChemSat.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### The kschemsat (fatsat) pulse sequence module

 This is the fatsat sequence module in kschemsat.e using the sequence objects in KSCHEMSAT_SEQUENCE with
 the sequence module name "kschemsat" (= kschemsat.seqctrl.description). On HOST, the minimum duration
 of the sequence module is set by ks_eval_seqctrl_setminduration().

 @param[in,out] kschemsat Pointer to KSCHEMSAT_SEQUENCE
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS kschemsat_pg(KSCHEMSAT_SEQUENCE *kschemsat) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;
  loc.pos = RUP_GRD(KS_RFSSP_PRETIME + 32);

  /* return early if sat mode is off */
  if (kschemsat->params.satmode == KSCHEMSAT_OFF) {
    return SUCCESS;
  }

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (kschemsat->seqctrl.duration == 0)
    return SUCCESS;
#endif

  /* RF */
  status = ks_pg_rf(&kschemsat->rf, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->rf.rfwave.duration;

  /* Y spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  /* Z spoiler */
  loc.board = ZGRAD;
  status = ks_pg_trap(&kschemsat->spoiler, loc, &kschemsat->seqctrl);
  if (status != SUCCESS) return status;

  loc.pos += kschemsat->spoiler.duration;

 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksspsat->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* HOST only: Sequence duration (kschemsat->seqctrl.ssi_time must be > 0 and is added to kschemsat->seqctrl.min_duration in ks_eval_seqctrl_setminduration()
     if kschemsat->params.satmode = KSCHEMSAT_OFF, then 2nd arg will be zero, making both kschemsat->seqctrl.min_duration and .duration = 0 */
  kschemsat->seqctrl.ssi_time = kschemsat->params.ssi_time;
  ks_eval_seqctrl_setminduration(&kschemsat->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* kschemsat_pg() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE

 This function sets the current state of all kschemsat sequence objects being part of KSCHEMSAT_SEQUENCE,
 incl. gradient amplitude and RF phase changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more.

 @return void
********************************************************************************************************/
void kschemsat_scan_seqstate(KSCHEMSAT_SEQUENCE *kschemsat) {
#ifdef IPG
  static int counter = 0;

  float rfphase = ks_scan_rf_phase_spoiling(counter++);

  ks_scan_rf_setphase(&kschemsat->rf, INSTRALL, rfphase);

#endif
}


/*******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : KSInversion.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file KSInversion.e
* @brief This file contains an inversion preparation module that should be `@inline`'d at the beginning
         of a KSFoundation PSD
********************************************************************************************************/




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  KSInversion.e: HOST functions and variables
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Resets the KSINV_PARAMS struct (arg 1) to KSINV_INIT_PARAMS

 @param[out] params Pointer to the ksinv params struct used to steer the behavior of this inversion
                     sequence module
 @return void
********************************************************************************************************/
void ksinv_init_params(KSINV_PARAMS *params) {
  KSINV_PARAMS defparams = KSINV_INIT_PARAMS;
  *params = defparams;
} /* ksinv_init_params() */




/**
 *******************************************************************************************************
 @brief #### Resets the KSINV_SEQUENCE struct (arg 1) to KSINV_INIT_SEQUENCE

 As KSINV_INIT_SEQUENCE contains KSINV_PARAMS, which sets the field `.irmode = KSINV_OFF`,
 calling ksinv_init_sequence() will disable the `ksinversion` sequence module (i.e. turn off inversion)

 @param[out] ksinv Pointer to KSINV_SEQUENCE
 @return void
********************************************************************************************************/
void ksinv_init_sequence(KSINV_SEQUENCE *ksinv) {
  KSINV_SEQUENCE defseq = KSINV_INIT_SEQUENCE;
  *ksinv = defseq;
  ksinv_init_params(&ksinv->params);
} /* ksinv_init_sequence() */




/**
 *******************************************************************************************************
 @brief #### Copy CVs into a common params struct (KSINV_PARAMS) used to steer this sequence module

 @param[out] params Pointer to the ksinv params struct used to steer the behavior of this inversion
                     sequence module
 @param[in] mode Inversion mode, one of: KSINV_OFF, KSINV_IR_SIMPLE, KSINV_IR_SLICEAHEAD, KSINV_FLAIR_BLOCK
 @return void
********************************************************************************************************/
void ksinv_eval_copycvs(KSINV_PARAMS *params, int mode) {

  ksinv_init_params(params);

  params->irmode = mode;

  if (params->irmode != KSINV_OFF) {
    params->flip = ksinv_flip;
    if (KS_3D_SELECTED) {
      params->slthick = opvthick * ksinv_slthickfact;
    } else {
      params->slthick = opslthick * ksinv_slthickfact;
    }
    params->rfoffset = ksinv_rfoffset;
    params->rftype = ksinv_rftype;
    params->spoilerarea = ksinv_spoilerarea;
    if (params->irmode == KSINV_IR_SLICEAHEAD) {
      params->approxti = ksinv_approxti; /* Only applicable for sliceahead mode */
    } else {
      params->approxti = FALSE;
    }
    params->startpos = RUP_GRD(ksinv_startpos);
    params->nslicesahead = 0;
    params->nflairslices = 0;

    if (params->irmode == KSINV_FLAIR_T2PREP_BLOCK) {
        params->slthick_exc = opslthick * ksinv_slthickfact_exc;
        params->flip_exc = ksinv_t2prep_exc_flip;
        params->N_Refoc = ksinv_t2prep_N_Refoc;
        params->t2prep_TE = ksinv_t2prep_TE;
        params->rftype_refoc = ksinv_t2prep_rftype_refoc;
    }   
  }

  /* SSI time */
  params->ssi_time = ksinv_ssi_time;

} /* ksinv_eval_copycvs() */




/**
 *******************************************************************************************************
 @brief #### Sets up the RF sequence object for the inversion sequence module (KSINV_SEQUENCE ksinv)

 This function is called from ksinv_eval_setupobjects()

 @param[in,out] ksinv Pointer to a KSINV_SEQUENCE sequence module to be set up
 @param[in] suffix Suffix string to att to "ksinv" for the description of the sequence module
 @param[in,out] custom_selrf Optional pointer to KS_SELRF for custom inversion RF pulse. Pass NULL to use
                         default RF pulses.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_setuprf(KSINV_SEQUENCE *ksinv, const char *suffix, KS_SELRF *custom_selrf) {
  STATUS status;
  char tmpstr[1000];

  /* if irmode == KSINV_OFF, reset and return */
  if (ksinv->params.irmode == KSINV_OFF) {
    ksinv_init_sequence(ksinv);
    return SUCCESS;
  }

  if (custom_selrf != NULL) {

    ksinv->selrfinv = *custom_selrf;
    ksinv->params.rftype = KSINV_RF_CUSTOM;
    return SUCCESS;

  } else if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {

    ksinv->selrfinv.rf = adinv_shNvrg5b; /* KSFoundation_GERF.h */

  } else if (ksinv->params.rftype == KSINV_RF_STD) {

    ksinv->selrfinv.rf = inv_invI0; /* KSFoundation_GERF.h */

  } else {

    return ks_error("%s: invalid RF type (ksinv.params.rftype = %d)", __FUNCTION__, ksinv->params.rftype);

  }

  /* N.B. The designed (i.e. nominal) flip angle varies a lot between GE's inversion RF pulses:
     - adinv_sh3t2: 250 deg.
     - shNvrg5b: 43.82 deg.
     - invI0: (non-adiabatic) 178 deg
     So it is important to set the desired FA now after the 'ksinv->selrfinv.rf =' assignment above.
     The relation between .selrfinv.rf.flip and .selrfinv.rf.rfpulse.nom_fa can be used internally for RF scaling
  */
  ksinv->selrfinv.rf.flip = ksinv->params.flip; /* desired FA */
  ksinv->selrfinv.rf.cf_offset = ksinv->params.rfoffset; /* Exciter offset in Hz */
  ksinv->selrfinv.slthick = ksinv->params.slthick;
  sprintf(tmpstr, "ksinv_selinv%s", suffix);

  status = ks_eval_selrf(&ksinv->selrfinv, tmpstr);
  if (status != SUCCESS) return status;


  return SUCCESS;

} /* ksinv_eval_setuprf() */


STATUS ksinv_eval_setupt2prep(KSINV_SEQUENCE *ksinv) {
  STATUS status;
    status = SUCCESS;

    ksinv->selrfexc.rf = exc_ssfse90new;
    ksinv->selrfexc.rf.flip = ksinv->params.flip_exc;
    ksinv->selrfexc.slthick = ksinv->params.slthick_exc;
    status = ks_eval_selrf(&ksinv->selrfexc, "ksinv_T2prep_exc");
    if (status != SUCCESS) return status;

    ksinv->selrfflip.rf = exc_ssfse90new;
    ksinv->selrfflip.slthick = ksinv->params.slthick_exc;
    ksinv->selrfflip.rf.flip = ksinv->params.flip_exc;
    status = ks_eval_selrf(&ksinv->selrfflip, "ksinv_T2prep_flip");
    if (status != SUCCESS) return status;

    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      /*adiabatic refoc and inversion pulses  */      
      if (cffield == 30000){
        ksinv->selrfinv.rf = adinv_sh3t2; /* KSFoundation_GERF.h */
      } else {
        ksinv->selrfinv.rf = adinv_shNvrg5b; /* KSFoundation_GERF.h */
      }
    } else {
      ksinv->selrfinv.rf = ref_se1b4;
    }

    if (ksinv->params.rftype_refoc == KSINV_RF_ADIABATIC) {
      /*adiabatic refoc and inversion pulses  */      
      if (cffield == 30000){
        ksinv->selrfrefoc.rf = adinv_sh3t2; /* KSFoundation_GERF.h */  
      } else {
        ksinv->selrfrefoc.rf = adinv_shNvrg5b; /* KSFoundation_GERF.h */         
      }
    } else {
      ksinv->selrfrefoc.rf = ref_se1b4;
    }

    ksinv->selrfrefoc.rf.role =  KS_RF_ROLE_REF;      
    ksinv->selrfrefoc.rf.flip = ksinv->params.flip;
    ksinv->selrfrefoc.slthick = ksinv->params.slthick;
    status = ks_eval_selrf(&ksinv->selrfrefoc, "ksinv_T2prep_refoc");
    if (status != SUCCESS) return status;

    ksinv->selrfinv.rf.role =  KS_RF_ROLE_INV;
    ksinv->selrfinv.rf.flip = ksinv->params.flip;
    ksinv->selrfinv.slthick = ksinv->params.slthick;
    status = ks_eval_selrf(&ksinv->selrfinv, "ksinv_T2prep_inv");
    if (status != SUCCESS) return status;

    ksinv->selrfflip.pregrad = ksinv->selrfflip.postgrad;
    /* ksinv->selrfexc.pregrad is empty --> no postgrad for selrfflip.postgrad*/
    ksinv->selrfflip.postgrad = ksinv->selrfexc.pregrad;

  return SUCCESS;

} /* ksinv_eval_setupt2prep() */

/**
 *******************************************************************************************************
 @brief #### Sets up the sequence objects for the inversion sequence module (KSINV_SEQUENCE ksinv)

 KSInversion.e has two inversion sequence modules, `ksinv1` and `ksinv2`, the latter only active for
 dual-IR. These are both declared in `@ipgexport` in KSInversion.e.

 This function takes one of these sequence modules as first input argument (called from
 ksinv_eval()) and sets up the sequence objects in that KSINV_SEQUENCE, with `suffix` as the unique suffix
 name for the sequence module (currently "1" and "2" in ksinv_eval()).

 @param[in,out] ksinv Pointer to a KSINV_SEQUENCE sequence module to be set up
 @param[in] suffix Suffix string to att to "ksinv" for the description of the sequence module
 @param[in,out] custom_selrf Optional pointer to KS_SELRF for custom inversion RF pulse. Pass NULL to use
                         default RF pulses.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_setupobjects(KSINV_SEQUENCE *ksinv, const char *suffix, KS_SELRF *custom_selrf) {
  STATUS status;
  char tmpstr[1000];

  /* if irmode == KSINV_OFF, reset and return */
  if (ksinv->params.irmode == KSINV_OFF) {
    ksinv_init_sequence(ksinv);
    return SUCCESS;
  }

  if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
    /* t2prepped selective RF inversion */
    status = ksinv_eval_setupt2prep(ksinv);
    if (status != SUCCESS) return status;
  } else {
    /* Selective RF inversion */
    status = ksinv_eval_setuprf(ksinv, suffix, custom_selrf);
    if (status != SUCCESS) return status;
  }

  /* set up spoiler */
  ksinv->spoiler.area = ksinv->params.spoilerarea;
  sprintf(tmpstr, "ksinv_spoiler%s", suffix);
  /* make a trap that has 3x lower slewrate than normal, since minimum IR seq duration is not time critical */
  status = ks_eval_trap_constrained(&ksinv->spoiler, tmpstr, ks_syslimits_ampmax(loggrd), ks_syslimits_slewrate(loggrd)/ 3.0, 0);
  /* status = ks_eval_trap(&ksinv->spoiler, tmpstr); */
  if (status != SUCCESS) return status;


  /* Name seqmodule and setup seqctrl with desired SSI time and zero duration. .min_duration will be set in ksinv_pg() */
  ks_init_seqcontrol(&ksinv->seqctrl);
  sprintf(tmpstr, "ksinv%s", suffix);
  strcpy(ksinv->seqctrl.description, tmpstr);

  return SUCCESS;

} /* ksinv_eval_setupobjects() */




/**
 *******************************************************************************************************
 @brief #### Calculates the TI value necessary to null the signal from a tissue with a given T1 value,
             the TR of the sequence and the main sequence duration, all in [us]

 @param[in] TR Repetition time in [us]
 @param[in] T1value The T1 value of the tissue to be nulled in [us]
 @param[in] seqdur The duration of the main sequence in [us]
 @retval TItime Inversion time in [us]
*/
int ksinv_eval_nullti(int TR, int T1value, int seqdur) {

  return (int) ((double) T1value * ( log(2.0) - log(1.0 + exp(-((double) TR - (double) seqdur)/((double) T1value))) ));

} /* ksinv_eval_nullti() */




/**
 *******************************************************************************************************
 @brief <h4>Sets the sequence module duration of a KSINV_SEQUENCE module based on an inversion time (TI)
            and the delay time from the start of the main sequence to its excitation center</h4>

 For simple main sequences consisting of only one sequence module each time it is played out (i.e. without
 additional fatsat or spatial sat sequences attached before each main sequence), `coreslice_momentstart`
 is typically a small value of a few [ms] indicating the isocenter of the excitation pulse of the main
 sequence measured from the start of the main sequence. When e.g. a fatsat pulse sequence module is added
 before each main sequence module, this needs to be taken into account to get the correct inversion time.
 In these cases `coreslice_momentstart` should be larger (to also include any leading extra sequence
 module between the inversion module and the main sequence module, and consequently the duration of the
 inversion module becomes proportionally smaller. If `TI` is short in relation to `coreslice_momentstart`
 this function will return an error.

 @param[in,out] ksinv Pointer to a KSINV_SEQUENCE sequence module
 @param[in] TI Desired inversion time in [us]
 @param[in] coreslice_momentstart The delay time from the end of the inversion module to the isocenter
                                   of the excitation pulse of the main sequence
 @retval TItime Inversion time in [us]
*/
STATUS ksinv_eval_duration(KSINV_SEQUENCE *ksinv, int TI, int coreslice_momentstart) {

  if (ksinv->seqctrl.momentstart <= 0) {
    return ks_error("%s: Moment start position of the inversion sequence (arg 1) must be > 0", __FUNCTION__);
  }
  if (TI <= 0) {
    return ks_error("%s: TI must be > 0", __FUNCTION__);
  }
  if (coreslice_momentstart <= 0) {
    return ks_error("%s: The core slice moment start position must be  > 0", __FUNCTION__);
  }
  if (ksinv->params.irmode != KSINV_IR_SIMPLE) {
       return ks_error("%s: ksinv.params.irmode must be KSINV_IR_SIMPLE for this function", __FUNCTION__);
  }

  ksinv->params.nslicesahead = 0;
  ksinv->params.nflairslices = 0;

  ksinv->seqctrl.duration = RUP_GRD(TI + ksinv->seqctrl.momentstart - coreslice_momentstart);

  if (ksinv->seqctrl.min_duration > ksinv->seqctrl.duration) {
    return ks_error("%s: Input args resulted in a a too short inv. seq. duration", __FUNCTION__);
  }

  return SUCCESS;

} /* ksinv_eval_duration() */




/**
 *******************************************************************************************************
 @brief #### Sets the sequence module duration of a KSINV_SEQUENCE as well as TI and TR (slice-ahead IR)

 This function enables the *slice-ahead* inversion mode, where the duration of the sequence module is
 determined while iteratively finding TI and TR, based on the duration and momentstart of the
 core slice playout. One 'core slice' consists of the main sequence and all other sequence modules played
 out every time with the main sequence directly before or after, e.g. [FatSat]-[SpatialSat]-[Mainsequence].

 Optionally, one can pass in an `approxti_flag`. If `FALSE (= 0)`, then the inversion module duration is
 set to meet exactly the TI that will null a tissue with a T1-value of `T1value_toNull`. As with any IR
 module, the minimum duration (`ksinv.seqctrl.min_duration) given by the RF pulse and spoiler is very
 short in comparison to the actual duration (`ksinv.seqctrl.duration) since TI >> min_duration.

 This function reduces the duration significantly by playing the IR module several slices ahead of the
 main sequence slice. This reduces the ksinv sequence module duration by one or more whole units of
 `coreslice_duration`, while still magnetically maintaining the inversion time (TI). The number of slices
 that the inversion module should be played out ahead of the main sequence is stored in
 ksinv.params.nslicesahead. Now, if `approxti_flag = TRUE`, the duration of this ksinv sequence module
 will be set to its minimum (`ksinv.seqctrl.min_duration`), and TI will be approximated to
 a whole number of `coreslice_duration`. This works best for long `T1value_toNull` and reasonably
 short `coreslice_duration` as the percent error in TI will be low. With `approxti_flag = TRUE` the
 scan time will be significantly reduced in general.

 As this function estimates the optimal TR and TI iteratively, AutoTR and AutoTI modes must be used
 when calling this function. Typically T1-FLAIR uses slice-ahead IR, but STIR should also be more
 efficient compared to a simple IR approach. See also ksinv_eval_multislice().

 @param[in,out] ksinv Pointer to KSINV_SEQUENCE sequence module to set up
 @param[out] TR Pointer to the repetition time (TR) resulting from the interative search in [us]
 @param[out] TI Pointer to the inversion time (TI) resulting from the interative search in [us]
 @param[in] approxti_flag 0: Make TI exact 1: Make TI approximate (shorter scan time in general)
 @param[in] coreslice_momentstart Time between the end of the inversion module and the moment start
                                  of the main sequence.
 @param[in] coreslice_duration Duration of the 'core slice' (main sequence + other attached sequence modules)
 @param[in] mainseq_mindur Minimum duration of just the main sequence (used by ksinv_eval_nullti())
 @param[in] T1value_toNull T1 value to null in [us]
 @param[in] slperpass Number of slices to play out in one pass (acquisition)
 @retval STATUS `SUCCESS` or `FAILURE`
*/
STATUS ksinv_eval_duration_t1value(KSINV_SEQUENCE *ksinv, int *TR /* [us] */, int *TI /* [us] */, int approxti_flag /* approx. TI */, int coreslice_momentstart /* [us] */,
                                   int coreslice_duration /* [us] */, int mainseq_mindur, int T1value_toNull /* [us] */, int slperpass) {

  if (ksinv->seqctrl.momentstart <= 0) {
    return ks_error("%s (%s): Moment start position of the inversion sequence (arg 1) must be > 0", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (TR == NULL) {
    return ks_error("%s (%s): TR pointer cannot be NULL", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (TI == NULL) {
    return ks_error("%s (%s): TI pointer cannot be NULL", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (coreslice_momentstart <= 0) {
    return ks_error("%s (%s): The core slice moment start position must be  > 0", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (coreslice_duration <= 0) {
    /* core slice duration is the sequence time (incl. SSI time) for the main sequence and other sequence modules that
    are played just before each main sequence (e.g. ChemSat, GRx Sat, Simple IR etc.) */
    return ks_error("%s (%s): The core slice time (arg 4) [attached seq. modules+ main seq.] must be > 0", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (slperpass < 1) {
    return ks_error("%s (%s): slperpass must be > 0", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (ksinv->params.irmode != KSINV_IR_SIMPLE && ksinv->params.irmode != KSINV_IR_SLICEAHEAD) {
    return ks_error("%s (%s): ksinv.params.irmode must be either KSINV_IR_SIMPLE or KSINV_IR_SLICEAHEAD for this function", __FUNCTION__, ksinv->seqctrl.description);
  }

  int i = 0;
  int iter_max = 50;
  int TItol = 20; /* TI error tolerance in [us] */
  int tempTI;
  int hasconverged = FALSE;
  int reduce_sliceahead = 0;
  int minimumTR_forslices = slperpass * (ksinv->seqctrl.min_duration + coreslice_duration);

  *TR = minimumTR_forslices;
  *TI = ksinv_eval_nullti(*TR, T1value_toNull, mainseq_mindur);

  ksinv->seqctrl.duration = ksinv->seqctrl.min_duration;

  if (approxti_flag == TRUE) {
    /* Optimal TI is approximated using discrete number of slice-aheads with ksinv->seqctrl.duration = ksinv->seqctrl.min_duration */

    /* set .duration = .min_duration (again to be safe) */
    ksinv->seqctrl.duration = ksinv->seqctrl.min_duration;

    /* integer nslicesahead that comes closest to the desired TI */
    ksinv->params.nslicesahead = (int) (((float) (*TI + ksinv->seqctrl.momentstart - ksinv->seqctrl.min_duration - coreslice_momentstart))/ ((float) (coreslice_duration + ksinv->seqctrl.min_duration)) + 0.5);

    /* adjust TI to reflect the approximation */
    *TI = ksinv->params.nslicesahead * (coreslice_duration + ksinv->seqctrl.min_duration) - ksinv->seqctrl.momentstart + ksinv->seqctrl.min_duration + coreslice_momentstart;

    return SUCCESS;
  }


  while (hasconverged == FALSE && ksinv->params.nslicesahead >= 0) {

    while (hasconverged == FALSE && i++ < iter_max) {

      if (ksinv->params.irmode == KSINV_IR_SLICEAHEAD && slperpass > 1) {

        ksinv->params.nslicesahead = (*TI + ksinv->seqctrl.momentstart - ksinv->seqctrl.min_duration - coreslice_momentstart)/ (coreslice_duration + ksinv->seqctrl.min_duration) - reduce_sliceahead;

        if (ksinv->params.nslicesahead < 0) {
          ksinv->params.nslicesahead = 0;
        } else if (ksinv->params.nslicesahead > (slperpass - 1)) {
          ksinv->params.nslicesahead = slperpass - 1;
        }
      } else {
        ksinv->params.nslicesahead = 0;
      }

      /* duration of inversion module */
      ksinv->seqctrl.duration = RUP_GRD((*TI + ksinv->seqctrl.momentstart - coreslice_momentstart - ksinv->params.nslicesahead * coreslice_duration)/ (ksinv->params.nslicesahead + 1));

      /* prevent too small durations */
      if (ksinv->seqctrl.min_duration > ksinv->seqctrl.duration) {
        ksinv->seqctrl.duration = ksinv->seqctrl.min_duration;
      }

      /* Update TR and TI after IR duration update */
      *TR = slperpass * (ksinv->seqctrl.duration + coreslice_duration);
      tempTI = ksinv_eval_nullti(*TR, T1value_toNull, mainseq_mindur);

      hasconverged = abs(tempTI - *TI) < TItol;

      *TI = tempTI;

    } /* inner while */

    reduce_sliceahead++;
    i = 0;

  } /* outer while */


  /* watchdogs */
  if (i >= iter_max) {
    return ks_error("%s (%s): No solution. Increase ETL or #slices", __FUNCTION__, ksinv1.seqctrl.description);
  }
  if (*TI == 0) {
    return ks_error("%s (%s): TI became zero", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (*TR < minimumTR_forslices) {
    return ks_error("%s (%s): TR became too short to fit the number of slices", __FUNCTION__, ksinv->seqctrl.description);
  }
  if (ksinv->seqctrl.min_duration > ksinv->seqctrl.duration) {
    return ks_error("%s: Input args resulted in a a too short inv. seq. duration", __FUNCTION__);
  }

  return SUCCESS;

} /* ksinv_eval_duration_t1value() */





/**
 *******************************************************************************************************
 @brief #### Sets the sequence module duration of a KSINV_SEQUENCE for a FLAIR block design

 This function sets the duration for an KSINV_SEQUENCE module in a FLAIR block design,
 where `ksinv.params.nflairslices` number of inversion pulses are played first (at different slice
 locations) followed by equally many 'core slice' playouts (main sequence + optional other sequence
 modules attached to the main sequence).

 The maximum number of FLAIR slices is capped by `slperpass`, which is the maximum number of slices to
 fit in one TR. As each inversion module must be as long as the `coreslice_duration` in a FLAIR block
 design, the integer number of flair slices (`ksinv.params.nflairslices`) rarely fit exactly in the
 desired TI time, why the duration of the inversion modules are increased to exactly fit this available
 time. This means that after calling this function, one must make sure that the duration of the main
 sequence is also increased accordingly. This is done in ksinv_eval_multislice().

 @param[in,out] ksinv Pointer to KSINV_SEQUENCE sequence module to set up
 @param[in] TI The inversion time (TI) resulting from the interative search in [us]
 @param[in] coreslice_momentstart Time between the end of closest inversion module and the moment start
                                  of the main sequence.
 @param[in] coreslice_duration Duration of the coreslice (main sequence + other attached sequence modules)
 @param[in] slperpass Number of slices to play out in one pass (acquisition)
 @retval STATUS `SUCCESS` or `FAILURE`
*/
STATUS ksinv_eval_duration_flairblock(KSINV_SEQUENCE *ksinv, int TI, int coreslice_momentstart, int coreslice_duration, int slperpass) {
  int avail_flairseqtime;

  if (TI <= 0) {
    return ks_error("%s: TI must be > 0", __FUNCTION__);
  }
  if (coreslice_momentstart <= 0) {
    return ks_error("%s: The core slice moment start position must be > 0", __FUNCTION__);
  }
  if (coreslice_duration <= 0) {
    /* core slice duration is the sequence time (incl. SSI time) for the main sequence and other sequence modules that
    are played just before each main sequence (e.g. ChemSat, GRx Sat, Simple IR etc.) */
    return ks_error("%s: The core slice time (arg 3) [attached seq. modules+ main seq.] must be > 0", __FUNCTION__);
  }
  if (ksinv->seqctrl.min_duration > coreslice_duration) {
    return ks_error("%s: Minimum FLAIR slice duration must be less than the core slice time", __FUNCTION__);
  }
  if (TI < ksinv->seqctrl.min_duration - ksinv->seqctrl.momentstart + coreslice_momentstart) {
    return ks_error("%s: TI too short to fit one inversion slice", __FUNCTION__);
  }

  if (ksinv->params.irmode != KSINV_FLAIR_BLOCK && ksinv->params.irmode != KSINV_FLAIR_T2PREP_BLOCK) {
    return ks_error("%s: ksinv.params.irmode must be KSINV_FLAIR_BLOCK or KSINV_FLAIR_T2PREP_BLOCK for this function", __FUNCTION__);
  }
  if (slperpass < 1) {
    return ks_error("%s: #slices per pass (5th arg) must be at least 1", __FUNCTION__);
  }

  ksinv->params.nslicesahead = 0;

  avail_flairseqtime = TI - coreslice_momentstart + ksinv->seqctrl.momentstart;

  /* how many slices that can be fitted within 'opti' */
  ksinv->params.nflairslices = avail_flairseqtime/ coreslice_duration;

  if (ksinv->params.nflairslices == 0) {
  /* round-up (fall back to simple IR style). We have already checked that TI is long enough to fit one IR playout */
    ksinv->params.nflairslices = 1;
  }

  /* don't exceed the total number of slices per pass */
  if (ksinv->params.nflairslices > slperpass) {
    ksinv->params.nflairslices = slperpass;
  }

  ksinv->params.nflairslices -= ksinv->params.nflairslices % ksinv->selrfinv.sms_info.mb_factor;

  /* increase the duration to fill up to 'avail_flairseqtime'
  N.B: The calling function must also increase the duration of its main sequence to fill up corresponding 'avail_flairseqtime' in the core slice block */
  ksinv->seqctrl.duration = RUP_GRD(avail_flairseqtime/ ksinv->params.nflairslices);

  if (ksinv->seqctrl.duration < coreslice_duration && ksinv->params.nflairslices > 1) {
    return ks_error("%s: FLAIR slice duration became shorter than coreslice duration", __FUNCTION__);
  }

  return SUCCESS;

} /* ksinv_eval_duration_flairblock() */




/**
 *******************************************************************************************************
 @brief #### Sets the duration of a wait sequence (filltr) between FLAIR-blocks to meet manual TR

 In ksinv_eval_duration_flairblock(), `ksinv.params.nflairslices` number of inversion pulses are played
 out before equally many main sequence playouts. This time corresponds to:
 `2 * ksinv.params.nflairslices * coreslice_duration`

 If TR is set manually (AutoTR off), this filltr wait sequence module is set to fill up the time to the
 desired TR. When ksinv.params.nflairslices <= number of slices per pass, two or more FLAIR-blocks will
 be played out in ksinv_scan_sliceloop(), where each block will end with this wait sequence. Therefore,
 the duration of this wait sequence will be reduced in time if used more than once in each slice loop,
 to keep the same total wait duration given by:
 `filltr duration = TR - N * (2 * ksinv.params.nflairslices * coreslice_duration`, where N is an integer
 >= 1.

 If the duration is zero, the description will be ignored and set to "fillTR_disabled".

 @param[in,out] filltr Pointer to the KS_SEQ_CONTROL for the fillTR wait sequence
 @param[in] desc Description of the wait sequence
 @param[in] duration Duration of the wait sequence
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_setfilltr(KS_SEQ_CONTROL *filltr, const char * const desc, int duration) {

  strcpy(filltr->description, desc);

  if (duration > 0) {
    strcpy(filltr->description, desc);
    filltr->ssi_time = ksinv_filltr_ssi_time;
    filltr->min_duration = RUP_GRD(ksinv_filltr.ssi_time);
    filltr->duration = RUP_GRD(duration);

    if (filltr->duration < filltr->min_duration || filltr->duration < filltr->ssi_time) {
      return ks_error("%s: filltr.duration must be >= .min_duration and .ssi_time", __FUNCTION__);
    }

  } else {
    ks_init_seqcontrol(filltr);
    filltr->ssi_time = ksinv_filltr_ssi_time;
    strcpy(filltr->description, "fillTR_disabled");
  }

  return SUCCESS;

} /* ksinv_eval_setfilltr() */




/**
 *******************************************************************************************************
 @brief #### Initializes inversion related UI

 Pre-DV26:
 - T2FLAIR set by: opflair == OPFLAIR_GROUP
 - T1FLAIR set by: opflair == OPFLAIR_INTERLEAVED

 DV26+:
 UI buttons have been moved from column 2 (under FastSpinEcho/SSFSE) to column 3 (imaging options)
 - T2FLAIR set by: opt2flair == TRUE
 - T1FLAIR set by: opt1flair == TRUE

 To be compatible with previous releases, this function sets the legacy opflair CV to the correct value,
 so that (for now) sequences using KSInversion.e can continue to use opflair despite the DV26 UI change.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_init_UI() {

#if EPIC_RELEASE >= 26

  set_incompatible(PSD_IOPT_T1FLAIR, PSD_IOPT_T2FLAIR); 

  if (opt1flair == TRUE && opt2flair == TRUE) {
    return ks_error("%s: Selection of T1FLAIR and T2FLAIR is not allowed", __FUNCTION__);
  } else if (opt1flair == TRUE && opt2flair == FALSE) {
    cvoverride(opflair, OPFLAIR_INTERLEAVED, PSD_FIX_ON, PSD_EXIST_ON);
  } else if (opt2flair == TRUE && opt1flair == FALSE) {
    cvoverride(opflair, OPFLAIR_GROUP, PSD_FIX_ON, PSD_EXIST_ON);
  } else {
    cvoverride(opflair, FALSE, PSD_FIX_ON, PSD_EXIST_ON);
  }
  
#endif

  return SUCCESS;
}


/**
 *******************************************************************************************************
 @brief #### Gets the current UI and checks for valid inputs related to the inversion module(s)

 The inversion mode(s) is initially dependent on the UI selections: T2-FLAIR, T1-FLAIR, IR-prep.
 Only 2D+Fast-SpinEcho enables the T2-FLAIR and T1-FLAIR buttons, but 2D+EchoPlanar enables a
 FLAIR-EPI button, which is the same thing as T2-FLAIR.

 If the T2-FLAIR button is selected, `opflair = OPFLAIR_GROUP`, resulting in a FLAIR-block design
 (`ksinv1.params.mode = KSINV_FLAIR_BLOCK`).

 If the T1-FLAIR button is selected, `opflair = OPFLAIR_INTERLEAVED`, resulting in a slice-ahead inversion
 mode (`ksinv1.params.mode = KSINV_IR_SLICEAHEAD`).

 In T2-FLAIR and T1-FLAIR modes, only the first of the four UserCVs reserved by KSINV_EVAL() is shown.

 For custom IR control, using simple IR or dual IR (in simple or sliceahead modes), opflair should be
 0 and opirprep should be 1. For FSE (ksfse.e), this advanced mode is set by selecting
 FSE-IR. For EPI (ksepi.e), this mode is set by selecting SE-EPI, GE-EPI or DW-EPI and then
 selecting IRprep.

 This function is used to set up inversion for 2D sequences and is not suited for future 3D psd support.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_UI() {


  cvmin(opti, 0);
  cvmax(opti, 20000000);
  cvmax(optr, 240000000); /* 4 mins */


  if (oppseq != PSD_IR /* 3 */ && opirprep == FALSE && opflair == FALSE) {
    /* no IR selection, disable everything IR related */
    piuset &= ~(use_ir1_mode + use_ir1_t1 + use_ir2_mode + use_ir2_t1);
    *ksinv1_mode = 0; _ksinv1_mode->existflag = TRUE; _ksinv1_mode->fixedflag = TRUE;
    *ksinv2_mode = 0; _ksinv2_mode->existflag = TRUE; _ksinv2_mode->fixedflag = TRUE;
    pitinub = 0;
    return SUCCESS;
  } else {
    /* GE's ARC recon does not seem to like the combined use of
      a) inversion
      b) interleaved spacing (opileave)

      We can avoid this at the PSD selection stage by not allowing ARC
      at all (disable_ioption) with any kind of inversion. This prevents however also ARC inversion
      w/o interleaved spacing. A second level of defense is to allow ARC for inversion, but to check
      whether interleaved spacing is on and if R > 1 (opaccel_ph_stride), but also checking if autolock
      is off. If autolock is on, one assumes that the user wants to reconstruct the data from Pfiles,
      which works without problems with ARC, inversion and interleaved spacing.

      First defense at PSD selection: Inversion is enabled => disable ARC option. Comment this out
      to allow ARC but instead be trapped by the second defense */
    disable_ioption(PSD_IOPT_ARC);

    /* Second defense against ARC, interleaved spacing and inversion, if rawdata is not saved */
    if ((opileave == TRUE) && (oparc == TRUE) && (opaccel_ph_stride > 1.0) && (autolock == FALSE)) {
      return ks_error("%s: Use ASSET for Inversion & Intleave Spacing", __FUNCTION__);
    }

  }


  if (opflair == OPFLAIR_GROUP || opflair == OPFLAIR_INTERLEAVED) {

    /* T2-FLAIR or T1-FLAIR */
    if (cffield == 30000) {
      _ksinv1_t1value->defval = T1_CSF_3T;
      _ksinv2_t1value->defval = T1_WM_3T;
    } else {
      _ksinv1_t1value->defval = T1_CSF_1_5T;
      _ksinv2_t1value->defval = T1_WM_1_5T;
    }
  } else {
    /* maybe STIR */
    if (cffield == 30000) {
      _ksinv1_t1value->defval = T1_FAT_3T;
    } else {
      _ksinv1_t1value->defval = T1_FAT_1_5T;
    }
    _ksinv2_t1value->defval = 50; /* ms */
  }

  /* presets for T1-FLAIR and T2-FLAIR */
  if (opflair == OPFLAIR_GROUP) {
    /* T2-FLAIR */
    pitival2 = 3000000;
    pitival3 = 0; /* should never show */
    pitival4 = 0;
    pitival5 = 0;
    pitival6 = 0;
    if (_optr.defval < ksinv_mintr_t2flair) {
      _optr.defval = ksinv_mintr_t2flair;
    }
    if (ksinv_t2prep == 1) {
      _ksinv1_mode->defval = KSINV_FLAIR_T2PREP_BLOCK;
    } else {
      _ksinv1_mode->defval = KSINV_FLAIR_BLOCK;
    }

  } else if (opflair == OPFLAIR_INTERLEAVED) {
    /* T1-FLAIR (must use autoTI) */
    pitival2 = 700000;
    pitival3 = 0; /* should never show */
    pitival4 = 0;
    pitival5 = 0;
    pitival6 = 0;
    _ksinv1_mode->defval = KSINV_IR_SLICEAHEAD;
  } else {
    pitival2 = 150000;
    pitival3 = 200000;
    pitival4 = 250000;
    pitival5 = 300000;
    pitival6 = 350000;
    _ksinv1_mode->defval = KSINV_IR_SIMPLE;
  }

  /*** begin: opusers ***/

  /* [opuser] IR #1 mode */
  _ksinv1_mode->minval = KSINV_OFF;
  _ksinv1_mode->maxval = KSINV_FLAIR_T2PREP_BLOCK;
  _cvdesc(_ksinv1_mode, "IR1 [0:Off 1:IR 2:SA-IR 3:FLAIR]");
  if (_ksinv1_mode->existflag == FALSE) {
    *ksinv1_mode = _ksinv1_mode->defval;
  }

  /* [opuser] IR #2 mode */
  _ksinv2_mode->minval = KSINV_OFF;
  _ksinv2_mode->maxval = KSINV_IR_SLICEAHEAD;
  _ksinv2_mode->defval = KSINV_OFF;
  _cvdesc(_ksinv2_mode, "IR2 [0:Off 1:IR 2:SA-IR]");
  if (_ksinv2_mode->existflag == FALSE) {
    *ksinv2_mode = _ksinv2_mode->defval;
  }

  /* [opuser] IR #1. T1 value to NULL in[ms] (N.B.: not TI, but T1!) */
  _ksinv1_t1value->minval = 0;
  _ksinv1_t1value->maxval = 10000;
  {
    char tmpstr[100];
    if (cffield == 30000) {
      sprintf(tmpstr, "    IR1 - T1 to null           [CSF:%d GM:%d WM:%d Fat:%d]", T1_CSF_3T, T1_GM_3T, T1_WM_3T, T1_FAT_3T);
    } else if (cffield == 15000) {
      sprintf(tmpstr, "    IR1 - T1 to null           [CSF:%d GM:%d WM:%d Fat:%d]", T1_CSF_1_5T, T1_GM_1_5T, T1_WM_1_5T, T1_FAT_1_5T);
    }
    _cvdesc(_ksinv1_t1value, tmpstr);
  }
  if (_ksinv1_t1value->existflag == FALSE) {
    *ksinv1_t1value = _ksinv1_t1value->defval;
  }

  /* [opuser] IR #2. T1 value to NULL in[ms] (N.B.: not TI, but T1!) */
  _ksinv2_t1value->minval = 0;
  _ksinv2_t1value->maxval = 10000;
  _cvdesc(_ksinv2_t1value, "IR2 - T1 to null");
  if (_ksinv2_t1value->existflag == FALSE) {
    *ksinv2_t1value = _ksinv2_t1value->defval;
  }

  /* turn on all these opuser CVs */
  piuset |= use_ir1_mode + use_ir1_t1 + use_ir2_mode + use_ir2_t1;

  if (((int) *ksinv1_mode) == KSINV_OFF) {
    /* if we are not doing inversion, hide the TI menu and other opusers and set opti = 0 */
    piuset &= ~(use_ir1_t1 + use_ir2_mode + use_ir2_t1);
    ksinv1_ti = 0;
    ksinv2_ti = 0;
    pitinub = 0;
    _ksinv1_mode->existflag = FALSE;
    _ksinv2_mode->existflag = FALSE;
  } else {
    /* Default: allow AutoTI and 5+1 rows in TI menu */
    piautoti = 1;
    pitinub = 6;
  }

  /* Set AutoTR and AutoTI */
  opautotr  = _opautotr.fixedflag ?  ((void)(TRUE), opautotr) : TRUE;
  opautoti  = _opautoti.fixedflag ?  ((void)(TRUE), opautoti) : TRUE;

  if (((int) *ksinv1_mode) == KSINV_IR_SLICEAHEAD) {
    pitrnub = 0; /* '2': only one menu choice (Minimum = AutoTR). '0': shown but greyed out (if also opautotr = 1) */
    pitinub = -1; /* '2': only one menu choice (AutoTI). '-1': shown but greyed out */
  }

  if (opflair == OPFLAIR_GROUP || opflair == OPFLAIR_INTERLEAVED) {
    /* T2-FLAIR or T1-FLAIR. Branded options, narrow options down */

    /* remove 0 mm gap from slice spacing menu */
    piisil = PSD_ON;
    float minspacing = exist(opslthick)/ 2.0;
    piisnub = 5;
    piisval2 = minspacing;
    piisval3 = minspacing + 1;
    piisval4 = minspacing + 2;
    piisval5 = minspacing + 3;
    piisval6 = minspacing + 4;

    cvdef(opslspace, minspacing);
    opslspace  = _opslspace.fixedflag ?  ((void)(_opslspace.defval), opslspace) : _opslspace.defval;

    if (opflair == OPFLAIR_INTERLEAVED) {
      pitrnub = 0;
      pitinub = -1;
      cvoverride(opautotr, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
    } else {
      pitrnub = 2; /* '2': only one menu choice (Minimum = AutoTR). '0': shown but greyed out (if also opautotr = 1) */
      pitinub = 2; /* '2': only one menu choice (AutoTI). '-1': shown but greyed out */
    }    

    /* disable 2nd IR for T1/T2-FLAIR */
    _ksinv2_mode->existflag = FALSE;
    *ksinv2_mode = 0;
    ksinv2_ti = 0;
    piuset &= ~(use_ir1_mode + use_ir2_mode + use_ir2_t1);
  }

  /* if not AutoTI, set internal TI variable to selected TI (opti) and hide T1value opuser */
  if (opautoti == FALSE) {
    piuset &= ~use_ir1_t1;
    ksinv1_ti = exist(opti);
  }

  if (((int) *ksinv2_mode) == KSINV_OFF) {
    piuset &= ~use_ir2_t1;
    ksinv2_ti = 0;
  }


  return SUCCESS;

} /* ksinv_eval_UI() */




/* To avoid macro length limitations, KSINV_EVAL() had to be split up into three
   smaller macros: KSINV_PIUSE, KSINV_OPUSER_VALS, KSINV_OPUSER_STRUCTS */
#define KSINV_PIUSE(o1, o2, o3, o4)\
({\
 use_ir1_mode = use ## o1;\
 use_ir1_t1 = use ## o2;\
 use_ir2_mode = use ## o3;\
 use_ir2_t1 = use ## o4;\
})

#define KSINV_OPUSER_VALS(o1, o2, o3, o4)\
({\
 ksinv1_mode = &opuser ## o1;\
 ksinv1_t1value = &opuser ## o2;\
 ksinv2_mode = &opuser ## o3;\
 ksinv2_t1value = &opuser ## o4;\
})

#define KSINV_OPUSER_STRUCTS(o1, o2, o3, o4)\
({\
 _ksinv1_mode = &_opuser ## o1;\
 _ksinv1_t1value = &_opuser ## o2;\
 _ksinv2_mode = &_opuser ## o3;\
 _ksinv2_t1value = &_opuser ## o4;\
})


/**
 *******************************************************************************************************
 @brief #### C-macro assigning four UserCV slots and then calling ksinv_eval()
 @param[in,out] sptr Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] o1 A number (not a variable) between 0 and 35 corresponding to the first UserCV used
 @param[in] o2 A number (not a variable) between 0 and 35 corresponding to the second UserCV used
 @param[in] o3 A number (not a variable) between 0 and 35 corresponding to the third UserCV used
 @param[in] o4 A number (not a variable) between 0 and 35 corresponding to the fourth UserCV used
********************************************************************************************************/
#define KSINV_EVAL(sptr, o1, o2, o3, o4)\
({\
  KSINV_PIUSE(o1, o2, o3, o4);\
  KSINV_OPUSER_VALS(o1, o2, o3, o4);\
  KSINV_OPUSER_STRUCTS(o1, o2, o3, o4);\
  ksinv_eval(sptr, NULL);\
})





#define KSINV_EVAL_CUSTOMRF(sptr, rfptr, o1, o2, o3, o4)\
({\
  KSINV_PIUSE(o1, o2, o3, o4);\
  KSINV_OPUSER_VALS(o1, o2, o3, o4);\
  KSINV_OPUSER_STRUCTS(o1, o2, o3, o4);\
  ksinv_eval(sptr, rfptr);\
})




/**
 *******************************************************************************************************
 @brief <h4> Gets the IR-related UI parameters, creates sequence objects and min_duration for the
             inversion module(s), and adds these modules to KS_SEQ_COLLECTION. </h4>
 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in,out] custom_selrf Optional pointer to KS_SELRF for custom inversion RF pulse. Pass NULL to use
                         default RF pulses.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval(KS_SEQ_COLLECTION *seqcollection, KS_SELRF *custom_selrf) {
  STATUS status;

  ksinv_init_sequence(&ksinv1);/* 1st IR */
  ksinv_init_sequence(&ksinv2);/* 2nd IR */
  ks_init_seqcontrol(&ksinv_filltr); /* init fillTR for FLAIR-block */

  status = ksinv_eval_UI();
  if (status != SUCCESS) return status;

  if (((int) *ksinv1_mode) == KSINV_OFF) {
    /* If no IR1 flag on, return quietly */
    return SUCCESS;
  }

  /* Set inversion slice thickness. N.B.: 'avmaxacqs' = number of acqs shown in the UI (a.k.a. acqs = npasses) */
  if (existcv(opslthick) && (opslthick > 0)) {
    int intleavefact = IMax(2, 1, avmaxacqs);
    float slthickfact = intleavefact * (opslthick + opslspace)/ opslthick;
    ksinv_slthickfact  = _ksinv_slthickfact.fixedflag ?        ((void)((slthickfact<=KSINV_MAXTHICKFACT)?slthickfact:KSINV_MAXTHICKFACT), ksinv_slthickfact) : (slthickfact<=KSINV_MAXTHICKFACT)?slthickfact:KSINV_MAXTHICKFACT;
    ksinv_slthickfact_exc  = _ksinv_slthickfact_exc.fixedflag ?  ((void)(ksinv_slthickfact), ksinv_slthickfact_exc) : ksinv_slthickfact;
  }
  if (existcv(optr) && existcv(opslquant) && existcv(opslspace) && opflair && (avmaxacqs <= 1) && (opssfse == FALSE) && (opslspace <= 0) && (opileave == 0)) {
    /* for single acquisition T1-FLAIR or T2-FLAIR, prevent too little spacing between slices it not interleaved
    spacing, but only once the user has set number of slices, TR, and slice gap (so we don't complain too early) */
    return ks_error("%s: Use slice gap or Intleave", __FUNCTION__);
  }


  /* single or 1st IR */
  ksinv_eval_copycvs(&ksinv1.params, (int) *ksinv1_mode);

  status = ksinv_eval_setupobjects(&ksinv1, "1", custom_selrf);
  if (status != SUCCESS) return status;

  status = ksinv_pg(&ksinv1);
  if (status != SUCCESS) return status;

  status = ks_eval_addtoseqcollection(seqcollection, &ksinv1.seqctrl);
  if (status != SUCCESS) return status;

  /* FillTR sequence for KSINV_FLAIR_BLOCK. This is added after all slices have been played out each TR instead
  of increasing the duration of the main pulse sequence to fullfill TR */
  status = ksinv_eval_setfilltr(&ksinv_filltr, "fillTR", 0); /* initialize to zero */
  if (status != SUCCESS) return status;


  if (((int) *ksinv2_mode) != KSINV_OFF) {

    ksinv_eval_copycvs(&ksinv2.params, (int) *ksinv2_mode);

    status = ksinv_eval_setupobjects(&ksinv2, "2", custom_selrf);
    if (status != SUCCESS) return status;

    status = ksinv_pg(&ksinv2);
    if (status != SUCCESS) return status;

    status = ks_eval_addtoseqcollection(seqcollection, &ksinv2.seqctrl);
    if (status != SUCCESS) return status;

  }

  return status;

} /* ksinv_eval() */





/**
 *******************************************************************************************************
 @brief #### Calculates the minimum TR allowed for the ksinv_scan_sliceloop()

 Given the current durations of the sequence modules involved in the ksinv_scan_sliceloop(), this
 function calculates the minimum TR, accounting also for SAR and hardware limits.

 This function expects a pointer to a scan function playing out one `coreslice`. The `coreslice` should
 play out the main sequence once (i.e. one slice), but the coreslice function may also play optional
 other sequence modules that should always be played together with the main sequence (e.g. fatsat).

 As the number of arguments to the sequence's coreslice is psd-dependent, the function pointer
 `play_coreslice` must be a wrapper function to the coreslice function taking standardized input arguments
 `(int) core_nargs` and `(void **) core_args`. This coreslice wrapper function must be on the form:
 `int coreslice_nargs(SCAN_INFO *, int storeslice, int core_nargs, void **core_args);`
 If the coreslice function does not need any additional input arguments, `core_nargs = 0`, and `core_args = NULL`.

 With this function pointer, ksinv_scan_sliceloop() can replace the sequence (non-inversion) sliceloop function,
 and play out the inversion module(s) and the sequence module(s) in the coreslice function.

 After resetting the `seqctrl.nseqinstances` for all sequence modules in the sequence collection,
 ksinv_scan_sliceloop() is called once to increment `seqctrl.nseqinstances` by 1 for every time each
 sequence modules is played out. With this updated information, `seqcollection` is passed to
 ks_eval_gradrflimits(), which will calculate the total duration and add additional time for SAR/hardware
 limits. This time is the return value of ksinv_eval_mintr().

 @param[in] slice_plan Pointer to the KS_SLICE_PLAN struct holding the slice order information
 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] gheatfact Value in range [0,1] denoting how much the gradient heating limits should be honored (0:none, 1:full)
 @param[in] ksinv1    Pointer to KSINV_SEQUENCE corresponding to the 1st (or only) inversion. Cannot be NULL
 @param[in] ksinv2    Pointer to KSINV_SEQUENCE corresponding to an optional 2nd inversion. May be NULL
 @param[in] ksinv_filltr    Pointer to KS_SEQ_CONTROL for fillTR sequence for FLAIR block modes. May be NULL
 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval minTR Minimum TR for ksinv_scan_sliceloop() honoring SAR and hardware limits
********************************************************************************************************/
int ksinv_eval_mintr(const KS_SLICE_PLAN *slice_plan, KS_SEQ_COLLECTION *seqcollection, float gheatfact, KSINV_SEQUENCE *ksinv1, KSINV_SEQUENCE *ksinv2, KS_SEQ_CONTROL *ksinv_filltr,
                     int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {

  /* must be run before each call to function pointer `play_coreslice()` to set all `seqctrl.nseqinstances` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);

  ksinv_scan_sliceloop(slice_plan, ks_scan_info, 0, ksinv1, ksinv2, ksinv_filltr, FALSE, play_coreslice, core_nargs, core_args); /* get sequence instance counts */

  return ks_eval_gradrflimits(NULL, seqcollection, gheatfact); /* minTR within limits given the number of sequence instances, durations and RF/grad content */

} /* ksinv_eval_mintr() */




/**
 *******************************************************************************************************
 @brief #### Calculates the maximum slices per TR using ksinv_scan_sliceloop()

 @param[in] TR Repetition time in [us]
 @param[in] temp_slice_plan Pointer to the KS_SLICE_PLAN struct holding the slice order information
 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] gheatfact Value in range [0,1] denoting how much the gradient heating limits should be honored (0:none, 1:full)
 @param[in] ksinv1    Pointer to KSINV_SEQUENCE corresponding to the 1st (or only) inversion. Cannot be NULL
 @param[in] ksinv2    Pointer to KSINV_SEQUENCE corresponding to an optional 2nd inversion. May be NULL
 @param[in] ksinv_filltr    Pointer to KS_SEQ_CONTROL for fillTR sequence for FLAIR block modes. May be NULL
 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval MaxSlicesPerTR Maximum slices that can fit in the specified TR, honoring SAR and hardware limits
********************************************************************************************************/
int ksinv_eval_maxslicespertr(int TR, KS_SLICE_PLAN temp_slice_plan, KS_SEQ_COLLECTION *seqcollection, float gheatfact, 
                              KSINV_SEQUENCE *ksinv1, KSINV_SEQUENCE *ksinv2, KS_SEQ_CONTROL *ksinv_filltr,
                              int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {
  int max_slquant1 = 0;
  int i, invslicelooptime;
  for (i = 1; i < 1024; i++) {

    temp_slice_plan.nslices_per_pass = i; /* hack the slice plan with 'i' #slices to see when invslicelooptime becomes larger than TR */

    invslicelooptime = ksinv_eval_mintr(&temp_slice_plan, seqcollection, gheatfact, ksinv1, ksinv2, ksinv_filltr, play_coreslice, core_nargs, core_args);

    if (invslicelooptime == KS_NOTSET) {
      return KS_NOTSET;
    }
    if (invslicelooptime > TR) {
      return max_slquant1;
    }
    max_slquant1 = i;
  }

  return max_slquant1;

} /* ksinv_eval_maxslicespertr() */




/**
 *******************************************************************************************************
 @brief #### FLAIR block calculations

 @param[in,out] ksinv Pointer to KSINV_SEQUENCE. ksinv.params.irmode must be KSINV_FLAIR_BLOCK and ksinv.seqctrl.min_duration and ksinv.seqctrl.momentstart both > 0.
 @param[out] filltr_time The time that needs to be added after all slices played out to fill up to the manual TR
 @param[in,out] repetition_time Pointer to the repetition time [us]. If autotr_flag = TRUE, this value will be set and returned as TR to the calling function. If autotr_flag = FALSE, 'repetition_time' will be used as TR here
 @param[in,out] inversion_time Pointer to the inversion time [us]. If 'T1tonull' > 0, this value will be set and returned as TI to the calling function. If 'T1tonull' = 0, 'inversion_time' will be used as TI here
 @param[in] autotr_flag TRUE/FALSE flag for autoTR. If TRUE, 'repetition_time' will be updated
 @param[in] T1tonull T1-value to null. 0: Off (value of 'inversion_time' is used. >0: Use this T1-value to calculate the TI value and update and return 'inversion_time'
 @param[in] coreslice_momentstart Time between the end of closest inversion module and the moment start of the main sequence.
 @param[in] coreslice_duration Duration of the coreslice (main sequence + other attached sequence modules)
 @param[in] slperpass Number of slices to play out in one pass (acquisition)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_flairblock(KSINV_SEQUENCE *ksinv, int *filltr_time, int *repetition_time, int *inversion_time, int autotr_flag, int T1tonull, int coreslice_momentstart, int coreslice_duration, int slperpass) {
  int i = 0;
  int iter_max = 20;
  int TRtol = 20; /* TR error tolerance in [us] */
  int hasconverged = FALSE;
  int cap_nflairslices = FALSE;
  int lowest_nflairslices = slperpass;
  int minTR, TR, TI;
  int nflairblocks;
  int lastTR = 0;
  int flair_duration;
  int timetoadd_perTR;
  STATUS status;

  if (filltr_time == NULL || repetition_time == NULL || inversion_time == NULL) {
    return ks_error("%s: 2nd-4th args must be non-NULL int pointers", __FUNCTION__);
  }
  if (autotr_flag != 0 && autotr_flag != 1) {
    return ks_error("%s: autotr flag must be 0 (false) or 1 (true)", __FUNCTION__);
  }

  if (autotr_flag) {
    /* AutoTR */
    TR = 20000000; /* starting guess */
  } else {
    TR = *repetition_time;
  }


  do {

    if (T1tonull > 0) {
      /* AutoTI: set TI based on T1tonull and current TR (AutoTR) or fixed TR */
      TI = ksinv_eval_nullti(TR, T1tonull, coreslice_duration);
    } else {
      TI = *inversion_time;
    }

    /* duration of each inversion module in the FLAIR block. This function sets the field ksinv.params.nflairslices */
    status = ksinv_eval_duration_flairblock(ksinv, TI, coreslice_momentstart, coreslice_duration, (cap_nflairslices == TRUE) ? lowest_nflairslices : slperpass);
    if (status != SUCCESS) return status;

    /* minimum TR (ignoring grad/RF heating and SAR) */
    nflairblocks = CEIL_DIV(slperpass, ksinv->params.nflairslices); /* number of FLAIR blocks */

    flair_duration = (nflairblocks * ksinv->params.nflairslices + slperpass) * ksinv->seqctrl.duration;

    /* keep minTR above ksinv_mintr_t2flair */
    minTR = IMax(2, flair_duration, ksinv_mintr_t2flair);

    if (autotr_flag == TRUE) {
      TR = minTR;
    }

    /* wait sequence after each set (group) of FLAIR + core slices to fill up TR. C.f. ksinv_scan_sliceloop() */
    timetoadd_perTR = IMax(2, TR, ksinv_mintr_t2flair) - flair_duration;
    *filltr_time = RUP_GRD(timetoadd_perTR/ nflairblocks);

    if (autotr_flag == TRUE) {

      /* converge check and lastTR update */
      hasconverged = abs(lastTR - minTR) < TRtol;
      lastTR = minTR;

      if (ksinv->params.nflairslices < lowest_nflairslices && cap_nflairslices == FALSE) {
        /* In the event that the number of FLAIR slices toggles between two (or more) values, this iteration process may not converge.
           We monitor the lowest nflairslices that occur during the first iteration round (lowest_nflairslices). If we reach iter_max, use lowest_nflairslices
           instead of slperass as last arg to ksinv_eval_duration_flairblock() to force nflairslices to this value, and re-iterate.
           If still no convergence, lowest_nflairslices is reduced by 1 */
        lowest_nflairslices = ksinv->params.nflairslices;
      }
      if (++i == iter_max) {
        /* Things to do when we have reached #iterations */
        if (lowest_nflairslices > 1) {
          i = 0; /* reset iteration counter */
          if (cap_nflairslices == FALSE) {
            /* try iterating a second time, now with the lowest number of nflairslices used in the iterations (lowest_nflairslices) */
            cap_nflairslices = TRUE;
          } else {
            /* try iterating again after the second time, now with lowest_nflairslices reduced by 1 */
            lowest_nflairslices--;
          }
        } else {
          return ks_error("%s: FLAIR-block - Combination of TI & TR not found after %d iterations", __FUNCTION__, iter_max);
        }
      }

    } /* autotr_flag */

  } while ((autotr_flag == TRUE) && (hasconverged == FALSE)); /* only iterate for AutoTR */


  if (TR < ksinv_mintr_t2flair) {
     return ks_error("%s: TR must be increased to %d ms", __FUNCTION__, CEIL_DIV(ksinv_mintr_t2flair, 1000));
  }
  
  *inversion_time = TI;
  *repetition_time = TR;

  return SUCCESS;

}



STATUS ksinv_eval_flairblock_withmainupdate(KSINV_SEQUENCE *ksinv, KS_SEQ_CONTROL *ksinv_filltr, KS_SEQ_CONTROL *mainseqctrl, int *repetition_time, int *inversion_time, int autotr_flag, int T1tonull, int coreslice_momentstart, int coreslice_duration, int slperpass) {
  STATUS status;
  int filltr_duration;

  status = ksinv_eval_flairblock(ksinv, &filltr_duration, repetition_time, inversion_time, autotr_flag, T1tonull, coreslice_momentstart, coreslice_duration, slperpass);
  if (status != SUCCESS) return status;

  /* set up fill TR sequence (to be played out CEIL_DIV(slperpass, ksinv->params.nflairslices) times per TR) unless filltr_duration < ssi_time */
  status = ksinv_eval_setfilltr(ksinv_filltr, "fillTR", (filltr_duration > ksinv_filltr_ssi_time) * filltr_duration);
  if (status != SUCCESS) return status;

  /* We must have the same seq duration for ksinv->seqctrl.duration and the coreslice duration, add round-up time due to nflairslices divisibility to the duration of the main sequence. */
  if (ksinv->seqctrl.duration > coreslice_duration) {
    mainseqctrl->duration += RUP_GRD(ksinv->seqctrl.duration - coreslice_duration);
  }

  return SUCCESS;

}





/**
 *******************************************************************************************************
 @brief #### Calculates the duration of inversion module(s) for various inversion modes

 This function is to be used by a 2D psd to set the inversion duration(s) for `ksinv1` and possibly `ksinv2`
 (dual IR). Before calling this function, the `ksinv->params.irmode` (and `ksinv2.params.irmode`) must be set
 to steer which type of inversion that should be performed. Here follows the inversion modes supported by this
 function:

 Single inversion (`ksinv2.params.irmode = KSINV_OFF`):
 1. `ksinv1.params.irmode = KSINV_FLAIR_BLOCK`:
    - Heat handling: None, but will be caught in final SAR check at the end. Unlikely to happen for T2-FLAIR
 2. `ksinv1.params.irmode = KSINV_IR_SIMPLE` and manual TR (`opautotr = FALSE`):
    - Heat handling: Increase mainseqctrl->duration based on timetoadd_perTR
 3. `ksinv1.params.irmode = KSINV_IR_SLICEAHEAD`  *or*  `ksinv1.params.irmode = KSINV_IR_SIMPLE` and (`opautotr = TRUE`)
    - Heat handling: C.f. "Early grad/RF heat calculations" that increases mainseqctrl->duration *before* IR/TR timing calculations

 Dual inversion:
 1. `ksinv1.params.irmode = KSINV_IR_SIMPLE` and `ksinv2.params.irmode = KSINV_IR_SIMPLE`
 2. `ksinv1.params.irmode = KSINV_IR_SLICEAHEAD` and `ksinv2.params.irmode = KSINV_IR_SIMPLE`
 3. `ksinv1.params.irmode = KSINV_FLAIR_BLOCK` and `ksinv2.params.irmode = KSINV_IR_SIMPLE`
 4. `ksinv1.params.irmode = KSINV_IR_SLICEAHEAD` and `ksinv2.params.irmode = KSINV_IR_SLICEAHEAD`. TI1 (opti) will be approximated

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] slice_plan Pointer to the KS_SLICE_PLAN struct holding the slice order information
 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @param[in] mainseqctrl Pointer to the KS_SEQ_CONTROL struct for the main sequence

 @retval MaxSlicesPerTR Maximum slices that can fit in the specified TR, honoring SAR and hardware limits
********************************************************************************************************/
STATUS ksinv_eval_multislice(KS_SEQ_COLLECTION *seqcollection, KS_SLICE_PLAN *slice_plan, int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args, KS_SEQ_CONTROL *mainseqctrl) {

  STATUS status;
  int coreslice_momentstart;
  int coreslice_duration;
  int minTR = 0;
  int timetoadd_perTR;
  SCAN_INFO dummy_slice_pos = DEFAULT_AXIAL_SCAN_INFO; /* dummy slice info for coreslice */


  /* return early if we don't have at least one inversion */
  if (ksinv1.params.irmode == KSINV_OFF) {
    return SUCCESS;
  }

  /* return early if #slices/TR = 0 */
  if (slice_plan->nslices_per_pass == 0) {
    return SUCCESS;
  }


  if (ksinv1.params.irmode == KSINV_OFF && ksinv2.params.irmode != KSINV_OFF) {
    return ks_error("%s: DualIR: If 2nd IR is on, so must the 1st IR", __FUNCTION__);
  } else if (ksinv1.params.irmode != KSINV_IR_SLICEAHEAD && ksinv2.params.irmode == KSINV_IR_SLICEAHEAD) {
    return ks_error("%s: DualIR: If 2nd IR is sliceahead, so must the 1st IR", __FUNCTION__);
  } else if (ksinv2.params.irmode == KSINV_FLAIR_BLOCK || ksinv2.params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
    return ks_error("%s: DualIR: 2nd IR cannot be a FLAIR block", __FUNCTION__);
  }

  if (ksinv1.params.irmode != KSINV_IR_SLICEAHEAD && ksinv1.params.approxti == TRUE) {
    return ks_error("%s: 1st IR (ksinv1): approximate TI only applicable to sliceahead IR mode", __FUNCTION__);
  }
  if (ksinv2.params.irmode != KSINV_IR_SLICEAHEAD && ksinv2.params.approxti == TRUE) {
    return ks_error("%s: 2nd IR (ksinv2): approximate TI only applicable to sliceahead IR mode", __FUNCTION__);
  }

  /* ks_eval_seqcollection_durations_atleastminimum() makes sure seqctrl.duration is at least seqctrl.min_duration for all sequence modules */
  status = ks_eval_seqcollection_durations_atleastminimum(seqcollection);
  if (status != SUCCESS) return status;


  if ( (ksinv1.params.irmode == KSINV_IR_SLICEAHEAD) || ((ksinv1.params.irmode == KSINV_IR_SIMPLE) && (opautoti == TRUE) && (opautotr == TRUE)) ) {

    /*******************************************************************************************************
     * Early grad/RF heat calculations
     *******************************************************************************************************/

    /* For KSINV_IR_SLICEAHEAD mode, we need to check for grad/RF heating *first* in a worst case scenario where all sequence
       modules have .duration = .min_duration. The penalty time is added the main sequence duration to be within the limits.
       After this, we can start calculating the IR time(s). This is due to that the KSINV_IR_SLICEAHEAD mode in part uses inversion
       pulses from the previous TR to invert slices in the current TR, why the TR cannot be changed (increased) after these
       calculations due to later heating issues. The same applies to simple IR mode with both AutoTR and AutoTI.
       For these two cases, both TR and TI are consequences of the chosen T1 null value */

    /* at this point, the IR module(s), main sequence, and other sequence modules should have .duration = .min_duration. Check worst case (minimum duration modules) */
    minTR = ksinv_eval_mintr(slice_plan, seqcollection, ks_gheatfact, &ksinv1, &ksinv2, NULL, play_coreslice, core_nargs, core_args);
    if (minTR == KS_NOTSET) return FAILURE;

    
    /* how much TR needs to increase if we have only minimum duration modules */
    timetoadd_perTR = minTR - ksinv_scan_sliceloop(slice_plan, ks_scan_info, 0, &ksinv1, &ksinv2, NULL, FALSE, play_coreslice, core_nargs, core_args);

    /* we spread the available timetoadd_perTR evenly, by increasing .duration of each slice by timetoadd_perTR/slice_plan->nslices_per_pass */
    mainseqctrl->duration += RUP_GRD(CEIL_DIV(timetoadd_perTR, slice_plan->nslices_per_pass));

  }

  /* get coreslice time, i.e. time for one slice. Note that this must come after early grad/RF heat calculation to reflect the increased mainseq duration */
  coreslice_duration = play_coreslice(&dummy_slice_pos, 0, core_nargs, core_args);

  /* momentstart will be = mainseqctrl->momentstart if there is no other sequence module in play_coreslice(). However if the coreslice function contains
  other sequence module they are required to be placed before the main sequence module to assure the inversion time is correctly calculated */
  coreslice_momentstart = coreslice_duration - mainseqctrl->duration + mainseqctrl->momentstart;



  if (ksinv1.params.irmode == KSINV_IR_SLICEAHEAD && ksinv2.params.irmode == KSINV_IR_SLICEAHEAD) {

    /*******************************************************************************************************
     * First and second IR when both are in mode KSINV_IR_SLICEAHEAD
     *******************************************************************************************************/

    /* mainseqctrl->duration already prolonged to meed grad/RF limits if necessary (see above).
       If both inversion pulses modes are KSINV_IR_SLICEAHEAD, the first IR has to get an approximate TI time using an
       (integer) ksinv1.params.nslicesahead and ksinv1.seqctrl.duration = ksinv1.seqctrl.min_duration. When calculating
       the sequence duration for ksinv2, we need to reserve this minimum time (ksinv1.seqctrl.min_duration) between the
       main sequence and ksinv2. Both IR pulses in KSINV_IR_SLICEAHEAD mode is faster, but the TI time for the first one
       will not be exact. For an FSE train of 200 ms, the TI will be rounded off by 200/2 ms at most, but since the 1st
       TI is usually 2500 ms when two IRs are used it may be ok */

    if (opautotr == FALSE || opautoti == FALSE) {
      return ks_error("%s: sliceahead mode requires AutoTI and AutoTR", __FUNCTION__);
    }

    /* 1st IR duration fixed to minimum */
    ksinv1.seqctrl.duration = ksinv1.seqctrl.min_duration;

    /* 2nd IR: get sequence module duration, TR and TI based on T1 null value and coreslice duration (iterative). Approximate TI if ksinv2.approxti = TRUE */
    status = ksinv_eval_duration_t1value(&ksinv2, &minTR, &ksinv2_ti, ksinv2.params.approxti, coreslice_momentstart, coreslice_duration + ksinv1.seqctrl.duration, mainseqctrl->min_duration, (int) (*ksinv2_t1value * 1000.0) /* [ms]->[us] */, slice_plan->nslices_per_pass);
    if (status != SUCCESS) return status;

    /* 1st IR (TI based on T1 to null) */
    ksinv1_ti = ksinv_eval_nullti(minTR, (int) (*ksinv1_t1value * 1000.0) /* [ms]->[us] */, mainseqctrl->min_duration);

    /* 1st IR (always approximate TI, using .duration = .min_duration) */
    ksinv1.params.nslicesahead = (ksinv1_ti + ksinv1.seqctrl.momentstart - coreslice_momentstart - ksinv1.seqctrl.min_duration)/ (coreslice_duration + ksinv1.seqctrl.min_duration);
    ksinv1_ti = ksinv1.params.nslicesahead * (coreslice_duration + ksinv1.seqctrl.min_duration) - ksinv1.seqctrl.momentstart + coreslice_momentstart;


  } else if (ksinv2.params.irmode == KSINV_IR_SIMPLE) {

    /*******************************************************************************************************
     * Second IR in mode KSINV_IR_SIMPLE
     *******************************************************************************************************/

     /* N.B: The TR we pass in to ksinv_eval_nullti() will be from last UI evaluation.
       This may change when opautotr = TRUE, and a new TI2 will cause a new TR due to TI1 calcs below,
       which in turn will cause a new TI2 etc. Can this be made non-iteratitve ? */
    ksinv2_ti = ksinv_eval_nullti(exist(optr), (int) (*ksinv2_t1value * 1000.0) /* [ms]->[us] */, mainseqctrl->min_duration);

    status = ksinv_eval_duration(&ksinv2, ksinv2_ti, coreslice_momentstart);
    if (status != SUCCESS) return status;

  }



  if (ksinv1.params.irmode == KSINV_FLAIR_BLOCK || ksinv1.params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {

    /*******************************************************************************************************
     * First IR in mode KSINV_FLAIR_BLOCK or KSINV_FLAIR_T2PREP_BLOCK (T2-FLAIR)
     *******************************************************************************************************/
    int TR;

    if (opautotr == FALSE) { /* Manual TR */
      int filltr_duration;

      /* minTR: Call ksinv_eval_flairblock() first in AutoTR mode to get the minimum TR to report back to the UI, then proceed with the actual TR (optr)
      using ksinv_eval_flairblock_withmainupdate(), where we also update the main sequence duration */
      status = ksinv_eval_flairblock(&ksinv1, &filltr_duration, &minTR, &ksinv1_ti, TRUE, (opautoti) * (*ksinv1_t1value * 1000.0),
                                   ksinv2.seqctrl.duration + coreslice_momentstart, ksinv2.seqctrl.duration + coreslice_duration, slice_plan->nslices_per_pass);

      TR = exist(optr);
      
      /* Maximum slices that would fit the chosen manual TR */
      int i = 0;
      while (1) {
        /* N.B. arg 3 (TR) not modified in ksinv_eval_flairblock() when arg 5 (opautotr) = FALSE */
        status = ksinv_eval_flairblock(&ksinv1, &filltr_duration, &TR, &ksinv1_ti, FALSE, (opautoti) * (*ksinv1_t1value * 1000.0),
                                     ksinv2.seqctrl.duration + coreslice_momentstart, ksinv2.seqctrl.duration + coreslice_duration, slice_plan->nslices_per_pass + i);
        if (filltr_duration <= 0) {
          avmaxslquant = slice_plan->nslices_per_pass + i - 1; break;
        } else {
          i++;
        }
      }

    } /* Manual TR */

    status = ksinv_eval_flairblock_withmainupdate(&ksinv1, &ksinv_filltr, mainseqctrl, (opautotr) ? (&minTR) : (&TR), 
                                                  &ksinv1_ti, opautotr, (opautoti) * (*ksinv1_t1value * 1000.0),
                                                  ksinv2.seqctrl.duration + coreslice_momentstart, ksinv2.seqctrl.duration + coreslice_duration, slice_plan->nslices_per_pass);
    if (status != SUCCESS) return status;

    if (opautotr) {
      /* show the optimal # slices to avoid inversion dummy inversion slices so the user can see what is the most time
         efficient number of slices (i.e. when scantime/slice is the lowest) */
      avmaxslquant = CEIL_DIV(slice_plan->nslices_per_pass, ksinv1.params.nflairslices) * ksinv1.params.nflairslices;
    } else if (existcv(optr)) {
      /* watch out for very narrow band of manual TR values between minTR and [minTR + nflairblocks*ksinv_filltr.ssi_time] where
      the sequence modules do not sum up to the intended optr since we have not been able to use the filltr sequence with this 
      short duration. Increase the minTR to trigger an error */
      int nflairblocks = CEIL_DIV(slice_plan->nslices_per_pass, ksinv1.params.nflairslices); /* number of FLAIR blocks */
      if (TR > minTR) {
        minTR = CEIL_DIV(minTR + nflairblocks * ksinv_filltr.ssi_time, 1000) * 1000;
      }
    }

    /* add the fillTR sequence module to the sequence collection (ignored if ksinv_filltr.duration = 0) */
    status = ks_eval_addtoseqcollection(seqcollection, &ksinv_filltr);
    if (status != SUCCESS) return status;   

  } else if (ksinv1.params.irmode == KSINV_IR_SIMPLE && (opautotr == FALSE || opautoti == FALSE)) {

    /*******************************************************************************************************
    * First IR in mode KSINV_IR_SIMPLE and not both AutoTI and AutoTR
    *******************************************************************************************************/

    if (opautoti) {
      /* AutoTI: set TI based on ksinv1_t1value and current (manual) TR */
      ksinv1_ti = ksinv_eval_nullti(exist(optr), (int) (*ksinv1_t1value * 1000.0) /* [ms]->[us] */, mainseqctrl->min_duration);
    }

    /* set the sequence module duration */
    status = ksinv_eval_duration(&ksinv1, ksinv1_ti, coreslice_momentstart);
    if (status != SUCCESS) return status;

    /* calculate min TR given the ksinv_scan_sliceloop() duration and addition heating penalties */
    minTR = ksinv_eval_mintr(slice_plan, seqcollection, ks_gheatfact, &ksinv1, &ksinv2, NULL, play_coreslice, core_nargs, core_args);
    if (minTR == KS_NOTSET) return FAILURE;

    /* how much time to add due to long manual TR (opautotr = FALSE) or due to heating (opautotr = TRUE) */
    if (opautotr == FALSE) {
      timetoadd_perTR = exist(optr) - ksinv_scan_sliceloop(slice_plan, ks_scan_info, 0, &ksinv1, &ksinv2, NULL, FALSE, play_coreslice, core_nargs, core_args);
    } else {
      timetoadd_perTR = minTR - ksinv_scan_sliceloop(slice_plan, ks_scan_info, 0, &ksinv1, &ksinv2, NULL, FALSE, play_coreslice, core_nargs, core_args);
    }

    /* we spread the available timetoadd_perTR evenly, by increasing .duration of each slice by timetoadd_perTR/slice_plan->nslices_per_pass */
    mainseqctrl->duration += RUP_GRD(CEIL_DIV(timetoadd_perTR, slice_plan->nslices_per_pass));


  } else if ( ((ksinv1.params.irmode == KSINV_IR_SLICEAHEAD) && (ksinv2.params.irmode != KSINV_IR_SLICEAHEAD)) || ((ksinv1.params.irmode == KSINV_IR_SIMPLE) && (opautoti == TRUE) && (opautotr == TRUE)) ) {

    /*******************************************************************************************************
     * First IR, in mode
     * - KSINV_IR_SIMPLE with AutoTI and AutoTR
     * - KSINV_IR_SLICEAHEAD, when second IR was not KSINV_IR_SLICEAHEAD
     * For both cases, early heating control has been done
     *******************************************************************************************************/

     if (opautotr == FALSE || opautoti == FALSE) {
      return ks_error("%s: sliceahead mode requires both AutoTI and AutoTR", __FUNCTION__);
    }

    /* get sequence module duration, TR and TI based on T1 null value and coreslice duration */
    status = ksinv_eval_duration_t1value(&ksinv1, &minTR, &ksinv1_ti, ksinv1.params.approxti, coreslice_momentstart, coreslice_duration, mainseqctrl->min_duration, (int) (*ksinv1_t1value * 1000.0) /* [ms]->[us] */, slice_plan->nslices_per_pass);
    if (status != SUCCESS) return status;

  }


  /*******************************************************************************************************
  * update UI and GE globals
  *******************************************************************************************************/

  /* for AutoTI, update TI menu (first row) with the value in ksinv1_ti as well as opti */
  if (opautoti == TRUE) {
    pitival2 = ksinv1_ti;
    cvoverride(opti, ksinv1_ti, PSD_FIX_ON, PSD_EXIST_ON);
  }

  if (ksinv2.params.irmode != KSINV_OFF) { /* update opuser for IR2 T1-value with TI information */
    char tmpstr[200];
    sprintf(tmpstr, "IR2 - T1 to null (TI=%d ms)", ksinv2_ti/ 1000);
    _cvdesc(_ksinv2_t1value, tmpstr);

    if ((ksinv1_ti - ksinv1.seqctrl.min_duration) < ksinv2_ti) {
      return ks_error("%s: IR2 must be shorter than IR1", __FUNCTION__);
    }
  }

  /* set npasses in slice plan to be consistent with nslices and nslices_per_pass */
  avmaxacqs = slice_plan->npasses; /* UI value ("# of Acqs:") */

  /* update min TR advisory */
  avmintr = minTR;
  avmaxtr = 100000000;

  /* make sure TR in UI (optr) is long enough */
  if (opautotr == TRUE) {

    avmaxtr = minTR;

    cvoverride(optr, minTR, PSD_FIX_ON, PSD_EXIST_ON);

    if (ksinv1.params.irmode != KSINV_FLAIR_BLOCK && ksinv1.params.irmode != KSINV_FLAIR_T2PREP_BLOCK) {
      avmaxslquant = slice_plan->nslices_per_pass;
    }

  } else if (existcv(optr) && (optr < minTR)) {

    return ks_error("%s: increase TR to %.1f ms (seq./heating limit)", __FUNCTION__, minTR/ 1000.0);

  } else {
    if (avmaxslquant < slice_plan->nslices_per_pass) {
      /* avoid the max slices value in the UI to show up smaller than the prescribed slices/pass now that all is good */
      avmaxslquant = slice_plan->nslices_per_pass;
    }
  }

  /* prevent further addition of other sequence modules. Inversion must be last one added to the
    sequence collection to keep inversion timing correct */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;

  /* synonyms for optr: avail_image_time and act_tr */
  avail_image_time = RDN_GRD(exist(optr));
  act_tr = avail_image_time;
  ihtr  = _ihtr.fixedflag ?  ((void)(act_tr), ihtr) : act_tr; /* image header TR */
  avminslquant = 1;


  /*******************************************************************************************************
  * Final SAR check
  *******************************************************************************************************/
  /* assure that we have taken care of TR timing and grad/RF heating issues so that we don't call GEReq_eval_TR() again
     This also prevents further addition of other sequence modules */
  seqcollection->evaltrdone = TRUE;

  /* Check TR timing and SAR limits */
  status = ksinv_eval_checkTR_SAR(seqcollection, slice_plan, play_coreslice, core_nargs, core_args);
  if (status != SUCCESS) return status;



return SUCCESS;

} /* ksinv_eval_multislice() */





/**
 *******************************************************************************************************
 @brief #### Runs the inversion slice loop and validates TR and SAR/hardware limits

 This function first makes sure that the `.nseqinstances` field for each sequence module in the sequence
 collection corresponds to the number of times played out in ksinv_scan_sliceloop()

 In simulation (WTools), ks_print_seqcollection() will print out a table of the sequence modules in
 the sequence collection in the WToolsMgd window.

 Finally, GEReq_eval_checkTR_SAR_calcs() is called to check that the TR is correct and within SAR/hardware
 limits.

 N.B.: For non-inversion sequences, ks_eval_checkTR_SAR() is used to do the same thing, with the difference
 that the psd's sliceloop function is used instead of ksinv_scan_sliceloop().

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] slice_plan Pointer to the KS_SLICE_PLAN struct holding the slice order information
 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_eval_checkTR_SAR(KS_SEQ_COLLECTION *seqcollection, KS_SLICE_PLAN *slice_plan, int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {
  STATUS status;

  /* set all `seqctrl.nseqinstances` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);

  /* set all `seqctrl.nseqinstances` to the number of occurrences */
  ksinv_scan_sliceloop(slice_plan, ks_scan_info, 0, &ksinv1, &ksinv2, &ksinv_filltr, FALSE, play_coreslice, core_nargs, core_args);

  /* validate TR and check that we are within SAR/hardware limits */
  status = GEReq_eval_checkTR_SAR_calcs(seqcollection, optr);
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* ksinv_eval_checkTR_SAR() */




/**
 *******************************************************************************************************
 @brief #### Checks related to inversion

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_check() {

  if (existcv(optr) && (opflair == OPFLAIR_INTERLEAVED) && (optr < KSINV_MINTR_T1FLAIR)) {
    ks_error("%s: TR should be >= %d ms for T1FLAIR", __FUNCTION__, KSINV_MINTR_T1FLAIR/1000);
  }

return SUCCESS;

}




/**
 *******************************************************************************************************
 @brief #### Sets IR-related recon variables in predownload

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_predownload_setrecon() {

  if (ksinv1_mode != KSINV_OFF) {
    cvoverride(ihti, ksinv1_ti, PSD_FIX_ON, PSD_EXIST_ON); /* same as opti */
  }

  return SUCCESS;

} /* ksinv_predownload_setrecon() */






/*******************************************************************************************************
*******************************************************************************************************
*
*  KSInversion.e: PULSEGEN functions
*                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
*
*******************************************************************************************************
*******************************************************************************************************/

KS_MAT4x4 Mphysical_inversion = KS_MAT4x4_IDENTITY;




/**
 *******************************************************************************************************
 @brief #### Generation of the waveforms for the sequence objects in a KSINV_SEQUENCE

 Two KSINV_SEQUENCE structs are currently declared in KSInversion.e, `ksinv1` and `ksinv2`. By passing
 each one of them to this function, will generate the actual sequence on TGT. On HOST, the
 `seqctrl.min_duration` field is set and used by TI/TR calculations.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_pg(KSINV_SEQUENCE *ksinv) {
  STATUS status;
  KS_SEQLOC loc = KS_INIT_SEQLOC;


  if (ksinv->params.irmode == KSINV_OFF)
    return SUCCESS;

#ifdef IPG
  /* TGT (IPG) only: return early if sequence module duration is zero */
  if (ksinv->seqctrl.duration == 0)
    return SUCCESS;
#endif


  loc.pos = ksinv->params.startpos;

  if (loc.pos % GRAD_UPDATE_TIME) {
    return ks_error("%s: Start position of RF pulse must be divisible by GRAD_UPDATE_TIME (ksinv->params.rfstartpos = %d)", __FUNCTION__, ksinv->params.startpos);
  }
  if (loc.pos < KS_RFSSP_PRETIME) {
    return ks_error("%s: Start position of RF pulse must be at least %d [us] (ksinv->params.rfstartpos = %d)", __FUNCTION__, KS_RFSSP_PRETIME, ksinv->params.startpos);
  }

  /* RF */
  if (ksinv_slicecheck){
    loc.board = XGRAD;
  } else {
    loc.board = ZGRAD;
  }


  if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {

    if (ks_pg_selrf(&ksinv->selrfexc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;

    int mag_center_exc = loc.pos + ksinv->selrfexc.grad.ramptime + ksinv->selrfexc.rf.start2iso;

    /* now refocussing pulses*/
    /* we make sure that that delta_t_refoc/2 is a multiple of GRAD_UPDATE_TIME using the RUP_GRD function (division results are integer truncated) */
    int delta_t_refoc_half = RUP_GRD(ksinv->params.t2prep_TE/ ksinv->params.N_Refoc/ 2);

    /* first refocusing pulse*/
    loc.pos = mag_center_exc + delta_t_refoc_half - ksinv->selrfrefoc.grad.ramptime - ksinv->selrfrefoc.rf.start2iso - ksinv->selrfrefoc.pregrad.duration;
    if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    /* all other refocusing pulses*/
    int n;
    for (n = 1; n < ksinv->params.N_Refoc; n++) {
      loc.pos += 2*delta_t_refoc_half;
      if (ks_pg_selrf(&ksinv->selrfrefoc, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
    }

    /***************************************************************************************************
     *  two different versions
     *  non adiabatic (+90)-(n*180)-(+90)
     *  adiabatic (+90)-(n*180)-(-90)-(180)
     *  the polarity of the flip angle of the flip pulse is set with loc.ampscale
     ***************************************************************************************************/

    loc.pos = mag_center_exc + ksinv->params.N_Refoc*delta_t_refoc_half*2 - ksinv->selrfflip.grad.ramptime - ksinv->selrfflip.rf.start2iso - ksinv->selrfflip.pregrad.duration;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      loc.ampscale = -1;
    } else {
      loc.ampscale = 1;
    }

    if (ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) == FAILURE)
    return FAILURE;
    
    /* Save absolute time in sequence for moment start, it is important to do that after 
    ks_pg_selrf(&ksinv->selrfflip, loc, &ksinv->seqctrl) because otherwise ksinv->seqctrl.momentstart would be overwritten as
    the "ROLE" of selrfflip is an excitation pulse, there is no ROLE for a flipup pulse yet */
    ksinv->seqctrl.momentstart = mag_center_exc;   

    loc.ampscale = 1; /* set it back to default */
    /* waveform overlap problems between selrfflip and selrfinv on DV25 --> 5*GRAD_UPDATE_TIME safety margin */
    loc.pos += ksinv->selrfflip.pregrad.duration + ksinv->selrfflip.grad.duration + 5*GRAD_UPDATE_TIME;
    
    if (ksinv->params.rftype == KSINV_RF_ADIABATIC) {
      if (ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl) == FAILURE)
      return FAILURE;
      loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;
    }
  } else {

    /* Save absolute time in sequence for moment start */
    ksinv->seqctrl.momentstart = loc.pos + ksinv->selrfinv.grad.ramptime + ksinv->selrfinv.rf.start2iso;

    status = ks_pg_selrf(&ksinv->selrfinv, loc, &ksinv->seqctrl);
    if (status != SUCCESS) return status;

    loc.pos += (ksinv->selrfinv.grad.duration > 0) ? ksinv->selrfinv.grad.duration : ksinv->selrfinv.gradwave.duration;

  }

  /* Z spoiler */
  loc.board = YGRAD;
  status = ks_pg_trap(&ksinv->spoiler, loc, &ksinv->seqctrl);
  if (status != SUCCESS) return status;
  loc.pos += ksinv->spoiler.duration;


 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksinv->seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  loc.pos = RUP_GRD(loc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence module duration (ksinv->seqctrl.ssi_time must be > 0 and is added to ksinv->seqctrl.min_duration in ks_eval_seqctrl_setminduration()) */
  ksinv->seqctrl.ssi_time = ksinv->params.ssi_time;
  ks_eval_seqctrl_setminduration(&ksinv->seqctrl, loc.pos); /* loc.pos now corresponds to the end of last gradient in the sequence */
#endif


  return SUCCESS;

} /* ksinv_pg() */




/**
 *******************************************************************************************************
 @brief #### Generation of all inversion-related sequence modules

 This function should be called directly from the `pulsegen()` function in a psd to create up to three
 sequence modules that can be used during scan.

 N.B.: If ksinvX.seqctrl.duration = 0, both ksinv_pg() and KS_SEQLENGTH() will return early avoiding this
 sequence module to be created. Similarly for the seqInvFillTR wait sequence.

 @return void
********************************************************************************************************/
void ksinv_pulsegen() {

  /* First (only) Inversion sequence module */
  ksinv_pg(&ksinv1);
   
    {
      if (ksinv1.seqctrl.duration > 0) {

        if (ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv1.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv1, "seqInv1");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv1) failed", ksinv1.seqctrl.description);
          }  
          status = createseq(&seqInv1, ksinv1.seqctrl.duration - ksinv1.seqctrl.ssi_time, off_seqInv1);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv1) failed", ksinv1.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv1 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv1) failed", ksinv1.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv1 = %d\n", idx_seqInv1 );
          ksinv1.seqctrl.handle.index = idx_seqInv1;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv1.seqctrl.handle.offset = off_seqInv1;
          ksinv1.seqctrl.handle.pulse = &seqInv1;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv1.seqctrl.duration = 0 */

  /* 2nd Inversion sequence module */
  ksinv_pg(&ksinv2);
   
    {
      if (ksinv2.seqctrl.duration > 0) {

        if (ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv2.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqInv2, "seqInv2");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInv2) failed", ksinv2.seqctrl.description);
          }  
          status = createseq(&seqInv2, ksinv2.seqctrl.duration - ksinv2.seqctrl.ssi_time, off_seqInv2);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInv2) failed", ksinv2.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInv2 );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInv2) failed", ksinv2.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInv2 = %d\n", idx_seqInv2 );
          ksinv2.seqctrl.handle.index = idx_seqInv2;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv2.seqctrl.handle.offset = off_seqInv2;
          ksinv2.seqctrl.handle.pulse = &seqInv2;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv2.seqctrl.duration = 0 */

  /* FillTR sequence for some inversion cases */
   
    {
      if (ksinv_filltr.duration > 0) {

        if (ksinv_filltr.duration - ksinv_filltr.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksinv_filltr.description);

        } else {

          STATUS status = pulsename(&seqInvFillTR, "seqInvFillTR");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqInvFillTR) failed", ksinv_filltr.description);
          }  
          status = createseq(&seqInvFillTR, ksinv_filltr.duration - ksinv_filltr.ssi_time, off_seqInvFillTR);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqInvFillTR) failed", ksinv_filltr.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqInvFillTR );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqInvFillTR) failed", ksinv_filltr.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqInvFillTR = %d\n", idx_seqInvFillTR );
          ksinv_filltr.handle.index = idx_seqInvFillTR;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksinv_filltr.handle.offset = off_seqInvFillTR;
          ksinv_filltr.handle.pulse = &seqInvFillTR;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if ksinv_filltr.duration = 0 */

} /* ksinv_pulsegen() */




/**
 *******************************************************************************************************
 @brief #### Sets the current state of a KSINV_SEQUENCE during scanning

 This function sets the current state of all `ksinv` sequence objects being part of KSINV_SEQUENCE,
 specifically slice-dependent RF freq/phases changes.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] ksinv Pointer to KSINV_SEQUENCE
 @param[in] slice_info Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksinv_scan_seqstate(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_info) {

  if (ksinv->params.irmode == KSINV_OFF || ksinv->seqctrl.duration == 0)
    return SUCCESS;

  if (slice_info != NULL) {

    ks_scan_rotate(*slice_info);

    if (ksinv->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
      ks_scan_rf_on(&ksinv->selrfexc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfexc, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfrefoc.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfrefoc, INSTRALL, *slice_info, 90);

      ks_scan_rf_on(&ksinv->selrfinv.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfinv, INSTRALL, *slice_info, 0);

      ks_scan_rf_on(&ksinv->selrfflip.rf, INSTRALL);
      ks_scan_selrf_setfreqphase(&ksinv->selrfflip, INSTRALL, *slice_info, 0);

    } else {  
      ks_scan_rf_on(&ksinv->selrfinv.rf, 0);

      if (ksinv->selrfinv.sms_info.pulse_type == KS_SELRF_SMS_PINS_DANTE) {
        ks_scan_selrf_setfreqphase_pins(&ksinv->selrfinv, 0, *slice_info,
                                        ksinv->selrfinv.sms_info.mb_factor, ksinv->selrfinv.sms_info.slice_gap, 0.0);
      } else {
        ks_scan_selrf_setfreqphase(&ksinv->selrfinv, 0, *slice_info, 0);
      }
    }

  } else {

    ks_scan_rf_off(&ksinv->selrfinv.rf, 0);

  }

  return SUCCESS;

} /* ksinv_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Plays out one inversion slice in real time during scanning

  On TGT on the MR system (PSD_HW), this function sets up (ksepi_scan_seqstate()) and plays out one
  KSINV_SEQUENCE. The low-level function call `startseq()`, which actually starts the realtime sequence
  playout is called from within ks_scan_playsequence(), which in addition also returns the time to play
  out that sequence module (see time += ...).

  On HOST (in ksepi_eval_tr()) we call ksepi_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksepi_scan_scantime(), which returns the total time of the
  entire scan.

  @param[in] ksinv Pointer to KSINV_SEQUENCE
  @param[in] slice_pos Pointer to position of the slice to be played out (one element in the `ks_scan_info[]` array)
  @retval irtime Time taken in [us] to play out one inversion slice
********************************************************************************************************/
int ksinv_scan_irslice(KSINV_SEQUENCE *ksinv, const SCAN_INFO *slice_pos) {
  SCAN_INFO slice_pos_updated;
  int time = 0;
  float tloc = 0.0;

  if (ksinv == NULL) {
    return 0;
  }

  if (ksinv->params.irmode != KSINV_OFF && ksinv->seqctrl.duration > 0) {

    if (slice_pos != NULL) {
      /* N.B.: Mphysical_inversion is an ipgexport KS_MAT4x4 variable that e.g. the main sequence can update in real time */
      ks_scan_update_slice_location(&slice_pos_updated, *slice_pos, Mphysical_inversion, NULL);
      tloc = slice_pos_updated.optloc;
      ksinv_scan_seqstate(ksinv, &slice_pos_updated);
    } else {
      ksinv_scan_seqstate(ksinv, slice_pos);
    }

    /* SMS offset */
    float offset = (ksinv->selrfinv.sms_info.slice_gap/ 2) * (ksinv->selrfinv.sms_info.mb_factor - 1);
    float sms_slice_positions[ksinv->selrfinv.sms_info.mb_factor];
    int slice = 0;
    for (slice = 0; slice < ksinv->selrfinv.sms_info.mb_factor; ++slice) {
      if (slice_pos != NULL)
        sms_slice_positions[slice] = tloc + ksinv->selrfinv.sms_info.slice_gap * (0.5 + slice - (ksinv->selrfinv.sms_info.mb_factor/ 2.0)) + offset;
      else
        sms_slice_positions[slice] = 0;
    }

    ks_plot_slicetime(&ksinv->seqctrl,
                      ksinv->selrfinv.sms_info.mb_factor,
                      sms_slice_positions,
                      ksinv->selrfinv.slthick,
                      slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

    time += ks_scan_playsequence(&ksinv->seqctrl);

  }

  return time;

} /* ksinv_scan_irslice() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slice_plan.nslices_per_pass` slices corresponding to one TR for inversion psds

 This function should replace the sliceloop function of a 2D psd when inversion is enabled. It will take
 over the sequence timing for one TR by playing out the inversion sequence module(s) and other sequence
 modules in an order that is subject to the inversion mode (`ksinvX.params.irmode`). The non-inversion
 sequence modules should be played out together in a 'core slice' function of the psd. This core slice
 function should have a wrapper function with standardized input arguments that conmplies with the
 function pointer (and core_nargs, core_args) passed to this function.

 @param[in] slice_plan  Pointer to the slice plan (KS_SLICE_PLAN) set up earlier using ks_calc_sliceplan() or similar
 @param[in] slice_positions Pointer to the SCAN_INFO array corresponding to the slice locations (typically `ks_scan_info`)
 @param[in] passindx  Pass index in range `[0, ks_slice_plan.npasses - 1]`
 @param[in] ksinv1    Pointer to KSINV_SEQUENCE corresponding to the 1st (or only) inversion. Cannot be NULL
 @param[in] ksinv2    Pointer to KSINV_SEQUENCE corresponding to an optional 2nd inversion. May be NULL
 @param[in] ksinv_filltr    Pointer to KS_SEQ_CONTROL for fillTR sequence for FLAIR block modes. May be NULL
 @param[in] ksinv_loop_mode If KSINV_LOOP_DUMMY, this function will pass in KS_NOTSET (-1) as the 2nd argument to 'play_coreslice'.
                       For this to work, the play_coreslice() function (usually the main sequence's coreslice),
                       must check if it's 2nd arg is KS_NOTSET, and if so shut off data collection in loaddab()
                       KSINV_LOOP_NORMAL: Slice excitation ON, Data acq. ON
                       KSINV_LOOP_DUMMY: Slice excitation ON, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_FIRST: Slice excitation ON for IR, OFF for coreslice, Data acq. OFF
                       KSINV_LOOP_SLICEAHEAD_LAST: Slice excitation OFF for IR, ON for coreslice, Data acq. ON

 @param[in] play_coreslice Function pointer to (the wrapper function to) the coreslice function of the sequence
 @param[in] core_nargs Number of extra input arguments to the coreslice wrapper function.
 @param[in] core_args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's coreslice function
 @retval slicelooptime Time taken in [us] to play out `slice_plan.nslices_per_pass` slices
********************************************************************************************************/
int ksinv_scan_sliceloop(const KS_SLICE_PLAN *slice_plan, const SCAN_INFO *slice_positions, int passindx, 
                         KSINV_SEQUENCE *ksinv1, KSINV_SEQUENCE *ksinv2, KS_SEQ_CONTROL *ksinv_filltr, KSINV_LOOP_MODE ksinv_loop_mode,
                         int (*play_coreslice)(const SCAN_INFO *, int, int, void **), int core_nargs, void **core_args) {
  int time = 0;
  int i, sltimeinpass;
  int slloc, sltime_adjusted;
  const SCAN_INFO *slpos;

  if (ksinv1 == NULL) {
    ks_error("%s: 4th arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (ksinv1->params.irmode == KSINV_OFF) {
    return 0;  /* if the IR mode for the 1st IR is off, return quietly */
  }
  if (slice_plan == NULL) {
    ks_error("%s: 1st arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }
  if (slice_positions == NULL) {
    ks_error("%s: 2nd arg cannot be NULL", __FUNCTION__);
    return KS_NOTSET;
  }

  if (play_coreslice == NULL) {
    ks_error("%s: 7th arg must be a function pointer to the coreslice function", __FUNCTION__);
    return KS_NOTSET;
  }


  if (ksinv1->params.irmode == KSINV_FLAIR_BLOCK || ksinv1->params.irmode == KSINV_FLAIR_T2PREP_BLOCK) {
    /* For classic T2-FLAIR, we often end up with 2 sets of FLAIR+core per TR
       Here is a generalization, where number of sets is equal to:
       CEIL_DIV(slice_plan->nslices_per_pass, ksinv1->params.nflairslices), where slice_plan->nslices_per_pass = CEIL_DIV(slice_plan->nslices, slice_plan->npasses)
    */
   
    /* make sure nflairslices > 0, or else we will be stuck here as sltimeinpass will remain at 0 forever */
    if (ksinv1->params.nflairslices <= 0) {
      ks_error("%s: ksinv1.params.nflairslices must be > 0", __FUNCTION__);
      return -1;
    }

    sltimeinpass = 0;

    while (sltimeinpass < slice_plan->nslices_per_pass) {

      /*--------- 1st inversion sequence module as FLAIR block -----------*/
      for (i = 0; i < ksinv1->params.nflairslices; i++) {
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      for (i = 0; (i < ksinv1->params.nflairslices) && (sltimeinpass + i < slice_plan->nslices_per_pass); i++) {

        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass + i);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;

        if (ksinv2 != NULL) {
          /*--------- optional 2nd inversion sequence module (DIR mode) attached to each coreslice playout -----------*/
          time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
        }

        /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
        time += play_coreslice(
                  slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                  (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : (sltimeinpass + i), /* if KS_NOTSET (-1), shut off data acquisition */
                  core_nargs, core_args);
      }

      sltimeinpass += ksinv1->params.nflairslices;

      if (ksinv_filltr != NULL) {
        /*--------- fillTR sequence module (to fill up to manual TR in CEIL_DIV(nslices_per_pass, ksinv1->params.nflairslices) chunks) -----------*/
        time += ks_scan_playsequence(ksinv_filltr);
        ks_plot_slicetime(ksinv_filltr, 1, NULL, KS_NOTSET, KS_PLOT_NO_EXCITATION); /* Add a filler to slicetime plot */
      }

    } /* while */


  } else {

    int sltime_start = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? (slice_plan->nslices_per_pass - ksinv1->params.nslicesahead) : 0;

    for (sltimeinpass = sltime_start; sltimeinpass < slice_plan->nslices_per_pass; sltimeinpass++) {

      /*--------- 1st inversion sequence module -----------*/
      if (ksinv1->params.irmode == KSINV_IR_SIMPLE || ksinv1->params.irmode == KSINV_IR_SLICEAHEAD)  {
        sltime_adjusted = (sltimeinpass + ksinv1->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;        
        slpos = ((ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_LAST) && (sltime_adjusted < ksinv1->params.nslicesahead)) ? NULL : slpos;
        time += ksinv_scan_irslice(ksinv1, slpos /* if NULL, shut off RF */);
      }

      /*--------- 2nd inversion sequence module -----------*/
      if (ksinv2 != NULL && (ksinv2->params.irmode == KSINV_IR_SIMPLE || ksinv2->params.irmode == KSINV_IR_SLICEAHEAD)) {
        sltime_adjusted = (sltimeinpass + ksinv2->params.nslicesahead) % slice_plan->nslices_per_pass;
        slloc = ks_scan_getsliceloc(slice_plan, passindx, sltime_adjusted);
        slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
        time += ksinv_scan_irslice(ksinv2, slpos /* if NULL, shut off RF */);
      }

      /*--------- "coreslice": main sequence module (may include e.g. GRx Sat, FatSat etc.) -----------*/
      slloc = ks_scan_getsliceloc(slice_plan, passindx, sltimeinpass);
      slpos = (slloc != KS_NOTSET) ? &slice_positions[slloc] : NULL;
      slpos = (ksinv_loop_mode == KSINV_LOOP_SLICEAHEAD_FIRST) ? NULL : slpos;
      time += play_coreslice(
                slpos, /* if NULL, shut off RF. The coreslice function must also shut data acquisition off regardless of next arg */
                (ksinv_loop_mode == KSINV_LOOP_DUMMY) ? KS_NOTSET : sltimeinpass, /* if KS_NOTSET (-1), shut off data acquisition */
                core_nargs,
                core_args);

    } /* slice in pass */

  } /* else (not FLAIR-block) */

  return time;

} /* ksinv_scan_sliceloop() */
 
                         

int ksinv_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  KS_SLICE_PLAN slice_plan = KS_INIT_SLICEPLAN;
  slice_plan.nslices_per_pass = slperpass;
  SCAN_INFO *slice_positions = NULL;
  int passindx = 0;
  KSINV_SEQUENCE *ksinv1 = NULL;
  KSINV_SEQUENCE *ksinv2 = NULL;
  KS_SEQ_CONTROL *ksinv_filltr = NULL;
  KSINV_LOOP_MODE ksinv_loop_mode = KSINV_LOOP_NORMAL;
  int (*play_coreslice)(const SCAN_INFO *, int, int, void **) = 0;
  int core_nargs = 0;
  void **core_args = NULL;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain 7 or 9 elements: slice_positions, passindx, &ksinv1, &ksinv2, &ksinv_filltr, play_as_dummy, play_coreslice [, core_nargs, core_args]", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    slice_positions = (SCAN_INFO *) args[0];
  }
  if (nargs >= 2 && args[1] != NULL) {
    passindx = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    ksinv1 = (KSINV_SEQUENCE *) args[2];
  }
  if (nargs >= 4 && args[3] != NULL) {
    ksinv2 = (KSINV_SEQUENCE *) args[3];
  }
  if (nargs >= 5 && args[4] != NULL) {
    ksinv_filltr = (KS_SEQ_CONTROL *) args[4];
  }
  if (nargs >= 6 && args[5] != NULL) {
    ksinv_loop_mode = *((KSINV_LOOP_MODE *) args[5]);
  }
  if (nargs >= 7 && args[6] != NULL) {
    play_coreslice = (int (*)(const SCAN_INFO *, int, int, void **)) args[6];
  }
  if (nargs >= 8 && args[7] != NULL) {
    core_nargs = *((int *) args[7]);
  }
  if (nargs >= 9 && args[8] != NULL) {
    core_args = (void **) args[8];
  }

  return ksinv_scan_sliceloop(&slice_plan, slice_positions, passindx, ksinv1, ksinv2, ksinv_filltr, ksinv_loop_mode, play_coreslice, core_nargs, core_args); /* in [us] */

} /* ksfse_scan_sliceloop_nargs() */

/******************************************************************************************************
 * Neuro MR Physics group
 * Department of Neuroradiology
 * Karolinska University Hospital
 * Stockholm, Sweden
 *
 * Filename : ksfse_implementation.e
 *
 * Authors  : Stefan Skare, Enrico Avventi, Henric Rydn, Ola Norbeck
 * Date     : 2019-Feb-15
 * Version  : 2.2
 *******************************************************************************************************
 * This code is shared under a specific licence agreement available on GE's collaboration portal, which
 * regulates the use of this software and states specifically that neither Karolinska University nor GE
 * Healthcare can be hold liable for anything related to the use of this software. Please consult this
 * legal document for details on collaborate.mr.gehealthcare.com. As with any other EPIC psd software,
 * compiled by an EPIC licenced user, it is to be used for research purposes only.
 *
 * The Neuro MR physics group at Karolinska University hospital encourages further modifications of, and
 * additions to, the provided PSDs and PSD modules. It is our hope that the KSFoundation library and
 * can provide a common base on top of which research users can share PSDs and PSD modules with each
 * other by e.g. adding branches or forks to the KSFoundation repository:
 * https://gitlab.com/neuromr_karolinska/psd_ksfoundation
 *******************************************************************************************************/

/**
********************************************************************************************************
* @file ksfse_implementation.e
* @brief This file contains the implementation details for the *ksfse* psd
********************************************************************************************************/




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: Host functions
 *
 *******************************************************************************************************
 *******************************************************************************************************/

abstract("FSE [KSFoundation]");
psdname("ksfse");

/* function prototypes */
void ksfse_eval_TEmenu(int esp, int maxte, int etl, double optechono);
STATUS ksfse_calc_echo(double *bestecho, double *optecho, KS_PHASER *pe, int TE, int etl, int esp);
STATUS ksfse_pg(int);
int ksfse_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, int shot, int exc);
int ksfse_scan_coreslice_nargs(const SCAN_INFO *slice_pos, int dabslice, int nargs, void **args);
int ksfse_scan_sliceloop(int slperpass, int passindx, int shot, int exc);
int ksfse_scan_sliceloop_nargs(int slperpass, int nargs, void **args);
float ksfse_scan_acqloop(int); /* float since scan clock will be 0:00 if scan time > 38 mins otherwise */
float ksfse_scan_scanloop();
STATUS ksfse_scan_seqstate(SCAN_INFO slice_info, int shot);

#include "epic_iopt_util.h"
#include <psdiopt.h>



/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: CVINIT
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/*******************************************************************************************************
  MultiPhase imaging option button:
  N.B: There are two types of multi-phase modes that are mutually exlusive, mapping to one and same UI
       button option (MultiPhase):
  Mode 1 (PSD_IOPT_MPH): opmph = 1 & opfphases > 1. Use opfphases-for-loop in scan for multiple volumes
  Mode 2 (PSD_IOPT_DYNPL): opdynaplan = 1 & opfphases = 1. The HOST is running the PSD multiple times
         and no modifications or for-loop in the PSD

  PSD_IOPT_DYNPL mode is used for this PSD (ksfse)
********************************************************************************************************/
int sequence_iopts[] = {
  PSD_IOPT_ARC, /* oparc */
  PSD_IOPT_ASSET, /* opasset (SENSE) */
  PSD_IOPT_EDR, /* opptsize */
  PSD_IOPT_DYNPL, /* opdynaplan */
  PSD_IOPT_TLRD_RF, /* optlrdrf */
  PSD_IOPT_MILDNOTE, /* opsilent */
  PSD_IOPT_ZIP_512, /* opzip512 */
#if EPIC_RELEASE >= 26
  PSD_IOPT_FR, /* opfr */
  PSD_IOPT_T1FLAIR, /* opt1flair */
  PSD_IOPT_T2FLAIR, /* opt2flair */
  PSD_IOPT_IR_PREP, /* opirprep */
#endif
#ifdef UNDEF
  PSD_IOPT_SEQUENTIAL, /* opirmode */
  PSD_IOPT_ZIP_1024, /* opzip1024 */
  PSD_IOPT_SLZIP_X2, /* opzip2 */
  PSD_IOPT_MPH, /* opmph */
  PSD_IOPT_NAV, /* opnav */
  PSD_IOPT_FLOW_COMP, /* opfcomp */
#endif
};




/**
 *******************************************************************************************************
 @brief #### Initial handling of imaging options buttons and top-level CVs at the PSD type-in pages
 @return void
********************************************************************************************************/
void ksfse_init_imagingoptions(void) {
  int numopts = sizeof(sequence_iopts)/ sizeof(int);

  psd_init_iopt_activity();
  activate_iopt_list(numopts, sequence_iopts);
  enable_iopt_list(numopts, sequence_iopts);

  /* Imaging option control functions (using PSD_IOPT_ZIP_512 as example):
    - Make an option unchecked and not selectable: disable_ioption(PSD_IOPT_ZIP_512)
    - Make an option checked and not selectable:   set_required_disabled_option(PSD_IOPT_ZIP_512)
    - Remove the imaging option:                   deactivate_ioption(PSD_IOPT_ZIP_512)
  */

  cvmax(opimode, PSD_3DM);

  /* Button accept control */
  cvmax(opepi, PSD_OFF); /* don't allow EPI selection */
  cvmax(opfast, PSD_ON);
  cvmax(opssfse, PSD_ON);
  cvmax(opflair, OPFLAIR_INTERLEAVED);
  cvmax(optlrdrf, PSD_ON);
  cvmax(opfr, PSD_ON);

  if (KS_3D_SELECTED) {
    pidefexcitemode = NON_SELECTIVE;
    piexcitemodenub = 1 + 2 /* + 4 FOCUS */;
    cvmax(opexcitemode, NON_SELECTIVE);

    /* For now, 3D is not compatible with: */
#if EPIC_RELEASE >= 26
    deactivate_ioption(PSD_IOPT_T1FLAIR);
    deactivate_ioption(PSD_IOPT_T2FLAIR);
#endif
    deactivate_ioption(PSD_IOPT_IR_PREP);
    deactivate_ioption(PSD_IOPT_TLRD_RF);
  }

#ifdef SIM
  oppseq  = _oppseq.fixedflag ?  ((void)(PSD_SE), oppseq) : PSD_SE;
  setexist(oppseq, PSD_ON);
  opfast  = _opfast.fixedflag ?  ((void)(PSD_ON), opfast) : PSD_ON;
  setexist(opfast, PSD_ON);
  opirmode  = _opirmode.fixedflag ?  ((void)(PSD_OFF), opirmode) : PSD_OFF; /* default interleaved slices */
  setexist(opirmode, PSD_ON);
#endif

} /* ksfse_init_imagingoptions() */




/**
 *******************************************************************************************************
 @brief #### Initial setup of user interface (UI) with default values for menus and fields
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_init_UI(void) {

  /* IR always in interleaved mode */
  if (oppseq == PSD_IR) {
    cvoverride(opirmode, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
  }

  acq_type  = _acq_type.fixedflag ?  ((void)(TYPSPIN), acq_type) : TYPSPIN; /* loadrheader.e rheaderinit: sets eeff = 1 */

  /* rBW */
  cvmin(oprbw, 2);
  cvmax(oprbw, 250.0);
  pircbnub  = 31; /* number of variable bandwidth */
  if (opssfse == PSD_ON) {
    pidefrbw = 62.50 * (cffield/ 30000.0);
  } else {
    pidefrbw = 41.67 * (cffield/ 30000.0);
  }
  pircbval2 = 31.25 * (cffield/ 30000.0);
  pircbval3 = 41.67 * (cffield/ 30000.0);
  pircbval4 = 50.00 * (cffield/ 30000.0);
  pircbval5 = 62.50 * (cffield/ 30000.0);
  pircbval6 = 83.33 * (cffield/ 30000.0);
  cvdef(oprbw, pidefrbw);
  oprbw  = _oprbw.fixedflag ?  ((void)(_oprbw.defval), oprbw) : _oprbw.defval;
  pircb2nub = 0; /* no second bandwidth option */

  /* NEX */
  pinexnub = 63;
  if (opssfse == PSD_ON) {
    cvdef(opnex, 0.6);
    cvmin(opnex, 0.55);
    cvmax(opnex, 100);
    pinexval2 = 0.55;
    pinexval3 = 0.575;
    pinexval4 = 0.60;
    pinexval5 = 0.625;
    pinexval6 = 0.65;
  } else {
    cvdef(opnex, 1);
    cvmin(opnex, 0.55);
    cvmax(opnex, 100);
    pinexval2 = 0.65;
    pinexval3 = 0.75;
    pinexval4 = 0.85;
    pinexval5 = 1;
    pinexval6 = 2;
  }
  opnex  = _opnex.fixedflag ?  ((void)(_opnex.defval), opnex) : _opnex.defval;

  /* FOV */
  opfov  = _opfov.fixedflag ?  ((void)(240), opfov) : 240;
  pifovnub = 4; /* show the first three + type-in */
  pifovval2 = 180;
  pifovval3 = 220;
  pifovval4 = 240;
  pifovval5 = 260;
  pifovval6 = 280;

  /* phase FOV fraction */
  opphasefov  = _opphasefov.fixedflag ?  ((void)(1), opphasefov) : 1;
  piphasfovnub2 = 63;
  piphasfovval2 = 1.0;
  piphasfovval3 = 0.9;
  piphasfovval4 = 0.8;
  piphasfovval5 = 0.7;
  piphasfovval6 = 0.6;

  /* freq (x) resolution */
  cvmin(opxres, 16);
  cvdef(opxres, 64);
  opxres  = _opxres.fixedflag ?  ((void)(_opxres.defval), opxres) : _opxres.defval;
  pixresnub = 63;
  pixresval2 = 192;
  pixresval3 = 224;
  pixresval4 = 256;
  pixresval5 = 320;
  pixresval6 = 384;

  /* phase (y) resolution */
  cvmin(opyres, 16);
  piyresnub = 63;
  if (opssfse == PSD_ON) {
    piyresval2 = 64;
    piyresval3 = 128;
    piyresval4 = 160;
    piyresval5 = 192;
    piyresval6 = 256;
    cvdef(opyres, 16); /* init low for SSFSE to avoid too long sequence length before proper values have been chosen */
  } else {
    piyresval2 = 192;
    piyresval3 = 224;
    piyresval4 = 256;
    piyresval5 = 320;
    piyresval6 = 384;
    cvdef(opyres, 128);
  }
  opyres  = _opyres.fixedflag ?  ((void)(_opyres.defval), opyres) : _opyres.defval;

  /* Num echoes */
  piechnub = 0;
  cvdef(opnecho, 1);
  cvmax(opnecho, 1);

  /* ETL */
  avminetl = 1;
  avmaxetl = 256;
  if (opssfse == PSD_ON) {

    if (ksfse.phaseenc.numlinestoacq > 0)
      cvdef(opetl, ksfse.phaseenc.numlinestoacq);
    else
      cvdef(opetl, _opyres.defval);
    opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
    pietlnub = 0;

  } else {

    if (!KS_3D_SELECTED) {
      /* 2D */

       if (opflair == FALSE) {
        if (optr < 1000000) {
          /* T1-w */
          cvdef(opetl, 1);
          opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
          pietlnub = 63;
          pietlval2 = 1;
          pietlval3 = 2;
          pietlval4 = 3;
          pietlval5 = 4;
          pietlval6 = 8;
        } else {
          /* T2-w */
          cvdef(opetl, 16);
          opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
          pietlnub = 63;
          pietlval2 = 8;
          pietlval3 = 12;
          pietlval4 = 16;
          pietlval5 = 20;
          pietlval6 = 24;
        }
      } else if (opflair == OPFLAIR_GROUP) { /* T2-FLAIR */
        cvdef(opetl, 24);
        opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
        pietlnub = 63;
        pietlval2 = 20;
        pietlval3 = 24;
        pietlval4 = 28;
        pietlval5 = 32;
        pietlval6 = 36;
      } else if (opflair == OPFLAIR_INTERLEAVED) { /* T1-FLAIR */
        cvdef(opetl, 8);
        opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
        pietlnub = 63;
        pietlval2 = 4;
        pietlval3 = 5;
        pietlval4 = 6;
        pietlval5 = 7;
        pietlval6 = 8;
      }

    } else {

      /* 3D */
      cvdef(opetl, 32);
      opetl  = _opetl.fixedflag ?  ((void)(_opetl.defval), opetl) : _opetl.defval;
      pietlnub = 63;
      pietlval2 = 32;
      pietlval3 = 48;
      pietlval4 = 64;
      pietlval5 = 96;
      pietlval6 = 128;
  }

  } /* non-ssfse ETL menu */


  /* TE */
  pitetype = PSD_LABEL_TE_EFF; /* alt. PSD_LABEL_TE_EFF */
  if (! existcv(opte)) {
    avmaxte = 2000000;
    avminte = 0;
    cvmin(opte, avminte);
    cvmax(opte, avmaxte);
    cvdef(opte, 100000);
    opte  = _opte.fixedflag ?  ((void)(_opte.defval), opte) : _opte.defval;
    ksfse_eval_TEmenu(10000 /* fake esp */, 200000 /* fake maxte */, opetl, opetl/ 2.0);
  }

  /* TE2 */
  pite2nub = 0;

  /* TR */
  cvdef(optr, 5000000);
  optr  = _optr.fixedflag ?  ((void)(_optr.defval), optr) : _optr.defval;
  /*
   If you want values (pitrval) in the dropdown menu, change to pitrnub = 6;. 
   Remember that you can control the minimum and maximum TR-range 
   from the advanced tab using opuser18 & 19. 
  */
  pitrnub = 2;
  pitrval2 = PSD_MINIMUMTR;
  pitrval3 = 500000;
  pitrval4 = 3000000;
  pitrval5 = 4000000;
  pitrval6 = 5000000;

  /* FA of refocusing pulse */
  cvmax(opflip, 360);
  cvdef(opflip, 125); /* set it low to avoid init errors on sequence selection */
  opflip  = _opflip.fixedflag ?  ((void)(_opflip.defval), opflip) : _opflip.defval;
#if EPIC_RELEASE >= 24
  pifamode = PSD_FLIP_ANGLE_MODE_REFOCUS;
  pifanub = 5;
  pifaval2 = 110;
  pifaval3 = 125;
  pifaval4 = 140;
  pifaval5 = 160;
#else
  pifanub = 0;
#endif

  /* slice thickness */
  pistnub = 5;
  if (KS_3D_SELECTED) {
    cvdef(opslthick, 1);
    pistval2 = 0.8;
    pistval3 = 0.9;
    pistval4 = 1;
    pistval5 = 1.5;
    pistval5 = 2;
  } else {
    cvdef(opslthick, 4);
    pistval2 = 2;
    pistval3 = 3;
    pistval4 = 4;
    pistval5 = 5;
    pistval6 = 10;
  }
  opslthick  = _opslthick.fixedflag ?  ((void)(_opslthick.defval), opslthick) : _opslthick.defval;

  /* slice spacing */
  cvdef(opslspace, 0);
  opslspace  = _opslspace.fixedflag ?  ((void)(_opslspace.defval), opslspace) : _opslspace.defval;
  piisil = PSD_ON;
  if (KS_3D_SELECTED) {
    /* change these to do overlaps */
    piisnub = 0;
    piisval2 = 0;
  } else {
    piisnub = 5;
    piisval2 = 0;
    piisval3 = 0.5;
    piisval4 = 1;
    piisval5 = 2;
    piisval6 = 3;
  }

  /* default # of slices */
  cvdef(opslquant, 30);

  /* 3D slice settings */
  if (KS_3D_SELECTED) { /* PSD_3D or PSD_3DM */
    pimultislab = 0; /* 0: forces only single slab, 1: allow multi-slab (won't work with non-selective refocusing pulses) */
    pilocnub = 4;
    pilocval2 = 28;
    pilocval3 = 60;
    pilocval4 = 124;
    pilocval5 = 252;
    /* opslquant = #slices in slab. opvquant = #slabs */
    cvdef(opslquant, 32);
  }

  opslquant  = _opslquant.fixedflag ?  ((void)(_opslquant.defval), opslquant) : _opslquant.defval;

  /* Multi phase (i.e. multi volumes) (only active if PSD_IOPT_MPH, not PSD_IOPT_DYNPL) */
  if (opmph) {
    pimphscrn = 1;   /* display Multi-Phase Parameter screen */
    pifphasenub = 6;
    pifphaseval2 = 1;
    pifphaseval3 = 2;
    pifphaseval4 = 5;
    pifphaseval5 = 10;
    pifphaseval6 = 15;
    pisldelnub = 0;
    piacqnub = 0;
    setexist(opacqo, 1);
    pihrepnub = 0;  /* no XRR gating */
  } else {
    cvoverride(opfphases, 1, PSD_FIX_ON, PSD_EXIST_ON);
  }

  /* opuser0: show GIT revision (GITSHA) using REV variable from the Imakefile */
  char userstr[100];
#ifdef REV
  sprintf(userstr, "    %s PSD version: %s", _ksfse_flipexc.descr, REV);
#else
  sprintf(userstr, "%s", _ksfse_flipexc.descr);
#endif
  cvmod(opuser0, _ksfse_flipexc.minval, _ksfse_flipexc.maxval, _ksfse_flipexc.defval, userstr, 0, " ");
  opuser0  = _opuser0.fixedflag ?  ((void)(_opuser0.defval), opuser0) : _opuser0.defval;
  piuset |= use0;

  /* opuser1: TE based on ETL. */
  cvmod(opuser1, _ksfse_etlte.minval, _ksfse_etlte.maxval, _ksfse_etlte.defval, _ksfse_etlte.descr, 0, " ");
  opuser1  = _opuser1.fixedflag ?  ((void)(_ksfse_etlte.defval), opuser1) : _ksfse_etlte.defval;
  ksfse_etlte  = _ksfse_etlte.fixedflag ?  ((void)(_ksfse_etlte.defval), ksfse_etlte) : _ksfse_etlte.defval;

  if (opssfse) {
    piuset &= ~use1; /* don't show for SSFSE */
  } else {
    piuset |= use1; /* show since not SSFSE */
  }

  cvmod(opuser2, _ksfse_inflowsuppression.minval, _ksfse_inflowsuppression.maxval, _ksfse_inflowsuppression.defval, _ksfse_inflowsuppression.descr, 0, " ");
  piuset |= use2;
  opuser2  = _opuser2.fixedflag ?  ((void)(_ksfse_inflowsuppression.defval), opuser2) : _ksfse_inflowsuppression.defval;


  if (opfr == FALSE && (oppseq != PSD_IR /* 3 */ && opirprep == FALSE && opflair == FALSE) && opssfse == FALSE && exist(opetl) > 1) {
    /* if FSE-XL has been selected, allow T1-w optimization */
    cvmod(opuser3, 0, 1, 0, "T1-w Optimization [0:OFF 1:ON]", 0, " ");
    opuser3  = _opuser3.fixedflag ?  ((void)(_opuser3.defval), opuser3) : _opuser3.defval;
    piuset |= use3;
  } else {
    opuser3  = _opuser3.fixedflag ?  ((void)(0), opuser3) : 0;
    piuset &= ~use3;
  }


  /* In-range TR support (but without using GE's opinrangetr, since we don't know
     how to read the AutoTR field values on the Advanced tab. Instead, for now, add two opusers
     for the range. If any of these are = 0, it is disabled */
  cvmod(opuser4, _ksfse_mintr.minval/1000, _ksfse_mintr.maxval/1000, _ksfse_mintr.defval/1000, _ksfse_mintr.descr, 0, " "); /* minTR in [ms] */
  opuser4  = _opuser4.fixedflag ?  ((void)(_opuser4.defval), opuser4) : _opuser4.defval;
  piuset |= use4;
  cvmod(opuser5, _ksfse_maxtr.minval/1000, _ksfse_maxtr.maxval/1000, _ksfse_maxtr.defval/1000, _ksfse_maxtr.descr, 0, " "); /* maxTR in [ms] */
  opuser5  = _opuser5.fixedflag ?  ((void)(_opuser5.defval), opuser5) : _opuser5.defval;
  if (opflair == OPFLAIR_GROUP) {
    piuset &= ~use5; /* Don't show maxTR limit for T2FLAIR */
  } else {
    piuset |= use5;
  }

  if (opflair != OPFLAIR_GROUP) {
    _rf_stretch_all.defval = 1.5; /* Wider default (except for T2FLAIR which is less SAR heavy) to shorten the scan time (less SAR penalty) */
  } else {
    _rf_stretch_all.defval = 1.0;
  }
  cvmod(opuser6, 1.0, _rf_stretch_all.maxval,  _rf_stretch_all.defval, _rf_stretch_all.descr, 0, " ");
  opuser6  = _opuser6.fixedflag ?  ((void)(_rf_stretch_all.defval), opuser6) : _rf_stretch_all.defval;
  piuset |= use6;

  /*
     Reserved opusers:
     -----------------
     ksfse_eval_inversion(): opuser26-29
     GE reserves: opuser36-48 (epic.h)
   */

  if (oparc) {
    /* Acceleration menu as decimal numbers (max accel = 4) */
    GEReq_init_accelUI(KS_ACCELMENU_FRACT, 4);
  } else {
    /* Acceleration menu as integers (max accel = 4)
       Covers the non-accelerated and ASSET cases */
    GEReq_init_accelUI(KS_ACCELMENU_INT, 4);
  }


  return SUCCESS;

} /* ksfse_init_UI() */





/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: CVEVAL
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Gets the current UI and checks for valid inputs
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_UI() {

  if (ksfse_init_UI() == FAILURE)
    return FAILURE;



  /*** Copy UserCVs to human readable CVs ***/
  ksfse_flipexc  = _ksfse_flipexc.fixedflag ?  ((void)(opuser0), ksfse_flipexc) : opuser0;

  ksfse_etlte  = _ksfse_etlte.fixedflag ?   ((void)((int)opuser1), ksfse_etlte) : (int)opuser1;
  if (ksfse_etlte != PSD_OFF && ksfse_etlte != PSD_ON) {
    return ks_error("'ETL controls TE' flag must be either [0:OFF, 1:ON]"); /* User error */
  }

  if (existcv(opetl)) {
    /* if ETL has been selected, adjust TR menu to either T1-w or T2-w mode */
    if (exist(opetl) < 6) {
      pitrval3 = 450000;
      pitrval4 = 500000;
      pitrval5 = 550000;
      pitrval6 = 600000;
    } else {
      pitrval3 = 2500000;
      pitrval4 = 3000000;
      pitrval5 = 4000000;
      pitrval6 = 5000000;
    }
  }

  /* Inflow suppression (only if spacing or multiple acqs) */
  if (existcv(opslquant) && (opslspace > 0.0 || avmaxacqs > 1)) {
    ksfse_inflowsuppression  = _ksfse_inflowsuppression.fixedflag ?  ((void)(opuser2), ksfse_inflowsuppression) : opuser2;
  } else {
    cvoverride(ksfse_inflowsuppression, 0, PSD_FIX_OFF, PSD_EXIST_ON);
  }
  if (ksfse_inflowsuppression > 0) {
    cvdesc(opuser2, "In-flow suppression 0:OFF [1:ON]"); /* Highlight ON */
  } else {
    cvdesc(opuser2, "In-flow suppression [0:OFF] 1:ON"); /* Highlight OFF */
  }

  /* Fast recovery / T1w optimization */
  if (opuser3 > 0) {
    ksfse_recovery  = _ksfse_recovery.fixedflag ?  ((void)(KSFSE_RECOVERY_T1WOPT), ksfse_recovery) : KSFSE_RECOVERY_T1WOPT;
  } else if (opfr) {
    ksfse_recovery  = _ksfse_recovery.fixedflag ?  ((void)(KSFSE_RECOVERY_FAST), ksfse_recovery) : KSFSE_RECOVERY_FAST;
  } else {
    ksfse_recovery  = _ksfse_recovery.fixedflag ?  ((void)(0), ksfse_recovery) : 0;
  }

  /* Min/Max TR */
  {
    char tmpstr[100];
  (ksfse_mintr) = RUP_GRD((int) opuser4 * 1000); /* in [us] */
  (ksfse_maxtr) = RUP_GRD((int) opuser5 * 1000); /* in [us] */

  if (opflair == OPFLAIR_GROUP) {
    /* T2FLAIR */
    (ksinv_mintr_t2flair) = (ksfse_mintr > 0) ? ksfse_mintr : _ksinv_mintr_t2flair.defval;
    if (ksfse_mintr > 0)
      sprintf(tmpstr, "Min TR (ms) [0: Auto]");
    else
      sprintf(tmpstr, "Min TR (ms) [0: Auto (%d)]", _ksinv_mintr_t2flair.defval/1000);
    cvdesc(opuser4, tmpstr);
  } else if (opflair == OPFLAIR_INTERLEAVED) {
    /* T1FLAIR */
    (ksinv_mintr_t1flair) = (ksfse_mintr > 0) ? ksfse_mintr : _ksinv_mintr_t1flair.defval;
    (ksinv_maxtr_t1flair) = (ksfse_maxtr > 0) ? ksfse_maxtr : _ksinv_maxtr_t1flair.defval;

    if (ksfse_mintr > 0)
      sprintf(tmpstr, "Min TR (ms) [0: Auto]");
    else
      sprintf(tmpstr, "Min TR (ms) [0: Auto (%d)]", _ksinv_mintr_t1flair.defval/1000);
    cvdesc(opuser4, tmpstr);

    if (ksfse_maxtr > 0)
      sprintf(tmpstr, "Max TR (ms) [0: Auto]");
    else
      sprintf(tmpstr, "Max TR (ms) [0: Auto (%d)]", _ksinv_maxtr_t1flair.defval/1000);
    cvdesc(opuser5, tmpstr);

  } else {
    cvdesc(opuser4, _ksfse_mintr.descr);
    cvdesc(opuser5, _ksfse_maxtr.descr);
  }
}

  /* overall RF pulse stretching */
  rf_stretch_all  = _rf_stretch_all.fixedflag ?  ((void)(opuser6), rf_stretch_all) : opuser6;


  /* Reserved opusers:
     -----------------
     ksfse_eval_inversion(): opuser26-29
     GE reserves: opuser36-48 (epic.h)
   */

  return SUCCESS;

} /* ksfse_eval_UI() */





/**
 *******************************************************************************************************
 @brief #### Sets up the TE menu based on echo spacing, max TE, ETL and the optimal echo index

 `optechono` is the echo index in range [0, ETL-1] that is in the center of the FSE train. If the TE
 corresponding to this index is chosen, optimal image quality is achieved with minimal FSE ghosting.

 For ETLs > 6, this value is given first in the TE menu, meaning that if the user chooses the first
 field in the TE menu this will have the same effect as setting "ETL controls TE", and the remaining
 TE fields in the menu are the ones straddling the optimal TE.

 For ETLs in range [2,6], MinFull is the first, followed by the optimal TE.

 For ETL = 1, which corresponds to a conventional Spin-Echo, the user can choose only between MinTE
 (partial kx Fourier) and MinFullTE. Manual type-in is not allowed for ETL = 1.

 @return void
********************************************************************************************************/
void ksfse_eval_TEmenu(int esp, int maxte, int etl, double optechono) {
  int allow_typein = 1;

  if (etl > 6) {
    pite1val2 = optechono * esp; /* best TE for image quality (minimal T2-blurring, ghosting) */
    pite1val3 = (optechono - 2) * esp;
    pite1val4 = (optechono - 1) * esp;
    pite1val5 = (optechono + 1) * esp;
    pite1val6 = (optechono + 2) * esp;
  } else if (etl > 1) {
    pite1val2 = PSD_MINFULLTE;
    pite1val3 = (optechono - 2) * esp;
    pite1val4 = (optechono - 1) * esp;
    pite1val5 = optechono * esp;
    pite1val6 = (optechono + 1) * esp;
  } else { /* etl = 1 */
    allow_typein = 0;
    pite1val2 = PSD_MINIMUMTE;
    pite1val3 = PSD_MINFULLTE;
    pite1val4 = 0;
    pite1val5 = 0;
    pite1val6 = 0;
  }

  if (etl > 1) {
    pite1nub = allow_typein + 2 +
               4  * (pite1val3 >= esp && pite1val3 <= maxte) +
               8  * (pite1val4 >= esp && pite1val4 <= maxte) +
               16 * (pite1val5 >= esp && pite1val5 <= maxte) +
               32 * (pite1val6 >= esp && pite1val6 <= maxte);
  } else {
    pite1nub = 6; /* only MinTE & MinFull */
  }

} /* ksfse_eval_TEmenu() */




/**
 *******************************************************************************************************
 @brief #### Calculates echo spacing for the sequence

 @param[out] min90_180   Pointer to the time between moment start of the excitation pulse to the center
                         of the refocusing pulse in [us]
 @param[out] min180_echo Pointer to the time between center of the refocusing pulse to the center of the
                         first echo in [us]
 @param[in] slicecheck  0: Normal mode 1: Slice check mode, where the readout is moved to the slice axis
 @param[in] seq         Pointer to KSFSE_SEQUENCE
 @retval echospacing Echo Spacing in [us]
********************************************************************************************************/
int ksfse_eval_esp(int *min90_180, int *min180_echo, int slicecheck, KSFSE_SEQUENCE *seq) {
  int echospacing;

  /*** minimum time needed between RF exc center to RF ref center ***/
  /* latter portion of RF pulse incl ramptime of slice sel grad */
  *min90_180 = seq->selrfexc.rf.iso2end;
  if (slicecheck) {
    /* need separate time for read dephaser */
    *min90_180 += seq->selrfexc.grad.ramptime + seq->readdephaser.duration + seq->selrfexc.postgrad.duration +
                  seq->selrfref1st.pregrad.duration + seq->selrfref1st.grad.ramptime;
  } else {
    /* max of seq->readdephaser and time from end of rfexc grad plateau to beginning of plateau for rfrefocus */
    *min90_180 += IMax(2,
                       seq->readdephaser.duration /* X */,
                       seq->selrfexc.grad.ramptime + seq->selrfexc.postgrad.duration + seq->selrfref1st.pregrad.duration + seq->selrfref1st.grad.ramptime /* Z */);
  }
  *min90_180 += seq->selrfref1st.rf.start2iso; /* slice selection time until RF center */

  /*** minimum time needed between RF ref center and echo center ***/
  *min180_echo = IMax(3, seq->selrfref1st.rf.iso2end, seq->selrfref2nd.rf.iso2end, seq->selrfref.rf.iso2end);
  if (slicecheck) {
    *min180_echo += IMax(4,
                        seq->phaseenc.grad.duration - seq->read.acqdelay + seq->read.time2center /* Y */,
                        seq->selrfref1st.grad.ramptime                + seq->selrfref1st.postgrad.duration + seq->zphaseenc.grad.duration + seq->read.time2center /* Z 1st echo */,
                        (opetl > 1) * (seq->selrfref2nd.grad.ramptime + seq->selrfref2nd.postgrad.duration + seq->zphaseenc.grad.duration + seq->read.time2center) /* Z 2nd echo */,
                        (opetl > 2) * (seq->selrfref.grad.ramptime    + seq->selrfref.postgrad.duration    + seq->zphaseenc.grad.duration + seq->read.time2center) /* Z 3-Nth echo */);
  } else {
    *min180_echo += IMax(5,
                        seq->read.acqdelay /* X */,
                        seq->phaseenc.grad.duration /* Y */,
                        seq->selrfref1st.grad.ramptime                + seq->selrfref1st.postgrad.duration + seq->zphaseenc.grad.duration /* Z 1st echo */,
                        (opetl > 1) * (seq->selrfref2nd.grad.ramptime + seq->selrfref2nd.postgrad.duration + seq->zphaseenc.grad.duration) /* Z 2nd echo */,
                        (opetl > 2) * (seq->selrfref.grad.ramptime    + seq->selrfref.postgrad.duration    + seq->zphaseenc.grad.duration) /* Z 3-Nth echo */);
    *min180_echo += seq->read.time2center - seq->read.acqdelay; /* time from start of acquisition to k-space center */
  }

  echospacing = IMax(2, *min90_180, *min180_echo) * 2;
  echospacing = RUP_FACTOR(echospacing, 16);

  return echospacing;
}




/**
 *******************************************************************************************************
 @brief #### Calculates the optimal number of k-space points for partial kx Fourier that does not increase TE

 This function plays by the following rules:
     1. CV ksfse_kxnover_min is the lowest number of samples allowed
     2. ksfse.read.res/2 is the highest number of samples allowed
     3. Increase `kxnover` until an increase in TE results, while staying within above limits

 @param[in] seq Pointer to the KSFSE_SEQUENCE struct holding all sequence objects
 @retval kxnover Optimal number of k-space points beyond half k-space for partial kx Fourier scans.
********************************************************************************************************/
int ksfse_eval_optimalkxnover(KSFSE_SEQUENCE *seq) {

  int min90_180 = 0; /* [us] */
  int min180_echo = 0; /* [us] */
  int kxnover = 0; /* samples */

  ksfse_eval_esp(&min90_180, &min180_echo, ksfse_slicecheck, seq);

  if (seq->read.nover) {
    /* we are currently using partial Fourier, adjust kxnover to balance the time before and after
    the refocusing pulse */
    kxnover = seq->read.nover + ((min90_180 - min180_echo)/ ks_calc_bw2tsp(seq->read.acq.rbw));
  } else {
    /* we are currently using full Fourier (read.nover = 0) */
    if (min90_180 > min180_echo) {
      /* more time needed before the 180 anyway, no need to do partial Fourier */
      kxnover = seq->read.res/ 2;
    } else {
      kxnover = seq->read.res/ 2 - ((min180_echo - min90_180)/ ks_calc_bw2tsp(seq->read.acq.rbw));
    }
  }

  /* keep in range */
  if (kxnover < ksfse_kxnover_min) {
    kxnover = ksfse_kxnover_min;
  } else if (kxnover > seq->read.res/ 2) {
    kxnover = seq->read.res/ 2;
  }

  kxnover = RUP_GRD(kxnover);

  return kxnover;

} /* ksfse_eval_optimalkxnover() */



float ksfse_eval_rfstretchfactor(float patientweight, float flipangle, int tailoredrf_flag) {
  float rfstretchfactor = 1.0;
  float flipangle_factor = 1.0;
  float patientweight_factor = FMax(2, 1.0, patientweight * 0.0055 + 0.6); /* 1.0 at around 75 kg, never less than 0 */

  if (tailoredrf_flag) {
    /* Empirical 2D plane as a function of patient weight and flip angle (for RF pulse set ref_fse1601/2/n)
       Important to not let it below ~0.6 when flipangle or patient weight is too small */
    flipangle_factor = FMax(2, 0.6, 0.0035 * flipangle + 0.15);
    rfstretchfactor = flipangle_factor * patientweight_factor;
  } else {
    /* Empirical 2D plane as a function of patient weight and flip angle (for RF pulse set ref_se1b4)
    Important to not let it below ~0.6 when flipangle or patient weight is too small */
    flipangle_factor = FMax(2, 0.6, 0.0080 * flipangle - 0.10);
    rfstretchfactor = flipangle_factor * patientweight_factor;
  }

  if (rfstretchfactor < 0.6)
    rfstretchfactor = 0.6; /* extra level of safety */

  return rfstretchfactor;
}



/**
 *******************************************************************************************************
 @brief #### Sets up the RF objects for the ksfse sequence (2D)

 This function attempts to mimick the RF scaling and flip angle varation performed in the product
 fsemaster.e psd, with and without the tailored RF (optlrdrf) option. It is called from
 ksfse_eval_setupobjects() to set up the RF pulses to keep ksfse_eval_setupobjects() from growing too
 much in size.

 @param[in] seq Pointer to the KSFSE_SEQUENCE struct holding all sequence objects
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_setuprfpulses_2D(KSFSE_SEQUENCE *seq) {
  STATUS status;

  /* Clear potential gradient waveforms in the KS_SELRF objects before we choose our RF pulses */
  ks_init_wave(&seq->selrfexc.gradwave);
  ks_init_wave(&seq->selrfref1st.gradwave);
  ks_init_wave(&seq->selrfref2nd.gradwave);
  ks_init_wave(&seq->selrfref.gradwave);

  /*******************************************************************************************************
   *  RF Selections. Flip angle and slice thickness tweaks
   *******************************************************************************************************/

  ksfse_excthickness  = _ksfse_excthickness.fixedflag ?  ((void)(opslthick), ksfse_excthickness) : opslthick;

  if (optlrdrf == TRUE || opetl > 2) {
    seq->selrfexc.rf = exc_fse90;      /* Excitation */
    seq->selrfref1st.rf = ref_fse1601; /* 1st Refocusing */
    seq->selrfref2nd.rf = ref_fse1602; /* 2nd Refocusing */
    seq->selrfref.rf = ref_fse160n;    /* 3->ETL Refocusing */
    ksfse_gscalerfexc  = _ksfse_gscalerfexc.fixedflag ?  ((void)(0.8), ksfse_gscalerfexc) : 0.8;
    ksfse_gscalerfref  = _ksfse_gscalerfref.fixedflag ?      ((void)((ksfse_inflowsuppression)?0.9:0.8), ksfse_gscalerfref) : (ksfse_inflowsuppression)?0.9:0.8;
  } else {
    seq->selrfexc.rf = exc_fl901mc;
    seq->selrfref1st.rf = ref_se1b4;
    seq->selrfref2nd.rf = ref_se1b4;
    seq->selrfref.rf = ref_se1b4;
    ksfse_gscalerfexc  = _ksfse_gscalerfexc.fixedflag ?  ((void)(0.9), ksfse_gscalerfexc) : 0.9;
    ksfse_gscalerfref  = _ksfse_gscalerfref.fixedflag ?      ((void)((ksfse_inflowsuppression)?1.0:0.9), ksfse_gscalerfref) : (ksfse_inflowsuppression)?1.0:0.9;
  }

  /* Stretch factors for RF refocusing pulses */
  rf_stretch_rfref  = _rf_stretch_rfref.fixedflag ?    ((void)(ksfse_eval_rfstretchfactor(opweight,opflip,optlrdrf)), rf_stretch_rfref) : ksfse_eval_rfstretchfactor(opweight,opflip,optlrdrf);
  rf_stretch_rfexc  = _rf_stretch_rfexc.fixedflag ?  ((void)(rf_stretch_rfref), rf_stretch_rfexc) : rf_stretch_rfref;

#if EPIC_RELEASE >= 26
  if (opsarmode == 0) { /* normal mode */
    rf_stretch_all  = _rf_stretch_all.fixedflag ?  ((void)(1.6), rf_stretch_all) : rf_stretch_all*1.6;
  } else if (opsarmode == 3) { /* low SAR mode */
    rf_stretch_all  = _rf_stretch_all.fixedflag ?  ((void)(3), rf_stretch_all) : rf_stretch_all*3;
  }
#endif

  /* Set flip angles */
  if (optlrdrf == TRUE && opetl > 2) {
    seq->selrfref1st.rf.flip = opflip + 0.6032 * (180.0 - opflip);
    seq->selrfref2nd.rf.flip = opflip + 0.1032 * (180.0 - opflip);
    seq->selrfref.rf.flip = opflip;
  } else {
    seq->selrfref1st.rf.flip = opflip;
    seq->selrfref2nd.rf.flip = opflip;
    seq->selrfref.rf.flip = opflip;
  }


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  seq->selrfexc.slthick = ksfse_excthickness/ ksfse_gscalerfexc;

  /* Optional widening of the excitation pulse when we have slice gap or
     interleaved (opileave) slice mode where odd slices are completed and reconstructed
     before playing out the even slices */
  if (ksfse_inflowsuppression) {
    if (ksfse_inflowsuppression_mm <= 0) {
      /* ksfse_inflowsuppression_mm = 0 => auto thickness */
      int intleavefact = IMax(2, 1, avmaxacqs);
      float newthick = intleavefact * (ksfse_excthickness + opslspace);
      newthick = FMax(2, seq->selrfexc.slthick, newthick); /* to handle case where newthick is smaller */
      /* up to the case where newthick is three times the slice thickness */
      seq->selrfexc.slthick = (newthick <= KSFSE_MAXTHICKFACT * ksfse_excthickness) ? newthick : KSFSE_MAXTHICKFACT * ksfse_excthickness;
    } else {
      /* ksfse_inflowsuppression_mm > 0: the user wants to specify how many mm extra the excitation
      thickness should be */
      seq->selrfexc.slthick += ksfse_inflowsuppression_mm/ ksfse_gscalerfexc;
    }
  }

  seq->selrfexc.rf.flip = ksfse_flipexc; /* value from opuser0 */

  status = ks_eval_stretch_rf(&seq->selrfexc.rf, rf_stretch_all * rf_stretch_rfexc);
  if (status != SUCCESS) return status;

  status = ks_eval_selrf(&seq->selrfexc, "rfexc");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  RF Refocusing (1st echo)
  *******************************************************************************************************/
  seq->selrfref1st.slthick = ksfse_excthickness/ ksfse_gscalerfref;

  status = ks_eval_stretch_rf(&seq->selrfref1st.rf, rf_stretch_all * rf_stretch_rfref);
  if (status != SUCCESS) return status;

  /* when quietness factor is used, find the crusherscale that minimizes the echo spacing (esp) */
  if (ks_qfact > 1) {
    int dummy1, dummy2;
    float c;
    float optc = 2.0;
    int optesp = 1000000;
    int my_esp = KS_NOTSET;
    for (c = 0.0; c < 2.0; c += 0.01) {
      seq->selrfref1st.crusherscale = c;
      status = ks_eval_selrf(&seq->selrfref1st, "rfref1st");
      seq->selrfexc.postgrad.duration = 0; /* disable the rephaser of the excitation */
      seq->selrfref1st.pregrad.area += seq->selrfexc.postgrad.area; /* note: postgrad.area is negative ! */
      status = ks_eval_trap(&seq->selrfref1st.pregrad, seq->selrfref1st.pregrad.description);
      my_esp = ksfse_eval_esp(&dummy1, &dummy2, FALSE, seq);
      if (my_esp < optesp) {
        optesp = my_esp;
        optc = c;
      }
    }
    ksfse_crusherscale  = _ksfse_crusherscale.fixedflag ?  ((void)(optc), ksfse_crusherscale) : optc;
  }

  seq->selrfref1st.crusherscale = ksfse_crusherscale;
  status = ks_eval_selrf(&seq->selrfref1st, "rfref1st");
  if (status != SUCCESS) return status;

  seq->selrfexc.postgrad.duration = 0; /* disable the rephaser of the excitation */
  seq->selrfref1st.pregrad.area += seq->selrfexc.postgrad.area; /* note: postgrad.area is negative ! */
  status = ks_eval_trap(&seq->selrfref1st.pregrad, seq->selrfref1st.pregrad.description);
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  RF Refocusing (2nd echo)
   *******************************************************************************************************/
  seq->selrfref2nd.slthick = ksfse_excthickness/ ksfse_gscalerfref;
  seq->selrfref2nd.crusherscale = ksfse_crusherscale;

  status = ks_eval_stretch_rf(&seq->selrfref2nd.rf, rf_stretch_all * rf_stretch_rfref);
  if (status != SUCCESS) return status;

  status = ks_eval_selrf(&seq->selrfref2nd, "rfref2nd");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  RF Refocusing (3rd-Nth echo)
   *******************************************************************************************************/
  seq->selrfref.slthick = ksfse_excthickness/ ksfse_gscalerfref;
  seq->selrfref.crusherscale = ksfse_crusherscale;

  status = ks_eval_stretch_rf(&seq->selrfref.rf, rf_stretch_all * rf_stretch_rfref);
  if (status != SUCCESS) return status;

  status = ks_eval_selrf(&seq->selrfref, "rfref");
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* ksfse_eval_setuprfpulses_2D() */





/**
 *******************************************************************************************************
 @brief #### Sets up the RF objects for the ksfse sequence (3D)

 This function attempts to mimick the RF scaling and flip angle varation performed in the product
 fsemaster.e psd, with and without the tailored RF (optlrdrf) option. It is called from
 ksfse_eval_setupobjects() to set up the RF pulses to keep ksfse_eval_setupobjects() from growing too
 much in size.

 @param[in] seq Pointer to the KSFSE_SEQUENCE struct holding all sequence objects
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_setuprfpulses_3D(KSFSE_SEQUENCE *seq) {
  STATUS status;

  /* GE defines (epic.h) for opexcitemode:
    SELECTIVE 0, NON_SELECTIVE 1, FOCUS 2 */
  const float hardpulse_duration = 1000;
  float adaptive_crusherscale = 1.0;

  /* Clear potential gradient waveforms in the KS_SELRF objects before we choose our RF pulses */
  ks_init_wave(&seq->selrfexc.gradwave);
  ks_init_wave(&seq->selrfref1st.gradwave);
  ks_init_wave(&seq->selrfref2nd.gradwave);
  ks_init_wave(&seq->selrfref.gradwave);

  cvoverride(opvthick, exist(opslquant) * exist(opslthick), _opslquant.fixedflag, existcv(opslquant));
  ksfse_excthickness  = _ksfse_excthickness.fixedflag ?        ((void)((exist(opslquant)-2*rhslblank)*exist(opslthick)), ksfse_excthickness) : (exist(opslquant)-2*rhslblank)*exist(opslthick);
  ksfse_gscalerfexc  = _ksfse_gscalerfexc.fixedflag ?  ((void)(1.0), ksfse_gscalerfexc) : 1.0;

  if (ksfse.zphaseenc.areaoffset > 0 || ksfse.zphaseenc.grad.area == 0) {
    return ks_error("%s: Call ks_eval_phaser(zphasenc) with .areaoffset = 0, before calling this function", __FUNCTION__);
  } else {
    /* we want the same big enough crusher for any kz encoding variation accross the ETL, where even the
    most negative kz encoding gradient will not be able to cancel out the positive crushers */
    adaptive_crusherscale = ksfse_crusherscale + (ksfse.zphaseenc.grad.area/ KS_RF_STANDARD_CRUSHERAREA);
  }


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  if (opexcitemode == NON_SELECTIVE) {
    /* Non-selective 90 hard excitaion */
    status = ks_eval_rf_hard(&seq->selrfexc.rf, "rfexc", hardpulse_duration, 90);
    if (status != SUCCESS) return status;
    seq->selrfexc.rf.role = KS_RF_ROLE_EXC;
  } else {
    /* Selective 90 using a sharp high-BW minimum phase excitation pulse */
    seq->selrfexc.rf = exc_3dfgre;
    seq->selrfexc.rf.flip = 90.0;
  }

  seq->selrfexc.slthick = ksfse_excthickness/ ksfse_gscalerfexc * (opexcitemode != NON_SELECTIVE);

  status = ks_eval_stretch_rf(&seq->selrfexc.rf, rf_stretch_all * rf_stretch_rfexc);
  if (status != SUCCESS) return status;

  status = ks_eval_selrf(&seq->selrfexc, "rfexc");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  RF Refocusing (1st echo)
  *******************************************************************************************************/
  status = ks_eval_rf_hard(&seq->selrfref1st.rf, "rfref1st", hardpulse_duration, opflip);
  if (status != SUCCESS) return status;
  seq->selrfref1st.rf.role = KS_RF_ROLE_REF;

  seq->selrfref1st.slthick = 0; /* N.B.: sel gradient = 0 if .selrfref1st.slthick = 0 (ks_eval_selrf()) */

  status = ks_eval_stretch_rf(&seq->selrfref1st.rf, rf_stretch_all * rf_stretch_rfref);
  if (status != SUCCESS) return status;

  seq->selrfref1st.crusherscale = adaptive_crusherscale;
  status = ks_eval_selrf(&seq->selrfref1st, "rfref1st");
  if (status != SUCCESS) return status;

  /* Left crusher: Merge excitation rephaser into left crusher */
  /* N.B.: Right crusher will be embedded in zphasenc in ksfse_eval_setupobjects() */
  seq->selrfexc.postgrad.duration = 0; /* disable the rephaser of the excitation */
  seq->selrfref1st.pregrad.area += seq->selrfexc.postgrad.area; /* note: postgrad.area is negative ! */
  status = ks_eval_trap(&seq->selrfref1st.pregrad, seq->selrfref1st.pregrad.description);
  if (status != SUCCESS) return status;


  /*******************************************************************************************************
   *  RF Refocusing (2nd echo)
   *******************************************************************************************************/
  seq->selrfref2nd.rf = seq->selrfref1st.rf;
  seq->selrfref2nd.slthick = seq->selrfref1st.slthick;
  seq->selrfref2nd.crusherscale = seq->selrfref1st.crusherscale;
  status = ks_eval_selrf(&seq->selrfref2nd, "rfref2nd");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  RF Refocusing (3rd-Nth echo)
   *******************************************************************************************************/
  seq->selrfref.rf = seq->selrfref1st.rf;
  seq->selrfref.slthick = seq->selrfref1st.slthick;
  seq->selrfref.crusherscale = seq->selrfref1st.crusherscale;
  status = ks_eval_selrf(&seq->selrfref, "rfref");
  if (status != SUCCESS) return status;


  /*******************************************************************************************************
   *  Move crushers area from selrf.pregrad/postgrad to zphasenc.areaoffset
   *  Disable pre/postgrads by setting their duration to 0
   *******************************************************************************************************/
  seq->selrfref1st.postgrad.duration = 0; /* right crusher only */
  seq->selrfref2nd.pregrad.duration = 0;
  seq->selrfref2nd.postgrad.duration = 0;
  seq->selrfref.pregrad.duration = 0;
  seq->selrfref.postgrad.duration = 0;

  ksfse.zphaseenc.areaoffset = ksfse.selrfref1st.postgrad.area;
  status = ks_eval_phaser(&ksfse.zphaseenc, "zphaseenc"); /* update zphaseenc, now with .areaoffset > 0 */
  if (status != SUCCESS) return status;


  return SUCCESS;

} /* ksfse_eval_setuprfpulses_3D() */



STATUS ksfse_eval_setuprfpulses_recovery(KSFSE_SEQUENCE *seq) {
  STATUS status;

  ks_init_wave(&seq->selrfrecover.gradwave);
  ks_init_wave(&seq->selrfrecoverref.gradwave);

  /*******************************************************************************************************
   * Post-ETL forced recovery: T1-w Optimization / T2 fast Recovery
   *******************************************************************************************************/

  /* Recovery "negative" excitation (selrfrecover) */
  seq->selrfrecover.rf = seq->selrfexc.rf; /* already potentially RF-stretched */
  seq->selrfrecover.slthick = seq->selrfexc.slthick;

  status = ks_eval_selrf(&seq->selrfrecover, "rfrecover");
  if (status != SUCCESS) return status;

  /* no postgrad by setting duration = 0 (or pregrad either since KS_RF_ROLE_EXC) */
  seq->selrfrecover.postgrad.duration = 0;

  /* Mirror RF wave using "-1" (negative stretch factor), will mirror the excitation RF pulse waveform */
  status = ks_eval_stretch_rf(&seq->selrfrecover.rf, -1);
  if (status != SUCCESS) return status;


  /* Recovery refocusing (selrfrecoverref). Use flip angle and design from 'selrfref.rf' but left crusher
     area from selrfref1st.pregrad.area */
  seq->selrfrecoverref.rf = seq->selrfref.rf;
  seq->selrfrecoverref.slthick = seq->selrfref.slthick;
  seq->selrfrecoverref.crusherscale = seq->selrfref1st.crusherscale;
  status = ks_eval_selrf(&seq->selrfrecoverref, "rfrecoverref");
  if (status != SUCCESS) return status;

  if (KS_3D_SELECTED) {
    seq->selrfrecoverref.pregrad.duration = 0; /* zphaseenc.areaoffset takes over */
  }

  seq->selrfrecoverref.postgrad.area = seq->selrfref1st.pregrad.area;
  status = ks_eval_trap(&seq->selrfrecoverref.postgrad, seq->selrfrecoverref.postgrad.description);
  if (status != SUCCESS) return status;

  return SUCCESS;

}


/**
 *******************************************************************************************************
 @brief #### Set the SSI time for the sequence

 @retval int SSI time in [us]
********************************************************************************************************/
int ksfse_eval_ssitime() {

  /* SSI time CV:
     Empirical finding as a function of etl on how much SSI time we need to update.
     But, use a longer SSI time when we write out data to file in scan() */
  ksfse_ssi_time  = _ksfse_ssi_time.fixedflag ?        ((void)(RUP_GRD(IMax(2,KSFSE_MIN_SSI_TIME+13*opetl,_ksfse_ssi_time.minval))), ksfse_ssi_time) : RUP_GRD(IMax(2,KSFSE_MIN_SSI_TIME+13*opetl,_ksfse_ssi_time.minval));

  /* Copy SSI CV to seqctrl field used by setssitime() */
  ksfse.seqctrl.ssi_time = ksfse_ssi_time;

  /* SSI time one-sequence-off workaround:
     We set the hardware ssitime in ks_scan_playsequence(), but it acts on the next sequence module, hence
     we aren't doing this correctly when using multiple sequence modules (as KSChemSat etc).
     One option would be to add a short dummy sequence ks_scan_playsequence(), but need to investigate
     if there is a better way. For now, let's assume the the necessary update time is the longest for
     the main sequence (this function), and let the ssi time for all other sequence modules (KSChemSat etc)
     have the same ssi time as the main sequence. */
  kschemsat_ssi_time     = _kschemsat_ssi_time.fixedflag ?  ((void)(ksfse_ssi_time), kschemsat_ssi_time) : ksfse_ssi_time;
  ksspsat_ssi_time       = _ksspsat_ssi_time.fixedflag ?  ((void)(ksfse_ssi_time), ksspsat_ssi_time) : ksfse_ssi_time;
  ksinv_ssi_time         = _ksinv_ssi_time.fixedflag ?  ((void)(ksfse_ssi_time), ksinv_ssi_time) : ksfse_ssi_time;
  ksinv_filltr_ssi_time  = _ksinv_filltr_ssi_time.fixedflag ?  ((void)(ksfse_ssi_time), ksinv_filltr_ssi_time) : ksfse_ssi_time;

  return ksfse_ssi_time;

} /* ksfse_eval_ssitime() */




/**
 *******************************************************************************************************
 @brief #### Sets up all sequence objects for the main sequence module (KSFSE_SEQUENCE ksfse)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
 STATUS ksfse_eval_setupobjects() {
   STATUS status;

  /* Readout gradient and data acquisition */
  ksfse.read.fov = opfov;
  ksfse.read.res = RUP_FACTOR(opxres, 2); /* Round UP to nearest multiple of 2 */

  ksfse.read.rampsampling = ksfse_rampsampling;
  if (ksfse.read.rampsampling)
    ksfse.read.acqdelay = 16; /* us on the ramp until acq should begin */
  if (opautote == PSD_MINTE) { /* PSD_MINTE = 2 */
    ksfse_kxnover  = _ksfse_kxnover.fixedflag ?  ((void)(ksfse_eval_optimalkxnover(&ksfse)), ksfse_kxnover) : ksfse_eval_optimalkxnover(&ksfse); /* Partial Fourier */
    ksfse.read.nover = ksfse_kxnover;
  } else {
    ksfse.read.nover = 0; /* Full Fourier */
  }
  ksfse.read.acq.rbw = oprbw;
  ksfse.read.paddingarea = ksfse_xcrusherarea;
  if (ks_eval_readtrap(&ksfse.read, "read") == FAILURE)
    return FAILURE;

  /* read dephaser */
  ksfse.readdephaser.area = ksfse.read.area2center;
  if (ks_eval_trap(&ksfse.readdephaser, "readdephaser") == FAILURE)
    return FAILURE;

  /* phase encoding gradient */
  ksfse.phaseenc.fov = opfov * opphasefov;
  ksfse.phaseenc.res = RUP_FACTOR((int) (opyres * opphasefov), 2); /* round up (RUP) to nearest multiple of 2 */

  if (ksfse.read.nover == 0 && opnex < 1) {
    int kynover;
    kynover = ksfse.phaseenc.res * (opnex - 0.5);
    kynover = ((kynover + 1)/ 2) * 2; /* round to nearest even number */
    if (kynover < KSFSE_MINHNOVER)
      kynover = KSFSE_MINHNOVER; /* protect against too few overscans */
    ksfse.phaseenc.nover = IMin(2, kynover, ksfse.phaseenc.res/ 2);
  } else {
    ksfse.phaseenc.nover = 0;
  }

  /* set .R and .nacslines fields of ksfse.phaseenc using ks_eval_phaser_setaccel() before calling ks_eval_phaser() */
  if (opasset) {
    cvoverride(ksfse_minacslines, 0, PSD_FIX_OFF, PSD_EXIST_ON);
  } else if (oparc) {
    ksfse_minacslines  = _ksfse_minacslines.fixedflag ?  ((void)(_ksfse_minacslines.defval), ksfse_minacslines) : _ksfse_minacslines.defval;
  }
  if (ks_eval_phaser_setaccel(&ksfse.phaseenc, ksfse_minacslines, opaccel_ph_stride) == FAILURE)
    return FAILURE;

  if (ks_eval_phaser(&ksfse.phaseenc, "phaseenc") == FAILURE)
    return FAILURE;


  /* z phase encoding gradient (N.B. 3D is not yet implemented in this sequence) */
  if (KS_3D_SELECTED) { /* PSD_3D or PSD_3DM */

    ksfse.selrfref1st.postgrad.duration = 0; /* disable the right crusher gradient (.duration = 0), and put area necessary in zphaseenc.areaoffset */
    ksfse.zphaseenc.areaoffset = 0; /* explicitly 0 here, since modified later in ksfse_eval_setuprfpulses_3D() */
    ksfse.zphaseenc.fov = opvthick;
    ksfse.zphaseenc.res = IMax(2, 1, opslquant);
    ksfse.zphaseenc.nover = 0;

    /* set .R and .nacslines fields of ksfse.zphaseenc using ks_eval_phaser_setaccel() before calling ks_eval_phaser() */
    if (opasset) {
      cvoverride(ksfse_minzacslines, 0, PSD_FIX_OFF, PSD_EXIST_ON);
    } else if (oparc) {
      ksfse_minzacslines  = _ksfse_minzacslines.fixedflag ?  ((void)(_ksfse_minzacslines.defval), ksfse_minzacslines) : _ksfse_minzacslines.defval;
    }
    if (ks_eval_phaser_setaccel(&ksfse.zphaseenc, ksfse_minzacslines, opaccel_sl_stride) == FAILURE)
      return FAILURE;

    /* another call done in ksfse_eval_setuprfpulses_3D() with .areaoffset > 0 */
    if (ks_eval_phaser(&ksfse.zphaseenc, "zphaseenc") == FAILURE)
      return FAILURE;

  } else {

    ks_init_phaser(&ksfse.zphaseenc);

  }


  /* setup RF pulses in FSE train */
  if (KS_3D_SELECTED) {
    if (ksfse_eval_setuprfpulses_3D(&ksfse) == FAILURE)
      return FAILURE;
  } else {
    if (ksfse_eval_setuprfpulses_2D(&ksfse) == FAILURE)
      return FAILURE;
  }

  /* Add recovery pulses after the main Echo Train, common for 2D and 3D */
  if (ksfse_recovery) {
    status = ksfse_eval_setuprfpulses_recovery(&ksfse);
    if (status != SUCCESS) return status;
  } else {
    ks_init_selrf(&ksfse.selrfrecover);
    ks_init_selrf(&ksfse.selrfrecoverref);
  }

  /* post-read spoiler */
  ksfse.spoiler.area = ksfse_spoilerarea;
  if (ks_eval_trap(&ksfse.spoiler, "spoiler") == FAILURE)
    return FAILURE;

  /* init seqctrl */
  ks_init_seqcontrol(&ksfse.seqctrl);
  strcpy(ksfse.seqctrl.description, "ksfsemain");
  ksfse_eval_ssitime();

  return SUCCESS;

} /* ksfse_eval_setupobjects() */




/**
 *******************************************************************************************************
 @brief #### Sets the min/max TE and echo spacing for the FSE train based on rBW, res and ETL

 Based on the duration of the sequence objects involved, this function first calculates the minimum echo
 spacing in the FSE train (`ksfse_esp`). Then, if the SSFSE flag is set (opssfse), the ETL (opetl) is
 forced to be equal to the number of phase encoding lines acquired (see ks_eval_phaseviewtable()),
 otherwise the chosen ETL is used to calculate how many TRs (or shots) is necessary to fill k-space
 (`ksfse.phaseenc_plan.num_shots`). This value is used later in scan.

 Next, if the user has selected that the "ETL should set TE" (ksfse_etlte = TRUE), the echo time
 is forced to be equal to the most optimal one in the center of the echo train (optecho).
 The benefits of setting ksfse_etlte are a) reduced T2-blurring due to faster k-space traversal, and
 b) no FSE ghosting. The drawback is that TE needs to be controlled via changing ETL in the UI, but
 image quality wise, it may still be worth it. If ksfse_etlte = FALSE, ksfse_calc_echo() will find the
 `bestecho`, which is the echo index in the FSE train closest to the desired TE. When `bestecho` ends up
 being equal to `optecho` (as enforced by ksfse_etlte), the image quality improves, however this it not
 possible, especially for long ETLs with a normal TE of 80-100 ms.

 Last, this function calls ksfse_eval_TEmenu() to change the TE menu so the optimal TE is always at the
 top, followed by other TEs one or more echo spacings from the optimal TE.

 N.B.: `ksfse_esp` is the shortest time allowed between the RF excitation and the first echo, which is
 also the same time needed between two consecutive echoes in the FSE train.
 `ksfse_esp` is used in ksfse_pg(). If the pulse sequence design changes in ksfse_pg() such that more/less
 time is needed to the first echo, or between consecutive echoes, ksfse_esp must here be updated to
 avoid gradient overlaps.

 @retval STATUS `SUCCESS` or `FAILURE`
******************************************************************************************************/
STATUS ksfse_eval_TErange() {
  int min90_180 = 0;
  int min180_echo = 0;
  double optecho, bestecho;
  int fixed_teflag = _opte.fixedflag;
  int exist_teflag = _opte.existflag;
  STATUS status;


  /* echo spacing (esp) */
  ksfse_esp  = _ksfse_esp.fixedflag ?     ((void)(ksfse_eval_esp(&min90_180,&min180_echo,ksfse_slicecheck,&ksfse)), ksfse_esp) : ksfse_eval_esp(&min90_180,&min180_echo,ksfse_slicecheck,&ksfse);

  /* ETL */
  if (opssfse == PSD_ON) {
    /* SSFSE case */
    cvoverride(opetl, ksfse.phaseenc.numlinestoacq, PSD_FIX_ON, PSD_EXIST_ON);
  } else {
    if (opetl < 1) {
      cvoverride(opetl, 1, PSD_FIX_ON, PSD_EXIST_ON);
    } else if (opetl > ksfse.phaseenc.numlinestoacq) {
      return ks_error("ksfse_eval_TErange: Please reduce ETL to %d", ksfse.phaseenc.numlinestoacq);
    }
  }

  /* if single shot (2D), ks_phaseencoding_generate_2Dfse() will not allow non-optimal TE, i.e. linear k-space sweep
     is required. Therefore, ETL must control TE via setting ksfse_etlte = TRUE */
  if (CEIL_DIV(ksfse.phaseenc.numlinestoacq, opetl) == 1) {
    cvoverride(ksfse_etlte, TRUE, PSD_FIX_ON, PSD_EXIST_ON);
  } else {
    _ksfse_etlte.fixedflag = FALSE;
  }


  /* calc spacing between RF pulses used for T1-w opt. */
  if (ksfse_recovery) {

    int recovery_min_read2ref = (ksfse.read.grad.duration - ksfse.read.time2center - ksfse.read.acqdelay) +
    ksfse.selrfrecoverref.pregrad.duration +
    ksfse.selrfrecoverref.grad.ramptime +
    ksfse.selrfrecoverref.rf.start2iso;

    int recovery_min_ref2exc = ksfse.selrfrecoverref.rf.iso2end +
    IMax(2, ksfse.readdephaser.duration,
    ksfse.selrfrecoverref.grad.ramptime + ksfse.selrfrecoverref.postgrad.duration) +
    ksfse.selrfrecoverref.grad.ramptime +
    ksfse.selrfrecoverref.rf.start2iso;

    if (ksfse_slicecheck) {
      recovery_min_read2ref += ksfse.read.grad.ramptime;
      recovery_min_ref2exc = ksfse.selrfrecoverref.rf.iso2end +
      ksfse.selrfrecoverref.grad.ramptime +
      ksfse.selrfrecoverref.postgrad.duration +
      ksfse.readdephaser.duration +
      ksfse.selrfrecover.grad.ramptime +
      ksfse.selrfrecover.rf.start2iso;
    }

    int ksfse_recovery_spacing = IMax(2, recovery_min_read2ref, recovery_min_ref2exc) * 2;

    ksfse_esp  = _ksfse_esp.fixedflag ?    ((void)(IMax(2,ksfse_esp,ksfse_recovery_spacing)), ksfse_esp) : IMax(2,ksfse_esp,ksfse_recovery_spacing);
  }

  ksfse_esp  = _ksfse_esp.fixedflag ?    ((void)(GRAD_UPDATE_TIME*2), ksfse_esp) : ksfse_esp+GRAD_UPDATE_TIME*2; /* 8us extra margin */
  ksfse_esp  = _ksfse_esp.fixedflag ?   ((void)(RUP_FACTOR(ksfse_esp,8)), ksfse_esp) : RUP_FACTOR(ksfse_esp,8); /* make sure ksfse_esp is divisible by 8us (as we will need to use ksfse_esp/2 on 4us grid) */


  /* protect against too long sequence before we are having trouble in pg */
  if (ksfse_esp * opetl > 2000000) {
    return ks_error("%s: Too long sequence duration (%.1f ms)", __FUNCTION__, (ksfse_esp * opetl)/ 1000.0);
  }

  /* bestecho: opte rounded off. optecho: ignores 'opte' input */
  status = ks_fse_calcecho(&bestecho, &optecho, &ksfse.phaseenc, opte, opetl, ksfse_esp);
  if (status != SUCCESS) return status;

  setpopup(opte, PSD_OFF);


  if (ksfse_etlte) {
    /* ETL is controlling the use of an optimal TE to ensure a linear k-space sweep */
    cvoverride(opte, (int) (ksfse_esp * optecho), PSD_FIX_ON, PSD_EXIST_ON);
    pite1nub = 0;
    _opte.defval = opte;
    pite1val2 = opte;
    avminte = opte;
    avmaxte = opte;

    /* must set opautote here so that the TE menu is shaded rather than removed */
    cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_OFF, PSD_EXIST_ON);

  } else {

    /* minimum TE */
    avminte = ksfse_esp;

    if (opautote || (opte < avminte)) {
      cvoverride(opte, avminte, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
      /* round opte to nearest valid value */
      cvoverride(opte, (int) (ksfse_esp * bestecho), fixed_teflag, exist_teflag);
    }

    /* maximum TE */
    avmaxte = ksfse_esp * opetl;

    /* Setup TE menu */
    ksfse_eval_TEmenu(ksfse_esp, avmaxte, opetl, optecho);

  }


  { /* Update opuser1 to show optimal TE and echo spacing) */
    char tmpstr[100];
    sprintf(tmpstr, "%s [opt=%.1f, esp=%d]", _ksfse_etlte.descr, (ksfse_esp * optecho)/ 1000.0, ksfse_esp/ 1000);
    cvdesc(opuser1, tmpstr);
  }

  return SUCCESS;

} /* ksfse_eval_TErange() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to KSInversion functions to add single and dual IR support to this sequence

 It is important that ksfse_eval_inversion() is called after other sequence modules have been set up and
 added to the KS_SEQ_COLLECTION struct in my_cveval(). Otherwise the TI and TR timing will be wrong.

 Whether IR is on or off is determined by ksinv1_mode, which is set up in KSINV_EVAL()->ksinv_eval().
 If it is off, this function will return quietly.

 This function calls ksinv_eval_multislice() (KSInversion.e), which takes over the responsibility of
 TR timing that otherwise is determined in ksfse_eval_tr().
 ksinv_eval_multislice() sets seqcollection.evaltrdone = TRUE, which indicates that TR timing has been done.
 ksfse_eval_tr() checks whether seqcollection.evaltrdone = TRUE to avoid that non-inversion TR timing
 overrides the TR timing set up in ksinv_eval_multislice().

 At the end of this function, TR validation and heat/SAR checks are done.

 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_inversion(KS_SEQ_COLLECTION *seqcollection) {
  STATUS status;
  int slperpass, npasses;
  int approved_TR = FALSE;

  status = KSINV_EVAL(seqcollection, 26, 27, 28, 29); /* args 2-6: integer X corresponds to opuserX CV */
  if (status != SUCCESS) return status;

  if (((int) *ksinv1_mode) == KSINV_OFF) {
    /* If no IR1 flag on, return */
    return SUCCESS;
  }

  if (KS_3D_SELECTED) {
    return ks_error("%s: This function is only for 2D scans", __FUNCTION__);
  }

  /* interleaved slices in slice gap menu, force 2+ acqs */
  if (opileave)
    npasses = 2;
  else
    npasses = 1;


  while (approved_TR == FALSE) {

    /* Inversion (specific to 2D FSE/EPI type of PSDs). Must be done after all other sequence modules have been set up */
    slperpass = CEIL_DIV((int) exist(opslquant), npasses);

    status = ks_calc_sliceplan(&ks_slice_plan, exist(opslquant), slperpass);
    if (status != SUCCESS) return status;

    /* ksinv_eval_multislice() sets seqcollection.evaltrdone = TRUE. This indicates that TR timing has been done.
       ksfse_eval_tr() check whether seqcollection.evaltrdone = TRUE to avoid that non-inversion TR timing overrides the
       intricate TR timing with inversion module(s). At the end of ksinv_eval_multislice(), TR validation and heat/SAR checks are done */
    status = ksinv_eval_multislice(seqcollection, &ks_slice_plan, ksfse_scan_coreslice_nargs, 0, NULL, &ksfse.seqctrl);
    if (status != SUCCESS) return status;

    if (existcv(optr) && existcv(opslquant) && opflair == OPFLAIR_INTERLEAVED && optr > ksinv_maxtr_t1flair) {
      /* T1-FLAIR, too long TR */
      if (npasses > exist(opslquant)) {
        return ks_error("%s: T1-FLAIR: TR not met for single slice per TR", __FUNCTION__);
      }
      npasses++; /* increase #passes and call ksinv_eval_multislice() again with a new ks_slice_plan */
    } else if (existcv(optr) && existcv(opslquant) && opflair == OPFLAIR_INTERLEAVED && optr < ksinv_mintr_t1flair) {
      /* T1-FLAIR, too short TR */
      return ks_error("%s: T1-FLAIR: Min TR is %.0f ms. Increase slices or ETL", __FUNCTION__, ksinv_mintr_t1flair/1000.0);
    } else {
      /* non-T1-FLAIR, or T1-FLAIR with approved TR value */
      approved_TR = TRUE;
    }

  } /* while (approved_TR == FALSE)  */


  return SUCCESS;

} /* ksfse_eval_inversion() */




/**
 *******************************************************************************************************
 @brief #### Evaluation of number of slices / TR, set up of slice plan, TR validation and SAR checks

 With the current sequence collection (see my_cveval()), and a function pointer to an
 argument-standardized wrapper function (ksfse_scan_sliceloop_nargs()) to the slice loop function
 (ksfse_scan_sliceloop(), this function calls GEReq_eval_TR(), where number of slices that can fit
 within one TR is determined by adding more slices as input argument to the slice loop function.
 For more details see GEReq_eval_TR().

 With the number of slices/TR now known, a standard 2D slice plan is set up using ks_calc_sliceplan()
 and the duration of the main sequence is increased based on timetoadd_perTR, which was returned by
 GEReq_eval_TR(). timetoadd_perTR > 0 when optr > avmintr and when heat or SAR restrictions requires
 `avmintr` to be larger than the net sum of sequence modules in the slice loop.

 This function first checks whether seqcollection.evaltrdone == TRUE. This is e.g. the case for inversion
 where the TR timing instead is controlled using ksfse_eval_inversion() (calling ksinv_eval_multislice()).

 At the end of this function, TR validation and heat/SAR checks are done using GEReq_eval_checkTR_SAR().
 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_tr(KS_SEQ_COLLECTION *seqcollection) {
  int timetoadd_perTR;
  STATUS status;
  int slperpass, min_npasses;

  if (seqcollection->evaltrdone == TRUE) {
    /*
     We cannot call GEReq_eval_TR() or GEReq_eval_checkTR_SAR(..., ksfse_scan_sliceloop_nargs, ...) if e.g. the inversion sequence module is used. This is because
     ksinv_scan_sliceloop() is used instead of ksfse_scan_sliceloop(). When ksinv1.params.mode != 0 (i.e. inversion sequence module on), the TR timing and
     heat/SAR limits checks are done in ksinv_eval_multislice(), which is called from ksfse_eval_inversion().
     In the future, other sequence modules may want to take over the responsibility of TR calculations and SAR checks, in which case they need to end their corresponding function
     by setting evaltrdone = TRUE to avoid double processing here */
    return SUCCESS;
  }

  /* interleaved slices in slice gap menu, force 2+ acqs */
  if (opileave)
    min_npasses = 2;
  else
    min_npasses = 1;

  /* Calculate # slices per TR and how much spare time we have within the current TR by running the slice loop. */
  status = GEReq_eval_TRrange(&slperpass, &timetoadd_perTR, min_npasses, ksfse_mintr, ksfse_maxtr, seqcollection, ksfse_scan_sliceloop_nargs, 0, NULL);
  if (status != SUCCESS) return status;

  /* Calculate the slice plan (ordering) and passes (acqs). ks_slice_plan is passed to GEReq_predownload_store_sliceplan() in predownload() */
  if (KS_3D_SELECTED) {
    ks_calc_sliceplan(&ks_slice_plan, exist(opvquant), 1 /* seq 3DMS */);
  } else {
    ks_calc_sliceplan(&ks_slice_plan, exist(opslquant), slperpass);
  }

  /* We spread the available timetoadd_perTR evenly, by increasing the .duration of each slice by timetoadd_perTR/ks_slice_plan.nslices_per_pass */
  ksfse.seqctrl.duration = RUP_GRD(ksfse.seqctrl.duration + CEIL_DIV(timetoadd_perTR, ks_slice_plan.nslices_per_pass));

  /* Update SAR values in the UI (error will occur if the sum of sequence durations differs from optr)  */
  status = GEReq_eval_checkTR_SAR(seqcollection, ks_slice_plan.nslices_per_pass, ksfse_scan_sliceloop_nargs, 0, NULL);
  if (status != SUCCESS) return status;


  /* Fill in the 'tmin' and 'tmin_total'. tmin_total is only like GEs use of the variable when TR = minTR */
  tmin  = _tmin.fixedflag ?  ((void)(ksfse.seqctrl.min_duration), tmin) : ksfse.seqctrl.min_duration;
  tmin_total  = _tmin_total.fixedflag ?  ((void)(ksfse.seqctrl.duration), tmin_total) : ksfse.seqctrl.duration;

  return SUCCESS;

} /* ksfse_eval_tr() */




/**
 *******************************************************************************************************
 @brief #### Set the number of dummy scans for the sequence and calls ksfse_scan_scanloop() to determine
        the length of the scan

        After setting the number of dummy scans based on the current TR, the ksfse_scan_scanloop() is
        called to get the scan time. `pitscan` is the UI variable for the scan clock shown in the top
        right corner on the MR scanner.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_eval_scantime() {

  /* ksfse_dda default = 2 */

  if (optr > 6000000 || opetl == ksfse.phaseenc.numlinestoacq) {
    /* For long TRs or single-shot FSE, don't use dummies */
    ksfse_dda  = _ksfse_dda.fixedflag ?  ((void)(0), ksfse_dda) : 0;
  } else if ((optr > 1000000) && (opflair != OPFLAIR_INTERLEAVED)) {
    /* For medium long TRs and not T1-FLAIR */
    ksfse_dda  = _ksfse_dda.fixedflag ?  ((void)(1), ksfse_dda) : 1;
  }

  pitscan  = _pitscan.fixedflag ?  ((void)(ksfse_scan_scanloop()), pitscan) : ksfse_scan_scanloop();

  return SUCCESS;

} /* ksfse_eval_scantime() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: CVCHECK
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Returns error of various parameter combinations that are not allowed for ksfse
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_check() {

  /* Show resolution, BW per pixel & echo spacing in the UI */
#if EPIC_RELEASE >= 26
  piinplaneres = 1;
  pirbwperpix = 1;
  piesp = 1;
  ihinplanexres = ksfse.read.fov/ksfse.read.res;
  ihinplaneyres = ksfse.phaseenc.fov/ksfse.phaseenc.res;
  ihrbwperpix = (1000.0 * ksfse.read.acq.rbw * 2.0)/ksfse.read.res;
  ihesp = ksfse_esp/1000.0;
#endif

  /* Force the user to select the Fast Spin echo button. This error needs to be in cvcheck(), not in
     cvinit()/cveval() to avoid it to trigger also when Fast Spin Echo has been selected */
  if (!((oppseq == PSD_SE || oppseq == PSD_IR) && opfast == PSD_ON && existcv(opfast))) {
    return ks_error("%s: Please first select the 'Fast Spin Echo' button", ks_psdname);
  }

  if (KS_3D_SELECTED && opcube) {
    return ks_error("%s: Please select either FRFSE-XL or FSE", __FUNCTION__);
  }

  if (oparc && KS_3D_SELECTED && (ksfse.zphaseenc.R > ksfse.phaseenc.R)) {
    /* Unclear why, but zR > R leads to corrupted images for ARC and 3D.
    Probably a bug that can be fixed later. Limited experience (July 2018) */
    return ks_error("%s: Need Slice acceleration <= Phase accleration", __FUNCTION__);
  }

  return SUCCESS;

} /* ksfse_check() */



/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: PREDOWNLOAD
 *
 *******************************************************************************************************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Plotting of sequence modules and slice timing to PNG/SVG/PDF files

 The ks_plot_*** functions used in here will save plots to disk depending on the value of the CV
 `ks_plot_filefmt` (see KS_PLOT_FILEFORMATS). E.g. if ks_plot_filefmt = KS_PLOT_OFF, nothing will be
 written to disk. On the MR scanner, the output will be located in /usr/g/mrraw/plot/\<ks_psdname\>. In
 simulation, it will be placed in the current directory (./plot/).

 Please see the documentation on how to install the required python version and links. Specifically,
 there must be a link /usr/local/bin/apython pointing to the Anaconda 2 python binary (v. 2.7).

 In addition, the following text files are printed out
 - \<ks_psdname\>_objects.txt
 - \<ks_psdname\>_seqcollection.txt

 @return STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_predownload_plot(KS_SEQ_COLLECTION* seqcollection) {
  char tmpstr[1000];

#ifdef PSD_HW
  sprintf(tmpstr, "/usr/g/mrraw/%s_objects.txt", ks_psdname);
#else
  sprintf(tmpstr, "./%s_objects.txt", ks_psdname);
#endif
  FILE *fp  = fopen(tmpstr, "w");

  /* Note: 'fp' can be replaced with 'stdout' or 'stderr' to get these
     values printed out in the WTools window in simulation. However,
     heavy printing may result in that the WTools window closes,
     why we here write to a file ksfse_objects.txt instead */
  ks_print_readtrap(ksfse.read, fp);
  ks_print_trap(ksfse.readdephaser, fp);
  ks_print_phaser(ksfse.phaseenc, fp);
  ks_print_trap(ksfse.zphaseenc.grad, fp);
  ks_print_trap(ksfse.spoiler, fp);
  ks_print_selrf(ksfse.selrfexc, fp);
  ks_print_selrf(ksfse.selrfref1st, fp);
  ks_print_selrf(ksfse.selrfref2nd, fp);
  ks_print_selrf(ksfse.selrfref, fp);
  if (ksinv1.params.irmode != KSINV_OFF) {
    ks_print_selrf(ksinv1.selrfinv, fp);
  }
  fclose(fp);


  /* ks_plot_host():
  Plot each sequence module as a separate file (PNG/SVG/PDF depending on ks_plot_filefmt (GERequired.e))
  See KS_PLOT_FILEFORMATS in KSFoundation.h for options.
  Note that the phase encoding amplitudes corresponds to the first shot, as set by the call to ksfse_scan_seqstate below */
  ksfse_scan_seqstate(ks_scan_info[0], 0);
  ks_plot_host(seqcollection, &ksfse.phaseenc_plan);

  /* Sequence timing plot: */
  ks_plot_slicetime_begin();
  ksfse_scan_scanloop();
  ks_plot_slicetime_end();

  /* ks_plot_tgt_reset():
  Creates sub directories and clear old files for later use of ksfse_scan_acqloop()->ks_plot_tgt_addframe().
  ks_plot_tgt_addframe() will only write in MgdSim (WTools) to avoid timing issues on the MR scanner. Hence,
  unlike ks_plot_host() and the sequence timing plot, one has to open MgdSim and press RunEntry (and also
  press PlotPulse several times after pressing RunEntry).
  ks_plot_tgt_reset() will create a 'makegif_***.sh' file that should be run in a terminal afterwards
  to create the animiated GIF from the dat files */
  ks_plot_tgt_reset(&ksfse.seqctrl);


  return SUCCESS;

} /* ksfse_predownload_plot() */




/**
 *******************************************************************************************************
 @brief #### Last-resort function to override certain recon variables not set up correctly already

 For most cases, the GEReq_predownload_*** functions in predownload() in ksfse.e set up
 the necessary rh*** variables for the reconstruction to work properly. However, if this sequence is
 customized, certain rh*** variables may need to be changed. Doing this here instead of in predownload()
 directly separates these changes from the standard behavior.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_predownload_setrecon() {

  return SUCCESS;

} /* ksfse_predownload_setrecon() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: PULSEGEN - builing of the sequence from the sequence objects
 *
 *  HOST: Called in cveval() to dry-run the sequence to determine timings
 *  TGT:  Waveforms are being written to hardware and necessary memory automatically alloacted
 *
 *******************************************************************************************************
 *******************************************************************************************************/






/**
 *******************************************************************************************************
 @brief #### Sets the phase encoding amplitudes in the FSE train on hardware using the phase enc. table and shot index

 This function will quietly return early when called on HOST. On IPG, it will set the instruction amplitudes
 of the phase encoding gradients in the FSE train given the phase encoding table, the pointer to the
 single phase encoding object for all phase encodes in the echo train, and the shot index.

 The `shot` index must be in range [0, ceil(pe.numlinestoacq/etl)] and is used to select the current
 row of `etl` different amplitudes in `phaseenc_plan[][shot]`.

 The KS_PHASER object must have been placed out `2*etl` times in `ksfse_pg()` before calling this
 function. The `etl` dephasing gradients before each readout in the echo train correspond to even
 indices, i.e. 0,2,4,...,(2*etl-1), whereas the rephasing gradients after each readout correspond to
 odd indices. This is an effect of that all `ks_pg_***()` functions sort the instances of an object in
 time.

 If `shot < 0` (e.g. `shot = KS_NOTSET = -1`), all phase encoding amplitudes will be set to zero.

 @param[in] phaseenc_plan_ptr Pointer to the phase encoding table (KS_PHASEENCODING_PLAN) (2D & 3D)
 @param[in] phaser Pointer to a KS_PHASER ("ky")
 @param[in] zphaser Pointer to a KS_PHASER ("kz"). Pass in NULL for 2D
 @param[in] shot Which `shot` index to play out for this echo train.
                 `shot = KS_NOTSET` will set all phase encoding gradients to zero.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_etlphaseamps(KS_PHASEENCODING_PLAN *phaseenc_plan_ptr, KS_PHASER *phaser, KS_PHASER *zphaser, int shot) {
  int echo;
  KS_PHASEENCODING_COORD coord = KS_INIT_PHASEENCODING_COORD;

  if (phaseenc_plan_ptr->etl == KS_NOTSET) {
    return SUCCESS; /* we haven't set it up yet */
  }

  /* TODO: Check that #instance for phaser and zphaser is equal to phaseenc_plan_ptr->etl * 2 - 1.
    If 1 less that 2*etl, this indicates no fastrecovery. Don't need the last arg then */

  for (echo = 0; echo < phaseenc_plan_ptr->etl; echo++) {

    coord = ks_phaseencoding_get(phaseenc_plan_ptr, echo, shot);

    ks_scan_phaser_toline(phaser,   0 + 2 * echo, coord.ky); /* dephaser */
    ks_scan_phaser_fromline(phaser, 1 + 2 * echo, coord.ky); /* rephaser */

    if (zphaser != NULL) {
      ks_scan_phaser_toline(zphaser,  0 + 2 * echo, coord.kz); /* dephaser */
      ks_scan_phaser_fromline(zphaser, 1 + 2 * echo, coord.kz); /* rephaser */
    }

  } /* for echo in etl */

  return SUCCESS;

} /* ksfse_etlphaseamps() */




/**
 *******************************************************************************************************
 @brief #### 2DFSE: Updates the spoiler amplitude on hardware during scanning depending on current `etl` and `shot`

 This function updates the spoiler amplitude during scanning, and will return quietly if called on HOST.

 @param[in] phaseenc_plan_ptr Pointer to the phase encoding table (KS_PHASEENCODING_PLAN) (2D & 3D)
 @param[in] spoiler Pointer to the KS_TRAP spoiler object
 @param[in] res Phase encoding resolution
 @param[in] shot `shot` index in range `[0, ceil(pe.numlinestoacq/etl)]`.
 @return void
********************************************************************************************************/
void ksfse_spoilamp(KS_PHASEENCODING_PLAN *phaseenc_plan_ptr, KS_TRAP *spoiler, int res, int shot) {
  KS_PHASEENCODING_COORD coord = KS_INIT_PHASEENCODING_COORD;

  /* change spoil direction with respect to last phase encoding blip */
  if (shot >= 0) {
    int i = 1;
    double kspace_dist = 0.0;
    for (i = 0; i < phaseenc_plan_ptr->etl; i++) {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, i, shot);
      if (coord.ky != KS_NOTSET) {
        kspace_dist = ((res - 1.0)/ 2.0) - coord.ky;
      }
    }
    if (kspace_dist >= 0.0) {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, phaseenc_plan_ptr->etl - 1, shot);
      if (coord.ky == KS_NOTSET) {
        ks_scan_trap_ampscale(spoiler, 0, -1.0);
      } else {
        ks_scan_trap_ampscale(spoiler, 0, 1.0);
      }
    } else {
      coord = ks_phaseencoding_get(phaseenc_plan_ptr, phaseenc_plan_ptr->etl - 1, shot);
      if (coord.ky == KS_NOTSET) {
        ks_scan_trap_ampscale(spoiler, 0, 1.0);
      } else {
        ks_scan_trap_ampscale(spoiler, 0, -1.0);
      }
    }
  }

} /* ksfse_spoilamp() */



/**
 *******************************************************************************************************
 @brief #### The ksfse (main) pulse sequence

 This is the main pulse sequence in ksfse.e using the sequence objects in KSFSE_SEQUENCE with
 the sequence module name "ksfsemain" (= ksfse.seqctrl.description)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_pg(int start_time) {

  KS_SEQLOC tmploc = KS_INIT_SEQLOC;
  int readpos_start = KS_NOTSET;
  int spoiler_pos = KS_NOTSET;
  int i;

  if (start_time < KS_RFSSP_PRETIME) {
    return ks_error("%s: 1st arg (pos start) must be at least %d us", __FUNCTION__, KS_RFSSP_PRETIME);
  }


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  tmploc.ampscale = 1.0;
  tmploc.pos = RUP_GRD(start_time + KS_RFSSP_PRETIME);
  tmploc.board = ZGRAD;

  /* N.B.: ks_pg_selrf()->ks_pg_rf() detects that ksfse.selrfexc is an excitation pulse
     (ksfse.selrfexc.rf.role = KS_RF_ROLE_EXC) and will also set ksfse.seqctrl.momentstart
     to the absolute position in [us] of the isocenter of the RF excitation pulse */
  if (ks_pg_selrf(&ksfse.selrfexc, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;


  /*******************************************************************************************************
   *  X dephaser (between 90 and 1st 180)
   *******************************************************************************************************/
  if (ksfse_slicecheck) {
    tmploc.pos = ksfse.seqctrl.momentstart + ksfse.selrfexc.rf.iso2end + ksfse.selrfexc.grad.ramptime;
    tmploc.board = ZGRAD;
  } else {
    tmploc.pos = ksfse.seqctrl.momentstart + ksfse.selrfexc.rf.iso2end;
    tmploc.board = XGRAD;
  }
  if (ks_pg_trap(&ksfse.readdephaser, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
  *  Generate the refocusing flip angles
  -------------------------------------------------------------------------------------------------------*/
  double flip_angles[512]; /* rad */

  if (ksfse_vfa) {

    STATUS status = ks_pg_fse_flip_angle_taperoff(flip_angles,
                                                  opetl,
                                                  ksfse.selrfref1st.rf.flip, ksfse.selrfref2nd.rf.flip, ksfse.selrfref.rf.flip,
                                                  80.0, /* degrees */
                                                  opflair != OPFLAIR_INTERLEAVED);
    if (status != SUCCESS) return ks_error("ks_pg_fse_flip_angle_taperoff failed");

    /* modify rfpulse-struct for SAR calcs. */
    ks_pg_mod_fse_rfpulse_structs(&ksfse.selrfref1st, &ksfse.selrfref2nd, &ksfse.selrfref,
                                  flip_angles,
                                  opetl);

  }



  /*******************************************************************************************************
  *  FSE train: Begin
  -------------------------------------------------------------------------------------------------------*/
  for (i = 0; i < opetl; i++) {

    /* Selective RF Refocus with left (pregrad.) and right (postgrad.) crushers */
    tmploc.board = ZGRAD;
    if (i == 0) {
      /* special case for 1st pulse with at least a smaller left crusher */
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref1st.rf.start2iso - ksfse.selrfref1st.grad.ramptime - ksfse.selrfref1st.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref1st.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref1st, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    } else if (i == 1) {
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref2nd.rf.start2iso - ksfse.selrfref2nd.grad.ramptime - ksfse.selrfref2nd.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref2nd.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref2nd, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    } else {
      tmploc.pos = ksfse.seqctrl.momentstart + (i + 0.5) * ksfse_esp - ksfse.selrfref.rf.start2iso - ksfse.selrfref.grad.ramptime - ksfse.selrfref.pregrad.duration;

      if (ksfse_vfa)
        tmploc.ampscale = flip_angles[i]/ ksfse.selrfref.rf.flip;

      if (ks_pg_selrf(&ksfse.selrfref, tmploc, &ksfse.seqctrl) == FAILURE)
        return FAILURE;
      tmploc.ampscale = 1;

    }

    /* ksfse_esp dependent time at beginning of readout ramp */
    readpos_start = ksfse.seqctrl.momentstart + (i + 1) * ksfse_esp - ksfse.read.time2center;

    /*******************************************************************************************************
    *  Readouts
    *******************************************************************************************************/
    tmploc.pos = readpos_start;
    if (ksfse_slicecheck)
      tmploc.board = ZGRAD;
    else
      tmploc.board = XGRAD;
    if (ks_pg_readtrap(&ksfse.read, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /*******************************************************************************************************
    *  Phase encoding dephasers & rephasers
    *******************************************************************************************************/
    tmploc.board = YGRAD;
    tmploc.pos = readpos_start + ksfse.read.acqdelay - ksfse.phaseenc.grad.duration;
    if (ks_pg_phaser(&ksfse.phaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i */
      return FAILURE;
    tmploc.pos = readpos_start + ksfse.read.grad.duration - ksfse.read.acqdelay;
    if (ks_pg_phaser(&ksfse.phaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i + 1 */
      return FAILURE;

    /*******************************************************************************************************
    *  Z phase encoding dephasers & rephasers (3D)
    *******************************************************************************************************/
    if (ksfse.zphaseenc.grad.duration > 0) {
      tmploc.board = ZGRAD;
      tmploc.pos = readpos_start + ksfse.read.acqdelay - ksfse.zphaseenc.grad.duration;
      if (ks_pg_phaser(&ksfse.zphaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i */
        return FAILURE;
      tmploc.pos = readpos_start + ksfse.read.grad.duration - ksfse.read.acqdelay;
      if (ks_pg_phaser(&ksfse.zphaseenc, tmploc, &ksfse.seqctrl) == FAILURE) /* instance 2*i + 1 */
        return FAILURE;
    }

  } /* opetl */

  /*------------------------------------------------------------------------------------------------------
   *  FSE train: End
   *******************************************************************************************************/


  /*******************************************************************************************************
   * Phase encoding table
   * written to /usr/g/mrraw/ks_phaseencodingtable.txt (HW) or ./ks_phaseencodingtable.txt (SIM)
   *
   * Need to call this in ksfse_pg() so it is run both on HOST and TGT. This, since the phase table
   * is dynamically allocated in ks_phaseencoding_generate_2Dfse()->ks_phaseencoding_resize()
   *
   * For 3D, ks_phaseencoding_generate_2Dfse() just repeats the same ETL ky path for every kz. This is just
   * for testing, and a better ks_phaseencoding_generate_*** function would be needed to do optimal ky-kz
   * trajectory for 3D
   *******************************************************************************************************/
  if (ks_phaseencoding_generate_2Dfse(&ksfse.phaseenc_plan, "",
                                      &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL,
                                      opte, opetl, ksfse_esp) == FAILURE)
     return FAILURE;

  ks_phaseencoding_print(&ksfse.phaseenc_plan);

  /* set phase encoding amp as for the first shot in the scan loop so it is displayed in WTools MGDSim */
  ksfse_etlphaseamps(&ksfse.phaseenc_plan, &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL, 0);

  /*******************************************************************************************************
   * Post-ETL forced recovery: T1-w Optimization / T2 fast Recovery
   *******************************************************************************************************/
  if (ksfse_recovery) {

    int lastReadoutCenter = ksfse.seqctrl.momentstart + opetl * ksfse_esp;

    /* Place extra refocusing pulse */
    tmploc.board = ZGRAD;
    tmploc.pos = lastReadoutCenter + ksfse_esp/2 - ksfse.selrfrecoverref.rf.start2iso - ksfse.selrfrecoverref.grad.ramptime - ksfse.selrfrecoverref.pregrad.duration;
    tmploc.ampscale = (ksfse_vfa) ? flip_angles[opetl-1]/ ksfse.selrfrecoverref.rf.flip : 1;

    if (ks_pg_selrf(&ksfse.selrfrecoverref, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /* Place rewinder of previous readout in order to get back to the center of k-space */
    tmploc.pos = lastReadoutCenter + ksfse_esp - ksfse.selrfrecover.rf.start2iso - ksfse.readdephaser.duration;
    tmploc.ampscale = 1;
    if (ksfse_slicecheck) {
      tmploc.board = ZGRAD;
      tmploc.pos -= ksfse.selrfrecover.grad.ramptime;
    } else {
      tmploc.board = XGRAD;
    }
    if (ks_pg_trap(&ksfse.readdephaser, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;

    /* Place excitation pulse */
    tmploc.board = ZGRAD;
    tmploc.pos = lastReadoutCenter + ksfse_esp - ksfse.selrfrecover.rf.start2iso - ksfse.selrfrecover.grad.ramptime - ksfse.selrfrecover.pregrad.duration;

    if (ksfse_recovery == KSFSE_RECOVERY_FAST) {
      tmploc.ampscale = -1;
    } else { /* = KSFSE_RECOVERY_T1WOPT */
      tmploc.ampscale = 1;
    }
    if (ks_pg_selrf(&ksfse.selrfrecover, tmploc, &ksfse.seqctrl) == FAILURE)
      return FAILURE;
    tmploc.ampscale = 1;

    /* spoiler pos */
    spoiler_pos = tmploc.pos + ksfse.selrfrecover.pregrad.duration + ksfse.selrfrecover.grad.duration;

  } else {

    /* spoiler pos */
    spoiler_pos = ksfse.seqctrl.momentstart + opetl * ksfse_esp + ksfse.read.grad.duration - ksfse.read.time2center - ksfse.read.acqdelay + ksfse.phaseenc.grad.duration;

  } /* ksfse_recovery */

  /*******************************************************************************************************
   *  Gradient spoiler on Y
   *******************************************************************************************************/
  tmploc.board = YGRAD;
  tmploc.pos = spoiler_pos;
  tmploc.ampscale = 1;
  if (ks_pg_trap(&ksfse.spoiler, tmploc, &ksfse.seqctrl) == FAILURE)
    return FAILURE;
  tmploc.pos += ksfse.spoiler.duration;
  ksfse_spoilamp(&ksfse.phaseenc_plan, &ksfse.spoiler, ksfse.phaseenc.res, 0);


 /*******************************************************************************************************
   *  Set the minimal sequence duration (ksfse.seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  /* make sure we are divisible by GRAD_UPDATE_TIME (4us) */
  tmploc.pos = RUP_GRD(tmploc.pos);

#ifdef HOST_TGT
  /* On HOST only: Sequence duration (ksfse.seqctrl.ssi_time must be > 0 and is added to ksfse.seqctrl.min_duration in ks_eval_seqctrl_setminduration() */
  ksfse.seqctrl.ssi_time = ksfse_eval_ssitime();
  ks_eval_seqctrl_setminduration(&ksfse.seqctrl, tmploc.pos); /* tmploc.pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksfse_pg() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksfse_implementation.e: SCAN in @pg section (functions accessible to both HOST and TGT)
 *
 *  Here are functions related to the scan process (ksfse_scan_***) that have to be placed here in @pg
 *  (not @rsp) to make them also accessible on HOST in order to enable scan-on-host for TR timing
 *  in my_cveval()
 *
 *******************************************************************************************************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksfse sequence objects being part of KSFSE_SEQUENCE

 This function sets the current state of all ksfse sequence objects being part of KSFSE_SEQUENCE, incl.
 gradient amplitude changes, RF freq/phases and receive freq/phase based on current slice position and
 phase encoding indices.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] slice_info Position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @param[in] shot `shot` index in range `[0, ksfse.phaseenc_plan.num_shots - 1]`
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksfse_scan_seqstate(SCAN_INFO slice_info, int shot) {
  int i;
  float rfphase = 0.0;
  KS_PHASEENCODING_COORD coord;

  ks_scan_rotate(slice_info);

  ks_scan_selrf_setfreqphase(&ksfse.selrfexc,    0,        slice_info, rfphase /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref1st, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref2nd, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  ks_scan_selrf_setfreqphase(&ksfse.selrfref,    INSTRALL, slice_info, rfphase + 90 /* [deg] */);
  if (ksfse_recovery) {
    ks_scan_selrf_setfreqphase(&ksfse.selrfrecoverref, INSTRALL, slice_info, rfphase + 90 /* [deg] */);
    ks_scan_selrf_setfreqphase(&ksfse.selrfrecover, 0, slice_info, rfphase /* [deg] */);
  }

  /* FOV offsets (by changing freq/phase of ksfse.read) */
  if (shot >= 0) {
    for (i = 0; i < ksfse.phaseenc_plan.etl; i++) {

      coord = ks_phaseencoding_get(&ksfse.phaseenc_plan, i, shot);

      if (KS_3D_SELECTED) {
        float zfovratio = (opslquant * opslthick)/ opfov;
        float zchop_phase = 0.0;
        if (oparc && (coord.kz % 2)) {
          /* GEs ARC recon ignores RHF_ZCHOP bit in 'rhformat', but expects 3D data to be z-chopped for proper slice sorting.
          In GERequired.e:GEReq_predownload_setrecon_voldata(), RHF_ZCHOP is unset by default. In combination with
          that we do not do zchop for non-ARC scans (incl ASSET), this works well. But for ARC scans, we must zchop. That is,
          we add 180 phase to every odd kz encoded line, which is the same as a final z fftshift in the image domain */
          zchop_phase = 180.0;
        }
        ks_scan_offsetfov3D(&ksfse.read, i, slice_info, coord.ky, opphasefov, coord.kz, zfovratio, rfphase + zchop_phase);
      } else {
        ks_scan_offsetfov(&ksfse.read, i, slice_info, coord.ky, opphasefov, rfphase);
      }

    } /* etl */
  } /* shot > 0 */

  /* change phase encoding amplitudes */
  ksfse_etlphaseamps(&ksfse.phaseenc_plan, &ksfse.phaseenc, (KS_3D_SELECTED) ? &ksfse.zphaseenc : NULL, shot);

  /* change spoiler amplitude */
  ksfse_spoilamp(&ksfse.phaseenc_plan, &ksfse.spoiler, ksfse.phaseenc.res, shot);

  /* Turn off T1-w opt. in DDAs */
  if ((ksfse_recovery) && (shot < 0)) {
    ks_scan_rf_off(&ksfse.selrfrecover.rf, 0);
    ks_scan_rf_off(&ksfse.selrfrecoverref.rf, 0);
  }

  return SUCCESS;

} /* ksfse_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Sets all RF pulse amplitudes to zero

 @return void
********************************************************************************************************/
void ksfse_scan_rf_off() {
  ks_scan_rf_off(&ksfse.selrfexc.rf,    INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref1st.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref2nd.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfref.rf,    INSTRALL);
  ks_scan_rf_off(&ksfse.selrfrecover.rf, INSTRALL);
  ks_scan_rf_off(&ksfse.selrfrecoverref.rf, INSTRALL);
} /* ksfse_scan_rf_off() */



/**
 *******************************************************************************************************
 @brief #### Sets all RF pulse amplitudes on

 @return void
********************************************************************************************************/
void ksfse_scan_rf_on() {
  ks_scan_rf_on(&ksfse.selrfexc.rf,    INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref1st.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref2nd.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfref.rf,    INSTRALL);
  ks_scan_rf_on(&ksfse.selrfrecover.rf, INSTRALL);
  ks_scan_rf_on(&ksfse.selrfrecoverref.rf, INSTRALL);
}



/**
 *******************************************************************************************************
 @brief #### Plays out one slice in real time during scanning together with other active sequence modules

  On TGT on the MR system (PSD_HW), this function sets up (ksfse_scan_seqstate()) and plays out the
  core ksfse sequence with optional sequence modules also called in this function. The low-level
  function call `startseq()`, which actually starts the realtime sequence playout is called from within
  ks_scan_playsequence(), which in addition also returns the time to play out that sequence module (see
  time += ...).

  On HOST (in ksfse_eval_tr()) we call ksfse_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksfse_scan_scantime(), which returns the total time of the
  entire scan.

  After each call to ks_scan_playsequence(), ks_plot_slicetime() is called to add slice-timing
  information on file for later PNG/PDF-generation of the sequence. As scanning is performed in real-time
  and may fail if interrupted, ks_plot_slicetime() will return quietly if it detects both IPG (TGT)
  and PSD_HW (on the MR scanner). See predownload() for the PNG/PDF generation.

  @param[in] slice_pos Position of the slice to be played out (one element in the global
                      `ks_scan_info[]` array)
  @param[in] dabslice  0-based slice index for data storage
  @param[in] shot `shot` index (over ky and kz)
  @param[in] exc Excitation index in range `[0, NEX-1]`, where NEX = number of excitations (opnex)
  @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksfse_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, /* psd specific: */ int shot, int exc) {
  int i;
  int dabop, dabview, acqflag;
  int time = 0;
  float tloc = 0.0;
  KS_PHASEENCODING_COORD coord;

  if (slice_pos != NULL)
    tloc = slice_pos->optloc;


  /*******************************************************************************************************
  * SpSat sequence module
  *******************************************************************************************************/
  time += ksspsat_scan_playsequences(ks_perform_slicetimeplot);


  /*******************************************************************************************************
  * Chemsat sequence module
  *******************************************************************************************************/
  kschemsat_scan_seqstate(&kschemsat);
  time += ks_scan_playsequence(&kschemsat.seqctrl);
  ks_plot_slicetime(&kschemsat.seqctrl, 1, NULL, KS_NOTSET, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD); /* no slice location for fat sat */


  /*******************************************************************************************************
  * ksfse main sequence module
  *******************************************************************************************************/
  if (slice_pos != NULL) {
    ksfse_scan_rf_on();
    ksfse_scan_seqstate(*slice_pos, (ksfse_noph != PSD_ON) ? shot : KS_NOTSET); /* shot. if = KS_NOTSET, no phase encodes */
  } else {
    ksfse_scan_rf_off(); /* false slice, shut off RF pulses */
  }


  for (i = 0; i < ksfse.read.acq.base.ngenerated; i++) {
    /* N.B.: Looping over ksfse.read.acq.base.ngenerated corresponds to:
       HOST: No looping since ksfse.read.acq.base.ngenerated is 0 on HOST
       TGT: ETL.
       This protects calls to loaddab() on HOST
    */
    coord = ks_phaseencoding_get(&ksfse.phaseenc_plan, i, shot);

    /* data routing control */
    acqflag = (shot >= 0 && slice_pos != NULL && coord.ky >= 0 && dabslice >= 0) ? DABON : DABOFF; /* open or close data receiver */
    dabop = (exc <= 0) ? DABSTORE : DABADD; /* replace or add to data */

    if (KS_3D_SELECTED) {
      if (ks_scan_info[1].optloc > ks_scan_info[0].optloc)
        dabslice = (opslquant * opvquant - 1) - coord.kz;
      else
        dabslice = coord.kz;
    }

    dabview = (shot >= 0) ? coord.ky : KS_NOTSET;

    if (ksfse.phaseenc.R > 1 && ksfse.phaseenc.nacslines == 0 && dabview != KS_NOTSET) {
      /* ASSET case triggered by R > 1 and no ACS lines */
      dabview/= ksfse.phaseenc.R; /* store in compressed BAM without empty non-acquired lines */
    }

    loaddab(&ksfse.read.acq.echo[i], dabslice, 0, dabop, dabview + 1, acqflag, PSD_LOAD_DAB_ALL); /* see epicfuns.h for alternatives to loaddab() */

  } /* etl */

  time += ks_scan_playsequence(&ksfse.seqctrl);
  ks_plot_slicetime(&ksfse.seqctrl, 1, &tloc, opslthick, slice_pos == NULL ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD);

  return time; /* in [us] */

} /* ksfse_scan_coreslice() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksfse_scan_coreslice() with standardized input arguments

 KSInversion.e has functions (ksinv_eval_multislice(), ksinv_eval_checkTR_SAR() and
 ksinv_scan_sliceloop()) that expect a standardized function pointer to the coreslice function of a main
 sequence. When inversion mode is enabled for the sequence, ksinv_scan_sliceloop() is used instead of
 ksfse_scan_sliceloop() in ksfse_scan_acqloop(), and the generic ksinv_scan_sliceloop() function need a
 handle to the coreslice function of the main sequence.

 In order for these `ksinv_***` functions to work for any pulse sequence they need a standardized
 function pointer with a fixed set of input arguments. As different pulse sequences may need different
 number of input arguments (with different meaning) this ksfse_scan_coreslice_nargs() wrapper function
 provides the argument translation for ksfse_scan_coreslice().

 The function pointer must have SCAN_INFO and slice storage index (dabslice) as the first two input
 args, while remaining input arguments (to ksfse_scan_coreslice()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksfse_scan_coreslice().

 @param[in] slice_pos Pointer to the SCAN_INFO struct corresponding to the current slice to be played out
 @param[in] dabslice  0-based slice index for data storage
 @param[in] nargs Number of extra input arguments to ksfse_scan_coreslice() in range [0,2]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksfse_scan_coreslice()
 @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksfse_scan_coreslice_nargs(const SCAN_INFO *slice_pos, int dabslice, int nargs, void **args) {
  int shot = 0;
  int exc = 0;

  if (nargs < 0 || nargs > 2) {
    ks_error("%s: 4th arg (void **) must contain up to 2 elements in the following order: shot, exc", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 4th arg (void **) cannot be NULL if nargs (3rd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    shot = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    exc = *((int *) args[1]);
  }

  return ksfse_scan_coreslice(slice_pos, dabslice, /* psd specific: */ shot, exc); /* in [us] */

} /* ksfse_scan_coreslice_nargs() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slperpass` slices corresponding to one TR

 This function gets a spatial slice location index based on the pass index and temporal position within
 current pass. It then calls ksfse_scan_coreslice() to play out one coreslice (i.e. the main ksfse main
 sequence + optional sequence modules, excluding inversion modules).

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] passindx  Pass index in range [0, ks_slice_plan.npasses - 1]
 @param[in] shot `shot` index in range `[0,  ksfse.phaseenc_plan.num_shots - 1]`
 @param[in] exc Excitation index in range `[0, NEX-1]`, where NEX = number of excitations (opnex)
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksfse_scan_sliceloop(int slperpass, int passindx, int shot, int exc) {
  int time = 0;
  int slloc, sltimeinpass;
  SCAN_INFO centerposition = ks_scan_info[0]; /* first slice chosen here, need only rotation stuff */

  if (KS_3D_SELECTED) {
    int centerslice = opslquant/2;
    /* for future 3D multislab support, let passindx update centerposition */
    centerposition.optloc = (ks_scan_info[centerslice-1].optloc + ks_scan_info[centerslice].optloc)/2.0;
  }

  for (sltimeinpass = 0; sltimeinpass < slperpass; sltimeinpass++) {

    SCAN_INFO *current_slice = &centerposition;

    if (!KS_3D_SELECTED) { /* 2D */
      /* slice location from slice plan */
      slloc = ks_scan_getsliceloc(&ks_slice_plan, passindx, sltimeinpass);

      /* if slloc = KS_NOTSET, pass in NULL as first argument to indicate 'false slice' */
      current_slice = (slloc != KS_NOTSET) ? &ks_scan_info[slloc]: NULL;
    }

    time += ksfse_scan_coreslice(current_slice, sltimeinpass, shot, exc);

  }

  return time; /* in [us] */

} /* ksfse_scan_sliceloop() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksfse_scan_sliceloop() with standardized input arguments

 For TR timing heat/SAR calculations of regular 2D multislice sequences, GEReq_eval_TR(),
 ks_eval_mintr() and GEReq_eval_checkTR_SAR() use a standardized function pointer with a fixed set of
 input arguments to call the sliceloop of the main sequence with different number of slices to check
 current slice loop duration. As different pulse sequences may need different number of input arguments
 (with different meaning) this ksfse_scan_sliceloop_nargs() wrapper function provides the argument
 translation for ksfse_scan_sliceloop().

 The function pointer must have an integer corresponding to the number of slices to use as its first
 argument while the remaining input arguments (to ksfse_scan_sliceloop()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksfse_scan_sliceloop().

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] nargs Number of extra input arguments to ksfse_scan_sliceloop() in range [0,4]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksfse_scan_sliceloop()
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksfse_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  int passindx = 0;
  int shot = KS_NOTSET;   /* off */
  int exc = 0;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain up to 3 elements: passindx, shot, exc", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    passindx = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    shot = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    exc = *((int *) args[2]);
  }

  return ksfse_scan_sliceloop(slperpass, passindx, shot, exc); /* in [us] */

} /* ksfse_scan_sliceloop_nargs() */




/**
 *******************************************************************************************************
 @brief #### Plays out all phase encodes for all slices belonging to one pass

 This function traverses through all shots (`ksfse.phaseenc_plan.num_shots`) to be played out and runs the
 ksfse_scan_sliceloop() for each set of shots and excitation. If ksfse_dda > 0, dummy scans
 will be played out before the phase encoding begins.

 In the case of inversion, ksinv_scan_sliceloop() is called instead of ksfse_scan_sliceloop(), where
 the former takes a function pointer to ksfse_scan_coreslice_nargs() in order to be able to play out
 the coreslice in a timing scheme set by ksinv_scan_sliceloop().

 @param[in] passindx  0-based pass index in range `[0, ks_slice_plan.npasses - 1]`
 @retval passlooptime Time taken in [us] to play out all phase encodes and excitations for `slperpass`
                      slices. Note that the value is a `float` instead of `int` to avoid int overrange
                      at 38 mins of scanning
********************************************************************************************************/
float ksfse_scan_acqloop(int passindx) {
  float time = 0.0;
  int shot, exc;

  for (shot = -ksfse_dda; shot < ksfse.phaseenc_plan.num_shots; shot++) {

    /* shot < 0 means dummy scans, and is handled in ksfse_scan_coreslice(), ksfse_scan_seqstate() and ksfse_etlphaseamps() */

    if (shot == 0 && ksfse_dda > 0) {
      ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_DUMMY);
    }

    for (exc = 0; exc < (int) ceil(opnex); exc++) { /* ceil rounds up opnex < 1 (used for partial Fourier) to 1 */

      if (ksinv1.params.irmode != KSINV_OFF) {
        void *args[2] = {(void *) &shot, (void *) &exc}; /* pass on args via ksinv_scan_sliceloop() to ksfse_scan_coreslice() */
        int nargs = sizeof(args)/ sizeof(void *);
        time += (float) ksinv_scan_sliceloop(&ks_slice_plan, ks_scan_info, passindx, &ksinv1, &ksinv2, &ksinv_filltr,
                                              (shot < 0) ? KSINV_LOOP_DUMMY : KSINV_LOOP_NORMAL, ksfse_scan_coreslice_nargs, nargs, args);
      } else {
        time += (float) ksfse_scan_sliceloop(ks_slice_plan.nslices_per_pass, passindx, shot, exc);
      }

      ks_plot_slicetime_endofslicegroup("ksfse shots");

    } /* for exc */

    /* save a frame of the main sequence for later generation of an animated GIF (only in MgdSim, WTools) */
    if (shot >= 0) {
      ks_plot_tgt_addframe(&ksfse.seqctrl);
    }

  } /* for shot */

  ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_STANDARD);
  return time; /* in [us] */

} /* ksfse_scan_acqloop() */




/**
 *******************************************************************************************************
 @brief #### Plays out all volumes and passes of a single or multi-pass scan

 This function performs the entire scan and traverses through passes and volumes. For now, since
 `opmph = 0` as multiphase is controlled outside the psd via PSD_IOPT_DYNPL, opfphases will always be 1.
 For each `passindx` (in range `[0, ks_slice_plan.npasses-1]`), ksfse_scan_acqloop() will be called to
 acquire all data for the current set of slices belong to the current pass (acquisition). At the end of
 each pass, GEReq_endofpass() is called to trigger GE's recon and to dump Pfiles (if `autolock = 1`).

 @retval scantime Total scan time in [us] (`float` to avoid int overrange after 38 mins)
********************************************************************************************************/
float ksfse_scan_scanloop() {
  float time = 0.0;

  for (volindx = 0; volindx < opfphases; volindx++) { /* opfphases is # volumes (BUT: opfphases always 1 since opmph = 0) */

    for (passindx = 0; passindx < ks_slice_plan.npasses; passindx++) { /* acqs = passes */

      time += ksfse_scan_acqloop(passindx);

#ifdef IPG
      GEReq_endofpass();
#endif

    } /* end: acqs (pass) loop */

  } /* end: volume loop */

  return time; /* in [us] */

} /* ksfse_scan_acqloop() */





/*****************************************************************************************************
 * Host Functions and variables
 *****************************************************************************************************/

  /* Collection (handle) of all sequence modules */
  KS_SEQ_COLLECTION seqcollection;

/*****************************************************************************************************
 * CVINIT (Executes at init and when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cvinit(void) {
  STATUS status;

  status = GEReq_cvinit();
  if (status != SUCCESS) return status;

  /* reset debug file ./ks_debug.txt (SIM) or /usr/g/mrraw/ks_debug.txt (HW) */
  ks_dbg_reset();

  /* Imaging Options buttons */
  ksfse_init_imagingoptions();

  /* Inversion UI init */
  status = ksinv_init_UI();
  if (status != SUCCESS) return status;
  
  /* Setup UI buttons */
  status = ksfse_init_UI();
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* cvinit() */



/*****************************************************************************************************
 * CVEVAL (Executes when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cveval(void) {
  /*
   cveval() is called 37+ times per UI button push on the MR system, while cvcheck() is only called once.
   For a faster execution we have a my_cveval() function that is called in cvcheck() instead
   */

  return SUCCESS;
}


STATUS my_cveval(void) {
  STATUS status;

  ks_init_seqcollection(&seqcollection);

  status = GEReq_cveval();
  if (status != SUCCESS) return status;

  /* User Interface updates & opuserCV sync */
  status = ksfse_eval_UI();
  if (status != SUCCESS) return status;

  /* Setup sequence objects */
  status = ksfse_eval_setupobjects();
  if (status != SUCCESS) return status;

  /* Calculate minimum (and maximum TE), and sometimes ETL */
  status = ksfse_eval_TErange();
  if (status != SUCCESS) return status;

  /* Run the sequence once (and only once after ksfse_eval_setupobjects()) in cveval() to
     get the sequence duration and the number of object instances (for grad/rf limits in GEReq...limits()) */
  status = ksfse_pg(ksfse_pos_start);
  if (status != SUCCESS) return status;

  status = ks_eval_addtoseqcollection(&seqcollection, &ksfse.seqctrl);
  if (status != SUCCESS) return status;


  /*--------- Begin: Additional sequence modules -----------*/

  /* Spatial Sat */
  status = ksspsat_eval(&seqcollection);
  if (status != SUCCESS) return status;

  /* ChemSat */
  status = kschemsat_eval(&seqcollection);
  if (status != SUCCESS) return status;

  /* Inversion (general & FSE specific). Must be the last sequence module added */
  if (!KS_3D_SELECTED) {
    status = ksfse_eval_inversion(&seqcollection);
    if (status != SUCCESS) return status;
  }
  /*--------- End: Additional sequence modules -----------*/


  /* Min TR, #slices per TR (unless Inversion on), RF/gradient heating & SAR  */
  status = ksfse_eval_tr(&seqcollection);
  if (status != SUCCESS) return status;

  /* RF scaling across sequence modules */
  status = GEReq_eval_rfscaling(&seqcollection);
  if (status != SUCCESS) return status;

  /* scan time */
  status = ksfse_eval_scantime();
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* my_cveval() */



/*****************************************************************************************************
 * CVCHECK (Executes when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cvcheck(void) {
  STATUS status;

  status = my_cveval();
  if (status != SUCCESS) return status;

    status = GEReq_cvcheck();
  if (status != SUCCESS) return status;

  status = ksfse_check();
  if (status != SUCCESS) return status;

  status = ksinv_check();
  if (status != SUCCESS) return status;

  abort_on_kserror = ksfse_abort_on_kserror;

  return SUCCESS;

} /* cvcheck() */


/*****************************************************************************************************
 * PREDOWNLOAD (Executes when pressing SaveRx on MR scanner (HW) or on value change in EvalTool (SIM)
 *****************************************************************************************************/
STATUS predownload( void ) {
  STATUS status;

  status = GEReq_predownload();
  if (status != SUCCESS) return status;

  /* Set filter slot # for SCAN, APS2, MPS2 */
  GEReq_predownload_setfilter(&ksfse.read.acq.filt);

  /* slice ordering */
  /* The following GE globals must be set appropriately:
     data_acq_order[], rsp_info[], rsprot[], rsptrigger[]. This is a must for a main pulse sequence */
  if (KS_3D_SELECTED) {
    status = GEReq_predownload_store_sliceplan3D(opslquant, opvquant);
  } else {
    status = GEReq_predownload_store_sliceplan(ks_slice_plan);
  }  
  if (status != SUCCESS) return status;

  /* generic rh-vars setup */
  GEReq_predownload_setrecon_readphase(&ksfse.read, &ksfse.phaseenc, KS_3D_SELECTED ? &ksfse.zphaseenc : NULL, \
                                       ksfse_imsize, KS_SAVEPFILES * autolock + KS_GERECON * (rhrecon < 1000) /* online recon if rhrecon < 1000 */);
  GEReq_predownload_setrecon_annotations_readtrap(&ksfse.read, ksfse_extragap);
  GEReq_predownload_setrecon_voldata(opfphases, ks_slice_plan); /* opfphases = number of volumes */

  /* KSInversion predownload */
  status = ksinv_predownload_setrecon();
  if (status != SUCCESS) return status;

  /* further sequence specific recon settings that have not been set correctly at this point */
  status = ksfse_predownload_setrecon();
  if (status != SUCCESS) return status;

  /* plotting of sequence modules and slice timing to disk */
  ksfse_predownload_plot(&seqcollection);


  return SUCCESS;

} /* predownload() */



/*****************************************************************************************************
 * PULSEGEN (Executes when pressing Scan or Research->Download)
 *****************************************************************************************************/

STATUS pulsegen( void ) {

  GEReq_pulsegenBegin();

  /* Main sequence */
  ksfse_pg(ksfse_pos_start);
   
    {
      if (ksfse.seqctrl.duration > 0) {

        if (ksfse.seqctrl.duration - ksfse.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksfse.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqcore, "seqcore");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqcore) failed", ksfse.seqctrl.description);
          }  
          status = createseq(&seqcore, ksfse.seqctrl.duration - ksfse.seqctrl.ssi_time, off_seqcore);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqcore) failed", ksfse.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqcore );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqcore) failed", ksfse.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqcore = %d\n", idx_seqcore );
          ksfse.seqctrl.handle.index = idx_seqcore;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksfse.seqctrl.handle.offset = off_seqcore;
          ksfse.seqctrl.handle.pulse = &seqcore;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  

  /* Spatial Sat */
  ksspsat_pulsegen();

  /* ChemSat sequence module */
  kschemsat_pg(&kschemsat);
   
    {
      if (kschemsat.seqctrl.duration > 0) {

        if (kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", kschemsat.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqKSChemSat, "seqKSChemSat");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }  
          status = createseq(&seqKSChemSat, kschemsat.seqctrl.duration - kschemsat.seqctrl.ssi_time, off_seqKSChemSat);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqKSChemSat) failed", kschemsat.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqKSChemSat );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqKSChemSat) failed", kschemsat.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqKSChemSat = %d\n", idx_seqKSChemSat );
          kschemsat.seqctrl.handle.index = idx_seqKSChemSat;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          kschemsat.seqctrl.handle.offset = off_seqKSChemSat;
          kschemsat.seqctrl.handle.pulse = &seqKSChemSat;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
   /* does nothing if kschemsat.seqctrl.duration = 0 */

  /* Inversion sequence modules */
  ksinv_pulsegen();

  GEReq_pulsegenEnd();

  buildinstr(); /* load the sequencer memory */

  return SUCCESS;

} /* pulsegen() */




/* Include special CV download code */
#include "ksfse.cvcopy.c"

