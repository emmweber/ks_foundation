/*
 *  ksgre_tutorial.host.c
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Nov 24 2018
 *  Time : 13:36:59
 */

#include <values.h>
#include <string.h>
#include "epic_macros.h"
#include "epic_struct.h"
#include "ksgre_tutorial.global.h"
#include "pgen_tmpl.h"
#include "ksgre_tutorial.allcv.h"
#include "ksgre_tutorial.tgtex.h"
#include "ksgre_tutorial.hostdecl.h"
#include "ksgre_tutorial.tgtdecl.h"
#include "ksgre_tutorial.exportstr.h"
#include "ksgre_tutorial.runtime.h"
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: HOST functions and variables
 *
 *******************************************************************************************************
 *******************************************************************************************************/

#ifndef KS_PSD_USE_APX
#define KS_PSD_USE_APX 0
#endif 

#include "sar_pm.h" /* must be before grad_rf_XXXX.h */
#include "grad_rf_empty.h" /* declaration of rfpulse[] here must be before PShost */

static char supfailfmt[] = "Support routine %s failed";
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;

#include <stdlib.h>
#include <sysDep.h>
#include <sysDepSupport.h>      /* FEC : fieldStrength dependency libraries */

/* unless 24-25x */
#include "psdopt.h"
#include "physics.h"
#include "psdIF.h"

MODEL_PARAMETERS_STRUCT model_parameters;
PURE_MIX_STRUCT pure_mix;
SCENIC_STRUCT scenic;

int anatomy_channel_compr_enable = PSD_OFF;
int anatomy_optimal_recon_enable = PSD_OFF;
int anatomy_self_uni_corr_enable = PSD_OFF;

int apps_channel_compr_enable = PSD_OFF;
int apps_self_uni_corr_enable = PSD_OFF;



#include <stdlib.h>

#include "epic_usercv.h"
#include "physics.h"
#include "psdIF.h"

/* for psddebugcode2 */
#define PSDDEBUG_SCAN 1
#define PSDDEBUG_IPG  2
#define PSDDEBUG_RTIA 4
#define PSDDEBUG_GSPEC 8

int Is3DGWAllowed(int maxSliceGap2ThickPercent)
{
    if ( ( (PSD_2D == exist(opimode)) || (PSD_CINE == exist(opimode)) ) && 
           ( (exist(opslspace) > (float)maxSliceGap2ThickPercent/100*exist(opslthick)+__FLT_EPSILON__) ||
             (0 == exist(opcoax)) || (exist(opnumgroups) > 1) ) )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

#include "rfsspsummary.h"

/* Structure definitions for prescan filters*/
FILTER_INFO echo1as_filt;
FILTER_INFO echo1mps1_filt;
FILTER_INFO echo1ftg_filt;
FILTER_INFO echo1xtg_filt;
FILTER_INFO echo1cfl;
FILTER_INFO echo1cfh;
FILTER_INFO echo1rcvn;
FILTER_INFO echo1rs_filt;
FILTER_INFO echo1dtg_filt;
FILTER_INFO echo1cal_filt;
FILTER_INFO echo1coil_filt;

/* defines for pimrsaps CVs from op_prescan.h */
#ifndef PSC_MAX_CONTROL_ARRAY
#define PSC_MAX_CONTROL_ARRAY 15
#endif

#define COILLOG_LOG_MAXSIZE 262144 /* quarter-Meg */

int* pimrs[PSC_MAX_CONTROL_ARRAY];

/* YMSmr09211 04/26/2006 YI */
SCAN_INFO rcvnscan_info[1];
SCAN_INFO cfh_info[MAX_PSC_VQUANT];
SCAN_INFO ps1scan_info[PRESCAN_ROT_MAX];
SCAN_INFO rsscan_info[RFSHIM_SLQ];
SCAN_INFO maptgscan_info[MAPTG_SLQ];


/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PShost                                *
 *                                                                   *
 * Write here the code unique to the Host PSD process.               *
 *********************************************************************/
#include <string.h>
#include "sar_limit_api.h"
#include "sar_pm.h" 

/*
 *  set_presscfh_mode
 *  
 *  Type: Private Function
 *  
 *  Description: Set the modes for presscfh
 * 			PRESSCFH_SLICE 1      
 * 			PRESSCFH_SLAB 2                                              
 * 			PRESSCFH_SHIMVOL 3
 * 			PRESSCFH_SHIMVOL_SLICE 4
 * 			PRESSCFH_NONE          5
 * 
 * */

STATUS
set_presscfh_mode (void)
{
    if(exist(oppscvquant) >= 1)
    {
        if (presscfh_override > 0) 
        {
            cvoverride(presscfh, presscfh_override, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else if (cfh_steam_flag == PSD_ON)
        {
            /* For STEAM CFH mode, force to use shim volume mode */
            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            switch(exist(opimode)) 
            {
                case PSD_2D:
                case PSD_CINE: 
                    if( (opplane == PSD_3PLANE) || ((exist(oprealtime) == PSD_ON)) || (exist(opcoax) == 0) )
                    {   /* For 3-Plane or Realtime or Radial mode use SHIMVOL Mode*/
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else if(exist(opassetcal) && existcv(opassetcal) 
                               && ( (1==exist(opasset)) || (exist(opasset) == ASSET_REG_CAL) ) && existcv(opasset)) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            }
                    else /* NON-RADIAL MODE */
                    {
                        int vidx;
                        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                        {
                            if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            } 
                            else 
                            {
                                cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                break;
                            }
                        }
                    }
                    break;
                case PSD_3D:
                case PSD_3DM:
                case PSD_ANGIO:
                    /* If Shim Volume is placed */
                    if( exist(opcoax) != 0 )      /* Non-Radial/Oblique MODE */
                    {
                        if( exist(opvquant) > 1 )     /* Multiple Slabs */
                        {
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                        else     /* Single Slab */
                        {
                            int vidx;
                            for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                            {
                                if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                                {
                                    cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                                } 
                                else 
                                {
                                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                    break;
                                }
                            }
                        }
                    }
                    else     /* Radial Case or Orthogonal Slabs */
                    {
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    break;
                default: 
                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
                    break;
            }
        } 
    }
    else
    {
        cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if(presscfh_debug) 
    {
        printf("\n The presscfh is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh);
        printf("\n The presscfh_ctrl is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE), \n",presscfh_ctrl);
        printf("\n The presscfh_override is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh_override);
        fflush(stdout);
    }
    return SUCCESS;
}

/*
 *  sr_derate
 *  
 *  Type: Private Function
 *  
 *  Description:
 *    update the ramp time for loggrad by *sr_derate_factor  
 *    @param[out] lgrad, logical gradient characteristics
 *    @param[in]  sc_derate_factor, SR derating factor ( >=1.0 ) 
 *
 */

STATUS
sr_derate (LOG_GRAD *lgrad, const float sr_derate_factor, const float amp_derate_factor)
{
    STATUS status = SUCCESS;

    if ((sr_derate_factor < 1.0) || (amp_derate_factor < 1.0))
    {
        status = FAILURE;
    }
    else
    {
        lgrad->xrt = (int)ceilf(lgrad->xrt*sr_derate_factor);
        lgrad->yrt = (int)ceilf(lgrad->yrt*sr_derate_factor);
        lgrad->zrt = (int)ceilf(lgrad->zrt*sr_derate_factor);
        lgrad->xft = (int)ceilf(lgrad->xft*sr_derate_factor);
        lgrad->yft = (int)ceilf(lgrad->yft*sr_derate_factor);
        lgrad->zft = (int)ceilf(lgrad->zft*sr_derate_factor);
        
        lgrad->tx_xyz = lgrad->tx_xyz/amp_derate_factor;
        lgrad->ty_xyz = lgrad->ty_xyz/amp_derate_factor;
        lgrad->tz_xyz = lgrad->tz_xyz/amp_derate_factor;
        lgrad->tx_xy = lgrad->tx_xy/amp_derate_factor;
        lgrad->tx_xz = lgrad->tx_xz/amp_derate_factor;
        lgrad->ty_xy = lgrad->ty_xy/amp_derate_factor;
        lgrad->ty_yz = lgrad->ty_yz/amp_derate_factor;
        lgrad->tz_xz = lgrad->tz_xz/amp_derate_factor;
        lgrad->tz_yz = lgrad->tz_yz/amp_derate_factor;
        lgrad->tx = lgrad->tx/amp_derate_factor;
        lgrad->ty = lgrad->ty/amp_derate_factor;
        lgrad->tz = lgrad->tz/amp_derate_factor;

        status = SUCCESS;
    }

    return status;
}

/*
 *  PS1cvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cvinit( void )
{
    INT index;

    /* initialize pulse widths */
    pw_rf1mps1  = _pw_rf1mps1.fixedflag ?  ((void)(rfpulse[RF1_APS1_SLOT].nom_pw), pw_rf1mps1) : rfpulse[RF1_APS1_SLOT].nom_pw;
    pw_rf2mps1  = _pw_rf2mps1.fixedflag ?  ((void)(rfpulse[RF2_APS1_SLOT].nom_pw), pw_rf2mps1) : rfpulse[RF2_APS1_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(0), res_rf1mps1) : 0;
    res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(0), res_rf2mps1) : 0;

    /* initialize amplitudes */
    a_rf1mps1  = _a_rf1mps1.fixedflag ?  ((void)(0.5), a_rf1mps1) : 0.5;
    a_rf2mps1  = _a_rf2mps1.fixedflag ?  ((void)(1.0), a_rf2mps1) : 1.0;

    /* initialize flip angles */
    flip_rf1mps1  = _flip_rf1mps1.fixedflag ?  ((void)(90), flip_rf1mps1) : 90;
    flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(180), flip_rf2mps1) : 180;

    /* initialize sinc cycles */
    cyc_rf1mps1  = _cyc_rf1mps1.fixedflag ?  ((void)(1), cyc_rf1mps1) : 1;
    cyc_rf2mps1  = _cyc_rf2mps1.fixedflag ?  ((void)(1), cyc_rf2mps1) : 1;

    /* initialize gscale values */
    gscale_rf1mps1  = _gscale_rf1mps1.fixedflag ?  ((void)(0.90909), gscale_rf1mps1) : 0.90909;
    gscale_rf2mps1  = _gscale_rf2mps1.fixedflag ?  ((void)(0.4545), gscale_rf2mps1) : 0.4545;

    /* begin aps1_mod changes (GE) */
    if ( ( getAps1Mod() > 0 || ((B0_15000 == cffield) && isLowSarEnabled()) ) && (PSD_OFF == local_tg) )
    {
        for( index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = 0.0;
        }

        if (1==getAps1ModPlane()) /* Axial, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (2==getAps1ModPlane()) /* Sagittal, read=z */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (3==getAps1ModPlane()) /* Coronal, read=z */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (4==getAps1ModPlane()) /* Axial, read=y */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (5==getAps1ModPlane()) /* Sagittal, read=y */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[7] = 1.0;
        }
        if (6==getAps1ModPlane()) /* Coronal, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[7] = 1.0;
        }
    }
    else if((oppscvquant > 0) && (PSD_ON == local_tg))
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = psc_info[0].oppscrot[index]; /* use shim vol rot for local tg */ 
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }
    /* end aps1_mod changes (GE) */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&ps1loggrd, &phygrd, ps1scan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp0_ps1_newgeo=ps1_newgeo,&_temp0_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PS1cvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&ps1loggrd, PSsr_derate_factor, PSamp_derate_factor);

    return SUCCESS;
}

/*
 *  CFLcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcvinit( void )
{
    /* initialize pulse widths */
    pw_rf1cfl  = _pw_rf1cfl.fixedflag ?  ((void)(rfpulse[RF1_CFL_SLOT].nom_pw), pw_rf1cfl) : rfpulse[RF1_CFL_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1cfl  = _res_rf1cfl.fixedflag ?   ((void)(0), res_rf1cfl) : 0;

    /* initialize amplitudes */
    a_rf1cfl  = _a_rf1cfl.fixedflag ?  ((void)(0.5), a_rf1cfl) : 0.5;

    /* initialize flip angles */
    flip_rf1cfl  = _flip_rf1cfl.fixedflag ?  ((void)(90), flip_rf1cfl) : 90;

    /* initialize sinc cycles */
    cyc_rf1cfl  = _cyc_rf1cfl.fixedflag ?  ((void)(2), cyc_rf1cfl) : 2; /* MRIhc54366: increased from 1 */

    /* initialize gscale values */
    gscale_rf1cfl  = _gscale_rf1cfl.fixedflag ?  ((void)(0.90909), gscale_rf1cfl) : 0.90909;

    return SUCCESS;
}


/*
 *  RCVNcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcvinit( void )
{
    if (CFG_VAL_RECEIVER_RRF == cfreceivertype)
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(1024), rcvn_xres) : 1024;
    }
    else
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(4096), rcvn_xres) : 4096;
    }


    return SUCCESS;
}


/*
 *  CFHcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcvinit( void )
{
    /* initialize pulse widths */
    pw_rf0cfh  = _pw_rf0cfh.fixedflag ?  ((void)(rfpulse[RF0_CFH_SLOT].nom_pw), pw_rf0cfh) : rfpulse[RF0_CFH_SLOT].nom_pw;
    pw_rf1cfh  = _pw_rf1cfh.fixedflag ?  ((void)(rfpulse[RF1_CFH_SLOT].nom_pw), pw_rf1cfh) : rfpulse[RF1_CFH_SLOT].nom_pw;
    pw_rf2cfh  = _pw_rf2cfh.fixedflag ?  ((void)(rfpulse[RF2_CFH_SLOT].nom_pw), pw_rf2cfh) : rfpulse[RF2_CFH_SLOT].nom_pw;
    pw_rf3cfh  = _pw_rf3cfh.fixedflag ?  ((void)(rfpulse[RF3_CFH_SLOT].nom_pw), pw_rf3cfh) : rfpulse[RF3_CFH_SLOT].nom_pw; /* For presscfh MRIhc08321 */
    pw_rf4cfh  = _pw_rf4cfh.fixedflag ?  ((void)(rfpulse[RF4_CFH_SLOT].nom_pw), pw_rf4cfh) : rfpulse[RF4_CFH_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf0cfh  = _res_rf0cfh.fixedflag ?   ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC; /* Adiabatic pulse */
    res_rf1cfh  = _res_rf1cfh.fixedflag ?   ((void)(0), res_rf1cfh) : 0;
    res_rf2cfh  = _res_rf2cfh.fixedflag ?   ((void)(0), res_rf2cfh) : 0;
    res_rf3cfh  = _res_rf3cfh.fixedflag ?   ((void)(0), res_rf3cfh) : 0; /* For presscfh MRIhc08321 */
    res_rf4cfh  = _res_rf4cfh.fixedflag ?   ((void)(0), res_rf4cfh) : 0;

    /* initialize amplitudes */
    a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
    a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
    a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
    a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; /* For presscfh MRIhc08321 */
    a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0;

    /* initialize flip angles */
    flip_rf0cfh  = _flip_rf0cfh.fixedflag ?  ((void)(180), flip_rf0cfh) : 180;
    flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
    flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
    flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; /* For presscfh MRIhc08321 */
    flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180;

    /* initialize sinc cycles */
    cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(2), cyc_rf0cfh) : 2; /* Adiabatic pulse */
    cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
    cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
    cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; /* For presscfh MRIhc08321 */
    cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1;
    a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(0.0), a_gzrf4cfh) : 0.0;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(0.0), a_gxrf2cfh) : 0.0;/*For  presscfh MRIhc11621 */
    a_gzrf1cfh  = _a_gzrf1cfh.fixedflag ?  ((void)(0.0), a_gzrf1cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0.0), a_gzrf0cfh) : 0.0;/*For presscfh MRIhc11621 */


    /* initialize gscale values */
    gscale_rf1cfh  = _gscale_rf1cfh.fixedflag ?  ((void)(0.90909), gscale_rf1cfh) : 0.90909;

#ifdef PSD_CFH_CHEMSAT
    rfpulse[RFCSSAT_CFH_SLOT].pw = &pw_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].amp = &a_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].act_fa = &flip_rfcssatcfh;
#endif

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp1_pw_rf1cfh=pw_rf1cfh,&_temp1_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp2_a_rf1cfh=a_rf1cfh,&_temp2_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp3_flip_rf1cfh=flip_rf1cfh,&_temp3_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp4_res_rf1cfh=res_rf1cfh,&_temp4_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp5_wg_rf1cfh=wg_rf1cfh,&_temp5_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp6_pw_rf2cfh=pw_rf2cfh,&_temp6_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp7_a_rf2cfh=a_rf2cfh,&_temp7_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp8_flip_rf2cfh=flip_rf2cfh,&_temp8_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp9_res_rf2cfh=res_rf2cfh,&_temp9_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp10_wg_rf2cfh=wg_rf2cfh,&_temp10_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp11_pw_rf3cfh=pw_rf3cfh,&_temp11_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp12_a_rf3cfh=a_rf3cfh,&_temp12_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp13_flip_rf3cfh=flip_rf3cfh,&_temp13_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp14_res_rf3cfh=res_rf3cfh,&_temp14_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp15_wg_rf3cfh=wg_rf3cfh,&_temp15_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp16_pw_rf4cfh=pw_rf4cfh,&_temp16_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp17_a_rf4cfh=a_rf4cfh,&_temp17_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp18_flip_rf4cfh=flip_rf4cfh,&_temp18_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp19_res_rf4cfh=res_rf4cfh,&_temp19_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp20_wg_rf4cfh=wg_rf4cfh,&_temp20_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464; /* 0.5/0.61*(60/90) */
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp21_pw_rf1cfh=pw_rf1cfh,&_temp21_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp22_a_rf1cfh=a_rf1cfh,&_temp22_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp23_flip_rf1cfh=flip_rf1cfh,&_temp23_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp24_res_rf1cfh=res_rf1cfh,&_temp24_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp25_wg_rf1cfh=wg_rf1cfh,&_temp25_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp26_pw_rf2cfh=pw_rf2cfh,&_temp26_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp27_a_rf2cfh=a_rf2cfh,&_temp27_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp28_flip_rf2cfh=flip_rf2cfh,&_temp28_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp29_res_rf2cfh=res_rf2cfh,&_temp29_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp30_wg_rf2cfh=wg_rf2cfh,&_temp30_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp31_pw_rf3cfh=pw_rf3cfh,&_temp31_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp32_a_rf3cfh=a_rf3cfh,&_temp32_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp33_flip_rf3cfh=flip_rf3cfh,&_temp33_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp34_res_rf3cfh=res_rf3cfh,&_temp34_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp35_wg_rf3cfh=wg_rf3cfh,&_temp35_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp36_pw_rf4cfh=pw_rf4cfh,&_temp36_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp37_a_rf4cfh=a_rf4cfh,&_temp37_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp38_flip_rf4cfh=flip_rf4cfh,&_temp38_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp39_res_rf4cfh=res_rf4cfh,&_temp39_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp40_wg_rf4cfh=wg_rf4cfh,&_temp40_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 
    }
    return SUCCESS;
}



/*
 *  PScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScvinit( void )
{
    if( (exist(opimode) == PSD_SPECTRO) || (PSD_ON == pimrsapsflg) )
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(0), fastprescan) : 0;
    }
    else
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(cffastprescan), fastprescan) : cffastprescan;
    }

    /* Set the modes for presscfh */
    set_presscfh_mode();
    
    /* Fix to set CFH,CFL,APS1, FTG slice location to be axial mid slice to ensure
       the presence of signal when sample position is off iso center such as wrist scout scans */
    if (opplane == PSD_3PLANE)
    {
        PSslice_num  = _PSslice_num.fixedflag ?  ((void)((int)(opaxial_slice/2)), PSslice_num) : (int)(opaxial_slice/2);
    }
    else
    {  /* Start of code moved up from PSpredownload section below by SL */
        FLOAT minloc;
        FLOAT maxloc;         /* For MRIge45995 */
        FLOAT midloc;         /* For MRIge45995 */
        FLOAT minimum;        /* For MRIge45995 */
        FLOAT loc;
        INT index;

        /* search through the scan table to find the location nearest
           isocenter. Save the location information for prescan since
           graphic sat and different imaging techniques can alter the
           content and format of the rspinfo structure
        */

        minloc = MAXFLOAT;  /* For MRIge45995 */
        maxloc = -MAXFLOAT; /* For MRIge45995 */

        /* First to find the center of the prescribed region, MRIge45995 */
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (loc < minloc)
            {
                minloc = loc;
            }
            if (loc > maxloc)
            {
                maxloc = loc;
            }
        }
        midloc = 0.5*(minloc + maxloc);

        /* Find the slice most close to the center of the prescribed region, MRIge45995 */
        minimum = MAXFLOAT;
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (fabs(loc-midloc) < minimum)
            {
                minimum = fabs(loc-midloc);
                PSslice_num  = _PSslice_num.fixedflag ?  ((void)(index), PSslice_num) : index;
            }
        }
    } /* End of code moved up from PSpredownload section below */

    /* Comment from /vobs/scan/MrScan/SrxControl/SrxGeos.m on setting opcoax */
    /* slightly modified */

    /* This next section determines the value of the opcoax CV  */
    /* The rules are as follows:  */
    /*   */
    /* coaxial      N   Y   Y  */
    /* offcenter    -   N   Y  */
    /* ======================  */
    /* opcoax       0   1   2  */
    /*  */
    /* The decision of NOT coaxial is determined by the following three  */
    /* conditions: (graphic rx imaging option selected) AND (oblique   */
    /* prescription) AND ( (more than one group has been prescribed) OR (Number
     * of radial slices > 1 ) ).  */
    /*  */
    /* The decision of offcenter is made based on whether or not   */
    /* all of the slices have 0 offset in their phase and frequency  */
    /* directions.  If even one is not 0, then the prescription is  */
    /* said to be offcenter.  */

    /* Use the below in the PSD Code if the HDMR2 changes for MRIhc08321
     * need to be overridden. RBA for MRIhc08321.
     */
    
    
    PS1cvinit();
    CFLcvinit();
    CFHcvinit();
    RCVNcvinit();

    /* initialize field strength and PS variables */ /* vmx 05/02/95 YO */
    PSfield_strength  = _PSfield_strength.fixedflag ?   ((void)((int)cffield), PSfield_strength) : (int)cffield;
    if(PSfield_strength <= B0_5000)
    {
        PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        PSmt  = _PSmt.fixedflag ?  ((void)(0), PSmt) : 0;
    }
    else
    {
        if (aspir_flag || (PSD_ON == exist(opspecir)))
        {   /* turn OFF ASPIR/SPECIAL during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } else {
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        }

        PSmt  = _PSmt.fixedflag ?  ((void)(1), PSmt) : 1;
    }

    pimrs[0] = _pimrsaps1.fixedflag ? (_temp41_pimrsaps1=pimrsaps1,&_temp41_pimrsaps1) : &pimrsaps1;
    pimrs[1] = _pimrsaps2.fixedflag ? (_temp42_pimrsaps2=pimrsaps2,&_temp42_pimrsaps2) : &pimrsaps2;
    pimrs[2] = _pimrsaps3.fixedflag ? (_temp43_pimrsaps3=pimrsaps3,&_temp43_pimrsaps3) : &pimrsaps3;
    pimrs[3] = _pimrsaps4.fixedflag ? (_temp44_pimrsaps4=pimrsaps4,&_temp44_pimrsaps4) : &pimrsaps4;
    pimrs[4] = _pimrsaps5.fixedflag ? (_temp45_pimrsaps5=pimrsaps5,&_temp45_pimrsaps5) : &pimrsaps5;
    pimrs[5] = _pimrsaps6.fixedflag ? (_temp46_pimrsaps6=pimrsaps6,&_temp46_pimrsaps6) : &pimrsaps6;
    pimrs[6] = _pimrsaps7.fixedflag ? (_temp47_pimrsaps7=pimrsaps7,&_temp47_pimrsaps7) : &pimrsaps7;
    pimrs[7] = _pimrsaps8.fixedflag ? (_temp48_pimrsaps8=pimrsaps8,&_temp48_pimrsaps8) : &pimrsaps8;
    pimrs[8] = _pimrsaps9.fixedflag ? (_temp49_pimrsaps9=pimrsaps9,&_temp49_pimrsaps9) : &pimrsaps9;
    pimrs[9] = _pimrsaps10.fixedflag ? (_temp50_pimrsaps10=pimrsaps10,&_temp50_pimrsaps10) : &pimrsaps10;
    pimrs[10] = _pimrsaps11.fixedflag ? (_temp51_pimrsaps11=pimrsaps11,&_temp51_pimrsaps11) : &pimrsaps11;
    pimrs[11] = _pimrsaps12.fixedflag ? (_temp52_pimrsaps12=pimrsaps12,&_temp52_pimrsaps12) : &pimrsaps12;
    pimrs[12] = _pimrsaps13.fixedflag ? (_temp53_pimrsaps13=pimrsaps13,&_temp53_pimrsaps13) : &pimrsaps13;
    pimrs[13] = _pimrsaps14.fixedflag ? (_temp54_pimrsaps14=pimrsaps14,&_temp54_pimrsaps14) : &pimrsaps14;
    pimrs[14] = _pimrsaps15.fixedflag ? (_temp55_pimrsaps15=pimrsaps15,&_temp55_pimrsaps15) : &pimrsaps15;

    
    /* MRIhc15304: we will keep asfov as cv and fill it with the value
     * from coil. Some application (Spectro related) need to decide the
     * asfov based on the application (overriding the value decided by
     * coil). */ 
    asfov  = _asfov.fixedflag ?  ((void)(coilInfo[0].autoshimFov), asfov) : coilInfo[0].autoshimFov;

    /* 
     * Set the wait time for sethubindeximm.  A 100 ms delay is
     * sufficent to apply the settings on the driver module.  On systems
     * with an RRF receiver, a longer delay (250 ms) is needed for the
     * new receiver channel map to be loaded into the DRF. 
     */
    if( cfcoilswitchmethod & COIL_SWITCH_RSP_SETHUBINDEXIMM )
    {
        if( CFG_VAL_RECEIVER_RRF == cfreceivertype )
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(250000), csw_wait_sethubindeximm) : 250000;
        }
        else
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(100000), csw_wait_sethubindeximm) : 100000;
        }
    }

    return SUCCESS;
}   /* end PScvinit() */


/*
 *  FTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcvinit( void )
{
    a_rf1ftg     = _a_rf1ftg.fixedflag ?  ((void)(0.5), a_rf1ftg) : 0.5;
    a_rf2ftg     = _a_rf2ftg.fixedflag ?  ((void)(1.0), a_rf2ftg) : 1.0;
    a_rf3ftg     = _a_rf3ftg.fixedflag ?  ((void)(1.0), a_rf3ftg) : 1.0;
    pw_rf1ftg    = _pw_rf1ftg.fixedflag ?  ((void)((int)rfpulse[RF1_FTG_SLOT].nom_pw), pw_rf1ftg) : (int)rfpulse[RF1_FTG_SLOT].nom_pw;
    pw_rf2ftg    = _pw_rf2ftg.fixedflag ?  ((void)((int)rfpulse[RF2_FTG_SLOT].nom_pw), pw_rf2ftg) : (int)rfpulse[RF2_FTG_SLOT].nom_pw;
    pw_rf3ftg    = _pw_rf3ftg.fixedflag ?  ((void)((int)rfpulse[RF3_FTG_SLOT].nom_pw), pw_rf3ftg) : (int)rfpulse[RF3_FTG_SLOT].nom_pw;
    cyc_rf1ftg   = _cyc_rf1ftg.fixedflag ?  ((void)(1), cyc_rf1ftg) : 1;
    res_rf1ftg   = _res_rf1ftg.fixedflag ?  ((void)(800), res_rf1ftg) : 800;
    cyc_rf2ftg   = _cyc_rf2ftg.fixedflag ?  ((void)(1), cyc_rf2ftg) : 1;
    res_rf2ftg   = _res_rf2ftg.fixedflag ?  ((void)(800), res_rf2ftg) : 800;
    cyc_rf3ftg   = _cyc_rf3ftg.fixedflag ?  ((void)(1), cyc_rf3ftg) : 1;
    res_rf3ftg   = _res_rf3ftg.fixedflag ?  ((void)(800), res_rf3ftg) : 800;
    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;

    return SUCCESS;
} /* end FTGcvinit() */


/*
 *  XTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcvinit( void )
{   
    double coil_maxb1, coil_maxb1_gauss, fermi_b1; /* HCSDM00157626 */
    a_rf1xtg     = _a_rf1xtg.fixedflag ?  ((void)(0.5), a_rf1xtg) : 0.5;
    a_rf2xtg     = _a_rf2xtg.fixedflag ?  ((void)(1.0), a_rf2xtg) : 1.0;
    pw_rf1xtg    = _pw_rf1xtg.fixedflag ?  ((void)((int)rfpulse[RF1_XTG_SLOT].nom_pw), pw_rf1xtg) : (int)rfpulse[RF1_XTG_SLOT].nom_pw;
    pw_rf2xtg    = _pw_rf2xtg.fixedflag ?  ((void)((int)rfpulse[RF2_XTG_SLOT].nom_pw), pw_rf2xtg) : (int)rfpulse[RF2_XTG_SLOT].nom_pw;
    cyc_rf1xtg   = _cyc_rf1xtg.fixedflag ?  ((void)(1), cyc_rf1xtg) : 1;
    res_rf1xtg   = _res_rf1xtg.fixedflag ?  ((void)(0), res_rf1xtg) : 0;
    cyc_rf2xtg   = _cyc_rf2xtg.fixedflag ?  ((void)(1), cyc_rf2xtg) : 1;
    res_rf2xtg   = _res_rf2xtg.fixedflag ?  ((void)(800), res_rf2xtg) : 800;
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;

    a_rf3xtg  = _a_rf3xtg.fixedflag ?  ((void)(-1.0), a_rf3xtg) : -1.0; 
    a_rf4xtg  = _a_rf4xtg.fixedflag ?  ((void)(1.0), a_rf4xtg) : 1.0;
    res_rf3xtg  = _res_rf3xtg.fixedflag ?  ((void)(RES_FERMI_BLS), res_rf3xtg) : RES_FERMI_BLS;
    res_rf4xtg  = _res_rf4xtg.fixedflag ?  ((void)(res_rf3xtg), res_rf4xtg) : res_rf3xtg;
    pw_rf3xtg    = _pw_rf3xtg.fixedflag ?  ((void)(pw_bsrf), pw_rf3xtg) : pw_bsrf;
    pw_rf4xtg    = _pw_rf4xtg.fixedflag ?  ((void)(pw_rf3xtg), pw_rf4xtg) : pw_rf3xtg;
    
    flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW), flip_rf3xtg) : (FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW;  /* scale flip to keep its maxB1 constant */
    /* 630 degree flip, 4ms pw: max B1 = 0.071 */
    flip_rf4xtg  = _flip_rf4xtg.fixedflag ?  ((void)(flip_rf3xtg), flip_rf4xtg) : flip_rf3xtg;       

    fermi_b1 = 100*FA_FERMI_BLS/NOM_FA_RFMT*SAR_MAXB1_FERMI_BLS;

    /* Find the maximum predicted B1 for the current weight and coil */
    /* HCSDM00384210 */

    if( SDL_RFDerating_entry( &coil_maxb1_gauss, cffield, opweight, txCoilInfo[getTxIndex(coilInfo[0])], (GRADIENT_COIL_E) cfgcoiltype, L_SCAN ) != SUCCESS)
    {
        epic_error(0, "Support routine %s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "SDL_RFDerating");
        return FAILURE;
    }

    coil_maxb1 = coil_maxb1_gauss/UTESLA2GAUSS;
        
    if(fermi_b1 > coil_maxb1)  /* disable XTG */ 
    {
        xtg_disabled = PSD_ON;
        rfpulse[RF1_XTG_SLOT].num = 0;  
        rfpulse[RF1_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF2_XTG_SLOT].num = 0; 
        rfpulse[RF2_XTG_SLOT].activity = PSD_OFF;    
        rfpulse[RF3_XTG_SLOT].num = 0;  
        rfpulse[RF3_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF4_XTG_SLOT].num = 0; 
        rfpulse[RF4_XTG_SLOT].activity = PSD_OFF;    
    }
    else
    {
        xtg_disabled = PSD_OFF;
        rfpulse[RF1_XTG_SLOT].num = 1;
        rfpulse[RF1_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF2_XTG_SLOT].num = 1;
        rfpulse[RF2_XTG_SLOT].activity = PSD_XTG_ON;    
        rfpulse[RF3_XTG_SLOT].num = 1;
        rfpulse[RF3_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF4_XTG_SLOT].num = 1;
        rfpulse[RF4_XTG_SLOT].activity = PSD_XTG_ON;    
    }
    
    xtgtr  = _xtgtr.fixedflag ?  ((void)(200000), xtgtr) : 200000;
    
    xtg_dda  = _xtg_dda.fixedflag ?  ((void)(2), xtg_dda) : 2;
    XTGacq1  = _XTGacq1.fixedflag ?  ((void)(PSD_ON), XTGacq1) : PSD_ON;
    
    return SUCCESS;
} /* end XTGcvinit() */

/*
 *  AScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScvinit( void )
{
    INT asplane;
    INT ascell;
    SCAN_INFO total_asscan_info[6];
    INT total_asplane = 3;

    td0as  = _td0as.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0as) : GRAD_UPDATE_TIME;

    /* Create a pseudo scan_info table for obloptimize to work with.
       The rotation matrices for the planes are what is important. */
    if(oppscvquant == 2)
    {
        total_asplane = oppscvquant * 3;
    }
    for( asplane = 0; asplane < total_asplane; asplane++ )
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[asplane].oprot[ascell] = 0.0;
        }
    }

    /* Axial */
    total_asscan_info[0].oprot[0] = total_asscan_info[0].oprot[4] = total_asscan_info[0].oprot[8]
        = 1.0;
    /* Sagittal */
    total_asscan_info[1].oprot[2] = total_asscan_info[1].oprot[4] = total_asscan_info[1].oprot[6]
        = 1.0;
    /* Coronal */
    total_asscan_info[2].oprot[1] = total_asscan_info[2].oprot[5] = total_asscan_info[2].oprot[6]
        = 1.0;

    if (oppscvquant > 0)
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[0].oprot[ascell] = psc_info[0].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            if (oppscvquant == 2)
            {
                total_asscan_info[3].oprot[ascell] = psc_info[1].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            }
        }

        /* Create 2nd orthogonal plane from first shim vol matrix */
        total_asscan_info[1].oprot[0] = -total_asscan_info[0].oprot[2];
        total_asscan_info[1].oprot[1] = total_asscan_info[0].oprot[1];
        total_asscan_info[1].oprot[2] = total_asscan_info[0].oprot[0];
        total_asscan_info[1].oprot[3] = -total_asscan_info[0].oprot[5];
        total_asscan_info[1].oprot[4] = total_asscan_info[0].oprot[4];
        total_asscan_info[1].oprot[5] = total_asscan_info[0].oprot[3];
        total_asscan_info[1].oprot[6] = -total_asscan_info[0].oprot[8];
        total_asscan_info[1].oprot[7] = total_asscan_info[0].oprot[7];
        total_asscan_info[1].oprot[8] = total_asscan_info[0].oprot[6];
        /* Create 3rd orthogonal plane */
        total_asscan_info[2].oprot[0] = total_asscan_info[0].oprot[0];
        total_asscan_info[2].oprot[1] = total_asscan_info[0].oprot[2];
        total_asscan_info[2].oprot[2] = -total_asscan_info[0].oprot[1];
        total_asscan_info[2].oprot[3] = total_asscan_info[0].oprot[3];
        total_asscan_info[2].oprot[4] = total_asscan_info[0].oprot[5];
        total_asscan_info[2].oprot[5] = -total_asscan_info[0].oprot[4];
        total_asscan_info[2].oprot[6] = total_asscan_info[0].oprot[6];
        total_asscan_info[2].oprot[7] = total_asscan_info[0].oprot[8];
        total_asscan_info[2].oprot[8] = -total_asscan_info[0].oprot[7];

        if (oppscvquant == 2)
        {
            /* Create 2nd orthogonal plane for 2nd shim vol */
            total_asscan_info[4].oprot[0] = -total_asscan_info[3].oprot[2];
            total_asscan_info[4].oprot[1] = total_asscan_info[3].oprot[1];
            total_asscan_info[4].oprot[2] = total_asscan_info[3].oprot[0];
            total_asscan_info[4].oprot[3] = -total_asscan_info[3].oprot[5];
            total_asscan_info[4].oprot[4] = total_asscan_info[3].oprot[4];
            total_asscan_info[4].oprot[5] = total_asscan_info[3].oprot[3];
            total_asscan_info[4].oprot[6] = -total_asscan_info[3].oprot[8];
            total_asscan_info[4].oprot[7] = total_asscan_info[3].oprot[7];
            total_asscan_info[4].oprot[8] = total_asscan_info[3].oprot[6];
            /* Create 3rd orthogonal plane */
            total_asscan_info[5].oprot[0] = total_asscan_info[3].oprot[0];
            total_asscan_info[5].oprot[1] = total_asscan_info[3].oprot[2];
            total_asscan_info[5].oprot[2] = -total_asscan_info[3].oprot[1];
            total_asscan_info[5].oprot[3] = total_asscan_info[3].oprot[3];
            total_asscan_info[5].oprot[4] = total_asscan_info[3].oprot[5];
            total_asscan_info[5].oprot[5] = -total_asscan_info[3].oprot[4];
            total_asscan_info[5].oprot[6] = total_asscan_info[3].oprot[6];
            total_asscan_info[5].oprot[7] = total_asscan_info[3].oprot[8];
            total_asscan_info[5].oprot[8] = -total_asscan_info[3].oprot[7];
        }
    }
  
    as_newgeo  = _as_newgeo.fixedflag ?  ((void)(1), as_newgeo) : 1;
    if (FAILURE==obloptimize(&asloggrd, &phygrd, total_asscan_info, total_asplane, PSD_OBL,
                             0, PSD_OBL_RESTRICT, asobl_debug, _as_newgeo.fixedflag ? (_temp56_as_newgeo=as_newgeo,&_temp56_as_newgeo) : &as_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in AScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&asloggrd, PSassr_derate_factor, PSasamp_derate_factor);

    /* X Killer CVs */
    if (FAILURE==amppwgrad(asx_killer_area, asloggrd.tx_xz, 0.0, 0.0, asloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkas.fixedflag ? (_temp57_a_gxkas=a_gxkas,&_temp57_a_gxkas) : &a_gxkas, _pw_gxkasa.fixedflag ? (_temp58_pw_gxkasa=pw_gxkasa,&_temp58_pw_gxkasa) : &pw_gxkasa,
                           _pw_gxkas.fixedflag ? (_temp59_pw_gxkas=pw_gxkas,&_temp59_pw_gxkas) : &pw_gxkas, _pw_gxkasd.fixedflag ? (_temp60_pw_gxkasd=pw_gxkasd,&_temp60_pw_gxkasd) : &pw_gxkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkas"); 
        return FAILURE;
    }

    /* Z Killer CVs */
    if (FAILURE==amppwgrad(asz_killer_area, asloggrd.tz_xz, 0.0, 0.0, asloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkas.fixedflag ? (_temp61_a_gzkas=a_gzkas,&_temp61_a_gzkas) : &a_gzkas, _pw_gzkasa.fixedflag ? (_temp62_pw_gzkasa=pw_gzkasa,&_temp62_pw_gzkasa) : &pw_gzkasa,
                           _pw_gzkas.fixedflag ? (_temp63_pw_gzkas=pw_gzkas,&_temp63_pw_gzkas) : &pw_gzkas, _pw_gzkasd.fixedflag ? (_temp64_pw_gzkasd=pw_gzkasd,&_temp64_pw_gzkasd) : &pw_gzkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkas"); 
        return FAILURE;
    }

    /* rf1 cvs  */
    a_rf1as  = _a_rf1as.fixedflag ?  ((void)(1.0), a_rf1as) : 1.0;
    pw_rf1as  = _pw_rf1as.fixedflag ?  ((void)(rfpulse[RF1_AUTOSHIM].nom_pw), pw_rf1as) : rfpulse[RF1_AUTOSHIM].nom_pw;
    gscale_rf1as  = _gscale_rf1as.fixedflag ?  ((void)(.90909), gscale_rf1as) : .90909;
    cyc_rf1as  = _cyc_rf1as.fixedflag ?  ((void)(1), cyc_rf1as) : 1;
    res_rf1as  = _res_rf1as.fixedflag ?  ((void)(0), res_rf1as) : 0; /* initialized to zero for system safety check in cveval */

    /* gzrf1 cvs */
    pw_gzrf1as  = _pw_gzrf1as.fixedflag ?  ((void)(pw_rf1as), pw_gzrf1as) : pw_rf1as;
    flip_rf1as  = _flip_rf1as.fixedflag ?  ((void)(asflip), flip_rf1as) : asflip;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadas   = _tleadas.fixedflag ?    ((void)(RUP_GRD(24)), tleadas) : RUP_GRD(24);
    bw_rf1as  = _bw_rf1as.fixedflag ?      ((void)((int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000))), bw_rf1as) : (int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000));
    t_exaas   = _t_exaas.fixedflag ?     ((void)(pw_gzrf1asa+pw_rf1as/2), t_exaas) : pw_gzrf1asa+pw_rf1as/2;

    return SUCCESS;
} /* end AScvinit() */


/*
 *  RScvinit
 *  Description:
 *  CV init for RFShim 
 *  
 *  Type: Public Function
 *  
 */
STATUS
RScvinit( void )
{
    INT index;

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* BLS RF pulse */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10.0), flip_rf1rs) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_RFSHIM_SLOT].abswidth = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].effwidth = 0.6755;
    rfpulse[RFB_RFSHIM_SLOT].area = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].dtycyc = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].maxpw = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_RFSHIM_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_RFSHIM_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_RFSHIM_SLOT].nom_fa = 90.0;
    rfpulse[RFB_RFSHIM_SLOT].act_fa = _flip_rfbrs.fixedflag ? (_temp65_flip_rfbrs=flip_rfbrs,&_temp65_flip_rfbrs) : &flip_rfbrs;
    rfpulse[RFB_RFSHIM_SLOT].nom_pw = 2000;
    rfpulse[RFB_RFSHIM_SLOT].num = 1;

    pw_rfbrs  = _pw_rfbrs.fixedflag ?  ((void)(2000), pw_rfbrs) : 2000;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(1000), res_rfbrs) : 1000;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    /* B1 Map rf1 */
    gscale_rf1rs  = _gscale_rf1rs.fixedflag ?  ((void)(1.0), gscale_rf1rs) : 1.0;
    a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(3200), pw_rf1rs) : 3200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(pw_rf1rs/RF_UPDATE_TIME), res_rf1rs) : pw_rf1rs/RF_UPDATE_TIME;
            cyc_rf1rs  = _cyc_rf1rs.fixedflag ?  ((void)(1), cyc_rf1rs) : 1;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rs_off90  = _rs_off90.fixedflag ?  ((void)(PSoff90), rs_off90) : PSoff90;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_RFSHIM_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = 3200;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = 90;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(1200), pw_rf1rs) : 1200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(RES_TBW6), res_rf1rs) : RES_TBW6;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;
    }

    /* Only support single slice RF Shim now */
    if ( PSD_ON == rsaxial_flag )
    {
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        for( index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = 0.0;
        }

        if ( (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast"))
             || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD) ) 
        {
            /* Axial plane, Freq A/P for breast or Head Anatomy */
            rsscan_info[0].oprot[1] = rsscan_info[0].oprot[3] = rsscan_info[0].oprot[8] = 1.0;
        }
        else   /* Freq R/L */
        {
            rsscan_info[0].oprot[0] = rsscan_info[0].oprot[4] = rsscan_info[0].oprot[8] = 1.0;
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&rsloggrd, &phygrd, rsscan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp66_ps1_newgeo=ps1_newgeo,&_temp66_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for silent PSC */ 
    sr_derate(&rsloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* gzrf1 cvs */
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadrs   = _tleadrs.fixedflag ?    ((void)(RUP_GRD(24)), tleadrs) : RUP_GRD(24);

    return SUCCESS;
}  /* end RScvinit */

/* 
 *  DTGcvinit
 *  Description:
 *  CV init for Dynamic TG 
 *  
 *  Type: Public Function
 *  
 */
STATUS
DTGcvinit( void )
{

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180.0), flip_rfbdtg) : 180.0;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10.0), flip_rf1dtg) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_DYNTG_SLOT].abswidth = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].effwidth = 0.6755;
    rfpulse[RFB_DYNTG_SLOT].area = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].dtycyc = 1.0;
    rfpulse[RFB_DYNTG_SLOT].maxpw = 1.0;
    rfpulse[RFB_DYNTG_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_DYNTG_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_DYNTG_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_DYNTG_SLOT].nom_fa = 90.0;
    rfpulse[RFB_DYNTG_SLOT].act_fa = _flip_rfbdtg.fixedflag ? (_temp67_flip_rfbdtg=flip_rfbdtg,&_temp67_flip_rfbdtg) : &flip_rfbdtg;
    rfpulse[RFB_DYNTG_SLOT].nom_pw = 2000;
    rfpulse[RFB_DYNTG_SLOT].num = 1;


    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(1000), res_rfbdtg) : 1000;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;
    pw_rfbdtg  = _pw_rfbdtg.fixedflag ?  ((void)(2000), pw_rfbdtg) : 2000;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;

    /* B1 Map rf1 */
    a_rf1dtg  = _a_rf1dtg.fixedflag ?  ((void)(1.0), a_rf1dtg) : 1.0;
    gscale_rf1dtg  = _gscale_rf1dtg.fixedflag ?  ((void)(1.0), gscale_rf1dtg) : 1.0;
    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(3200), pw_rf1dtg) : 3200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(pw_rf1dtg/RF_UPDATE_TIME), res_rf1dtg) : pw_rf1dtg/RF_UPDATE_TIME;
            cyc_rf1dtg  = _cyc_rf1dtg.fixedflag ?  ((void)(1), cyc_rf1dtg) : 1;
            dtg_off90  = _dtg_off90.fixedflag ?  ((void)(PSoff90), dtg_off90) : PSoff90;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_DYNTG_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_DYNTG_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_DYNTG_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_DYNTG_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = 3200;
            rfpulse[RF1_DYNTG_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = 90;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(1200), pw_rf1dtg) : 1200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(RES_TBW6), res_rf1dtg) : RES_TBW6;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_DYNTG_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_DYNTG_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_DYNTG_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_DYNTG_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;
    }


    /* gzrf1 cvs */
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    /*******************/
    /* Starting point  */
    /*******************/
    tleaddtg   = _tleaddtg.fixedflag ?    ((void)(RUP_GRD(24)), tleaddtg) : RUP_GRD(24);

    return SUCCESS;
}  /* end DTGcvinit */



/*
 *  ExtCalcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:  cvinit section
 *  for ExtCal entry point
 *  
 */
STATUS
ExtCalcvinit( void )
{
    cal_xres  = _cal_xres.fixedflag ?  ((void)(32), cal_xres) : 32;
    cal_yres  = _cal_yres.fixedflag ?  ((void)(32), cal_yres) : 32;
    cal_nex  = _cal_nex.fixedflag ?  ((void)(2), cal_nex) : 2; 
    cal_pass  = _cal_pass.fixedflag ?  ((void)(2), cal_pass) : 2; 

    echo1bwcal  = _echo1bwcal.fixedflag ?  ((void)(62.5), echo1bwcal) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    /* use original_phygrd to avoid ART derating; use phygrd to apply derating */
    original_pgrd = getOrigphygrd();
    if (obloptimize(&calloggrd, &original_pgrd, calscan_info, cal_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp68_ps1_newgeo=ps1_newgeo,&_temp68_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize");
        return FAILURE;
    }

    cal_slewrate  = _cal_slewrate.fixedflag ?  ((void)(original_pgrd.zfs*10000.0/original_pgrd.zrt), cal_slewrate) : original_pgrd.zfs*10000.0/original_pgrd.zrt;

    /* initialize pulse */
    a_rf1cal  = _a_rf1cal.fixedflag ?  ((void)(1.0), a_rf1cal) : 1.0;
    flip_rf1cal  = _flip_rf1cal.fixedflag ?  ((void)(1.0), flip_rf1cal) : 1.0;
    res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(150), res_rf1cal) : 150;
    pw_rf1cal  = _pw_rf1cal.fixedflag ?    ((void)(300), pw_rf1cal) : 300;

    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    tleadcal  = _tleadcal.fixedflag ?    ((void)(RUP_GRD(24)), tleadcal) : RUP_GRD(24);

    return SUCCESS;
}

/*
 *  AutoCoilcvinit
 *
 *  Type: Public Function
 *
 *  Description:  cvinit section
 *  for Auto Coil entry point
 *
 */
STATUS
AutoCoilcvinit( void )
{
    float coil_sr_derate = 1.0;

    coil_nex  = _coil_nex.fixedflag ?  ((void)(2), coil_nex) : 2;
    coil_pass  = _coil_pass.fixedflag ?  ((void)(1), coil_pass) : 1;

    echo1bwcoil  = _echo1bwcoil.fixedflag ?  ((void)(62.5), echo1bwcoil) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;

    if (obloptimize(&coilloggrd, &phygrd, coilscan_info, coil_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp69_ps1_newgeo=ps1_newgeo,&_temp69_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize");
        return FAILURE;
    }

    if(opsilentmr)
    {
        coil_sr_derate = 40.0;
    }
    else
    {
        coil_sr_derate = 1.0;
    }
    coil_slewrate  = _coil_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt)), coil_slewrate) : phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt);
    coil_slewrate  = _coil_slewrate.fixedflag ?    ((void)(FMax(2,3.0,coil_slewrate)), coil_slewrate) : FMax(2,3.0,coil_slewrate);  /* limited slewrate to 3 mT/m/ms and above */

    /* initialize pulse */
    a_rf1coil  = _a_rf1coil.fixedflag ?  ((void)(1.0), a_rf1coil) : 1.0;
    flip_rf1coil  = _flip_rf1coil.fixedflag ?  ((void)(1.0), flip_rf1coil) : 1.0;
    res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(150), res_rf1coil) : 150;
    pw_rf1coil  = _pw_rf1coil.fixedflag ?    ((void)(300), pw_rf1coil) : 300;

    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    tleadcoil  = _tleadcoil.fixedflag ?    ((void)(RUP_GRD(24)), tleadcoil) : RUP_GRD(24);

    return SUCCESS;
}


/*
 *  PS1cveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cveval( FLOAT *opthickPS )
{
    LONG bw_rf1mps1, bw_rf2mps1;    /* band widths of rf pulses */
    FLOAT area_pulse;
    FLOAT area_readrampmps1;
    FLOAT area_gxwmps1;
    FLOAT av_temp_float1 = 0;
    INT ps1_xrt;
    FLOAT ps1_tx;
    FLOAT ps1_tx_xz;
    FLOAT ps1_tz_xz;

    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

    /* check for breast L/R coil */
    if( isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast") )
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_ON), ps1_rxcoil) : PSD_ON;  /* Rxed rec coil for TG */
    }
    else
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_OFF), ps1_rxcoil) : PSD_OFF;
    }

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_ON == ps1_rxcoil) )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(getAps1ModFov()), mpsfov) : getAps1ModFov();
    }
    else
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(cfsystemmaxfov), mpsfov) : cfsystemmaxfov;
    }

    if(PSD_ON == local_tg)
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(TGopslthickx), mpsfov) : TGopslthickx;
    }

    ps1_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ps1_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ps1_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ps1_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);

    /* Z slice select for 90 pulse */
    bw_rf1mps1 = (LONG)(rfpulse[RF1_APS1_SLOT].nom_bw*rfpulse[RF1_APS1_SLOT].nom_pw/(float)pw_rf1mps1);

    if (FAILURE== minslicethick(&av_temp_float1, bw_rf1mps1, ps1loggrd.tz, gscale_rf1mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "minslicethick");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1*10.0)/10.0;
    if (av_temp_float1 > *opthickPS)
    {
        *opthickPS = av_temp_float1;
    }

    if (0 == getAps1Mod()) {
        cvoverride(thickPS_mod, *opthickPS, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        float fov = FMax(2, getAps1ModSlThick(), av_temp_float1);
        cvoverride(thickPS_mod, fov, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(PSD_ON == local_tg)
    {
        pw_gyrf1mps1  = _pw_gyrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gyrf1mps1) : pw_rf1mps1;
        if(av_temp_float1 > TGopslthicky)
        {
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(av_temp_float1), TGopslthicky) : av_temp_float1;
        }

        if (FAILURE==ampslice(_a_gyrf1mps1.fixedflag ? (_temp70_a_gyrf1mps1=a_gyrf1mps1,&_temp70_a_gyrf1mps1) : &a_gyrf1mps1, bw_rf1mps1,TGopslthicky,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1mps1.");
            return FAILURE;
        }

        /* slice selection ramp */
        if (optramp(_pw_gyrf1mps1a.fixedflag ? (_temp71_pw_gyrf1mps1a=pw_gyrf1mps1a,&_temp71_pw_gyrf1mps1a) : &pw_gyrf1mps1a, a_gyrf1mps1, ps1loggrd.ty, ps1loggrd.yrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1mps1a.");
            return FAILURE;
        }
        pw_gyrf1mps1d  = _pw_gyrf1mps1d.fixedflag ?  ((void)(pw_gyrf1mps1a), pw_gyrf1mps1d) : pw_gyrf1mps1a;

        area_pulse = a_gyrf1mps1*(pw_gyrf1mps1/2 + PSoff90 + pw_gyrf1mps1d/2);
        if (amppwgz1(_a_gy1mps1.fixedflag ? (_temp72_a_gy1mps1=a_gy1mps1,&_temp72_a_gy1mps1) : &a_gy1mps1,_pw_gy1mps1.fixedflag ? (_temp73_pw_gy1mps1=pw_gy1mps1,&_temp73_pw_gy1mps1) : &pw_gy1mps1,_pw_gy1mps1a.fixedflag ? (_temp74_pw_gy1mps1a=pw_gy1mps1a,&_temp74_pw_gy1mps1a) : &pw_gy1mps1a,_pw_gy1mps1d.fixedflag ? (_temp75_pw_gy1mps1d=pw_gy1mps1d,&_temp75_pw_gy1mps1d) : &pw_gy1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }

        if(av_temp_float1 > TGopslthick)
        {
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(av_temp_float1), TGopslthick) : av_temp_float1;
        }

        thickPS_mod  = _thickPS_mod.fixedflag ?  ((void)(TGopslthick), thickPS_mod) : TGopslthick;
    }
    else
    {
        pw_gzrf1mps1  = _pw_gzrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gzrf1mps1) : pw_rf1mps1;
        if (FAILURE==ampslice(_a_gzrf1mps1.fixedflag ? (_temp76_a_gzrf1mps1=a_gzrf1mps1,&_temp76_a_gzrf1mps1) : &a_gzrf1mps1, bw_rf1mps1,thickPS_mod,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gzrf1mps1.");
            return FAILURE;
        }
        /* end aps1_mod changes (GE) */

        /* slice selection ramp */
        if (optramp(_pw_gzrf1mps1a.fixedflag ? (_temp77_pw_gzrf1mps1a=pw_gzrf1mps1a,&_temp77_pw_gzrf1mps1a) : &pw_gzrf1mps1a, a_gzrf1mps1, ps1loggrd.tz, ps1loggrd.zrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */ 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gzrf1mps1a.");
            return FAILURE;
        }
        pw_gzrf1mps1d  = _pw_gzrf1mps1d.fixedflag ?  ((void)(pw_gzrf1mps1a), pw_gzrf1mps1d) : pw_gzrf1mps1a;

        /* Z gradient refocus */
        /* available time not calculated, defaulted to 10ms */
        area_pulse = a_gzrf1mps1*(pw_gzrf1mps1/2 + PSoff90 + pw_gzrf1mps1d/2);
        if (amppwgz1(_a_gz1mps1.fixedflag ? (_temp78_a_gz1mps1=a_gz1mps1,&_temp78_a_gz1mps1) : &a_gz1mps1,_pw_gz1mps1.fixedflag ? (_temp79_pw_gz1mps1=pw_gz1mps1,&_temp79_pw_gz1mps1) : &pw_gz1mps1,_pw_gz1mps1a.fixedflag ? (_temp80_pw_gz1mps1a=pw_gz1mps1a,&_temp80_pw_gz1mps1a) : &pw_gz1mps1a,_pw_gz1mps1d.fixedflag ? (_temp81_pw_gz1mps1d=pw_gz1mps1d,&_temp81_pw_gz1mps1d) : &pw_gz1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }
    }

    /* Z gradient crushers for 180 pulse */
    /* Left crusher. Denoted by the "l" after the "2"  in "gzrf2lmps1" */
    if (amppwgrad(ps_crusher_area, ps1_tz_xz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzrf2lmps1.fixedflag ? (_temp82_a_gzrf2lmps1=a_gzrf2lmps1,&_temp82_a_gzrf2lmps1) : &a_gzrf2lmps1, _pw_gzrf2lmps1a.fixedflag ? (_temp83_pw_gzrf2lmps1a=pw_gzrf2lmps1a,&_temp83_pw_gzrf2lmps1a) : &pw_gzrf2lmps1a,
                  _pw_gzrf2lmps1.fixedflag ? (_temp84_pw_gzrf2lmps1=pw_gzrf2lmps1,&_temp84_pw_gzrf2lmps1) : &pw_gzrf2lmps1, _pw_gzrf2lmps1d.fixedflag ? (_temp85_pw_gzrf2lmps1d=pw_gzrf2lmps1d,&_temp85_pw_gzrf2lmps1d) : &pw_gzrf2lmps1d) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzrf2lmps1"); 
        return FAILURE;
    }
  
    /* Right crusher. Denoted by the "r" after the "2" in "gzrf2rmps1"*/
    /* This is identical to left crusher */
    pw_gzrf2rmps1  = _pw_gzrf2rmps1.fixedflag ?  ((void)(pw_gzrf2lmps1), pw_gzrf2rmps1) : pw_gzrf2lmps1;
    a_gzrf2rmps1  = _a_gzrf2rmps1.fixedflag ?   ((void)(a_gzrf2lmps1), a_gzrf2rmps1) : a_gzrf2lmps1;

    /* right crusher ramps */
    pw_gzrf2rmps1a  = _pw_gzrf2rmps1a.fixedflag ?  ((void)(pw_gzrf2lmps1a), pw_gzrf2rmps1a) : pw_gzrf2lmps1a;
    pw_gzrf2rmps1d  = _pw_gzrf2rmps1d.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2rmps1d) : pw_gzrf2lmps1d;

    /* Z slice select for 180 pulse */
    pw_gzrf2mps1  = _pw_gzrf2mps1.fixedflag ?  ((void)(pw_rf2mps1), pw_gzrf2mps1) : pw_rf2mps1;
    bw_rf2mps1 = (LONG)(rfpulse[RF2_APS1_SLOT].nom_bw*rfpulse[RF2_APS1_SLOT].nom_pw/(float)pw_rf2mps1);

    /* begin aps1_mod changes (GE) */
    if (FAILURE==ampslice(_a_gzrf2mps1.fixedflag ? (_temp86_a_gzrf2mps1=a_gzrf2mps1,&_temp86_a_gzrf2mps1) : &a_gzrf2mps1, bw_rf2mps1, thickPS_mod, gscale_rf2mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* match ramps so gradient can be bridged in pulsegen */
    pw_gzrf2mps1a  = _pw_gzrf2mps1a.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2mps1a) : pw_gzrf2lmps1d;
    pw_gzrf2mps1d  = _pw_gzrf2mps1d.fixedflag ?  ((void)(pw_gzrf2rmps1a), pw_gzrf2mps1d) : pw_gzrf2rmps1a;

    /* readout gradient */
    if (FAILURE==calcfilter( &echo1mps1_filt, 15.625, 256, OVERWRITE_NONE))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1mps1_filt");
        return FAILURE;
    }

    /* MRIge30642 */
    /* Need check on fov.  Otherwise causes dwnld failures w/0.8 G/cm. */ 
    if (ampfov(&av_temp_float1, echo1mps1_filt.bw, ps1_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1/ 10.0) * 10.0;
    if( av_temp_float1 > mpsfov )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(av_temp_float1), mpsfov) : av_temp_float1;
    }

    if (ampfov(_a_gxwmps1.fixedflag ? (_temp87_a_gxwmps1=a_gxwmps1,&_temp87_a_gxwmps1) : &a_gxwmps1, echo1mps1_filt.bw, mpsfov) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwmps1.");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmps1a.fixedflag ? (_temp88_pw_gxwmps1a=pw_gxwmps1a,&_temp88_pw_gxwmps1a) : &pw_gxwmps1a, a_gxwmps1, ps1_tx, ps1_xrt,
                TYPDEF)==FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxwmps1a.");
        return FAILURE;
    }
  
    pw_gxwmps1d  = _pw_gxwmps1d.fixedflag ?  ((void)(pw_gxwmps1a), pw_gxwmps1d) : pw_gxwmps1a;

    pw_gxwmps1  = _pw_gxwmps1.fixedflag ?  ((void)(echo1mps1_filt.tdaq), pw_gxwmps1) : echo1mps1_filt.tdaq;
  
    /* dephaser */
    area_gxwmps1 = a_gxwmps1*(pw_gxwmps1);
    area_readrampmps1 = 0.5*pw_gxwmps1a*a_gxwmps1;

    if (amppwgx1(_a_gx1mps1.fixedflag ? (_temp89_a_gx1mps1=a_gx1mps1,&_temp89_a_gx1mps1) : &a_gx1mps1, _pw_gx1mps1.fixedflag ? (_temp90_pw_gx1mps1=pw_gx1mps1,&_temp90_pw_gx1mps1) : &pw_gx1mps1, _pw_gx1mps1a.fixedflag ? (_temp91_pw_gx1mps1a=pw_gx1mps1a,&_temp91_pw_gx1mps1a) : &pw_gx1mps1a ,_pw_gx1mps1d.fixedflag ? (_temp92_pw_gx1mps1d=pw_gx1mps1d,&_temp92_pw_gx1mps1d) : &pw_gx1mps1d, TYPSPIN,
                 area_gxwmps1, (float)area_readrampmps1, 
                 (int)1000000, 1.0, MIN_PLATEAU_TIME, ps1_xrt, ps1_tx_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1mps1.");
        return FAILURE;
    }

    /* Y gradient is not used in MPS1 */

    return SUCCESS;
}

/*
 *  CFLcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcveval( FLOAT opthickPS )
{
    LONG bw_rf1cfl;
    FLOAT area_gz1cfl;

    cflloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&cflloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(2), cfl_dda) : 2;      /* BJM MRIge80347: Changed from 0 -> 2 for MGD, coil switch problem */
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(1), cfl_nex) : 1;
    }
    else
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(4), cfl_dda) : 4;
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(2), cfl_nex) : 2;
    }

    if(cffield == B0_2000) 
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(10.41666), echo1bwcfl) : 10.41666;
    } 
    else if(cffield == B0_15000)
    {
        /* MRIhc54366: accommodate B0 drift using larger receive bandwidth 
           with matched spectral resolution */
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(7.8125), echo1bwcfl) : 7.8125;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }
    else
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(15.625), echo1bwcfl) : 15.625;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }

    /* MRIhc54366: changed hard coded number of output points to CFLxres */
    if ( FAILURE==calcfilter( &echo1cfl, echo1bwcfl, CFLxres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfl_filt");
        return FAILURE;
    }

    /* MRIhc54366: dynamic CFL excitation pulse selection: */
    if(floatsAlmostEqualEpsilons(cyc_rf1cfl, 2.0, 2)) 
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC2;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC2;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC2;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC2;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC2;
        rfpulse[RF1_CFL_SLOT].max_b1 = SAR_MAXB1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 2500;
    }
    else
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC1;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RF1_CFL_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 1250;
    }
    /* MRIhc54366: END pulse selection. */

    /* CFL acq duration needed for attenuator setting */
    cfl_tdaq = echo1cfl.tdaq;

    pw_gzrf1cfl  = _pw_gzrf1cfl.fixedflag ?  ((void)(pw_rf1cfl), pw_gzrf1cfl) : pw_rf1cfl;
    bw_rf1cfl = (LONG)(rfpulse[RF1_CFL_SLOT].nom_bw*rfpulse[RF1_CFL_SLOT].nom_pw/(float)pw_rf1cfl);

    /* MRIhc54366: new lower limit */
    opthickPS = (exist(opslthick) < 5.0) ? 5.0 : exist(opslthick);

    if ( FAILURE==ampslice(_a_gzrf1cfl.fixedflag ? (_temp93_a_gzrf1cfl=a_gzrf1cfl,&_temp93_a_gzrf1cfl) : &a_gzrf1cfl, bw_rf1cfl, opthickPS, gscale_rf1cfl, TYPDEF) ) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    if ( FAILURE==optramp(_pw_gzrf1cfla.fixedflag ? (_temp94_pw_gzrf1cfla=pw_gzrf1cfla,&_temp94_pw_gzrf1cfla) : &pw_gzrf1cfla, a_gzrf1cfl, cflloggrd.tz, cflloggrd.zrt, TYPDEF) )  
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfld  = _pw_gzrf1cfld.fixedflag ?  ((void)(pw_gzrf1cfla), pw_gzrf1cfld) : pw_gzrf1cfla;

    /* Find Params for refocusing pulse */
    area_gz1cfl =  a_gzrf1cfl *0.5* ( pw_gzrf1cfl + pw_gzrf1cfld);
    if ( FAILURE==amppwgz1(_a_gz1cfl.fixedflag ? (_temp95_a_gz1cfl=a_gz1cfl,&_temp95_a_gz1cfl) : &a_gz1cfl, _pw_gz1cfl.fixedflag ? (_temp96_pw_gz1cfl=pw_gz1cfl,&_temp96_pw_gz1cfl) : &pw_gz1cfl, _pw_gz1cfla.fixedflag ? (_temp97_pw_gz1cfla=pw_gz1cfla,&_temp97_pw_gz1cfla) : &pw_gz1cfla, _pw_gz1cfld.fixedflag ? (_temp98_pw_gz1cfld=pw_gz1cfld,&_temp98_pw_gz1cfld) : &pw_gz1cfld, 
                           area_gz1cfl, (INT)1000000, MIN_PLATEAU_TIME,
                           cflloggrd.zrt, cflloggrd.tz) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1cfl");
        return FAILURE;
    }

    /* Find Params for killer pulse */
    area_gykcfl  = _area_gykcfl.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfl) : amp_killer*pw_killer;
    if ( FAILURE==amppwgrad(area_gykcfl, cflloggrd.ty, 0.0, 0.0, cflloggrd.yrt,
                            MIN_PLATEAU_TIME, _a_gykcfl.fixedflag ? (_temp99_a_gykcfl=a_gykcfl,&_temp99_a_gykcfl) : &a_gykcfl, _pw_gykcfla.fixedflag ? (_temp100_pw_gykcfla=pw_gykcfla,&_temp100_pw_gykcfla) : &pw_gykcfla,
                            _pw_gykcfl.fixedflag ? (_temp101_pw_gykcfl=pw_gykcfl,&_temp101_pw_gykcfl) : &pw_gykcfl, _pw_gykcfld.fixedflag ? (_temp102_pw_gykcfld=pw_gykcfld,&_temp102_pw_gykcfld) : &pw_gykcfld) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfl");
        return FAILURE;
    }

    return SUCCESS;
}


/*
 *  RCVNcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcveval( void )
{
    int rcvn_newgeo = 1;
    int roti;
    INT tot_gradtime = 0;
    INT tot_gradtime2 = 0;

    rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;

    for(  roti = 0; roti < 9; roti++ )
    {
        rcvnscan_info[0].oprot[roti] = 0.0;
    }
    /* for gradient prognostic, play out gradient on physical axes */
    rcvnscan_info[0].oprot[0]=rcvnscan_info[0].oprot[4]=rcvnscan_info[0].oprot[8]=1.0;

    if (FAILURE==obloptimize(&rcvnloggrd, &phygrd, rcvnscan_info, 1, PSD_OBL,
                             0, PSD_OBL_RESTRICT, ps1obl_debug, &rcvn_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in RCVNcveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    if(mkgspec_flag == MK_SPEC_MODE_GRAD_3AXES)
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;  /* disable gradient prognostic and using Imaging plane */
        for (roti = 0; roti < 9; roti++)
        {
            rcvnscan_info[0].oprot[roti] = scan_info[PSslice_num].oprot[roti]; /* use Rxed slice rot */
        }
        rcvnloggrd = loggrd;
    }
    /* for grad prognostic test only for non-derated case */
    else if((PSsr_derate_factor < 2.0) && (PSamp_derate_factor < 2.0) && !(isSVSystem()))
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(3), rcvn_flag) : 3;  /* new waveform for grad prognostic, using Axial plane */
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&rcvnloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient before Receiver noise sequence */

    if ( FAILURE==amppwgrad( area_gxkrcvn, rcvnloggrd.tx_xyz, 0.0, 0.0, rcvnloggrd.xrt,
                             MIN_PLATEAU_TIME, _a_gxkrcvn.fixedflag ? (_temp103_a_gxkrcvn=a_gxkrcvn,&_temp103_a_gxkrcvn) : &a_gxkrcvn, _pw_gxkrcvna.fixedflag ? (_temp104_pw_gxkrcvna=pw_gxkrcvna,&_temp104_pw_gxkrcvna) : &pw_gxkrcvna,
                             _pw_gxkrcvn.fixedflag ? (_temp105_pw_gxkrcvn=pw_gxkrcvn,&_temp105_pw_gxkrcvn) : &pw_gxkrcvn, _pw_gxkrcvnd.fixedflag ? (_temp106_pw_gxkrcvnd=pw_gxkrcvnd,&_temp106_pw_gxkrcvnd) : &pw_gxkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gxkrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gykrcvn, rcvnloggrd.ty_xyz, 0.0, 0.0, rcvnloggrd.yrt,
                             MIN_PLATEAU_TIME, _a_gykrcvn.fixedflag ? (_temp107_a_gykrcvn=a_gykrcvn,&_temp107_a_gykrcvn) : &a_gykrcvn, _pw_gykrcvna.fixedflag ? (_temp108_pw_gykrcvna=pw_gykrcvna,&_temp108_pw_gykrcvna) : &pw_gykrcvna,
                             _pw_gykrcvn.fixedflag ? (_temp109_pw_gykrcvn=pw_gykrcvn,&_temp109_pw_gykrcvn) : &pw_gykrcvn, _pw_gykrcvnd.fixedflag ? (_temp110_pw_gykrcvnd=pw_gykrcvnd,&_temp110_pw_gykrcvnd) : &pw_gykrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gzkrcvn, rcvnloggrd.tz_xyz, 0.0, 0.0, rcvnloggrd.zrt,
                             MIN_PLATEAU_TIME, _a_gzkrcvn.fixedflag ? (_temp111_a_gzkrcvn=a_gzkrcvn,&_temp111_a_gzkrcvn) : &a_gzkrcvn, _pw_gzkrcvna.fixedflag ? (_temp112_pw_gzkrcvna=pw_gzkrcvna,&_temp112_pw_gzkrcvna) : &pw_gzkrcvna,
                             _pw_gzkrcvn.fixedflag ? (_temp113_pw_gzkrcvn=pw_gzkrcvn,&_temp113_pw_gzkrcvn) : &pw_gzkrcvn, _pw_gzkrcvnd.fixedflag ? (_temp114_pw_gzkrcvnd=pw_gzkrcvnd,&_temp114_pw_gzkrcvnd) : &pw_gzkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzkrcvn");
        return FAILURE;
    }

    if( 3 == rcvn_flag )
    {
        /* X Grad -- +12 ms, -4ms */
        pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gxkrcvna)), pw_gxkrcvn) : RUP_GRD(12000-2*pw_gxkrcvna);
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(-a_gxkrcvn), a_gxk2rcvn) : -a_gxkrcvn;
        pw_gxk2rcvna  = _pw_gxk2rcvna.fixedflag ?  ((void)(pw_gxkrcvna), pw_gxk2rcvna) : pw_gxkrcvna;
        pw_gxk2rcvnd  = _pw_gxk2rcvnd.fixedflag ?  ((void)(pw_gxk2rcvna), pw_gxk2rcvnd) : pw_gxk2rcvna;
        pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gxk2rcvna)), pw_gxk2rcvn) : RUP_GRD(4000-2*pw_gxk2rcvna);
        if(pw_gxkrcvn <= 0)
        {
            pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?  ((void)(4), pw_gxkrcvn) : 4;
        }
        if(pw_gxk2rcvn <= 0)
        {
            pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?  ((void)(4), pw_gxk2rcvn) : 4;
        }

        /* Y Grad -- +8 ms, -12ms  */
        pw_gykrcvn  = _pw_gykrcvn.fixedflag ?    ((void)(RUP_GRD(8000-2*pw_gykrcvna)), pw_gykrcvn) : RUP_GRD(8000-2*pw_gykrcvna);
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(-a_gykrcvn), a_gyk2rcvn) : -a_gykrcvn;
        pw_gyk2rcvna  = _pw_gyk2rcvna.fixedflag ?  ((void)(pw_gykrcvna), pw_gyk2rcvna) : pw_gykrcvna;
        pw_gyk2rcvnd  = _pw_gyk2rcvnd.fixedflag ?  ((void)(pw_gyk2rcvna), pw_gyk2rcvnd) : pw_gyk2rcvna;
        pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gyk2rcvna)), pw_gyk2rcvn) : RUP_GRD(12000-2*pw_gyk2rcvna);
        if(pw_gykrcvn <= 0)
        {
            pw_gykrcvn  = _pw_gykrcvn.fixedflag ?  ((void)(4), pw_gykrcvn) : 4;
        }
        if(pw_gyk2rcvn <= 0)
        {
            pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?  ((void)(4), pw_gyk2rcvn) : 4;
        }

        /* Z Grad -- +4 ms, -12ms */
        pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gzkrcvna)), pw_gzkrcvn) : RUP_GRD(4000-2*pw_gzkrcvna);
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(-a_gzkrcvn), a_gzk2rcvn) : -a_gzkrcvn;
        pw_gzk2rcvna  = _pw_gzk2rcvna.fixedflag ?  ((void)(pw_gzkrcvna), pw_gzk2rcvna) : pw_gzkrcvna;
        pw_gzk2rcvnd  = _pw_gzk2rcvnd.fixedflag ?  ((void)(pw_gzk2rcvna), pw_gzk2rcvnd) : pw_gzk2rcvna;
        pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gzk2rcvna)), pw_gzk2rcvn) : RUP_GRD(12000-2*pw_gzk2rcvna);
        if(pw_gzkrcvn <= 0)
        {
            pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?  ((void)(4), pw_gzkrcvn) : 4;
        }
        if(pw_gzk2rcvn <= 0)
        {
            pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?  ((void)(4), pw_gzk2rcvn) : 4;
        }

        tot_gradtime2 = IMax(3, pw_gxk2rcvna+pw_gxk2rcvn+pw_gxk2rcvnd, 
                             pw_gyk2rcvna+pw_gyk2rcvn+pw_gyk2rcvnd, pw_gzk2rcvna+pw_gzk2rcvn+pw_gzk2rcvnd);
    }
    else
    {
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(0.0), a_gxk2rcvn) : 0.0;
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(0.0), a_gyk2rcvn) : 0.0;
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(0.0), a_gzk2rcvn) : 0.0;
        tot_gradtime2 = 0;
    }

    tot_gradtime = pw_gykrcvna+pw_gykrcvn+pw_gykrcvnd+tot_gradtime2;

    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?    ((void)(IMax(2,20000,RUP_GRD(tot_gradtime+1000))), pre_rcvn_tr) : IMax(2,20000,RUP_GRD(tot_gradtime+1000));
    }
    else if(rcvn_flag == 2)  /* extra wait before rcvn */
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?  ((void)(1000000), pre_rcvn_tr) : 1000000;
    }

    if (existcv(oprbw))
    {
        echo1bwrcvn  = _echo1bwrcvn.fixedflag ?  ((void)(exist(oprbw)), echo1bwrcvn) : exist(oprbw);
    }

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW)), echo1bwrcvn) : FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW);

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW)), echo1bwrcvn) : FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW);

    if ( FAILURE==calcfilter( &echo1rcvn, echo1bwrcvn, rcvn_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rcvn");
        return FAILURE;
    }

    /* RCVN acq duration needed for attenuator setting */
    rcvn_tdaq = echo1rcvn.tdaq;

    /* Add 20ms dead time to prevent runtime errors */
    rcvn_tr  = _rcvn_tr.fixedflag ?       ((void)(IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR)), rcvn_tr) : IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR);

    /* To make sure RCVN loops enough to acquire 4K points */
    rcvn_loops  = _rcvn_loops.fixedflag ?       ((void)(IMax(2,2*(int)(4096/rcvn_xres),1)), rcvn_loops) : IMax(2,2*(int)(4096/rcvn_xres),1);

    return SUCCESS;
}

/*
 *  AScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScveval( void )
{
    /* DV26: Baseline used for Autoshim noise level thresholding */
    asbaseline  = _asbaseline.fixedflag ?  ((void)(8), asbaseline) : 8;
    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) ||
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(0), as_dda) : 0;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(62.5), echo1bwas) : 62.5;
        asxres  = _asxres.fixedflag ?  ((void)(128), asxres) : 128;
        asyres  = _asyres.fixedflag ?   ((void)(64), asyres) : 64;
        /* asres=128 and asyres=64 for all T fields */
    }
    else
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(4), as_dda) : 4;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(15.625), echo1bwas) : 15.625;
        asxres  = _asxres.fixedflag ?  ((void)(256), asxres) : 256;
        asyres  = _asyres.fixedflag ?  ((void)(128), asyres) : 128;
        te_as  = _te_as.fixedflag ?  ((void)(9000), te_as) : 9000;
        if (cffield == B0_15000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
        }
        else if (cffield == B0_10000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(30000), tr_as) : 30000;
        }
        else if (cffield == B0_2000) /* profile 05/22/95 NM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000; /* Profile 09/29/95 NM */
        }
        else if (cffield == B0_3500) /* MFO,Hino, Feb/02/00 MM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000;
        }
        else if (cffield == B0_5000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(35000), tr_as) : 35000;
        }
        else if (cffield == B0_40000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(32000), tr_as) : 32000;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else 
        {
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
    }

    /* MRIge21914 - moved deltf to @cv */

    /* Call the SDL function to compute fat-water separation. */
    deltf  = _deltf.fixedflag ?    ((void)(SDL_GetChemicalShift(cffield)), deltf) : SDL_GetChemicalShift(cffield);
    /* In phase delta TE will be used in MFO. Hino, Feb/02/00 MM */

    /* dixon time shift.  put it on grad boundary. */
    dix_timeas  = _dix_timeas.fixedflag ?   ((void)(RUP_GRD((int)(1000000/deltf))), dix_timeas) : RUP_GRD((int)(1000000/deltf));
    pw_sdixon2  = _pw_sdixon2.fixedflag ?    ((void)(GRAD_UPDATE_TIME+dix_timeas), pw_sdixon2) : GRAD_UPDATE_TIME+dix_timeas;

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    if (FAILURE==ampslice(_a_gzrf1as.fixedflag ? (_temp115_a_gzrf1as=a_gzrf1as,&_temp115_a_gzrf1as) : &a_gzrf1as, bw_rf1as, asslthick, gscale_rf1as, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1as.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1asa.fixedflag ? (_temp116_pw_gzrf1asa=pw_gzrf1asa,&_temp116_pw_gzrf1asa) : &pw_gzrf1asa, a_gzrf1as, asloggrd.tz_xyz, asloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1asa.");
        return FAILURE;
    }
    pw_gzrf1asd  = _pw_gzrf1asd.fixedflag ?  ((void)(pw_gzrf1asa), pw_gzrf1asd) : pw_gzrf1asa;

    /******************************************/
    /*   Calc area needed for z rephaser      */
    /******************************************/
    area_gz1as  = _area_gz1as.fixedflag ?     ((void)((off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as), area_gz1as) : (off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as;

    /* availible time for rephaser */
    avail_pwgz1as  = _avail_pwgz1as.fixedflag ?  ((void)(1000000), avail_pwgz1as) : 1000000;

    if ( FAILURE==amppwgz1(_a_gz1as.fixedflag ? (_temp117_a_gz1as=a_gz1as,&_temp117_a_gz1as) : &a_gz1as, _pw_gz1as.fixedflag ? (_temp118_pw_gz1as=pw_gz1as,&_temp118_pw_gz1as) : &pw_gz1as, _pw_gz1asa.fixedflag ? (_temp119_pw_gz1asa=pw_gz1asa,&_temp119_pw_gz1asa) : &pw_gz1asa, _pw_gz1asd.fixedflag ? (_temp120_pw_gz1asd=pw_gz1asd,&_temp120_pw_gz1asd) : &pw_gz1asd,
                           area_gz1as, avail_pwgz1as, MIN_PLATEAU_TIME,
                           asloggrd.zrt, asloggrd.tz_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1as.");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1as_filt, echo1bwas, asxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1as_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(_a_gxwas.fixedflag ? (_temp121_a_gxwas=a_gxwas,&_temp121_a_gxwas) : &a_gxwas, echo1as_filt.bw, asfov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwas.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwasa.fixedflag ? (_temp122_pw_gxwasa=pw_gxwasa,&_temp122_pw_gxwasa) : &pw_gxwasa, a_gxwas, asloggrd.tx_xyz, asloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwasa.");
        return FAILURE;
    }

    pw_gxwasd  = _pw_gxwasd.fixedflag ?  ((void)(pw_gxwasa), pw_gxwasd) : pw_gxwasa;
    pw_gxwas  = _pw_gxwas.fixedflag ?  ((void)(echo1as_filt.tdaq), pw_gxwas) : echo1as_filt.tdaq;

    avail_pwgx1as  = _avail_pwgx1as.fixedflag ?  ((void)(1000000), avail_pwgx1as) : 1000000;

    area_readrampas  = _area_readrampas.fixedflag ?  ((void)(0.5*pw_gxwasa*a_gxwas), area_readrampas) : 0.5*pw_gxwasa*a_gxwas;
    area_gxwas  = _area_gxwas.fixedflag ?  ((void)(pw_gxwas*a_gxwas), area_gxwas) : pw_gxwas*a_gxwas;

    if ( FAILURE==amppwgx1(_a_gx1as.fixedflag ? (_temp123_a_gx1as=a_gx1as,&_temp123_a_gx1as) : &a_gx1as, _pw_gx1as.fixedflag ? (_temp124_pw_gx1as=pw_gx1as,&_temp124_pw_gx1as) : &pw_gx1as, _pw_gx1asa.fixedflag ? (_temp125_pw_gx1asa=pw_gx1asa,&_temp125_pw_gx1asa) : &pw_gx1asa, _pw_gx1asd.fixedflag ? (_temp126_pw_gx1asd=pw_gx1asd,&_temp126_pw_gx1asd) : &pw_gx1asd,
                           (int)TYPGRAD, area_gxwas, area_readrampas,
                           avail_pwgx1as, 1.0, MIN_PLATEAU_TIME,
                           asloggrd.xrt, asloggrd.tx_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1as.");
        return FAILURE;
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(asyres), _endview_iampas.fixedflag ? (_temp127_endview_iampas=endview_iampas,&_temp127_endview_iampas) : &endview_iampas) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:autoshim");
        return FAILURE;
    } 
  
    endview_scaleas  = _endview_scaleas.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampas), endview_scaleas) : (float)max_pg_iamp/(float)endview_iampas;

    if ( FAILURE==amppwtpe(_a_gy1asa.fixedflag ? (_temp128_a_gy1asa=a_gy1asa,&_temp128_a_gy1asa) : &a_gy1asa, _a_gy1asb.fixedflag ? (_temp129_a_gy1asb=a_gy1asb,&_temp129_a_gy1asb) : &a_gy1asb, _pw_gy1as.fixedflag ? (_temp130_pw_gy1as=pw_gy1as,&_temp130_pw_gy1as) : &pw_gy1as, _pw_gy1asa.fixedflag ? (_temp131_pw_gy1asa=pw_gy1asa,&_temp131_pw_gy1asa) : &pw_gy1asa, _pw_gy1asd.fixedflag ? (_temp132_pw_gy1asd=pw_gy1asd,&_temp132_pw_gy1asd) : &pw_gy1asd,
                           asloggrd.ty_xyz/endview_scaleas,asloggrd.yrt,
                           (0.5 * (FLOAT)(asyres-1))/(asfov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:autoshim");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1ras  = _a_gy1ras.fixedflag ?  ((void)(a_gy1as), a_gy1ras) : a_gy1as;
    a_gy1rasa  = _a_gy1rasa.fixedflag ?  ((void)(a_gy1asa), a_gy1rasa) : a_gy1asa;
    a_gy1rasb  = _a_gy1rasb.fixedflag ?  ((void)(a_gy1asb), a_gy1rasb) : a_gy1asb;
    pw_gy1ras  = _pw_gy1ras.fixedflag ?  ((void)(pw_gy1as), pw_gy1ras) : pw_gy1as;
    pw_gy1rasa  = _pw_gy1rasa.fixedflag ?  ((void)(pw_gy1asa), pw_gy1rasa) : pw_gy1asa;
    pw_gy1rasd  = _pw_gy1rasd.fixedflag ?  ((void)(pw_gy1asd), pw_gy1rasd) : pw_gy1asd;

    if(1==fastprescan) 
    {

        te_as  = _te_as.fixedflag ?           
                                  
                               ((void)(RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2)), te_as) : RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2);

        tr_as  = _tr_as.fixedflag ?           
                                  
                             ((void)(RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000)), tr_as) : RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000);
    }

    return SUCCESS;
}   /* end AScveval() */


/*
 *  CFHfilter
 *  
 *  Type: Private Function
 *  
 *  Description: Separate function for CFH for inclusion in 
 *               in Spectroscopy volume localized CFH
 *  
 */
STATUS
CFHfilter( int xres )
{
    CFHxres  = _CFHxres.fixedflag ?  ((void)(xres), CFHxres) : xres;

    if(cffield <= B0_5000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.25), echo1bwcfh) : 0.25;
    }
    else if (cffield >= B0_30000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(1.0), echo1bwcfh) : 1.0;
    }
    else 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.50), echo1bwcfh) : 0.50;
    }

    if ( FAILURE==calcfilter( &echo1cfh, echo1bwcfh, CFHxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfh_filt");
        return FAILURE;
    }

    cfh_tdaq = echo1cfh.tdaq;

    return SUCCESS;
}

/*
 *  CFHcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcveval( FLOAT opthickPS )
{
    LONG bw_rf0cfh;
    LONG bw_rf1cfh;

    GRAD_PULSE psd_cfhrightcrush;
    GRAD_PULSE psd_cfhleftcrush;

    FLOAT area_gz1cfh;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For MRIhc11621 */
    /* For presscfh MRIhc08321 */
    if( presscfh == PRESSCFH_SLICE && PSfield_strength > B0_5000 && 
        cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    } 
    else if(presscfh == PRESSCFH_SLAB && PSfield_strength > B0_5000 &&
            cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.75), presscfh_slab_ratio) : 0.75;
    }
    else if( presscfh == PRESSCFH_SHIMVOL && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.5), presscfh_fov_ratio) : 0.5;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.5), presscfh_pfov_ratio) : 0.5;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    }
    else if( presscfh == PRESSCFH_SHIMVOL_SLICE && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL_SLICE, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(1.0), presscfh_fov_ratio) : 1.0;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(1.0), presscfh_pfov_ratio) : 1.0;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(1.0), presscfh_slab_ratio) : 1.0;
    }
    else
    { 
        cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
    }
    
    if(presscfh_debug) 
    {
        printf("\n CFHcveval : presscfh = %d,presscfh_ctrl = %d,presscfh_override = %d\n",presscfh,presscfh_ctrl,presscfh_override);
        fflush(stdout);
    }

    wg_cfh_rf3  = _wg_cfh_rf3.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD), wg_cfh_rf3) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD;
    wg_cfh_rf4  = _wg_cfh_rf4.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD), wg_cfh_rf4) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD;

    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(0), cfh_dda) : 0;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(1), cfh_nex) : 1;
    }
    else
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(4), cfh_dda) : 4;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(2), cfh_nex) : 2;
    }

    if(cffield == B0_15000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_1HT), cfh_ti) : CFHTI_1HT;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_1HT), eff_cfh_te) : CFHTE_1HT;
    }
    else if(cffield >= B0_30000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_3T), cfh_ti) : CFHTI_3T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_3T), eff_cfh_te) : CFHTE_3T;
    }

    CFHfilter(256);

    /* Initialize some grad structures 
       so we can use the psdsupport routine amppwlcrsh */
    psd_cfhleftcrush.attack = _pw_gzrf2lcfha.fixedflag ? (_temp133_pw_gzrf2lcfha=pw_gzrf2lcfha,&_temp133_pw_gzrf2lcfha) : &pw_gzrf2lcfha;
    psd_cfhleftcrush.decay = _pw_gzrf2lcfhd.fixedflag ? (_temp134_pw_gzrf2lcfhd=pw_gzrf2lcfhd,&_temp134_pw_gzrf2lcfhd) : &pw_gzrf2lcfhd;
    psd_cfhleftcrush.pw = _pw_gzrf2lcfh.fixedflag ? (_temp135_pw_gzrf2lcfh=pw_gzrf2lcfh,&_temp135_pw_gzrf2lcfh) : &pw_gzrf2lcfh;
    psd_cfhleftcrush.amp = _a_gzrf2lcfh.fixedflag ? (_temp136_a_gzrf2lcfh=a_gzrf2lcfh,&_temp136_a_gzrf2lcfh) : &a_gzrf2lcfh;
 
    psd_cfhrightcrush.attack = _pw_gzrf2rcfha.fixedflag ? (_temp137_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp137_pw_gzrf2rcfha) : &pw_gzrf2rcfha;
    psd_cfhrightcrush.decay = _pw_gzrf2rcfhd.fixedflag ? (_temp138_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp138_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd;
    psd_cfhrightcrush.pw = _pw_gzrf2rcfh.fixedflag ? (_temp139_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp139_pw_gzrf2rcfh) : &pw_gzrf2rcfh;
    psd_cfhrightcrush.amp = _a_gzrf2rcfh.fixedflag ? (_temp140_a_gzrf2rcfh=a_gzrf2rcfh,&_temp140_a_gzrf2rcfh) : &a_gzrf2rcfh;

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        psd_cfhrightcrush.attack = _pw_gzrf3rcfha.fixedflag ? (_temp141_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp141_pw_gzrf3rcfha) : &pw_gzrf3rcfha;
        psd_cfhrightcrush.decay = _pw_gzrf3rcfhd.fixedflag ? (_temp142_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp142_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd;
        psd_cfhrightcrush.pw = _pw_gzrf3rcfh.fixedflag ? (_temp143_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp143_pw_gzrf3rcfh) : &pw_gzrf3rcfh;
        psd_cfhrightcrush.amp = _a_gzrf3rcfh.fixedflag ? (_temp144_a_gzrf3rcfh=a_gzrf3rcfh,&_temp144_a_gzrf3rcfh) : &a_gzrf3rcfh;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp145_pw_rf1cfh=pw_rf1cfh,&_temp145_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp146_a_rf1cfh=a_rf1cfh,&_temp146_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp147_flip_rf1cfh=flip_rf1cfh,&_temp147_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp148_res_rf1cfh=res_rf1cfh,&_temp148_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp149_wg_rf1cfh=wg_rf1cfh,&_temp149_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp150_pw_rf2cfh=pw_rf2cfh,&_temp150_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp151_a_rf2cfh=a_rf2cfh,&_temp151_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp152_flip_rf2cfh=flip_rf2cfh,&_temp152_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp153_res_rf2cfh=res_rf2cfh,&_temp153_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp154_wg_rf2cfh=wg_rf2cfh,&_temp154_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp155_pw_rf3cfh=pw_rf3cfh,&_temp155_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp156_a_rf3cfh=a_rf3cfh,&_temp156_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp157_flip_rf3cfh=flip_rf3cfh,&_temp157_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp158_res_rf3cfh=res_rf3cfh,&_temp158_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp159_wg_rf3cfh=wg_rf3cfh,&_temp159_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp160_pw_rf4cfh=pw_rf4cfh,&_temp160_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp161_a_rf4cfh=a_rf4cfh,&_temp161_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp162_flip_rf4cfh=flip_rf4cfh,&_temp162_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp163_res_rf4cfh=res_rf4cfh,&_temp163_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp164_wg_rf4cfh=wg_rf4cfh,&_temp164_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp165_pw_rf1cfh=pw_rf1cfh,&_temp165_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp166_a_rf1cfh=a_rf1cfh,&_temp166_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp167_flip_rf1cfh=flip_rf1cfh,&_temp167_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp168_res_rf1cfh=res_rf1cfh,&_temp168_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp169_wg_rf1cfh=wg_rf1cfh,&_temp169_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp170_pw_rf2cfh=pw_rf2cfh,&_temp170_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp171_a_rf2cfh=a_rf2cfh,&_temp171_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp172_flip_rf2cfh=flip_rf2cfh,&_temp172_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp173_res_rf2cfh=res_rf2cfh,&_temp173_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp174_wg_rf2cfh=wg_rf2cfh,&_temp174_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp175_pw_rf3cfh=pw_rf3cfh,&_temp175_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp176_a_rf3cfh=a_rf3cfh,&_temp176_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp177_flip_rf3cfh=flip_rf3cfh,&_temp177_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp178_res_rf3cfh=res_rf3cfh,&_temp178_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp179_wg_rf3cfh=wg_rf3cfh,&_temp179_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp180_pw_rf4cfh=pw_rf4cfh,&_temp180_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp181_a_rf4cfh=a_rf4cfh,&_temp181_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp182_flip_rf4cfh=flip_rf4cfh,&_temp182_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp183_res_rf4cfh=res_rf4cfh,&_temp183_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp184_wg_rf4cfh=wg_rf4cfh,&_temp184_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 

    }

    if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) 
    {
        /* it is assumed: 
         * (a) cubicle local shim volume 
         */

        FLOAT av;
        FLOAT dxv, dyv, dzv, dxs, dys, dzs, dxs0, dys0, dzs0; 
        FLOAT Dz=0.0;
        FLOAT al2=0.0;
        FLOAT al=0.0;
        FLOAT dxl=0.0;
        FLOAT dyl=0.0;
        FLOAT dzl=0.0;
        FLOAT rs[9], rv[9], rstrv[9];
        INT ii, vidx;
       
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            av = (psc_info[vidx].oppsclenx)/2.0;
            dxv = psc_info[vidx].oppscrloc;
            dyv = psc_info[vidx].oppscphasoff;
            dzv = psc_info[vidx].oppsctloc;

            dxs = scan_info[PSslice_num].oprloc    + scan_info[PSslice_num].oprloc_shift;
            dys = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            dzs = scan_info[PSslice_num].optloc    + scan_info[PSslice_num].optloc_shift;

            for( ii = 0; ii < 9; ii++ )
            {
                rs[ii] = scan_info[PSslice_num].oprot[ii];
                rv[ii] = psc_info[vidx].oppscrot[ii];
            }

            for( ii = 0; ii < 9; ii++ )
            {
                int ir, ic;
                ir = ii/ 3;
                ic = ii % 3;
                rstrv[ii] = rs[3*0+ir]*rv[3*0+ic] 
                    + rs[3*1+ir]*rv[3*1+ic] 
                    + rs[3*2+ir]*rv[3*2+ic]; 
            }

            if( presscfh_debug )
            {
                printf("rot for shim volume %d\n", vidx);
                printf("%8.2f %8.2f %8.2f\n", rv[0], rv[3], rv[6]);
                printf("%8.2f %8.2f %8.2f\n", rv[1], rv[4], rv[7]);
                printf("%8.2f %8.2f %8.2f\n", rv[2], rv[5], rv[8]);
                printf("rot for slice\n");
                printf("%8.2f %8.2f %8.2f\n", rs[0], rs[3], rs[6]);
                printf("%8.2f %8.2f %8.2f\n", rs[1], rs[4], rs[7]);
                printf("%8.2f %8.2f %8.2f\n", rs[2], rs[5], rs[8]);
            }

            dxs0 = rstrv[0]*dxv + rstrv[1]*dyv + rstrv[2]*dzv;
            dys0 = rstrv[3]*dxv + rstrv[4]*dyv + rstrv[5]*dzv;
            dzs0 = rstrv[6]*dxv + rstrv[7]*dyv + rstrv[8]*dzv;

            if( presscfh == PRESSCFH_SLICE ) 
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                if( fabs(dzs0 - dzs) >= av )
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                } else {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }
            } 
            else 
            {   /* presscfh == PRESSCFH_SLAB */
                FLOAT dzss, dzse, dzs0s, dzs0e;
                FLOAT dz1, dz2;
                dzss = scan_info[0].optloc + scan_info[0].optloc_shift;
                dzse = scan_info[opslquant*opvquant-1].optloc + scan_info[opslquant*opvquant-1].optloc_shift;
                dzs0s = dzs0 - av/2;
                dzs0e = dzs0 + av/2;

                /* find dz1 and dz2 */
                if( dzs0e - dzs0s < 0 ) 
                {
                    FLOAT temp;
                    temp = dzs0e;
                    dzs0e = dzs0s;
                    dzs0s = temp;
                }
                if( dzse - dzss < 0 ) 
                {
                    FLOAT temp;
                    temp = dzse;
                    dzse = dzss;
                    dzss = temp;
                }

                dz1 = dzs0s;
                dz2 = dzs0e;

                if( dzss > dz1 ) 
                { 
                    dz1 = dzss;
                }
                if( dzse < dz2 ) 
                {
                    dz2 = dzse;
                }

                if( dzss >= dz2 || dzse <= dz1 ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                }
                else
                {
                    dzs = dz1 + (dz2-dz1)/2;   
                    presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_slab_ratio*(dz2-dz1)), presscfh_slthick) : presscfh_slab_ratio*(dz2-dz1);
                    if( presscfh_slthick < opthickPS ) 
                    {
                        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                    }
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }         
            }

            if( presscfh_outrange == 0 ) 
            {
                Dz = dzs0 - dzs;
                al2 = av*av - Dz*Dz;
                if( al2 > 0 ) 
                {
                    al = sqrt(al2);
                } else {
                    al = 0;
                }
            }

            if( al >= presscfh_minfov_ratio*av ) 
            {
                dxl = dxs0;
                dyl = dys0;
                dzl = dzs;

                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_fov_ratio*al*2.0), presscfh_fov) : presscfh_fov_ratio*al*2.0;
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_pfov_ratio*al*2.0), presscfh_pfov) : presscfh_pfov_ratio*al*2.0;

                presscfh_info[vidx].oppsctloc = dzl;
                presscfh_info[vidx].oppscrloc = dxl;
                presscfh_info[vidx].oppscphasoff = dyl;
                for( ii = 0; ii < 9; ii++ ) 
                {
                    presscfh_info[vidx].oppscrot[ii] = scan_info[PSslice_num].oprot[ii]; 
                }
                presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov_ratio*al*2.0);
                presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov_ratio*al*2.0);
                presscfh_info[vidx].oppsclenz = (INT)presscfh_slthick;
            } 
            else 
            {
                presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
            }

            if( presscfh_debug ) 
            {
                printf("av, dxv, dyv, dzv: %8.2f, %8.2f, %8.2f, %8.2f\n", av, dxv, dyv, dzv);    
                printf("dxs, dys, dzs: %8.2f, %8.2f, %8.2f\n", dxs, dys, dzs);    
                printf("al, dxl, dyl, dzl: %8.2f, %8.2f, %8.2f, %8.2f\n", al, dxl, dyl, dzl);    
                printf("presscfh_slthick: %8.2f\n", presscfh_slthick);    
                printf("outrange: %d\n", presscfh_outrange);    
            }

            if( presscfh_outrange == 1 ) 
            {
                cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
                if(presscfh_debug) 
                {
                    printf("\nCFHcveval : THIS TURNS OUT TO BE PRESSCFH_NONE,but was initially %d\n",presscfh);
                    fflush(stdout);
                }
                break;
            }
        }
    } 

    if( (presscfh_ctrl == PRESSCFH_SHIMVOL ) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            presscfh_fov  = _presscfh_fov.fixedflag ?    ((void)(presscfh_fov_ratio*psc_info[vidx].oppsclenx), presscfh_fov) : presscfh_fov_ratio*psc_info[vidx].oppsclenx;
            presscfh_pfov  = _presscfh_pfov.fixedflag ?    ((void)(presscfh_pfov_ratio*psc_info[vidx].oppscleny), presscfh_pfov) : presscfh_pfov_ratio*psc_info[vidx].oppscleny;
            presscfh_slthick  = _presscfh_slthick.fixedflag ?    ((void)(presscfh_slab_ratio*psc_info[vidx].oppsclenz), presscfh_slthick) : presscfh_slab_ratio*psc_info[vidx].oppsclenz;

            presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov);
            presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov);
            presscfh_info[vidx].oppsclenz = (INT)(presscfh_slthick);

            if( presscfh_debug ) 
            {
                printf(": SHIM VOLUME %d presscfh=2; presscfh_fov=%8.2f\n", vidx, presscfh_fov);
                fflush(stdout);
            }
        }
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            if( presscfh_fov < presscfh_info[vidx].oppsclenx )
            {
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenx), presscfh_fov) : presscfh_info[vidx].oppsclenx;
            }
            if( presscfh_pfov < presscfh_info[vidx].oppscleny )
            {
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_info[vidx].oppscleny), presscfh_pfov) : presscfh_info[vidx].oppscleny;
            }
            if( presscfh_slthick < presscfh_info[vidx].oppsclenz )
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenz), presscfh_slthick) : presscfh_info[vidx].oppsclenz;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                if( presscfh_slice < opthickPS )
                {
                    presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;
                }
            }
        }

        presscfh_ir_slthick  = _presscfh_ir_slthick.fixedflag ?  ((void)(presscfh_slthick), presscfh_ir_slthick) : presscfh_slthick;

        rfpulse[RF3_CFH_SLOT].num = 1;
        rfpulse[RF3_CFH_SLOT].activity = PSD_CFH_ON;

        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;

            rfpulse[RF4_CFH_SLOT].num = 1;
            rfpulse[RF4_CFH_SLOT].activity = PSD_CFH_ON;
        }
        else
        {
            rfpulse[RF4_CFH_SLOT].num = 0; 
            rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
        }
    }
    else
    {
        rfpulse[RF3_CFH_SLOT].num = 0;
        rfpulse[RF3_CFH_SLOT].activity = PSD_PULSE_OFF;

        rfpulse[RF4_CFH_SLOT].num = 0; 
        rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* If inversion recovery image mode, Calcs for the Inversion pulse */
    if (PSD_ON == PSir)
    {
        res_rf0cfh  = _res_rf0cfh.fixedflag ?  ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC;  /* Adiabatic pulse */
        /* MRIge90312 -- use 1.5sec TR for IR cfh */
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(1500000), cfh_tr) : 1500000;
        gscale_rf0cfh  = _gscale_rf0cfh.fixedflag ?  ((void)(0.87), gscale_rf0cfh) : 0.87; /* Changed from .65 to .87 for adiabatic pulse */

        pw_gzrf0cfh    = _pw_gzrf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_gzrf0cfh) : pw_rf0cfh;

        /* Y Killer CVs */ /* YMSmr09211  04/26/2006 YI */
        if(amppwgrad(cfhir_killer_area, cfhloggrd.ty_yz, 0.0, 0.0, cfhloggrd.yrt,
                     MIN_PLATEAU_TIME, _a_gyrf0kcfh.fixedflag ? (_temp185_a_gyrf0kcfh=a_gyrf0kcfh,&_temp185_a_gyrf0kcfh) : &a_gyrf0kcfh, _pw_gyrf0kcfha.fixedflag ? (_temp186_pw_gyrf0kcfha=pw_gyrf0kcfha,&_temp186_pw_gyrf0kcfha) : &pw_gyrf0kcfha, _pw_gyrf0kcfh.fixedflag ? (_temp187_pw_gyrf0kcfh=pw_gyrf0kcfh,&_temp187_pw_gyrf0kcfh) : &pw_gyrf0kcfh, _pw_gyrf0kcfhd.fixedflag ? (_temp188_pw_gyrf0kcfhd=pw_gyrf0kcfhd,&_temp188_pw_gyrf0kcfhd) : &pw_gyrf0kcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgrad:gyrf0kcfh"); 
            return FAILURE;
        }

        rfpulse[RF0_CFH_SLOT].num = 1;
        rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON;
        bw_rf0cfh = (LONG)(5.12*cyc_rf0cfh/((FLOAT)pw_rf0cfh/(FLOAT)1000000)); /* adiabatic pulse */
 
        if(ampslice(_a_gzrf0cfh.fixedflag ? (_temp189_a_gzrf0cfh=a_gzrf0cfh,&_temp189_a_gzrf0cfh) : &a_gzrf0cfh, bw_rf0cfh, ((presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_ir_slthick),
                    gscale_rf0cfh, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gzrf0cfh.",EM_PSD_SUPPORT_FAILURE, 
                       EE_ARGS(1), STRING_ARG, "ampslice");
            return FAILURE;
        }
        /* Non Selective IR */
        if( (presscfh_ctrl != PRESSCFH_NONE) && presscfh_ir_noselect ) 
        {
            a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0), a_gzrf0cfh) : 0;
        }
        /* YMSmr09211  04/26/2006 YI */
        if(optramp(_pw_gzrf0cfha.fixedflag ? (_temp190_pw_gzrf0cfha=pw_gzrf0cfha,&_temp190_pw_gzrf0cfha) : &pw_gzrf0cfha,a_gzrf0cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gzrf0cfha.");
            return FAILURE;
        }
        pw_gzrf0cfhd  = _pw_gzrf0cfhd.fixedflag ?  ((void)(pw_gzrf0cfha), pw_gzrf0cfhd) : pw_gzrf0cfha;
    } else {
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(398000), cfh_tr) : 398000;
        rfpulse[RF0_CFH_SLOT].num = 0;
        rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* Calculations for the 90 pulse */
    pw_gzrf1cfh  = _pw_gzrf1cfh.fixedflag ?  ((void)(pw_rf1cfh), pw_gzrf1cfh) : pw_rf1cfh;
    bw_rf1cfh = (LONG)(rfpulse[RF1_CFH_SLOT].nom_bw*rfpulse[RF1_CFH_SLOT].nom_pw/(float)pw_rf1cfh);
       
    if (ampslice(_a_gzrf1cfh.fixedflag ? (_temp191_a_gzrf1cfh=a_gzrf1cfh,&_temp191_a_gzrf1cfh) : &a_gzrf1cfh, bw_rf1cfh, ( (presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_slthick),
                 gscale_rf1cfh, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    /* YMSmr09211  04/26/2006 YI */
    if (optramp(_pw_gzrf1cfha.fixedflag ? (_temp192_pw_gzrf1cfha=pw_gzrf1cfha,&_temp192_pw_gzrf1cfha) : &pw_gzrf1cfha, a_gzrf1cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfhd  = _pw_gzrf1cfhd.fixedflag ?  ((void)(pw_gzrf1cfha), pw_gzrf1cfhd) : pw_gzrf1cfha;

    /* Calculations for the 180 pulse */
    /* Have to rely on the PSD to keep these up to date - can't tell from
       here whether or not the PSD is a mempoid. */
    pw_gxrf2cfh  = _pw_gxrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gxrf2cfh) : pw_rf2cfh;
    pw_gyrf2cfh  = _pw_gyrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gyrf2cfh) : pw_rf2cfh;
    pw_gyrf3cfh  = _pw_gyrf3cfh.fixedflag ?  ((void)(pw_rf3cfh), pw_gyrf3cfh) : pw_rf3cfh; /* for presscfh */
    pw_gzrf4cfh  = _pw_gzrf4cfh.fixedflag ?  ((void)(pw_rf4cfh), pw_gzrf4cfh) : pw_rf4cfh; /* for presscfh-slice */ 

    /* Find amplitudes for the FOV selective traps */
    if (opcoax==1) 
    {
        /* If coaxial through isocenter */
        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,opfov/10.0)), cfh_fov) : FMin(2,40.0,opfov/10.0);
    } else {
        /* Otherwise open it up */
        cfh_fov  = _cfh_fov.fixedflag ?  ((void)(40.0), cfh_fov) : 40.0;
    }

    if(cfh_newmode) 
    {   /*override with new mode*/
        float cfh_new_fov = opspf ? (opphasefov*opfov/10.0) : (opfov/10.0);

        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,cfh_new_fov)), cfh_fov) : FMin(2,40.0,cfh_new_fov);
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground */
        cfh_fov  = _cfh_fov.fixedflag ?        ((void)((opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov)), cfh_fov) : (opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov);
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0);
        if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp193_pw_gxrf2cfha=pw_gxrf2cfha,&_temp193_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gxrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gxrf2cfh"); 
            return FAILURE;
        }
        pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
        pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
        target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */

        /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0)), a_gyrf3cfh) : 4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0);
        if (optramp(_pw_gyrf3cfha.fixedflag ? (_temp194_pw_gyrf3cfha=pw_gyrf3cfha,&_temp194_pw_gyrf3cfha) : &pw_gyrf3cfha, a_gyrf3cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gyrf3cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gyrf3cfh");
            return FAILURE;
        }
        pw_gyrf3cfha  = _pw_gyrf3cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha)), pw_gyrf3cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha);
        pw_gyrf3cfhd  = _pw_gyrf3cfhd.fixedflag ?  ((void)(pw_gyrf3cfha), pw_gyrf3cfhd) : pw_gyrf3cfha;
        target_cfh_crusher2  = _target_cfh_crusher2.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher2) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */

        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            /* Z SLICE Selective */
            a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0)), a_gzrf4cfh) : 4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0);
            if (optramp(_pw_gzrf4cfha.fixedflag ? (_temp195_pw_gzrf4cfha=pw_gzrf4cfha,&_temp195_pw_gzrf4cfha) : &pw_gzrf4cfha, a_gzrf4cfh, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gzrf4cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gzrf4cfh");
                return FAILURE;
            }
            pw_gzrf4cfha  = _pw_gzrf4cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha)), pw_gzrf4cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha);
            pw_gzrf4cfhd  = _pw_gzrf4cfhd.fixedflag ?  ((void)(pw_gzrf4cfha), pw_gzrf4cfhd) : pw_gzrf4cfha;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp196_a_gzrf2rcfh=a_gzrf2rcfh,&_temp196_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp197_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp197_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp198_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp198_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp199_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp199_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp200_a_gzrf3rcfh=a_gzrf3rcfh,&_temp200_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp201_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp201_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp202_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp202_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp203_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp203_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf3rcfha), pw_gzrf2lcfha) : pw_gzrf3rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf3rcfhd), pw_gzrf2lcfhd) : pw_gzrf3rcfhd;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp204_a_gzrf3rcfh=a_gzrf3rcfh,&_temp204_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp205_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp205_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp206_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp206_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp207_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp207_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }

            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp208_a_gzrf3lcfh=a_gzrf3lcfh,&_temp208_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp209_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp209_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp210_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp210_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp211_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp211_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4rcfh.fixedflag ? (_temp212_a_gzrf4rcfh=a_gzrf4rcfh,&_temp212_a_gzrf4rcfh) : &a_gzrf4rcfh, _pw_gzrf4rcfha.fixedflag ? (_temp213_pw_gzrf4rcfha=pw_gzrf4rcfha,&_temp213_pw_gzrf4rcfha) : &pw_gzrf4rcfha,
                              _pw_gzrf4rcfh.fixedflag ? (_temp214_pw_gzrf4rcfh=pw_gzrf4rcfh,&_temp214_pw_gzrf4rcfh) : &pw_gzrf4rcfh, _pw_gzrf4rcfhd.fixedflag ? (_temp215_pw_gzrf4rcfhd=pw_gzrf4rcfhd,&_temp215_pw_gzrf4rcfhd) : &pw_gzrf4rcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                              STRING_ARG, "amppwgrad:gzrf4rcfh"); 
                    return FAILURE;
                }

                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4lcfh.fixedflag ? (_temp216_a_gzrf4lcfh=a_gzrf4lcfh,&_temp216_a_gzrf4lcfh) : &a_gzrf4lcfh, _pw_gzrf4lcfha.fixedflag ? (_temp217_pw_gzrf4lcfha=pw_gzrf4lcfha,&_temp217_pw_gzrf4lcfha) : &pw_gzrf4lcfha,
                              _pw_gzrf4lcfh.fixedflag ? (_temp218_pw_gzrf4lcfh=pw_gzrf4lcfh,&_temp218_pw_gzrf4lcfh) : &pw_gzrf4lcfh, _pw_gzrf4lcfhd.fixedflag ? (_temp219_pw_gzrf4lcfhd=pw_gzrf4lcfhd,&_temp219_pw_gzrf4lcfhd) : &pw_gzrf4lcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gzrf4lcfh"); 
                    return FAILURE;
                }
            }
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp220_a_gzrf2rcfh=a_gzrf2rcfh,&_temp220_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp221_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp221_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp222_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp222_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp223_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp223_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }

            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp224_a_gzrf3lcfh=a_gzrf3lcfh,&_temp224_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp225_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp225_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp226_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp226_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp227_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp227_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }
        }
    } else {
        if (opspf == 0) 
        {
            /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp228_pw_gxrf2cfha=pw_gxrf2cfha,&_temp228_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gxrf2cfh.", 
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gxrf2cfh");
                return FAILURE;
            }
            pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
            pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */
        } 
        else 
        {
            /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gyrf2cfh  = _a_gyrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gyrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gyrf2cfha.fixedflag ? (_temp229_pw_gyrf2cfha=pw_gyrf2cfha,&_temp229_pw_gyrf2cfha) : &pw_gyrf2cfha, a_gyrf2cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gyrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gyrf2cfh");
                return FAILURE;
            }
            pw_gyrf2cfha  = _pw_gyrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha)), pw_gyrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha);
            pw_gyrf2cfhd  = _pw_gyrf2cfhd.fixedflag ?  ((void)(pw_gyrf2cfha), pw_gyrf2cfhd) : pw_gyrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */
        }

        /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
        if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp230_a_gzrf2rcfh=a_gzrf2rcfh,&_temp230_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp231_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp231_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                      _pw_gzrf2rcfh.fixedflag ? (_temp232_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp232_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp233_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp233_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gzrf2rcfh"); 
            return FAILURE;
        }

        pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
        pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
    }

    area_gz1cfh = (PSoff90 + pw_rf1cfh/2.0 + pw_gzrf1cfhd/2.0)*a_gzrf1cfh;
    /* YMSmr09211  04/26/2006 YI */
    if (amppwlcrsh(&psd_cfhleftcrush, &psd_cfhrightcrush,
                   area_gz1cfh, (float)0, cfhloggrd.tz_xz, 
                   MIN_PLATEAU_TIME, cfhloggrd.zrt, _dummy_pw.fixedflag ? (_temp234_dummy_pw=dummy_pw,&_temp234_dummy_pw) : &dummy_pw) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwlcrsh for gzrf2lcfh");
        return FAILURE;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        FLOAT area_g1 = (pw_gxrf2cfh + pw_gxrf2cfha)*a_gxrf2cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.tx, 0.0, 0.0, cfhloggrd.xrt,
                      MIN_PLATEAU_TIME, _a_gx1cfh.fixedflag ? (_temp235_a_gx1cfh=a_gx1cfh,&_temp235_a_gx1cfh) : &a_gx1cfh, _pw_gx1cfha.fixedflag ? (_temp236_pw_gx1cfha=pw_gx1cfha,&_temp236_pw_gx1cfha) : &pw_gx1cfha,
                      _pw_gx1cfh.fixedflag ? (_temp237_pw_gx1cfh=pw_gx1cfh,&_temp237_pw_gx1cfh) : &pw_gx1cfh, _pw_gx1cfhd.fixedflag ? (_temp238_pw_gx1cfhd=pw_gx1cfhd,&_temp238_pw_gx1cfhd) : &pw_gx1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gx1cfh"); 
            return FAILURE;
        }

        area_g1 = (pw_gyrf3cfh + pw_gyrf3cfhd)*a_gyrf3cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gy1cfh.fixedflag ? (_temp239_a_gy1cfh=a_gy1cfh,&_temp239_a_gy1cfh) : &a_gy1cfh, _pw_gy1cfha.fixedflag ? (_temp240_pw_gy1cfha=pw_gy1cfha,&_temp240_pw_gy1cfha) : &pw_gy1cfha,
                      _pw_gy1cfh.fixedflag ? (_temp241_pw_gy1cfh=pw_gy1cfh,&_temp241_pw_gy1cfh) : &pw_gy1cfh, _pw_gy1cfhd.fixedflag ? (_temp242_pw_gy1cfhd=pw_gy1cfhd,&_temp242_pw_gy1cfhd) : &pw_gy1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gy1cfh"); 
            return FAILURE;
        }
    }

    /* Find Params for killer pulse */ /* YMSmr09211  04/26/2006 YI */
    area_gykcfh  = _area_gykcfh.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfh) : amp_killer*pw_killer;
    if (amppwgrad(area_gykcfh, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                  MIN_PLATEAU_TIME, _a_gykcfh.fixedflag ? (_temp243_a_gykcfh=a_gykcfh,&_temp243_a_gykcfh) : &a_gykcfh, _pw_gykcfha.fixedflag ? (_temp244_pw_gykcfha=pw_gykcfha,&_temp244_pw_gykcfha) : &pw_gykcfha,
                  _pw_gykcfh.fixedflag ? (_temp245_pw_gykcfh=pw_gykcfh,&_temp245_pw_gykcfh) : &pw_gykcfh, _pw_gykcfhd.fixedflag ? (_temp246_pw_gykcfhd=pw_gykcfhd,&_temp246_pw_gykcfhd) : &pw_gykcfhd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfh");
        return FAILURE;
    }
    return SUCCESS;
}

/*
 *  PScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScveval( void )
{
    STATUS ps_status;
    FLOAT opthickPS;
    INT i,j; /* YMSmr09211  04/26/2006 YI */
    INT num_cfhlocs;

    /*********************************************************************
     * Generic SECTION
     *********************************************************************/
   
    /* Set the modes for presscfh */
    set_presscfh_mode();

    /* YMSmr09211  04/26/2006 YI */
    if( ( presscfh_ctrl == PRESSCFH_SHIMVOL ) || ( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        num_cfhlocs = exist(oppscvquant);
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = psc_info[i].oppscrot[j];
            }
        }
    }
    else
    {
        num_cfhlocs = IMax(2, 1, exist(oppscvquant));
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = scan_info[PSslice_num].oprot[j];
            }
        }
    }

    cfh_newgeo  = _cfh_newgeo.fixedflag ?  ((void)(1), cfh_newgeo) : 1;
    if (obloptimize(&cfhloggrd, &phygrd, cfh_info, num_cfhlocs,
                    PSD_OBL, 0, obl_method, cfhobl_debug, _cfh_newgeo.fixedflag ? (_temp247_cfh_newgeo=cfh_newgeo,&_temp247_cfh_newgeo) : &cfh_newgeo, cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"%s failed in %s",
                   EM_PSD_FUNCTION_FAILURE,EE_ARGS(2),STRING_ARG,"obloptimize",STRING_ARG,"PScveval()");
        return FAILURE; 

    }

    /* derate SR for quiet PSC */ 
    sr_derate(&cfhloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if (opimode == PSD_3D)  
    {
        opthickPS = 10.0;
    } 
    else 
    {
            opthickPS = (exist(opslthick) < 3.5) ? 3.5 : exist(opslthick);
        }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1cveval( &opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1cveval");
        return ps_status;
    }

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLcveval");
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNcveval( )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNcveval");
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHcveval");
        return ps_status;
    }

    /***********************************************************************
     * Programmable Prescan SECTION
     ***********************************************************************/

    /* Check for valid Optprescan entry points */
    if(pimrsapsflg) {
        int ipi;
        char strmrs[16] = "pimrsaps1";

        for (ipi = 0; ipi < PSC_MAX_CONTROL_ARRAY; ipi++) 
        {
            switch(*pimrs[ipi]) 
            {
            case MRSAPS_OFF: case MRSAPS_CFL: case MRSAPS_TG:
            case MRSAPS_CFH: case MRSAPS_TR: case MRSAPS_FSEPS:
            case MRSAPS_AWS: case MRSAPS_AVS: case MRSAPS_XTG:
            case MRSAPS_AS: case MRSAPS_FTG: case MRSAPS_RCVN:
            case MRSAPS_XTG_SPINE:
            case MRSAPS_RFSHIM: case MRSAPS_DYNTG:
            case MRSAPS_CAL: case MRSAPS_AUTOCOIL:
                break;
            default:
                sprintf(strmrs, "pimrsaps%d", ipi + 1);
                epic_error(use_ermes, "%s is out of range.",
                           EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                           STRING_ARG, strmrs);
                return FAILURE;
            }
        }
    } /* end pimrsapsflg check */

    return SUCCESS;
}   /* end PScveval() */


/*
 *  FTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcveval( void )
{
    LONG bw_rf1ftg;
    LONG bw_rf2ftg;
    LONG bw_rf3ftg;
    FLOAT area_g1ftg;
    FLOAT area_g2ftg;
    FLOAT area_g2bftg;
    FLOAT area_g3ftg;
    FLOAT area_postgxw1ftg;
    FLOAT area_gxw1ftg;
    FLOAT area_gx1ftg;
    FLOAT area_gx2ftg;
    INT PosReadoutWindow;  /* Readout window location            */
    INT ftg_xrt;
    FLOAT ftg_tx;
    FLOAT ftg_tx_xz;
    FLOAT ftg_tz_xz;
    FLOAT ftg_tx_xyz;
    INT FTGtau1check1, FTGtau1check2, FTGtau1check3,
        FTGtau1check4, FTGtau1check5, FTGtau1check6, temp_FTGtau1;

    /* HCSDM00161809: for calculation of minimum FTGtau1 */
    FTGtau1  = _FTGtau1.fixedflag ?    ((void)(8192), FTGtau1) : 8192;
    FTGtau1check1   = FTGtau1;
    FTGtau1check2   = FTGtau1;
    FTGtau1check3   = FTGtau1;
    FTGtau1check4   = FTGtau1;
    FTGtau1check5   = FTGtau1;
    FTGtau1check6   = FTGtau1;
    temp_FTGtau1    = FTGtau1;
    
    ftg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ftg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ftg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ftg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    ftg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);

    FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

    FTGopslthickz1  = _FTGopslthickz1.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz1) : 4*FTGslthk;
    FTGopslthickz2  = _FTGopslthickz2.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz2) : 4*FTGslthk;
    FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(FTGslthk), FTGopslthickz3) : FTGslthk;
    gscale_rf1ftg   = _gscale_rf1ftg.fixedflag ?  ((void)(0.90909), gscale_rf1ftg) : 0.90909;
    gscale_rf2ftg   = _gscale_rf2ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf2ftg) : gscale_rf1ftg;
    gscale_rf3ftg   = _gscale_rf3ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf3ftg) : gscale_rf1ftg;
    pw_gzrf1ftg  = _pw_gzrf1ftg.fixedflag ?  ((void)(pw_rf1ftg), pw_gzrf1ftg) : pw_rf1ftg;
    pw_gzrf2ftg  = _pw_gzrf2ftg.fixedflag ?  ((void)(pw_rf2ftg), pw_gzrf2ftg) : pw_rf2ftg;
    pw_gzrf3ftg  = _pw_gzrf3ftg.fixedflag ?  ((void)(pw_rf3ftg), pw_gzrf3ftg) : pw_rf3ftg;

    /* 12/07/94 YI temporary change to avoid internal error with Vectra SGC coil */
    if( cfgradcoil == GCOIL_VECTRA )
    {
        FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(7), FTGopslthickz3) : 7;
    }
    
    bw_rf1ftg = (LONG)(4 * cyc_rf1ftg/ ((FLOAT)pw_rf1ftg/ (FLOAT)1000000));

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    if( ampslice(_a_gzrf1ftg.fixedflag ? (_temp248_a_gzrf1ftg=a_gzrf1ftg,&_temp248_a_gzrf1ftg) : &a_gzrf1ftg, bw_rf1ftg, FTGopslthickz1, gscale_rf1ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1ftg.");
        return FAILURE;
    }
    
    bw_rf2ftg = (LONG)(4 * cyc_rf2ftg/ ((FLOAT)pw_rf2ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf2ftg.fixedflag ? (_temp249_a_gzrf2ftg=a_gzrf2ftg,&_temp249_a_gzrf2ftg) : &a_gzrf2ftg, bw_rf2ftg, FTGopslthickz2, gscale_rf2ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2ftg.");
        return FAILURE;
    }
    
 
    bw_rf3ftg = (LONG)(4 * cyc_rf3ftg/ ((FLOAT)pw_rf3ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf3ftg.fixedflag ? (_temp250_a_gzrf3ftg=a_gzrf3ftg,&_temp250_a_gzrf3ftg) : &a_gzrf3ftg, bw_rf3ftg, FTGopslthickz3, gscale_rf3ftg, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf3ftg.");
        return FAILURE;
    }
    if( optramp(_pw_gzrf1ftga.fixedflag ? (_temp251_pw_gzrf1ftga=pw_gzrf1ftga,&_temp251_pw_gzrf1ftga) : &pw_gzrf1ftga, a_gzrf1ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1ftga.");
        return FAILURE;
    }    
    
    pw_gzrf1ftgd  = _pw_gzrf1ftgd.fixedflag ?  ((void)(pw_gzrf1ftga), pw_gzrf1ftgd) : pw_gzrf1ftga;

    if (optramp(_pw_gzrf2ftga.fixedflag ? (_temp252_pw_gzrf2ftga=pw_gzrf2ftga,&_temp252_pw_gzrf2ftga) : &pw_gzrf2ftga, a_gzrf2ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2ftga.");
        return FAILURE;
    }    
    
    pw_gzrf2ftgd  = _pw_gzrf2ftgd.fixedflag ?  ((void)(pw_gzrf2ftga), pw_gzrf2ftgd) : pw_gzrf2ftga;
 
 
    /* Find Params for first zgrad refocusing pulse */
    area_g1ftg = ( a_gzrf1ftg *.5* ( pw_gzrf1ftg + pw_gzrf1ftgd)
                   + a_gzrf2ftg *.5 * (pw_gzrf2ftga + pw_gzrf2ftg) );
    if( amppwgz1(_a_gz1ftg.fixedflag ? (_temp253_a_gz1ftg=a_gz1ftg,&_temp253_a_gz1ftg) : &a_gz1ftg, _pw_gz1ftg.fixedflag ? (_temp254_pw_gz1ftg=pw_gz1ftg,&_temp254_pw_gz1ftg) : &pw_gz1ftg, _pw_gz1ftga.fixedflag ? (_temp255_pw_gz1ftga=pw_gz1ftga,&_temp255_pw_gz1ftga) : &pw_gz1ftga, _pw_gz1ftgd.fixedflag ? (_temp256_pw_gz1ftgd=pw_gz1ftgd,&_temp256_pw_gz1ftgd) : &pw_gz1ftgd,
                 area_g1ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1ftg.");
        return FAILURE;
    }
    

    /* Find Params for refocusing pulse gz2ftg */
    area_g2ftg =  a_gzrf2ftg *.5* ( pw_gzrf2ftg + pw_gzrf2ftgd);
    if( amppwgz1(_a_gz2ftg.fixedflag ? (_temp257_a_gz2ftg=a_gz2ftg,&_temp257_a_gz2ftg) : &a_gz2ftg, _pw_gz2ftg.fixedflag ? (_temp258_pw_gz2ftg=pw_gz2ftg,&_temp258_pw_gz2ftg) : &pw_gz2ftg, _pw_gz2ftga.fixedflag ? (_temp259_pw_gz2ftga=pw_gz2ftga,&_temp259_pw_gz2ftga) : &pw_gz2ftga, _pw_gz2ftgd.fixedflag ? (_temp260_pw_gz2ftgd=pw_gz2ftgd,&_temp260_pw_gz2ftgd) : &pw_gz2ftgd,
                 area_g2ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE ) {
	epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz2ftg.");
	return FAILURE;
    }
 
    /* Find Params for refocusing pulse gz2btg */

    /* MRIge56170  AF  10/13/99 */
    if( optramp(_pw_gzrf3ftga.fixedflag ? (_temp261_pw_gzrf3ftga=pw_gzrf3ftga,&_temp261_pw_gzrf3ftga) : &pw_gzrf3ftga, a_gzrf3ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf3ftga.");
        return FAILURE;
    }

    area_g2bftg =  a_gzrf3ftg * .5 *(pw_gzrf3ftga + pw_gzrf3ftg);
    if( amppwgz1(_a_gz2bftg.fixedflag ? (_temp262_a_gz2bftg=a_gz2bftg,&_temp262_a_gz2bftg) : &a_gz2bftg, _pw_gz2bftg.fixedflag ? (_temp263_pw_gz2bftg=pw_gz2bftg,&_temp263_pw_gz2bftg) : &pw_gz2bftg, _pw_gz2bftga.fixedflag ? (_temp264_pw_gz2bftga=pw_gz2bftga,&_temp264_pw_gz2bftga) : &pw_gz2bftga, _pw_gz2bftgd.fixedflag ? (_temp265_pw_gz2bftgd=pw_gz2bftgd,&_temp265_pw_gz2bftgd) : &pw_gz2bftgd,
                 area_g2bftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, ":amppwgz1 for gz2bftg.");
        return FAILURE;
    }
    
    pw_gzrf3ftgd  = _pw_gzrf3ftgd.fixedflag ?  ((void)(pw_gzrf3ftga), pw_gzrf3ftgd) : pw_gzrf3ftga;
 
    /* Find Params for refocusing pulse */
    area_g3ftg =  a_gzrf3ftg *.5* ( pw_gzrf3ftg + pw_gzrf3ftgd);
    if( amppwgz1(_a_gz3ftg.fixedflag ? (_temp266_a_gz3ftg=a_gz3ftg,&_temp266_a_gz3ftg) : &a_gz3ftg, _pw_gz3ftg.fixedflag ? (_temp267_pw_gz3ftg=pw_gz3ftg,&_temp267_pw_gz3ftg) : &pw_gz3ftg, _pw_gz3ftga.fixedflag ? (_temp268_pw_gz3ftga=pw_gz3ftga,&_temp268_pw_gz3ftga) : &pw_gz3ftga, _pw_gz3ftgd.fixedflag ? (_temp269_pw_gz3ftgd=pw_gz3ftgd,&_temp269_pw_gz3ftgd) : &pw_gz3ftgd,
                 area_g3ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE )
    {

        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz3ftg.");
        return FAILURE;
    }
    
    if( calcfilter( &echo1ftg_filt, FTGecho1bw, FTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1ftg_filt");
        return FAILURE;
    }

    if( ampfov(_a_gxw1ftg.fixedflag ? (_temp270_a_gxw1ftg=a_gxw1ftg,&_temp270_a_gxw1ftg) : &a_gxw1ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1ftg.");
        return FAILURE;
 
    }
 
    pw_gxw1ftg  = _pw_gxw1ftg.fixedflag ?  ((void)(RUP_GRD((int)(echo1ftg_filt.tdaq)/4)), pw_gxw1ftg) : RUP_GRD((int)(echo1ftg_filt.tdaq)/4);

    area_gxw1ftg = 2.0*a_gxw1ftg*(float)(pw_gxw1ftg);
 
    if( amppwgx1(_a_gx1ftg.fixedflag ? (_temp271_a_gx1ftg=a_gx1ftg,&_temp271_a_gx1ftg) : &a_gx1ftg, _pw_gx1ftg.fixedflag ? (_temp272_pw_gx1ftg=pw_gx1ftg,&_temp272_pw_gx1ftg) : &pw_gx1ftg, _pw_gx1ftga.fixedflag ? (_temp273_pw_gx1ftga=pw_gx1ftga,&_temp273_pw_gx1ftga) : &pw_gx1ftga, _pw_gx1ftgd.fixedflag ? (_temp274_pw_gx1ftgd=pw_gx1ftgd,&_temp274_pw_gx1ftgd) : &pw_gx1ftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");
        return FAILURE;
    }
    
    if( amppwgx1(_a_gx2test.fixedflag ? (_temp275_a_gx2test=a_gx2test,&_temp275_a_gx2test) : &a_gx2test, _pw_gx2test.fixedflag ? (_temp276_pw_gx2test=pw_gx2test,&_temp276_pw_gx2test) : &pw_gx2test, _pw_gx2testa.fixedflag ? (_temp277_pw_gx2testa=pw_gx2testa,&_temp277_pw_gx2testa) : &pw_gx2testa, _pw_gx2testd.fixedflag ? (_temp278_pw_gx2testd=pw_gx2testd,&_temp278_pw_gx2testd) : &pw_gx2testd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");

        return FAILURE;
    }
    
 
    area_gxw1ftg = a_gxw1ftg*(float)(pw_gxw1ftg);
    if( amppwgx1(_a_gx1bftg.fixedflag ? (_temp279_a_gx1bftg=a_gx1bftg,&_temp279_a_gx1bftg) : &a_gx1bftg, _pw_gx1bftg.fixedflag ? (_temp280_pw_gx1bftg=pw_gx1bftg,&_temp280_pw_gx1bftg) : &pw_gx1bftg, _pw_gx1bftga.fixedflag ? (_temp281_pw_gx1bftga=pw_gx1bftga,&_temp281_pw_gx1bftga) : &pw_gx1bftga, _pw_gx1bftgd.fixedflag ? (_temp282_pw_gx1bftgd=pw_gx1bftgd,&_temp282_pw_gx1bftgd) : &pw_gx1bftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s call failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1:gx1btg");
    }

    if( optramp(_pw_gxw1ftga.fixedflag ? (_temp283_pw_gxw1ftga=pw_gxw1ftga,&_temp283_pw_gxw1ftga) : &pw_gxw1ftga, a_gxw1ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1ftga.");
        return FAILURE;
    }    
    
    pw_gxw1ftgd  = _pw_gxw1ftgd.fixedflag ?  ((void)(pw_gxw1ftga), pw_gxw1ftgd) : pw_gxw1ftga;
 
    area_postgxw1ftg = ( 3.0 * a_gxw1ftg * (float)(pw_gxw1ftg)
                         - 0.5 * a_gxw1ftg * (pw_gxw1ftga + pw_gxw1ftgd) );
    if( amppwgx1(_a_postgxw1ftg.fixedflag ? (_temp284_a_postgxw1ftg=a_postgxw1ftg,&_temp284_a_postgxw1ftg) : &a_postgxw1ftg, _pw_postgxw1ftg.fixedflag ? (_temp285_pw_postgxw1ftg=pw_postgxw1ftg,&_temp285_pw_postgxw1ftg) : &pw_postgxw1ftg, _pw_postgxw1ftga.fixedflag ? (_temp286_pw_postgxw1ftga=pw_postgxw1ftga,&_temp286_pw_postgxw1ftga) : &pw_postgxw1ftga,
                 _pw_postgxw1ftgd.fixedflag ? (_temp287_pw_postgxw1ftgd=pw_postgxw1ftgd,&_temp287_pw_postgxw1ftgd) : &pw_postgxw1ftgd, TYPSPIN, area_postgxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for postgxw1ftg.");
        return FAILURE;
    }
    
    if( ampfov(_a_gxw2ftg.fixedflag ? (_temp288_a_gxw2ftg=a_gxw2ftg,&_temp288_a_gxw2ftg) : &a_gxw2ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw2ftg.");
        return FAILURE;
    }
    
    pw_gxw2ftg  = _pw_gxw2ftg.fixedflag ?  ((void)(RUP_GRD((int)(4.0*(float)pw_gxw1ftg))), pw_gxw2ftg) : RUP_GRD((int)(4.0*(float)pw_gxw1ftg));
    if( optramp(_pw_gxw2ftga.fixedflag ? (_temp289_pw_gxw2ftga=pw_gxw2ftga,&_temp289_pw_gxw2ftga) : &pw_gxw2ftga, a_gxw2ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    { 
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw2ftga.");
 
        return FAILURE;
    }
    
    pw_gxw2ftgd  = _pw_gxw2ftgd.fixedflag ?  ((void)(pw_gxw2ftga), pw_gxw2ftgd) : pw_gxw2ftga;
 
    /* We want S1 to refocus tau1 ms after rf3.  The gx2tg refocusing
       pulse accomplishes this.  gxw2tg pulse can't start before the
       end of the gz3tg refocussing pulse (why bother collecting
       corrupt data? ). */
    area_gx1ftg = a_gx1ftg * (0.5 * (float)(pw_gx1ftga + pw_gx1ftgd) + pw_gx1ftg);
 
    /* Starting readout window position relative to center of rf3 */
    PosReadoutWindow = ( pw_rf3ftg/2 + pw_gzrf3ftgd + pw_gz3ftga
                         + pw_gz3ftg + pw_gz3ftgd );
 
    pw_gxw2ftgleft  = _pw_gxw2ftgleft.fixedflag ?  ((void)(RUP_GRD(echo1ftg_filt.tdaq/8)), pw_gxw2ftgleft) : RUP_GRD(echo1ftg_filt.tdaq/8);   /* 1/8th of readout window to left of S1 */

    area_gx2ftg = area_gx1ftg - a_gxw2ftg * (float)(pw_gxw2ftga/ 2 + pw_gxw2ftgleft);
 
    if( amppwgrad(area_gx2ftg, ftg_tx_xz,
                  0.0, 0.0, ftg_xrt,
                  MIN_PLATEAU_TIME, _a_gx2ftg.fixedflag ? (_temp290_a_gx2ftg=a_gx2ftg,&_temp290_a_gx2ftg) : &a_gx2ftg, _pw_gx2ftga.fixedflag ? (_temp291_pw_gx2ftga=pw_gx2ftga,&_temp291_pw_gx2ftga) : &pw_gx2ftga,
                  _pw_gx2ftg.fixedflag ? (_temp292_pw_gx2ftg=pw_gx2ftg,&_temp292_pw_gx2ftg) : &pw_gx2ftg, _pw_gx2ftgd.fixedflag ? (_temp293_pw_gx2ftgd=pw_gx2ftgd,&_temp293_pw_gx2ftgd) : &pw_gx2ftgd) == FAILURE ) {
        epic_error(use_ermes, "%s failed in fasttg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gx2ftg");
        return FAILURE;
    }
   
    if( (pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft
         > FTGtau1) || (pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft > FTGtau1) )
    {
        /* return FAILURE; */
    }
    
    /* HCSDM00161809: calculate minimum FTGtau1 */
    FTGtau1check1 = RUP_GRD(pw_rf1ftg/2+pw_gx1ftga+pw_gx1ftg+pw_gx1ftgd+pw_rf2ftg/2);
    FTGtau1check2 = RUP_GRD(pw_rf1ftg/2+pw_gzrf1ftgd+pw_gz1ftga+pw_gz1ftg+pw_gz1ftgd+pw_gzrf2ftga+pw_rf2ftg/2);
    FTGtau1check3 = RUP_GRD(pw_rf2ftg/2+pw_gx1bftga+pw_gx1bftg+pw_gx1bftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check4 = RUP_GRD(pw_rf2ftg/2+pw_gzrf2ftgd+pw_gz2ftga+pw_gz2ftg+pw_gz2ftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check5 = RUP_GRD(pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft);
    FTGtau1check6 = RUP_GRD(pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft);

    temp_FTGtau1 = IMax(7, FTGtau1, FTGtau1check1, FTGtau1check2, FTGtau1check3, FTGtau1check4, FTGtau1check5, FTGtau1check6);

    cvoverride(FTGtau1, temp_FTGtau1, PSD_FIX_OFF, PSD_EXIST_ON);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;
    
    strcpy(entry_point_table[L_FTG].epname, "fasttg");
 
    return SUCCESS;
}   /* end FTGcveval() */


/*
 *  XTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcveval( void )
{
    LONG bw_rf1xtg;
    LONG bw_rf2xtg;
    FLOAT area_g1xtg;
    FLOAT area_gxw1xtg;
    INT ta_180, tb_180;
    FLOAT area_gxw1rampxtg;
    INT xtg_xrt, xtg_yrt;
    FLOAT xtg_tx;
    FLOAT xtg_tx_xz;
    FLOAT xtg_tz_xz;
    FLOAT xtg_tx_xyz, xtg_ty_xyz, xtg_tz_xyz;
    FLOAT xtg_temp_float;
    INT XTGspf;
    INT timeBeforeFermi; /* Time before Off resonance Fermi pulse */

    XTGspf = (TGspf && (PSD_OFF == local_tg));
    XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), XTGfov) : FMin(2,480.0,cfsystemmaxfov);

    if(0 == getAps1Mod())
    {
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,opfov,XTGfov)), XTGfov) : FMin(2,opfov,XTGfov);
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMax(2,XTGfov,MINFOV_TG)), XTGfov) : FMax(2,XTGfov,MINFOV_TG);
    }

    xtg_xrt = (XTGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    xtg_yrt = (XTGspf ? ps1loggrd.xrt : ps1loggrd.yrt);
    xtg_tx = (XTGspf ? ps1loggrd.ty : ps1loggrd.tx);
    xtg_tx_xz = (XTGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    xtg_tz_xz = (XTGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    xtg_tz_xyz = ps1loggrd.tz_xyz;
    xtg_tx_xyz = (XTGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);
    xtg_ty_xyz = (XTGspf ? ps1loggrd.tx_xyz : ps1loggrd.ty_xyz);

    gscale_rf1xtg   = _gscale_rf1xtg.fixedflag ?  ((void)(0.90909), gscale_rf1xtg) : 0.90909;
    gscale_rf2xtg   = _gscale_rf2xtg.fixedflag ?  ((void)(gscale_rf1xtg), gscale_rf2xtg) : gscale_rf1xtg;

    pw_gzrf2xtg  = _pw_gzrf2xtg.fixedflag ?  ((void)(pw_rf2xtg), pw_gzrf2xtg) : pw_rf2xtg;

    XTGecho1bw  = _XTGecho1bw.fixedflag ?  ((void)(15.625), XTGecho1bw) : 15.625;

    bw_rf1xtg = (LONG)(4 * cyc_rf1xtg/ ((FLOAT)pw_rf1xtg/ (FLOAT)1000000));

    if(PSD_ON == local_tg)
    {
        pw_gyrf1xtg  = _pw_gyrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gyrf1xtg) : pw_rf1xtg;
        XTGfov  = _XTGfov.fixedflag ?  ((void)(TGopslthickx), XTGfov) : TGopslthickx;

        if( ampslice(_a_gyrf1xtg.fixedflag ? (_temp294_a_gyrf1xtg=a_gyrf1xtg,&_temp294_a_gyrf1xtg) : &a_gyrf1xtg, bw_rf1xtg, TGopslthicky, gscale_rf1xtg, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gyrf1xtga.fixedflag ? (_temp295_pw_gyrf1xtga=pw_gyrf1xtga,&_temp295_pw_gyrf1xtga) : &pw_gyrf1xtga, a_gyrf1xtg, ps1loggrd.ty, ps1loggrd.yrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1xtga.");
            return FAILURE;
        }    

        pw_gyrf1xtgd  = _pw_gyrf1xtgd.fixedflag ?  ((void)(pw_gyrf1xtga), pw_gyrf1xtgd) : pw_gyrf1xtga;

    }
    else
    {
        pw_gzrf1xtg  = _pw_gzrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gzrf1xtg) : pw_rf1xtg;

        if( ampslice(_a_gzrf1xtg.fixedflag ? (_temp296_a_gzrf1xtg=a_gzrf1xtg,&_temp296_a_gzrf1xtg) : &a_gzrf1xtg, bw_rf1xtg, TGopslthick, gscale_rf1xtg, TYPDEF)
        == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gzrf1xtga.fixedflag ? (_temp297_pw_gzrf1xtga=pw_gzrf1xtga,&_temp297_pw_gzrf1xtga) : &pw_gzrf1xtga, a_gzrf1xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1xtga.");
            return FAILURE;
        }    

        pw_gzrf1xtgd  = _pw_gzrf1xtgd.fixedflag ?  ((void)(pw_gzrf1xtga), pw_gzrf1xtgd) : pw_gzrf1xtga;

    }

    bw_rf2xtg = (LONG)(4 * cyc_rf2xtg/ ((FLOAT)pw_rf2xtg/ (FLOAT)1000000));

    if( ampslice(_a_gzrf2xtg.fixedflag ? (_temp298_a_gzrf2xtg=a_gzrf2xtg,&_temp298_a_gzrf2xtg) : &a_gzrf2xtg, bw_rf2xtg, TGopslthick, gscale_rf2xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2xtg.");
        return FAILURE;
    }

    if (optramp(_pw_gzrf2xtga.fixedflag ? (_temp299_pw_gzrf2xtga=pw_gzrf2xtga,&_temp299_pw_gzrf2xtga) : &pw_gzrf2xtga, a_gzrf2xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2xtga.");
        return FAILURE;
    }    

    pw_gzrf2xtgd  = _pw_gzrf2xtgd.fixedflag ?  ((void)(pw_gzrf2xtga), pw_gzrf2xtgd) : pw_gzrf2xtga;

    /* Z CRUSHER CVs */ 
    if(PSD_ON == local_tg)
    {
        area_g1xtg = 0.0;
    }
    else
    {
        area_g1xtg = (PSoff90 + pw_gzrf1xtg/2.0 + pw_gzrf1xtgd/2.0)*a_gzrf1xtg;
    }
    area_xtgzkiller  = _area_xtgzkiller.fixedflag ?  ((void)(amp_killer*pw_killer+area_g1xtg), area_xtgzkiller) : amp_killer*pw_killer+area_g1xtg;
    if (amppwgrad(area_xtgzkiller, xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz2xtg.fixedflag ? (_temp300_a_gz2xtg=a_gz2xtg,&_temp300_a_gz2xtg) : &a_gz2xtg, _pw_gz2xtga.fixedflag ? (_temp301_pw_gz2xtga=pw_gz2xtga,&_temp301_pw_gz2xtga) : &pw_gz2xtga,
                  _pw_gz2xtg.fixedflag ? (_temp302_pw_gz2xtg=pw_gz2xtg,&_temp302_pw_gz2xtg) : &pw_gz2xtg, _pw_gz2xtgd.fixedflag ? (_temp303_pw_gz2xtgd=pw_gz2xtgd,&_temp303_pw_gz2xtgd) : &pw_gz2xtgd) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz2xtg"); 
        return FAILURE;
    }

    if (amppwgrad((area_xtgzkiller-area_g1xtg), xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz1xtg.fixedflag ? (_temp304_a_gz1xtg=a_gz1xtg,&_temp304_a_gz1xtg) : &a_gz1xtg, _pw_gz1xtga.fixedflag ? (_temp305_pw_gz1xtga=pw_gz1xtga,&_temp305_pw_gz1xtga) : &pw_gz1xtga,
                  _pw_gz1xtg.fixedflag ? (_temp306_pw_gz1xtg=pw_gz1xtg,&_temp306_pw_gz1xtg) : &pw_gz1xtg, _pw_gz1xtgd.fixedflag ? (_temp307_pw_gz1xtgd=pw_gz1xtgd,&_temp307_pw_gz1xtgd) : &pw_gz1xtgd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz1xtg"); 
        return FAILURE;
    }

    /* use 16kHz, 256 xres */
    if( calcfilter( &echo1xtg_filt, XTGecho1bw, XTGxres, OVERWRITE_NONE)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1xtg_filt");
        return FAILURE;
    }
    
    if (ampfov(&xtg_temp_float, echo1xtg_filt.bw, xtg_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "xtg ampfov");
        return FAILURE;
    }

    xtg_temp_float = ceil(xtg_temp_float/ 10.0) * 10.0;
    if( xtg_temp_float > XTGfov )
    {
        XTGfov  = _XTGfov.fixedflag ?  ((void)(xtg_temp_float), XTGfov) : xtg_temp_float;
    }

    if( ampfov(_a_gxw1xtg.fixedflag ? (_temp308_a_gxw1xtg=a_gxw1xtg,&_temp308_a_gxw1xtg) : &a_gxw1xtg, echo1xtg_filt.bw, XTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1xtg.");
        return FAILURE;        
    }

    if( optramp(_pw_gxw1xtga.fixedflag ? (_temp309_pw_gxw1xtga=pw_gxw1xtga,&_temp309_pw_gxw1xtga) : &pw_gxw1xtga, a_gxw1xtg, xtg_tx,
                xtg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1xtga.");
        return FAILURE;
    }    

    pw_gxw1xtgd  = _pw_gxw1xtgd.fixedflag ?  ((void)(pw_gxw1xtga), pw_gxw1xtgd) : pw_gxw1xtga;
    
    pw_gxw1xtg  = _pw_gxw1xtg.fixedflag ?  ((void)(RUP_GRD((int)(echo1xtg_filt.tdaq))), pw_gxw1xtg) : RUP_GRD((int)(echo1xtg_filt.tdaq));
    
    area_gxw1xtg = a_gxw1xtg*(float)(pw_gxw1xtg);
    area_gxw1rampxtg = 0.5*a_gxw1xtg*(float)(pw_gxw1xtga);
    
    if( amppwgx1(_a_gx1bxtg.fixedflag ? (_temp310_a_gx1bxtg=a_gx1bxtg,&_temp310_a_gx1bxtg) : &a_gx1bxtg, _pw_gx1bxtg.fixedflag ? (_temp311_pw_gx1bxtg=pw_gx1bxtg,&_temp311_pw_gx1bxtg) : &pw_gx1bxtg, _pw_gx1bxtga.fixedflag ? (_temp312_pw_gx1bxtga=pw_gx1bxtga,&_temp312_pw_gx1bxtga) : &pw_gx1bxtga, _pw_gx1bxtgd.fixedflag ? (_temp313_pw_gx1bxtgd=pw_gx1bxtgd,&_temp313_pw_gx1bxtgd) : &pw_gx1bxtgd,
                 TYPSPIN, area_gxw1xtg, area_gxw1rampxtg,
                 1000000, 1.0, MIN_PLATEAU_TIME, xtg_xrt, xtg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1bxtg.");
        return FAILURE;
    }
    a_gx1bxtg  = _a_gx1bxtg.fixedflag ?  ((void)(-a_gx1bxtg), a_gx1bxtg) : -a_gx1bxtg;

    /* Find Params for killer pulse */
    if(PSD_ON == local_tg)
    {
        area_g1xtg = (PSoff90 + pw_gyrf1xtg/2.0 + pw_gyrf1xtgd/2.0)*a_gyrf1xtg;
    }
    else
    {
        area_g1xtg = 0.0;
    }
    area_xtgykiller  = _area_xtgykiller.fixedflag ?  ((void)(amp_killer*pw_killer), area_xtgykiller) : amp_killer*pw_killer;
    if (amppwgrad(area_xtgykiller-area_g1xtg, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgl.fixedflag ? (_temp314_a_gykxtgl=a_gykxtgl,&_temp314_a_gykxtgl) : &a_gykxtgl, _pw_gykxtgla.fixedflag ? (_temp315_pw_gykxtgla=pw_gykxtgla,&_temp315_pw_gykxtgla) : &pw_gykxtgla,
                  _pw_gykxtgl.fixedflag ? (_temp316_pw_gykxtgl=pw_gykxtgl,&_temp316_pw_gykxtgl) : &pw_gykxtgl, _pw_gykxtgld.fixedflag ? (_temp317_pw_gykxtgld=pw_gykxtgld,&_temp317_pw_gykxtgld) : &pw_gykxtgld) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgl");
        return FAILURE;
    }
    
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgr.fixedflag ? (_temp318_a_gykxtgr=a_gykxtgr,&_temp318_a_gykxtgr) : &a_gykxtgr, _pw_gykxtgra.fixedflag ? (_temp319_pw_gykxtgra=pw_gykxtgra,&_temp319_pw_gykxtgra) : &pw_gykxtgra,
                  _pw_gykxtgr.fixedflag ? (_temp320_pw_gykxtgr=pw_gykxtgr,&_temp320_pw_gykxtgr) : &pw_gykxtgr, _pw_gykxtgrd.fixedflag ? (_temp321_pw_gykxtgrd=pw_gykxtgrd,&_temp321_pw_gykxtgrd) : &pw_gykxtgrd) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgr");
        return FAILURE;
    }
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;
 
    /* XTGtau1 */
    /* 1. Compute ta_180 */
    /*    Compute timeBeforeFermi as time after RF1 and before FermiL, accouting for min_ssp */
    if(PSD_ON == local_tg)
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GyRF1d */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd );
        }
        else
        {
            /* GyRF1d + YKillerL */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd + pw_gykxtgla+pw_gykxtgl+pw_gykxtgld );  
        }
    }
    else
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GzRF1d */
            timeBeforeFermi = IMax(2, min_ssp, pw_gzrf1xtgd);
        }
        else
        {
            /* MAX(GzRF1d,YKillerL), since YKillerL can be applied during GzRF1d) */
            timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf1xtgd, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld));
        }
    }
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL + FermiL + MAX(ZDephaser,YKillerL) + HALF(GzRF2) */
        ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + IMax(2, pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld) + pw_gzrf2xtg/2;
    }
    else
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL(including YKillerL) + FermiL + ZDephaser + HALF(GzRF2) */
         ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + pw_gz1xtga + pw_gz1xtg+pw_gz1xtgd+pw_gzrf2xtga+pw_gzrf2xtg/2;
    }

    /* 2. Compute tb_180 */
    /*    Compute timeBeforeFermi as time after RF2 and before FermiR, accouting for min_ssp */  
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* MAX(ZRephaser,YKillerR), since YKillerR can be applied during ZRephaser */
        timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd));
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser and YKillerR) + FermiR + XReadoutDephaser + HALFeadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd + pw_gxw1xtga+pw_gxw1xtg/2;
    }
    else
    {
        /* MAX of XReadoutDephaser and YKillerR */
        timeBeforeFermi = IMax(2, min_ssp, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd);
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser) + FermiR + MAX(YKillerR,XReadoutDephaser) + HALF(ReadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + IMax(2, pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd) + pw_gxw1xtga+pw_gxw1xtg/2;
    }   

    /* 3. Compute XTGtau1 based on ta_180 and tb180 */
    XTGtau1  = _XTGtau1.fixedflag ?    ((void)(RUP_GRD(IMax(2,ta_180,tb_180))), XTGtau1) : RUP_GRD(IMax(2,ta_180,tb_180)); 
    
    strcpy(entry_point_table[L_XTG].epname, "expresstg");
 
    return SUCCESS;
}   /* end XTGcveval() */

/* 
 *  RScveval
 *  Description:
 *  CV eval for RFShim 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
RScveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1rs, area_gx1rs;
    FLOAT area_gxkbsrs, area_gxkrs;
    FLOAT area_gzkbsrs, area_gzkrs;
    FLOAT area_gx2rs;
    FLOAT temp_float;
    LONG bw_rf1rs;

    echo1bwrs  = _echo1bwrs.fixedflag ?  ((void)(31.25), echo1bwrs) : 31.25;
    rfshim_baseline  = _rfshim_baseline.fixedflag ?  ((void)(0), rfshim_baseline) : 0;
    rfshim_xres  = _rfshim_xres.fixedflag ?  ((void)(64), rfshim_xres) : 64;
    rfshim_yres  = _rfshim_yres.fixedflag ?  ((void)(64), rfshim_yres) : 64;
    rfshim_slthick  = _rfshim_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), rfshim_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if( (PSD_ON == rsaxial_flag) )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(460), rfshim_fov) : 460;
        if(isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD))
        {
            rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(280), rfshim_fov) : 280;  /* 28 cm FOV for head scans */
        }

    }

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* I/Q DD cal needs to double flip */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10), flip_rf1rs) : 10;
    rfshim_flipangle  = _rfshim_flipangle.fixedflag ?  ((void)(flip_rf1rs), rfshim_flipangle) : flip_rf1rs;

    rfshim_slquant  = _rfshim_slquant.fixedflag ?  ((void)(1), rfshim_slquant) : 1;
    rfshim_slquant  = _rfshim_slquant.fixedflag ?    ((void)(IMin(2,RFSHIM_SLQ,rfshim_slquant)), rfshim_slquant) : IMin(2,RFSHIM_SLQ,rfshim_slquant);

    pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(RUP_GRD(pw_rf1rs)), pw_rf1rs) : RUP_GRD(pw_rf1rs);

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            bw_rf1rs = (LONG)(4*cyc_rf1rs/((float)pw_rf1rs/(float)1000000));
            rs_iso_delay   = _rs_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw)), rs_iso_delay) : RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1rs = (LONG)(rfpulse[RF1_RFSHIM_SLOT].nom_bw*rfpulse[RF1_RFSHIM_SLOT].nom_pw/pw_rf1rs);
            rs_iso_delay  = _rs_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw))), rs_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw));
            break;
    }


    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    if (FAILURE==ampslice(_a_gzrf1rs.fixedflag ? (_temp322_a_gzrf1rs=a_gzrf1rs,&_temp322_a_gzrf1rs) : &a_gzrf1rs, bw_rf1rs, rfshim_slthick, gscale_rf1rs, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1rs.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1rsa.fixedflag ? (_temp323_pw_gzrf1rsa=pw_gzrf1rsa,&_temp323_pw_gzrf1rsa) : &pw_gzrf1rsa, a_gzrf1rs, rsloggrd.tz_xyz, rsloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1rsa.");
        return FAILURE;
    }
    pw_gzrf1rsd  = _pw_gzrf1rsd.fixedflag ?  ((void)(pw_gzrf1rsa), pw_gzrf1rsd) : pw_gzrf1rsa;

    /* Z BLS killer */
    area_gzkbsrs = 1.0E6*3.0*10.0/GAM/exist(rfshim_slthick);

    if (FAILURE==amppwgrad(area_gzkbsrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsrs.fixedflag ? (_temp324_a_gzkbsrs=a_gzkbsrs,&_temp324_a_gzkbsrs) : &a_gzkbsrs, _pw_gzkbsrsa.fixedflag ? (_temp325_pw_gzkbsrsa=pw_gzkbsrsa,&_temp325_pw_gzkbsrsa) : &pw_gzkbsrsa,
                           _pw_gzkbsrs.fixedflag ? (_temp326_pw_gzkbsrs=pw_gzkbsrs,&_temp326_pw_gzkbsrs) : &pw_gzkbsrs, _pw_gzkbsrsd.fixedflag ? (_temp327_pw_gzkbsrsd=pw_gzkbsrsd,&_temp327_pw_gzkbsrsd) : &pw_gzkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsrs");
        return FAILURE;
    }

    if (a_gzrf1rs>0.0)
    {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsrs)), a_gzkbsrs) : -1.0*fabsf(a_gzkbsrs);
    } else {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(fabsf(a_gzkbsrs)), a_gzkbsrs) : fabsf(a_gzkbsrs);
    }

    rst_exa  = _rst_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay)), rst_exa) : RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay);
    rst_exb  = _rst_exb.fixedflag ?  ((void)(rs_iso_delay), rst_exb) : rs_iso_delay;

    area_gz1rs = (rs_iso_delay + (pw_gzrf1rsd/ 2.0)) * a_gzrf1rs;
    if (area_gz1rs > 0.0)
    {
        area_gz1rs -= fabsf(area_gzkbsrs);
    }
    else
    {
        area_gz1rs += fabsf(area_gzkbsrs);
    }

    if (amppwgz1(_a_gz1rs.fixedflag ? (_temp328_a_gz1rs=a_gz1rs,&_temp328_a_gz1rs) : &a_gz1rs,_pw_gz1rs.fixedflag ? (_temp329_pw_gz1rs=pw_gz1rs,&_temp329_pw_gz1rs) : &pw_gz1rs,_pw_gz1rsa.fixedflag ? (_temp330_pw_gz1rsa=pw_gz1rsa,&_temp330_pw_gz1rsa) : &pw_gz1rsa,_pw_gz1rsd.fixedflag ? (_temp331_pw_gz1rsd=pw_gz1rsd,&_temp331_pw_gz1rsd) : &pw_gz1rsd,area_gz1rs,
                 (int)(1000000),MIN_PLATEAU_TIME,rsloggrd.zrt,rsloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1rs.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkrs = 980;

    if (FAILURE==amppwgrad(area_gzkrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkrs.fixedflag ? (_temp332_a_gzkrs=a_gzkrs,&_temp332_a_gzkrs) : &a_gzkrs, _pw_gzkrsa.fixedflag ? (_temp333_pw_gzkrsa=pw_gzkrsa,&_temp333_pw_gzkrsa) : &pw_gzkrsa,
                           _pw_gzkrs.fixedflag ? (_temp334_pw_gzkrs=pw_gzkrs,&_temp334_pw_gzkrs) : &pw_gzkrs, _pw_gzkrsd.fixedflag ? (_temp335_pw_gzkrsd=pw_gzkrsd,&_temp335_pw_gzkrsd) : &pw_gzkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkrs");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1rs_filt, echo1bwrs, rfshim_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rs_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1rs_filt.bw, rsloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > rfshim_fov )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(temp_float), rfshim_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwrs.fixedflag ? (_temp336_a_gxwrs=a_gxwrs,&_temp336_a_gxwrs) : &a_gxwrs, echo1rs_filt.bw, rfshim_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwrs.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwrsa.fixedflag ? (_temp337_pw_gxwrsa=pw_gxwrsa,&_temp337_pw_gxwrsa) : &pw_gxwrsa, a_gxwrs, rsloggrd.tx_xyz, rsloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwrsa.");
        return FAILURE;
    }

    pw_gxwrsd  = _pw_gxwrsd.fixedflag ?  ((void)(pw_gxwrsa), pw_gxwrsd) : pw_gxwrsa;
    pw_acqrs1  = _pw_acqrs1.fixedflag ?  ((void)(echo1rs_filt.tdaq), pw_acqrs1) : echo1rs_filt.tdaq;  /* one echo data */

    rd_ext_rs  = _rd_ext_rs.fixedflag ?  
                        ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_rs) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwrs  = _pw_gxwrs.fixedflag ?      ((void)(pw_acqrs1+e2_delay_rs+rd_ext_rs), pw_gxwrs) : pw_acqrs1+e2_delay_rs+rd_ext_rs;  /* total readout */

    /* X BLS killer */
    area_gxkbsrs = area_gzkbsrs;

    if (FAILURE==amppwgrad(area_gxkbsrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsrs.fixedflag ? (_temp338_a_gxkbsrs=a_gxkbsrs,&_temp338_a_gxkbsrs) : &a_gxkbsrs, _pw_gxkbsrsa.fixedflag ? (_temp339_pw_gxkbsrsa=pw_gxkbsrsa,&_temp339_pw_gxkbsrsa) : &pw_gxkbsrsa,
                           _pw_gxkbsrs.fixedflag ? (_temp340_pw_gxkbsrs=pw_gxkbsrs,&_temp340_pw_gxkbsrs) : &pw_gxkbsrs, _pw_gxkbsrsd.fixedflag ? (_temp341_pw_gxkbsrsd=pw_gxkbsrsd,&_temp341_pw_gxkbsrsd) : &pw_gxkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RFcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsrs");
        return FAILURE;
    }

    if (a_gxwrs>0.0)
    {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsrs)), a_gxkbsrs) : -1.0*fabsf(a_gxkbsrs);
    } else {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(fabsf(a_gxkbsrs)), a_gxkbsrs) : fabsf(a_gxkbsrs);
    }

    /* combine gxkbs and gx1 */
    area_gx1rs = area_gxkbsrs - (pw_gxwrs+pw_gxwrsa)/2.0*a_gxwrs;

    if (FAILURE==amppwgrad(area_gx1rs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1rs.fixedflag ? (_temp342_a_gx1rs=a_gx1rs,&_temp342_a_gx1rs) : &a_gx1rs, _pw_gx1rsa.fixedflag ? (_temp343_pw_gx1rsa=pw_gx1rsa,&_temp343_pw_gx1rsa) : &pw_gx1rsa,
                           _pw_gx1rs.fixedflag ? (_temp344_pw_gx1rs=pw_gx1rs,&_temp344_pw_gx1rs) : &pw_gx1rs, _pw_gx1rsd.fixedflag ? (_temp345_pw_gx1rsd=pw_gx1rsd,&_temp345_pw_gx1rsd) : &pw_gx1rsd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1rs.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkrs = 980;
    if (FAILURE==amppwgrad(area_gxkrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkrs.fixedflag ? (_temp346_a_gxkrs=a_gxkrs,&_temp346_a_gxkrs) : &a_gxkrs, _pw_gxkrsa.fixedflag ? (_temp347_pw_gxkrsa=pw_gxkrsa,&_temp347_pw_gxkrsa) : &pw_gxkrsa,
                           _pw_gxkrs.fixedflag ? (_temp348_pw_gxkrs=pw_gxkrs,&_temp348_pw_gxkrs) : &pw_gxkrs, _pw_gxkrsd.fixedflag ? (_temp349_pw_gxkrsd=pw_gxkrsd,&_temp349_pw_gxkrsd) : &pw_gxkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkrs");
        return FAILURE;
    }

    if(rfshim_etl >=2)
    {
        pw_gxw2rs  = _pw_gxw2rs.fixedflag ?  ((void)(pw_gxwrs), pw_gxw2rs) : pw_gxwrs;
        pw_gxw2rsa  = _pw_gxw2rsa.fixedflag ?  ((void)(pw_gxwrsa), pw_gxw2rsa) : pw_gxwrsa;
        pw_gxw2rsd  = _pw_gxw2rsd.fixedflag ?  ((void)(pw_gxwrsd), pw_gxw2rsd) : pw_gxwrsd;
        a_gxw2rs  = _a_gxw2rs.fixedflag ?  ((void)(a_gxwrs), a_gxw2rs) : a_gxwrs;

        area_gx2rs = -(pw_gxw2rs+(pw_gxw2rsa+pw_gxw2rsd)/2.0)*a_gxw2rs;

        if (FAILURE==amppwgrad(area_gx2rs, rsloggrd.tx_xy, 0.0, 0.0, rsloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2rs.fixedflag ? (_temp350_a_gx2rs=a_gx2rs,&_temp350_a_gx2rs) : &a_gx2rs, _pw_gx2rsa.fixedflag ? (_temp351_pw_gx2rsa=pw_gx2rsa,&_temp351_pw_gx2rsa) : &pw_gx2rsa,
                               _pw_gx2rs.fixedflag ? (_temp352_pw_gx2rs=pw_gx2rs,&_temp352_pw_gx2rs) : &pw_gx2rs, _pw_gx2rsd.fixedflag ? (_temp353_pw_gx2rsd=pw_gx2rsd,&_temp353_pw_gx2rsd) : &pw_gx2rsd ))
        {
            epic_error(use_ermes, "%s failed in RScveval.", EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2rs");
            return FAILURE;
        }

        rs_esp  = _rs_esp.fixedflag ?                
                                                
                                                  
                                                
                                                  ((void)(RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd))), rs_esp) : RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd));

    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(rfshim_yres), _endview_iamprs.fixedflag ? (_temp354_endview_iamprs=endview_iamprs,&_temp354_endview_iamprs) : &endview_iamprs) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:RFShim B1 map");
        return FAILURE;
    } 
  
    endview_scalers  = _endview_scalers.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamprs), endview_scalers) : (float)max_pg_iamp/(float)endview_iamprs;

    if ( FAILURE==amppwtpe(_a_gy1rsa.fixedflag ? (_temp355_a_gy1rsa=a_gy1rsa,&_temp355_a_gy1rsa) : &a_gy1rsa, _a_gy1rsb.fixedflag ? (_temp356_a_gy1rsb=a_gy1rsb,&_temp356_a_gy1rsb) : &a_gy1rsb, _pw_gy1rs.fixedflag ? (_temp357_pw_gy1rs=pw_gy1rs,&_temp357_pw_gy1rs) : &pw_gy1rs, _pw_gy1rsa.fixedflag ? (_temp358_pw_gy1rsa=pw_gy1rsa,&_temp358_pw_gy1rsa) : &pw_gy1rsa, _pw_gy1rsd.fixedflag ? (_temp359_pw_gy1rsd=pw_gy1rsd,&_temp359_pw_gy1rsd) : &pw_gy1rsd,
                           rsloggrd.ty_xyz/endview_scalers,rsloggrd.yrt,
                           (0.5 * (FLOAT)(rfshim_yres-1))/(rfshim_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:RFShim B1 map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rrs  = _a_gy1rrs.fixedflag ?  ((void)(a_gy1rs), a_gy1rrs) : a_gy1rs;
    a_gy1rrsa  = _a_gy1rrsa.fixedflag ?  ((void)(a_gy1rsa), a_gy1rrsa) : a_gy1rsa;
    a_gy1rrsb  = _a_gy1rrsb.fixedflag ?  ((void)(a_gy1rsb), a_gy1rrsb) : a_gy1rsb;
    pw_gy1rrs  = _pw_gy1rrs.fixedflag ?  ((void)(pw_gy1rs), pw_gy1rrs) : pw_gy1rs;
    pw_gy1rrsa  = _pw_gy1rrsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy1rrsa) : pw_gy1rsa;
    pw_gy1rrsd  = _pw_gy1rrsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy1rrsd) : pw_gy1rsd;

    a_gy2rs  = _a_gy2rs.fixedflag ?  ((void)(a_gy1rs), a_gy2rs) : a_gy1rs;
    a_gy2rsa  = _a_gy2rsa.fixedflag ?  ((void)(a_gy1rsa), a_gy2rsa) : a_gy1rsa;
    a_gy2rsb  = _a_gy2rsb.fixedflag ?  ((void)(a_gy1rsb), a_gy2rsb) : a_gy1rsb;
    pw_gy2rs  = _pw_gy2rs.fixedflag ?  ((void)(pw_gy1rs), pw_gy2rs) : pw_gy1rs;
    pw_gy2rsa  = _pw_gy2rsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy2rsa) : pw_gy1rsa;
    pw_gy2rsd  = _pw_gy2rsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy2rsd) : pw_gy1rsd;


    td0rs  = _td0rs.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()))), td0rs) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1rsd + pw_gz1rsa + pw_gz1rs + pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd);
    temp_time2 = IMax(3, pw_gx1rsa + pw_gx1rs + pw_gx1rsd + pw_gxwrsa, pw_gy1rsa + pw_gy1rs + pw_gy1rsd,
                      pw_gzkbsrsa + pw_gzkbsrs + pw_gzkbsrsd);

    min_rste  = _min_rste.fixedflag ?            ((void)(RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0)), min_rste) : RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0);

    temp_time = IMax(3, pw_gxwrsd + pw_gxkrsa + pw_gxkrs + pw_gxkrsd, pw_gy1rrsa + pw_gy1rrs + pw_gy1rrsd,
                     pw_gzkrsa + pw_gzkrs + pw_gzkrsd);

    tr_rs  = _tr_rs.fixedflag ?              ((void)(RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp)), tr_rs) : RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp);

    return SUCCESS;
} /* end RScveval */

/* 
 *  DTGcveval
 *  Description:
 *  CV eval for DynTG B1map 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
DTGcveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1dtg, area_gx1dtg;
    FLOAT area_gxkbsdtg, area_gxkdtg, area_gzkbsdtg, area_gzkdtg, area_gx2dtg;
    FLOAT temp_float;
    LONG bw_rf1dtg;
    int maptg_newgeo = 1;
    int rotation_index;

    if ( PSD_ON == enableMapTg)
    {
		for( rotation_index = 0; rotation_index < 9; rotation_index++)
		{
			maptgscan_info[0].oprot[rotation_index] = 0.0;
		}

        /* Axial Scan with Freq R/L */
		maptgscan_info[0].oprot[0] = maptgscan_info[0].oprot[4] = maptgscan_info[0].oprot[8] = 1.0;

		if (obloptimize(&maptgloggrd, &phygrd, maptgscan_info, 1, PSD_OBL,
					0, obl_method, ps1obl_debug, &maptg_newgeo,
					cfsrmode) == FAILURE)
		{
			epic_error(use_ermes, "%s failed in DTGcvinit.", EM_PSD_SUPPORT_FAILURE,
					EE_ARGS(1), STRING_ARG, "obloptimize"); 
			return FAILURE;
		}

		/* derate SR for silent PSC */ 
		sr_derate(&maptgloggrd, PSsr_derate_factor, PSamp_derate_factor);

        dtgloggrd = maptgloggrd; /* Map TG uses Axial scan */
    }
    else
    {
        dtgloggrd = loggrd; /* same as imaging loggrd */
    }

    echo1bwdtg  = _echo1bwdtg.fixedflag ?  ((void)(31.25), echo1bwdtg) : 31.25;
    dynTG_baseline  = _dynTG_baseline.fixedflag ?  ((void)(0), dynTG_baseline) : 0;
    dynTG_xres  = _dynTG_xres.fixedflag ?  ((void)(64), dynTG_xres) : 64;
    dynTG_yres  = _dynTG_yres.fixedflag ?  ((void)(64), dynTG_yres) : 64;
    dynTG_slthick  = _dynTG_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), dynTG_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if(PSD_ON == enableMapTg)
    {
        /* Setting FOV for map TG */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), dynTG_fov) : FMin(2,480.0,cfsystemmaxfov);
    }
    else
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMax(2,exist(opfov),80.0)), dynTG_fov) : FMax(2,exist(opfov),80.0);  /* limit to min FOV of 80mm */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,dynTG_fov,(float)FOV_MAX)), dynTG_fov) : FMin(2,dynTG_fov,(float)FOV_MAX);
    }

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180), flip_rfbdtg) : 180;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10), flip_rf1dtg) : 10;

    dynTG_flipangle  = _dynTG_flipangle.fixedflag ?  ((void)(flip_rf1dtg), dynTG_flipangle) : flip_rf1dtg;

    pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(RUP_GRD(pw_rf1dtg)), pw_rf1dtg) : RUP_GRD(pw_rf1dtg);

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            bw_rf1dtg = (LONG)(4*cyc_rf1dtg/((float)pw_rf1dtg/(float)1000000));
            dtg_iso_delay   = _dtg_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw)), dtg_iso_delay) : RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1dtg = (LONG)(rfpulse[RF1_DYNTG_SLOT].nom_bw*rfpulse[RF1_DYNTG_SLOT].nom_pw/pw_rf1dtg);
            dtg_iso_delay  = _dtg_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw))), dtg_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw));
            break;
    }

    if(PSD_ON == enableMapTg)
    {
        dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(MAPTG_SLQ), dynTG_slquant) : MAPTG_SLQ;
    }
    else
    {
        if (exist(opslquant)<=DYNTG_SLQ)
        {
            if (1 == (exist(opslquant) % 2))
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(exist(opslquant)), dynTG_slquant) : exist(opslquant);
            }
            else
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?    ((void)(exist(opslquant)-1), dynTG_slquant) : exist(opslquant)-1;
            }
        }
        else
        {
            dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(DYNTG_SLQ), dynTG_slquant) : DYNTG_SLQ;
        }
    }

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    if (FAILURE==ampslice(_a_gzrf1dtg.fixedflag ? (_temp360_a_gzrf1dtg=a_gzrf1dtg,&_temp360_a_gzrf1dtg) : &a_gzrf1dtg, bw_rf1dtg, dynTG_slthick, gscale_rf1dtg, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1dtg.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1dtga.fixedflag ? (_temp361_pw_gzrf1dtga=pw_gzrf1dtga,&_temp361_pw_gzrf1dtga) : &pw_gzrf1dtga, a_gzrf1dtg, dtgloggrd.tz_xyz, dtgloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1dtga.");
        return FAILURE;
    }
    pw_gzrf1dtgd  = _pw_gzrf1dtgd.fixedflag ?  ((void)(pw_gzrf1dtga), pw_gzrf1dtgd) : pw_gzrf1dtga;

    /* Z BLS killer */
    area_gzkbsdtg = 1.0E6*3.0*10.0/GAM/exist(dynTG_slthick);

    if (FAILURE==amppwgrad(area_gzkbsdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsdtg.fixedflag ? (_temp362_a_gzkbsdtg=a_gzkbsdtg,&_temp362_a_gzkbsdtg) : &a_gzkbsdtg, _pw_gzkbsdtga.fixedflag ? (_temp363_pw_gzkbsdtga=pw_gzkbsdtga,&_temp363_pw_gzkbsdtga) : &pw_gzkbsdtga,
                           _pw_gzkbsdtg.fixedflag ? (_temp364_pw_gzkbsdtg=pw_gzkbsdtg,&_temp364_pw_gzkbsdtg) : &pw_gzkbsdtg, _pw_gzkbsdtgd.fixedflag ? (_temp365_pw_gzkbsdtgd=pw_gzkbsdtgd,&_temp365_pw_gzkbsdtgd) : &pw_gzkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsdtg"); 
        return FAILURE;
    }

    if (a_gzrf1dtg>0.0)
    {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsdtg)), a_gzkbsdtg) : -1.0*fabsf(a_gzkbsdtg);
    } else {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(fabsf(a_gzkbsdtg)), a_gzkbsdtg) : fabsf(a_gzkbsdtg);
    }

    dtgt_exa  = _dtgt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay)), dtgt_exa) : RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay);
    dtgt_exb  = _dtgt_exb.fixedflag ?  ((void)(dtg_iso_delay), dtgt_exb) : dtg_iso_delay;

    area_gz1dtg = (dtg_iso_delay + (pw_gzrf1dtgd/ 2.0)) * a_gzrf1dtg;
    if (area_gz1dtg > 0.0)
    {
        area_gz1dtg -= fabsf(area_gzkbsdtg);
    }
    else
    {
        area_gz1dtg += fabsf(area_gzkbsdtg);
    }

    if (amppwgz1(_a_gz1dtg.fixedflag ? (_temp366_a_gz1dtg=a_gz1dtg,&_temp366_a_gz1dtg) : &a_gz1dtg,_pw_gz1dtg.fixedflag ? (_temp367_pw_gz1dtg=pw_gz1dtg,&_temp367_pw_gz1dtg) : &pw_gz1dtg,_pw_gz1dtga.fixedflag ? (_temp368_pw_gz1dtga=pw_gz1dtga,&_temp368_pw_gz1dtga) : &pw_gz1dtga,_pw_gz1dtgd.fixedflag ? (_temp369_pw_gz1dtgd=pw_gz1dtgd,&_temp369_pw_gz1dtgd) : &pw_gz1dtgd,area_gz1dtg,
                 (int)(1000000),MIN_PLATEAU_TIME,dtgloggrd.zrt,dtgloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1dtg.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkdtg = 980;

    if (FAILURE==amppwgrad(area_gzkdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkdtg.fixedflag ? (_temp370_a_gzkdtg=a_gzkdtg,&_temp370_a_gzkdtg) : &a_gzkdtg, _pw_gzkdtga.fixedflag ? (_temp371_pw_gzkdtga=pw_gzkdtga,&_temp371_pw_gzkdtga) : &pw_gzkdtga,
                           _pw_gzkdtg.fixedflag ? (_temp372_pw_gzkdtg=pw_gzkdtg,&_temp372_pw_gzkdtg) : &pw_gzkdtg, _pw_gzkdtgd.fixedflag ? (_temp373_pw_gzkdtgd=pw_gzkdtgd,&_temp373_pw_gzkdtgd) : &pw_gzkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkdtg"); 
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1dtg_filt, echo1bwdtg, dynTG_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1dtg_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1dtg_filt.bw, dtgloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > dynTG_fov )
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?  ((void)(temp_float), dynTG_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwdtg.fixedflag ? (_temp374_a_gxwdtg=a_gxwdtg,&_temp374_a_gxwdtg) : &a_gxwdtg, echo1dtg_filt.bw, dynTG_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwdtg.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwdtga.fixedflag ? (_temp375_pw_gxwdtga=pw_gxwdtga,&_temp375_pw_gxwdtga) : &pw_gxwdtga, a_gxwdtg, dtgloggrd.tx_xyz, dtgloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwdtga.");
        return FAILURE;
    }

    pw_gxwdtgd  = _pw_gxwdtgd.fixedflag ?  ((void)(pw_gxwdtga), pw_gxwdtgd) : pw_gxwdtga;
    pw_acqdtg1  = _pw_acqdtg1.fixedflag ?  ((void)(echo1dtg_filt.tdaq), pw_acqdtg1) : echo1dtg_filt.tdaq;  /* one echo data */

    rd_ext_dtg  = _rd_ext_dtg.fixedflag ?  
                           ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_dtg) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwdtg  = _pw_gxwdtg.fixedflag ?      ((void)(pw_acqdtg1+e2_delay_dtg+rd_ext_dtg), pw_gxwdtg) : pw_acqdtg1+e2_delay_dtg+rd_ext_dtg;  /* total readout */

    /* X BLS killer */
    area_gxkbsdtg = area_gzkbsdtg;

    if (FAILURE==amppwgrad(area_gxkbsdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsdtg.fixedflag ? (_temp376_a_gxkbsdtg=a_gxkbsdtg,&_temp376_a_gxkbsdtg) : &a_gxkbsdtg, _pw_gxkbsdtga.fixedflag ? (_temp377_pw_gxkbsdtga=pw_gxkbsdtga,&_temp377_pw_gxkbsdtga) : &pw_gxkbsdtga,
                           _pw_gxkbsdtg.fixedflag ? (_temp378_pw_gxkbsdtg=pw_gxkbsdtg,&_temp378_pw_gxkbsdtg) : &pw_gxkbsdtg, _pw_gxkbsdtgd.fixedflag ? (_temp379_pw_gxkbsdtgd=pw_gxkbsdtgd,&_temp379_pw_gxkbsdtgd) : &pw_gxkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsdtg"); 
        return FAILURE;
    }

    if (a_gxwdtg>0.0)
    {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsdtg)), a_gxkbsdtg) : -1.0*fabsf(a_gxkbsdtg);
    } else {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(fabsf(a_gxkbsdtg)), a_gxkbsdtg) : fabsf(a_gxkbsdtg);
    }

    /* combine gxkbs and gx1dtg */
    area_gx1dtg = area_gxkbsdtg - (pw_gxwdtg+pw_gxwdtga)/2.0*a_gxwdtg;

    if (FAILURE==amppwgrad(area_gx1dtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1dtg.fixedflag ? (_temp380_a_gx1dtg=a_gx1dtg,&_temp380_a_gx1dtg) : &a_gx1dtg, _pw_gx1dtga.fixedflag ? (_temp381_pw_gx1dtga=pw_gx1dtga,&_temp381_pw_gx1dtga) : &pw_gx1dtga,
                           _pw_gx1dtg.fixedflag ? (_temp382_pw_gx1dtg=pw_gx1dtg,&_temp382_pw_gx1dtg) : &pw_gx1dtg, _pw_gx1dtgd.fixedflag ? (_temp383_pw_gx1dtgd=pw_gx1dtgd,&_temp383_pw_gx1dtgd) : &pw_gx1dtgd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1dtg.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkdtg = 980;
    if (FAILURE==amppwgrad(area_gxkdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkdtg.fixedflag ? (_temp384_a_gxkdtg=a_gxkdtg,&_temp384_a_gxkdtg) : &a_gxkdtg, _pw_gxkdtga.fixedflag ? (_temp385_pw_gxkdtga=pw_gxkdtga,&_temp385_pw_gxkdtga) : &pw_gxkdtga,
                           _pw_gxkdtg.fixedflag ? (_temp386_pw_gxkdtg=pw_gxkdtg,&_temp386_pw_gxkdtg) : &pw_gxkdtg, _pw_gxkdtgd.fixedflag ? (_temp387_pw_gxkdtgd=pw_gxkdtgd,&_temp387_pw_gxkdtgd) : &pw_gxkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkdtg"); 
        return FAILURE;
    }

    /* echo train */
    if(dynTG_etl >= 2)
    {
        pw_gxw2dtg  = _pw_gxw2dtg.fixedflag ?  ((void)(pw_gxwdtg), pw_gxw2dtg) : pw_gxwdtg;
        pw_gxw2dtga  = _pw_gxw2dtga.fixedflag ?  ((void)(pw_gxwdtga), pw_gxw2dtga) : pw_gxwdtga;
        pw_gxw2dtgd  = _pw_gxw2dtgd.fixedflag ?  ((void)(pw_gxwdtgd), pw_gxw2dtgd) : pw_gxwdtgd;
        a_gxw2dtg  = _a_gxw2dtg.fixedflag ?  ((void)(a_gxwdtg), a_gxw2dtg) : a_gxwdtg;

        area_gx2dtg = -(pw_gxwdtg+(pw_gxwdtga+pw_gxwdtgd)/2.0)*a_gxwdtg;

        if (FAILURE==amppwgrad(area_gx2dtg, dtgloggrd.tx_xy, 0.0, 0.0, dtgloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2dtg.fixedflag ? (_temp388_a_gx2dtg=a_gx2dtg,&_temp388_a_gx2dtg) : &a_gx2dtg, _pw_gx2dtga.fixedflag ? (_temp389_pw_gx2dtga=pw_gx2dtga,&_temp389_pw_gx2dtga) : &pw_gx2dtga,
                               _pw_gx2dtg.fixedflag ? (_temp390_pw_gx2dtg=pw_gx2dtg,&_temp390_pw_gx2dtg) : &pw_gx2dtg, _pw_gx2dtgd.fixedflag ? (_temp391_pw_gx2dtgd=pw_gx2dtgd,&_temp391_pw_gx2dtgd) : &pw_gx2dtgd ))
        {
            epic_error(use_ermes, "%s failed in DTGcveval.",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2dtg"); 
            return FAILURE;
        }

        dtg_esp  = _dtg_esp.fixedflag ?                
                                        
                                            
                                        
                                          ((void)(RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd))), dtg_esp) : RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd));
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(dynTG_yres), _endview_iampdtg.fixedflag ? (_temp392_endview_iampdtg=endview_iampdtg,&_temp392_endview_iampdtg) : &endview_iampdtg) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:DynTG B1 map");
        return FAILURE;
    } 
  
    endview_scaledtg  = _endview_scaledtg.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampdtg), endview_scaledtg) : (float)max_pg_iamp/(float)endview_iampdtg;

    if ( FAILURE==amppwtpe(_a_gy1dtga.fixedflag ? (_temp393_a_gy1dtga=a_gy1dtga,&_temp393_a_gy1dtga) : &a_gy1dtga, _a_gy1dtgb.fixedflag ? (_temp394_a_gy1dtgb=a_gy1dtgb,&_temp394_a_gy1dtgb) : &a_gy1dtgb, _pw_gy1dtg.fixedflag ? (_temp395_pw_gy1dtg=pw_gy1dtg,&_temp395_pw_gy1dtg) : &pw_gy1dtg, _pw_gy1dtga.fixedflag ? (_temp396_pw_gy1dtga=pw_gy1dtga,&_temp396_pw_gy1dtga) : &pw_gy1dtga, _pw_gy1dtgd.fixedflag ? (_temp397_pw_gy1dtgd=pw_gy1dtgd,&_temp397_pw_gy1dtgd) : &pw_gy1dtgd,
                           dtgloggrd.ty_xyz/endview_scaledtg,dtgloggrd.yrt,
                           (0.5 * (FLOAT)(dynTG_yres-1))/(dynTG_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:DynTG map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rdtg  = _a_gy1rdtg.fixedflag ?  ((void)(a_gy1dtg), a_gy1rdtg) : a_gy1dtg;
    a_gy1rdtga  = _a_gy1rdtga.fixedflag ?  ((void)(a_gy1dtga), a_gy1rdtga) : a_gy1dtga;
    a_gy1rdtgb  = _a_gy1rdtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy1rdtgb) : a_gy1dtgb;
    pw_gy1rdtg  = _pw_gy1rdtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy1rdtg) : pw_gy1dtg;
    pw_gy1rdtga  = _pw_gy1rdtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy1rdtga) : pw_gy1dtga;
    pw_gy1rdtgd  = _pw_gy1rdtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy1rdtgd) : pw_gy1dtgd;

    a_gy2dtg  = _a_gy2dtg.fixedflag ?  ((void)(a_gy1dtg), a_gy2dtg) : a_gy1dtg;
    a_gy2dtga  = _a_gy2dtga.fixedflag ?  ((void)(a_gy1dtga), a_gy2dtga) : a_gy1dtga;
    a_gy2dtgb  = _a_gy2dtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy2dtgb) : a_gy1dtgb;
    pw_gy2dtg  = _pw_gy2dtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy2dtg) : pw_gy1dtg;
    pw_gy2dtga  = _pw_gy2dtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy2dtga) : pw_gy1dtga;
    pw_gy2dtgd  = _pw_gy2dtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy2dtgd) : pw_gy1dtgd;

    td0dtg  = _td0dtg.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()))), td0dtg) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1dtgd + pw_gz1dtga + pw_gz1dtg + pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd);
    temp_time2 = IMax(3, pw_gx1dtga + pw_gx1dtg + pw_gx1dtgd + pw_gxwdtga, pw_gy1dtga + pw_gy1dtg + pw_gy1dtgd,
                      pw_gzkbsdtga + pw_gzkbsdtg + pw_gzkbsdtgd);

    min_dtgte  = _min_dtgte.fixedflag ?            ((void)(RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0)), min_dtgte) : RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0); 

    temp_time = IMax(3, pw_gxwdtgd + pw_gxkdtga + pw_gxkdtg + pw_gxkdtgd, pw_gy1rdtga + pw_gy1rdtg + pw_gy1rdtgd,
                     pw_gzkdtga + pw_gzkdtg + pw_gzkdtgd);

    tr_dtg  = _tr_dtg.fixedflag ?              ((void)(RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp)), tr_dtg) : RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp);

    return SUCCESS;
} /* end DTGcveval */


/* 
 *  ExtCalcveval
 *  Description:
 *  CV eval for ExtCal entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
ExtCalcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_cal;
    FLOAT encode_cal = 0.0;
    FLOAT a_delta_cal = 0.0;
    FLOAT encode_cal2 = 0.0;
    FLOAT a_delta_cal2 = 0.0;
    FLOAT area_gxwcal;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;
    INT temp_time;


    if(coilInfo[0].pureCompatible > 0)
    {
        cvoverride(cal_pass, 2, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(cal_pass, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* freq/phase scaling for image cut reduction */
    cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(calscan_info[0].opfov_freq_scale), cal_freq_scale) : calscan_info[0].opfov_freq_scale;
    cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(calscan_info[0].opfov_phase_scale), cal_phase_scale) : calscan_info[0].opfov_phase_scale;

    if(cal_freq_scale <= 0.0)
    {
        cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(1.0), cal_freq_scale) : 1.0;
    }
    if(cal_phase_scale <= 0.0)
    {
        cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(1.0), cal_phase_scale) : 1.0;
    }
    cal_xfov  = _cal_xfov.fixedflag ?  ((void)(cal_fov*cal_freq_scale), cal_xfov) : cal_fov*cal_freq_scale;
    cal_yfov  = _cal_yfov.fixedflag ?  ((void)(cal_fov*cal_phase_scale), cal_yfov) : cal_fov*cal_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    cal_vthick  = _cal_vthick.fixedflag ?    ((void)(cal_slthick*cal_slq), cal_vthick) : cal_slthick*cal_slq;
    bw_rf1cal  = _bw_rf1cal.fixedflag ?  ((void)((int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal), bw_rf1cal) : (int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal;

    if (ampslice(_a_gzrf1cal.fixedflag ? (_temp398_a_gzrf1cal=a_gzrf1cal,&_temp398_a_gzrf1cal) : &a_gzrf1cal, bw_rf1cal, cal_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1cal)");
        return FAILURE;
    }

    a_gzrf1cal  = _a_gzrf1cal.fixedflag ?    ((void)(cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal), a_gzrf1cal) : cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp399_cal_amplimit=cal_amplimit,&_temp399_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz);

    if(a_gzrf1cal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tz;
        target_risetime = calloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1cala.fixedflag ? (_temp400_pw_gzrf1cala=pw_gzrf1cala,&_temp400_pw_gzrf1cala) : &pw_gzrf1cala, a_gzrf1cal, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1cala)");
        return FAILURE;
    }
    pw_gzrf1cald  = _pw_gzrf1cald.fixedflag ?  ((void)(pw_gzrf1cala), pw_gzrf1cald) : pw_gzrf1cala;

    if (endview(cal_slq, _endviewz_iampcal.fixedflag ? (_temp401_endviewz_iampcal=endviewz_iampcal,&_temp401_endviewz_iampcal) : &endviewz_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcal");
        return FAILURE;
    } 

    endviewz_scalecal  = _endviewz_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcal), endviewz_scalecal) : (float)max_pg_iamp/(float)endviewz_iampcal;

    refocus_cal = fabs(a_gzrf1cal)*(cal_iso_delay + pw_gzrf1cald/2.0);
    temp_area = (0.5 * (FLOAT)(cal_slq-1))/(cal_vthick * 0.1) * 1.0e6/ GAM;

    /* Z slice encode + gzrf1 refocus */
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp402_cal_amplimit=cal_amplimit,&_temp402_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz_xyz);
    target_amp = cal_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    if ( FAILURE==amppwtpe(_a_gzcombcala.fixedflag ? (_temp403_a_gzcombcala=a_gzcombcala,&_temp403_a_gzcombcala) : &a_gzcombcala, _a_gzcombcalb.fixedflag ? (_temp404_a_gzcombcalb=a_gzcombcalb,&_temp404_a_gzcombcalb) : &a_gzcombcalb, _pw_gzcombcal.fixedflag ? (_temp405_pw_gzcombcal=pw_gzcombcal,&_temp405_pw_gzcombcal) : &pw_gzcombcal, 
                           _pw_gzcombcala.fixedflag ? (_temp406_pw_gzcombcala=pw_gzcombcala,&_temp406_pw_gzcombcala) : &pw_gzcombcala, _pw_gzcombcald.fixedflag ? (_temp407_pw_gzcombcald=pw_gzcombcald,&_temp407_pw_gzcombcald) : &pw_gzcombcald,
                           target_amp, target_risetime,
                           temp_area + refocus_cal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode cal");
        return FAILURE;
    }

    encode_cal = 0.5*(float)pw_gzcombcala*a_gzcombcala + 0.5*(float)pw_gzcombcal*(a_gzcombcala
             + a_gzcombcalb) + 0.5*(float)pw_gzcombcald*a_gzcombcalb - fabs(refocus_cal);

    a_delta_cal = 4.0*encode_cal/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcal + (float)pw_gzcombcald);
    
    /* max neg amp */
    a_combcal  = _a_combcal.fixedflag ?  ((void)(a_gzcombcalb), a_combcal) : a_gzcombcalb;

    /* max positive amp */
    a_endcal  = _a_endcal.fixedflag ?    ((void)(a_combcal-a_delta_cal*(float)(cal_slq-1)), a_endcal) : a_combcal-a_delta_cal*(float)(cal_slq-1);

    a_gzcombcal  = _a_gzcombcal.fixedflag ?  ((void)(-a_combcal), a_gzcombcal) : -a_combcal;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcala.fixedflag ? (_temp408_a_gzprcala=a_gzprcala,&_temp408_a_gzprcala) : &a_gzprcala, _a_gzprcalb.fixedflag ? (_temp409_a_gzprcalb=a_gzprcalb,&_temp409_a_gzprcalb) : &a_gzprcalb, _pw_gzprcal.fixedflag ? (_temp410_pw_gzprcal=pw_gzprcal,&_temp410_pw_gzprcal) : &pw_gzprcal, 
                           _pw_gzprcala.fixedflag ? (_temp411_pw_gzprcala=pw_gzprcala,&_temp411_pw_gzprcala) : &pw_gzprcala, _pw_gzprcald.fixedflag ? (_temp412_pw_gzprcald=pw_gzprcald,&_temp412_pw_gzprcald) : &pw_gzprcald,
                           target_amp, target_risetime,
                           temp_area + area_gzkcal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr cal rewinder");
        return FAILURE;
    }
    encode_cal2 = 0.5*(float)pw_gzprcala*a_gzprcala + 0.5*(float)pw_gzprcal*(a_gzprcala
             + a_gzprcalb) + 0.5*(float)pw_gzprcald*a_gzprcalb - area_gzkcal;

    a_delta_cal2 = 4.0*encode_cal2/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcal + (float)pw_gzprcald);
    
    /* max neg amp */
    a_combcal2  = _a_combcal2.fixedflag ?  ((void)(a_gzprcalb), a_combcal2) : a_gzprcalb;

    /* max positive amp */
    a_endcal2  = _a_endcal2.fixedflag ?    ((void)(a_combcal2-a_delta_cal2*(float)(cal_slq-1.0)), a_endcal2) : a_combcal2-a_delta_cal2*(float)(cal_slq-1.0);

    a_gzprcal  = _a_gzprcal.fixedflag ?  ((void)(a_combcal2), a_gzprcal) : a_combcal2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1cal_filt, echo1bwcal, cal_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cal_filt");

        return FAILURE;
    }

    if((echo1bwcal > 0) && (cal_xfov > 0.0))
    {
        a_gxwcal  = _a_gxwcal.fixedflag ?          ((void)((FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov)), a_gxwcal) : (FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov);
    }
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcal");
        return FAILURE;
    }

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp413_cal_amplimit=cal_amplimit,&_temp413_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if(a_gxwcal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tx_xyz;
        target_risetime = calloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcala.fixedflag ? (_temp414_pw_gxwcala=pw_gxwcala,&_temp414_pw_gxwcala) : &pw_gxwcala, a_gxwcal, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcala.");
        return FAILURE;
    }
    pw_gxwcald  = _pw_gxwcald.fixedflag ?  ((void)(pw_gxwcala), pw_gxwcald) : pw_gxwcala;

    tacq_cal  = _tacq_cal.fixedflag ?  ((void)(RUP_GRD(echo1cal_filt.tdaq)), tacq_cal) : RUP_GRD(echo1cal_filt.tdaq);

    /* Gx1 */
    area_gxwcal = a_gxwcal*tacq_cal;
    temp_area = 0.5*a_gxwcal*pw_gxwcala;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp415_cal_amplimit=cal_amplimit,&_temp415_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if (amppwgx1(_a_gx1cal.fixedflag ? (_temp416_a_gx1cal=a_gx1cal,&_temp416_a_gx1cal) : &a_gx1cal, _pw_gx1cal.fixedflag ? (_temp417_pw_gx1cal=pw_gx1cal,&_temp417_pw_gx1cal) : &pw_gx1cal, _pw_gx1cala.fixedflag ? (_temp418_pw_gx1cala=pw_gx1cala,&_temp418_pw_gx1cala) : &pw_gx1cala, _pw_gx1cald.fixedflag ? (_temp419_pw_gx1cald=pw_gx1cald,&_temp419_pw_gx1cald) : &pw_gx1cald,
                 (int)TYPGRAD, area_gxwcal, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, cal_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1cal");
    }

    /* X killer -- ext gxwcal */
    temp_area = 5.0e6 * cal_xres/(cal_fov*GAM);
    pw_gxwcal  = _pw_gxwcal.fixedflag ?        ((void)(IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2))), pw_gxwcal) : IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(cal_yres, _endview_iampcal.fixedflag ? (_temp420_endview_iampcal=endview_iampcal,&_temp420_endview_iampcal) : &endview_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for cal");
        return FAILURE;
    } 

    endview_scalecal  = _endview_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcal), endview_scalecal) : (float)max_pg_iamp/(float)endview_iampcal;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp421_cal_amplimit=cal_amplimit,&_temp421_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.ty_xyz);
    target_amp = cal_amplimit/endview_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecal));  /* rise time for target amp */
    
    if ( FAILURE==amppwtpe(_a_gy1cala.fixedflag ? (_temp422_a_gy1cala=a_gy1cala,&_temp422_a_gy1cala) : &a_gy1cala, _a_gy1calb.fixedflag ? (_temp423_a_gy1calb=a_gy1calb,&_temp423_a_gy1calb) : &a_gy1calb, _pw_gy1cal.fixedflag ? (_temp424_pw_gy1cal=pw_gy1cal,&_temp424_pw_gy1cal) : &pw_gy1cal, _pw_gy1cala.fixedflag ? (_temp425_pw_gy1cala=pw_gy1cala,&_temp425_pw_gy1cala) : &pw_gy1cala, _pw_gy1cald.fixedflag ? (_temp426_pw_gy1cald=pw_gy1cald,&_temp426_pw_gy1cald) : &pw_gy1cald,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(cal_yres-1))/(cal_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: cal ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcal  = _a_gy1rcal.fixedflag ?  ((void)(a_gy1cal), a_gy1rcal) : a_gy1cal;
    a_gy1rcala  = _a_gy1rcala.fixedflag ?  ((void)(a_gy1cala), a_gy1rcala) : a_gy1cala;
    a_gy1rcalb  = _a_gy1rcalb.fixedflag ?  ((void)(a_gy1calb), a_gy1rcalb) : a_gy1calb;
    pw_gy1rcal  = _pw_gy1rcal.fixedflag ?  ((void)(pw_gy1cal), pw_gy1rcal) : pw_gy1cal;
    pw_gy1rcala  = _pw_gy1rcala.fixedflag ?  ((void)(pw_gy1cala), pw_gy1rcala) : pw_gy1cala;
    pw_gy1rcald  = _pw_gy1rcald.fixedflag ?  ((void)(pw_gy1cald), pw_gy1rcald) : pw_gy1cald;


    td0cal  = _td0cal.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0cal) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0cal  = _td0cal.fixedflag ?    ((void)(RUP_GRD((int)(td0cal+tleadcal))), td0cal) : RUP_GRD((int)(td0cal+tleadcal));

    cal_iso_delay  = _cal_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw))), cal_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw));

    calt_exa  = _calt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay)), calt_exa) : RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay);
    calt_exb  = _calt_exb.fixedflag ?  ((void)(cal_iso_delay), calt_exb) : cal_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcala + pw_gx1cala + pw_gx1cal + pw_gx1cald,
                     pw_gy1cala + pw_gy1cal + pw_gy1cald,
                     pw_gzrf1cald + pw_gzcombcala + pw_gzcombcal + pw_gzcombcald);

    te_cal  = _te_cal.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0))), te_cal) : IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0));

    temp_time = IMax(3, pw_gxwcald + pw_gxwcal - tacq_cal,
                     pw_gy1rcala + pw_gy1rcal + pw_gy1rcald,
                     pw_gzprcala + pw_gzprcal + pw_gzprcald);
    tr_cal  = _tr_cal.fixedflag ?              ((void)(RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical)), tr_cal) : RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical);

    cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;

    if(cal_pass > 1)
    {
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if (B0_30000 == cffield)
        {
            if ((isDVSystem() || isRioSystem()) &&
                ((isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strcmp(attribute_codeMeaning, "Breast"))
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_ABDOMEN)
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_PELVIS)))
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_ON), cal_tr_interleave) : PSD_ON;
            }
            else
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_ON), cal_nex_interleave) : PSD_ON;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
            }
        }
        else
        {
            cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
            cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
        }
    }

    /* set up CV cal_interleave mode */
    if (cal_nex_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NEX_INTERLEAVED), cal_interleave) : CAL_NEX_INTERLEAVED;
        cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    }
    else if (cal_tr_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_TR_INTERLEAVED), cal_interleave) : CAL_TR_INTERLEAVED;
    }
    else
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NONE_INTERLEAVED), cal_interleave) : CAL_NONE_INTERLEAVED;
    }

    cal_delay_dda  = _cal_delay_dda.fixedflag ?  ((void)(((int)(cal_delay/(float)tr_cal)/2)*2), cal_delay_dda) : ((int)(cal_delay/(float)tr_cal)/2)*2;  /* delay for long T1 signal to recover */


    return SUCCESS;
} /* End of ExtCalcveval */


/* 
 *  AutoCoilcveval
 *  Description:
 *  CV eval for AutoCoil entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
AutoCoilcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_coil;
    FLOAT encode_coil = 0.0;
    FLOAT a_delta_coil = 0.0;
    FLOAT encode_coil2 = 0.0;
    FLOAT a_delta_coil2 = 0.0;
    FLOAT area_gxwcoil;
    FLOAT area_gzkcoil = 300.0;
    INT temp_time;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;

    /* freq/phase scaling for image cut reduction */
    coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_freq_scale), coil_freq_scale) : coilscan_info[0].opfov_freq_scale;
    coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_phase_scale), coil_phase_scale) : coilscan_info[0].opfov_phase_scale;

    if(coil_freq_scale <= 0.0)
    {
        coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(1.0), coil_freq_scale) : 1.0;
    }
    if(coil_phase_scale <= 0.0)
    {
        coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(1.0), coil_phase_scale) : 1.0;
    }
    coil_xfov  = _coil_xfov.fixedflag ?  ((void)(coil_fov*coil_freq_scale), coil_xfov) : coil_fov*coil_freq_scale;
    coil_yfov  = _coil_yfov.fixedflag ?  ((void)(coil_fov*coil_phase_scale), coil_yfov) : coil_fov*coil_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    coil_vthick  = _coil_vthick.fixedflag ?    ((void)(coil_slthick*coil_slq), coil_vthick) : coil_slthick*coil_slq;
    bw_rf1coil  = _bw_rf1coil.fixedflag ?  ((void)((int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil), bw_rf1coil) : (int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil;

    if (ampslice(_a_gzrf1coil.fixedflag ? (_temp427_a_gzrf1coil=a_gzrf1coil,&_temp427_a_gzrf1coil) : &a_gzrf1coil, bw_rf1coil, coil_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1coil)");
        return FAILURE;
    }

    a_gzrf1coil  = _a_gzrf1coil.fixedflag ?    ((void)(1.05*coil_slq/(coil_slq-4)*a_gzrf1coil), a_gzrf1coil) : 1.05*coil_slq/(coil_slq-4)*a_gzrf1coil;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp428_coil_amplimit=coil_amplimit,&_temp428_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz);
    if(a_gzrf1coil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tz;
        target_risetime = coilloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1coila.fixedflag ? (_temp429_pw_gzrf1coila=pw_gzrf1coila,&_temp429_pw_gzrf1coila) : &pw_gzrf1coila, a_gzrf1coil, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1coila)");
        return FAILURE;
    }
    pw_gzrf1coild  = _pw_gzrf1coild.fixedflag ?  ((void)(pw_gzrf1coila), pw_gzrf1coild) : pw_gzrf1coila;

    if (endview(coil_slq, _endviewz_iampcoil.fixedflag ? (_temp430_endviewz_iampcoil=endviewz_iampcoil,&_temp430_endviewz_iampcoil) : &endviewz_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcoil");
        return FAILURE;
    } 
    endviewz_scalecoil  = _endviewz_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcoil), endviewz_scalecoil) : (float)max_pg_iamp/(float)endviewz_iampcoil;

    refocus_coil = fabs(a_gzrf1coil)*(coil_iso_delay + pw_gzrf1coild/2.0);
    temp_area = (0.5 * (FLOAT)(coil_slq-1))/(coil_vthick * 0.1) * 1.0e6/ GAM;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp431_coil_amplimit=coil_amplimit,&_temp431_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz_xyz);
    target_amp = coil_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    /* Z slice encode + gzrf1 refocus */
    if ( FAILURE==amppwtpe(_a_gzcombcoila.fixedflag ? (_temp432_a_gzcombcoila=a_gzcombcoila,&_temp432_a_gzcombcoila) : &a_gzcombcoila, _a_gzcombcoilb.fixedflag ? (_temp433_a_gzcombcoilb=a_gzcombcoilb,&_temp433_a_gzcombcoilb) : &a_gzcombcoilb, _pw_gzcombcoil.fixedflag ? (_temp434_pw_gzcombcoil=pw_gzcombcoil,&_temp434_pw_gzcombcoil) : &pw_gzcombcoil, 
                           _pw_gzcombcoila.fixedflag ? (_temp435_pw_gzcombcoila=pw_gzcombcoila,&_temp435_pw_gzcombcoila) : &pw_gzcombcoila, _pw_gzcombcoild.fixedflag ? (_temp436_pw_gzcombcoild=pw_gzcombcoild,&_temp436_pw_gzcombcoild) : &pw_gzcombcoild,
                           target_amp, target_risetime,
                           temp_area + refocus_coil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode for auto coil");
        return FAILURE;
    }

    encode_coil = 0.5*(float)pw_gzcombcoila*a_gzcombcoila + 0.5*(float)pw_gzcombcoil*(a_gzcombcoila
             + a_gzcombcoilb) + 0.5*(float)pw_gzcombcoild*a_gzcombcoilb - fabs(refocus_coil);

    a_delta_coil = 4.0*encode_coil/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcoil + (float)pw_gzcombcoild);
    
    /* max neg amp */
    a_combcoil  = _a_combcoil.fixedflag ?  ((void)(a_gzcombcoilb), a_combcoil) : a_gzcombcoilb;

    /* max positive amp */
    a_endcoil  = _a_endcoil.fixedflag ?    ((void)(a_combcoil-a_delta_coil*(float)(coil_slq-1.0)), a_endcoil) : a_combcoil-a_delta_coil*(float)(coil_slq-1.0);

    a_gzcombcoil  = _a_gzcombcoil.fixedflag ?  ((void)(-a_combcoil), a_gzcombcoil) : -a_combcoil;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcoila.fixedflag ? (_temp437_a_gzprcoila=a_gzprcoila,&_temp437_a_gzprcoila) : &a_gzprcoila, _a_gzprcoilb.fixedflag ? (_temp438_a_gzprcoilb=a_gzprcoilb,&_temp438_a_gzprcoilb) : &a_gzprcoilb, _pw_gzprcoil.fixedflag ? (_temp439_pw_gzprcoil=pw_gzprcoil,&_temp439_pw_gzprcoil) : &pw_gzprcoil, 
                           _pw_gzprcoila.fixedflag ? (_temp440_pw_gzprcoila=pw_gzprcoila,&_temp440_pw_gzprcoila) : &pw_gzprcoila, _pw_gzprcoild.fixedflag ? (_temp441_pw_gzprcoild=pw_gzprcoild,&_temp441_pw_gzprcoild) : &pw_gzprcoild,
                           target_amp, target_risetime,
                           temp_area + area_gzkcoil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr autocoil rewinder");
        return FAILURE;
    }
    encode_coil2 = 0.5*(float)pw_gzprcoila*a_gzprcoila + 0.5*(float)pw_gzprcoil*(a_gzprcoila
             + a_gzprcoilb) + 0.5*(float)pw_gzprcoild*a_gzprcoilb - area_gzkcoil;

    a_delta_coil2 = 4.0*encode_coil2/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcoil + (float)pw_gzprcoild);
    
    /* max neg amp */
    a_combcoil2  = _a_combcoil2.fixedflag ?  ((void)(a_gzprcoilb), a_combcoil2) : a_gzprcoilb;

    /* max positive amp */
    a_endcoil2  = _a_endcoil2.fixedflag ?    ((void)(a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0)), a_endcoil2) : a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0);

    a_gzprcoil  = _a_gzprcoil.fixedflag ?  ((void)(a_combcoil2), a_gzprcoil) : a_combcoil2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1coil_filt, echo1bwcoil, coil_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "coilcfilter for echo1coil_filt");

        return FAILURE;
    }

    if ((echo1bwcoil > 0) && (coil_xfov > 0.0))
    {
        a_gxwcoil  = _a_gxwcoil.fixedflag ?         ((void)((FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov)), a_gxwcoil) : (FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov);
    }   
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcoil");
        return FAILURE;
    }

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp442_coil_amplimit=coil_amplimit,&_temp442_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if(a_gxwcoil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tx_xyz;
        target_risetime = coilloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcoila.fixedflag ? (_temp443_pw_gxwcoila=pw_gxwcoila,&_temp443_pw_gxwcoila) : &pw_gxwcoila, a_gxwcoil, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcoila.");
        return FAILURE;
    }
    pw_gxwcoild  = _pw_gxwcoild.fixedflag ?  ((void)(pw_gxwcoila), pw_gxwcoild) : pw_gxwcoila;

    tacq_coil  = _tacq_coil.fixedflag ?  ((void)(RUP_GRD(echo1coil_filt.tdaq)), tacq_coil) : RUP_GRD(echo1coil_filt.tdaq);

    /* Gx1 */
    area_gxwcoil = a_gxwcoil*tacq_coil;
    temp_area = 0.5*a_gxwcoil*pw_gxwcoila;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp444_coil_amplimit=coil_amplimit,&_temp444_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if (amppwgx1(_a_gx1coil.fixedflag ? (_temp445_a_gx1coil=a_gx1coil,&_temp445_a_gx1coil) : &a_gx1coil, _pw_gx1coil.fixedflag ? (_temp446_pw_gx1coil=pw_gx1coil,&_temp446_pw_gx1coil) : &pw_gx1coil, _pw_gx1coila.fixedflag ? (_temp447_pw_gx1coila=pw_gx1coila,&_temp447_pw_gx1coila) : &pw_gx1coila, _pw_gx1coild.fixedflag ? (_temp448_pw_gx1coild=pw_gx1coild,&_temp448_pw_gx1coild) : &pw_gx1coild,
                 (int)TYPGRAD, area_gxwcoil, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, coil_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1coil");
    }

    /* X killer -- ext gxwcoil */
    temp_area = 5.0e6 * coil_xres/(coil_fov*GAM);
    pw_gxwcoil  = _pw_gxwcoil.fixedflag ?        ((void)(IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2))), pw_gxwcoil) : IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(coil_yres, _endview_iampcoil.fixedflag ? (_temp449_endview_iampcoil=endview_iampcoil,&_temp449_endview_iampcoil) : &endview_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for coil");
        return FAILURE;
    } 
    endview_scalecoil  = _endview_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcoil), endview_scalecoil) : (float)max_pg_iamp/(float)endview_iampcoil;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp450_coil_amplimit=coil_amplimit,&_temp450_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.ty_xyz);
    target_amp = coil_amplimit/endview_scalecoil;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecoil));  /* rise time for target amp */

    if ( FAILURE==amppwtpe(_a_gy1coila.fixedflag ? (_temp451_a_gy1coila=a_gy1coila,&_temp451_a_gy1coila) : &a_gy1coila, _a_gy1coilb.fixedflag ? (_temp452_a_gy1coilb=a_gy1coilb,&_temp452_a_gy1coilb) : &a_gy1coilb, _pw_gy1coil.fixedflag ? (_temp453_pw_gy1coil=pw_gy1coil,&_temp453_pw_gy1coil) : &pw_gy1coil, _pw_gy1coila.fixedflag ? (_temp454_pw_gy1coila=pw_gy1coila,&_temp454_pw_gy1coila) : &pw_gy1coila, _pw_gy1coild.fixedflag ? (_temp455_pw_gy1coild=pw_gy1coild,&_temp455_pw_gy1coild) : &pw_gy1coild,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(coil_yres-1))/(coil_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: coil ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcoil  = _a_gy1rcoil.fixedflag ?  ((void)(a_gy1coil), a_gy1rcoil) : a_gy1coil;
    a_gy1rcoila  = _a_gy1rcoila.fixedflag ?  ((void)(a_gy1coila), a_gy1rcoila) : a_gy1coila;
    a_gy1rcoilb  = _a_gy1rcoilb.fixedflag ?  ((void)(a_gy1coilb), a_gy1rcoilb) : a_gy1coilb;
    pw_gy1rcoil  = _pw_gy1rcoil.fixedflag ?  ((void)(pw_gy1coil), pw_gy1rcoil) : pw_gy1coil;
    pw_gy1rcoila  = _pw_gy1rcoila.fixedflag ?  ((void)(pw_gy1coila), pw_gy1rcoila) : pw_gy1coila;
    pw_gy1rcoild  = _pw_gy1rcoild.fixedflag ?  ((void)(pw_gy1coild), pw_gy1rcoild) : pw_gy1coild;


    td0coil  = _td0coil.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0coil) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0coil  = _td0coil.fixedflag ?    ((void)(RUP_GRD((int)(td0coil+tleadcoil))), td0coil) : RUP_GRD((int)(td0coil+tleadcoil));

    coil_iso_delay  = _coil_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw))), coil_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw));

    coilt_exa  = _coilt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay)), coilt_exa) : RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay);
    coilt_exb  = _coilt_exb.fixedflag ?  ((void)(coil_iso_delay), coilt_exb) : coil_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcoila + pw_gx1coila + pw_gx1coil + pw_gx1coild,
                     pw_gy1coila + pw_gy1coil + pw_gy1coild,
                     pw_gzrf1coild + pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild);

    te_coil  = _te_coil.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0))), te_coil) : IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0));

    temp_time = IMax(3, pw_gxwcoild + pw_gxwcoil - tacq_coil,
                     pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild,
                     pw_gzprcoila + pw_gzprcoil + pw_gzprcoild);
    tr_coil  = _tr_coil.fixedflag ?              ((void)(RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil)), tr_coil) : RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil);

    coil_interleave  = _coil_interleave.fixedflag ?      ((void)(coil_nex_interleave?CAL_NEX_INTERLEAVED:0), coil_interleave) : coil_nex_interleave?CAL_NEX_INTERLEAVED:0;

    return SUCCESS;
} /* End of AutoCoilcveval */


/*
 *  RGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RGcvinit( void )
{
    return SUCCESS;
}


/*
 *  RGcveval
 *
 *  Type: Public Function
 *
 *  Description:
 *
 */
STATUS
RGcveval( void )
{
    if (PSD_ON == rgfeature_enable) 
    { 
        cvmod( opuser39, RG_CAL_MODE_MEASURED, RG_CAL_MODE_HIGH_FIXED, RG_CAL_MODE_HIGH_FIXED, 
               "Receiver Gain (0:Prescan Measured, 1:Predefined)", 0, "" );

        if ( (PSD_2D == exist(opimode)) &&
             ((PSD_SE == exist(oppseq)) || (PSD_IR == exist(oppseq))) &&
             (exist(opptsize) == 4) &&
             (exist(opslthick) <= 10) ) 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(_opuser39.defval), opuser39) : _opuser39.defval;
            activate_reserved_usercv(39);

            if( existcv(opuser39) && 
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.minval, 2) &&
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.maxval, 2) )
            {
                epic_error(use_ermes, "%s must be 0 or 1", EM_PSD_CV_0_OR_1,
                           EE_ARGS(1), STRING_ARG, "UserCV39");

                return FAILURE;
            }

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)((int)rint(exist(opuser39))), oprgcalmode) : (int)rint(exist(opuser39));
        }
        else 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
            deactivate_reserved_usercv(39);

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
        }
    } 
    else 
    {
        opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
        deactivate_reserved_usercv(39);

        oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
    }

    return SUCCESS;
}   /* end RGcveval() */

/*
 *  PSfilter
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfilter( void )
{
    if (setfilter( &echo1cfl,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfl_fid  = _filter_cfl_fid.fixedflag ?  ((void)(echo1cfl.fslot), filter_cfl_fid) : echo1cfl.fslot;

    if (setfilter( &echo1rcvn,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_rcvn_fid  = _filter_rcvn_fid.fixedflag ?  ((void)(echo1rcvn.fslot), filter_rcvn_fid) : echo1rcvn.fslot;

    if (setfilter(&echo1cfh, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfh_fid  = _filter_cfh_fid.fixedflag ?  ((void)(echo1cfh.fslot), filter_cfh_fid) : echo1cfh.fslot;


    if (setfilter(&echo1mps1_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1mps1  = _filter_echo1mps1.fixedflag ?  ((void)(echo1mps1_filt.fslot), filter_echo1mps1) : echo1mps1_filt.fslot;

    if (setfilter(&echo1ftg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1ftg   = _filter_echo1ftg.fixedflag ?  ((void)(echo1ftg_filt.fslot), filter_echo1ftg) : echo1ftg_filt.fslot; /* 11/24/94 YI */
    filter_echo2ftg  = _filter_echo2ftg.fixedflag ?   ((void)(filter_echo1ftg), filter_echo2ftg) : filter_echo1ftg;

    if (setfilter(&echo1xtg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1xtg   = _filter_echo1xtg.fixedflag ?  ((void)(echo1xtg_filt.fslot), filter_echo1xtg) : echo1xtg_filt.fslot;

    if (setfilter(&echo1as_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1as  = _filter_echo1as.fixedflag ?  ((void)(echo1as_filt.fslot), filter_echo1as) : echo1as_filt.fslot;

    if (setfilter(&echo1rs_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter rs");
        return FAILURE;
    }
    filter_echo1rs  = _filter_echo1rs.fixedflag ?  ((void)(echo1rs_filt.fslot), filter_echo1rs) : echo1rs_filt.fslot;

    if (setfilter(&echo1dtg_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter dtg");
        return FAILURE;
    }
    filter_echo1dtg  = _filter_echo1dtg.fixedflag ?  ((void)(echo1dtg_filt.fslot), filter_echo1dtg) : echo1dtg_filt.fslot;

    if (setfilter(&echo1cal_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter cal");
        return FAILURE;
    }
    filter_echo1cal  = _filter_echo1cal.fixedflag ?  ((void)(echo1cal_filt.fslot), filter_echo1cal) : echo1cal_filt.fslot;

    if (setfilter(&echo1coil_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter coil");
        return FAILURE;
    }
    filter_echo1coil  = _filter_echo1coil.fixedflag ?  ((void)(echo1coil_filt.fslot), filter_echo1coil) : echo1coil_filt.fslot;

    return SUCCESS;
}   /* end PSfilter() */


/*
 *  PS1predownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1predownload( void )
{
    /* Set xmtaddAPS1 according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddAPS1 is too big.
       Add in coilatten, too. */
    xmtaddAPS1  = _xmtaddAPS1.fixedflag ?    ((void)(-200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten()), xmtaddAPS1) : -200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten();
    if (xmtaddAPS1 > cfdbmax)
    {
        ps1scale  = _ps1scale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0)), ps1scale) : (float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0);
        xmtaddAPS1  = _xmtaddAPS1.fixedflag ?  ((void)(cfdbmax), xmtaddAPS1) : cfdbmax;
    }
    else
    {
        ps1scale  = _ps1scale.fixedflag ?  ((void)(1.0), ps1scale) : 1.0;
    }
  
    if( ((B0_30000 == cffield) && (PSD_XRMW_COIL == cfgcoiltype || PSD_VRMW_COIL == cfgcoiltype)) 
        || isRioSystem() )
    {
        /* MRIhc57081: Limit TG to coil peak B1 on MR750w */
        calcTGLimit(_tgcap.fixedflag ? (_temp456_tgcap=tgcap,&_temp456_tgcap) : &tgcap, _tgwindow.fixedflag ? (_temp457_tgwindow=tgwindow,&_temp457_tgwindow) : &tgwindow, maxB1Seq, txCoilInfo[getTxIndex(coilInfo[0])]);
    }
    else
    {
        /* Otherwise use defaults */
        tgcap  = _tgcap.fixedflag ?  ((void)(_tgcap.defval), tgcap) : _tgcap.defval;
        tgwindow  = _tgwindow.fixedflag ?  ((void)(_tgwindow.defval), tgwindow) : _tgwindow.defval;
    }

    if (setScale(L_APS1, RF_FREE, rfpulse, maxB1[L_APS1], 
                 ps1scale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale ps1");
        return FAILURE;
    }

    ia_rf1mps1  = _ia_rf1mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp))), ia_rf1mps1) : (int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp));
    ia_rf2mps1  = _ia_rf2mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp))), ia_rf2mps1) : (int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp));

    entry_point_table[L_APS1].epxmtadd = (short) rint((double)xmtaddAPS1);
    /* APS1 & MPS1 */
    strcpy(entry_point_table[L_APS1].epname,"aps1");
    entry_point_table[L_APS1].epfilter=(n8)filter_echo1mps1;

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_APS1],
                  L_APS1,
                  (int)RF_FREE,
                  rfpulse,
                  ps1_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ps1");
        return FAILURE;
    }

    /* Check for multiple Tx coils. This routine is optimized only
     * for single Tx coil. */ 
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "Prescan");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp458_min_seqgrad=min_seqgrad,&_temp458_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqmps1, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* If aps1_mod set to 1 and NOT breast R or L coil, use volRec coil to set TG */
    if ( (getAps1Mod() > 0) && (PSD_OFF == ps1_rxcoil) )
    {
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_APS1], 0);
        }
    }

    /* copy APS1 to MPS1 */
    entry_point_table[L_MPS1] = entry_point_table[L_APS1];

    strcpy(entry_point_table[L_MPS1].epname, "mps1");

    /* This is usually equal to the scan entry point.
       Make sure it is continuous for manual prescan */
    entry_point_table[L_MPS1].eppmtable.pmContinuousUpdate = 1;
    entry_point_table[L_MPS2].eppmtable.pmContinuousUpdate = 1;

    return SUCCESS;
}

/*
 *  CFLpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpredownload( void )
{
    /* Sample time for cfl */
    pitsp1 = echo1cfl.tdaq/echo1cfl.outputs;

    xmtaddCFL  = _xmtaddCFL.fixedflag ?    ((void)(-200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten()), xmtaddCFL) : -200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFL > cfdbmax)
    {
        cflscale  = _cflscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0)), cflscale) : (float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0);
        xmtaddCFL  = _xmtaddCFL.fixedflag ?  ((void)(cfdbmax), xmtaddCFL) : cfdbmax;
    }
    else
    {
        cflscale  = _cflscale.fixedflag ?  ((void)(1.0), cflscale) : 1.0;
    }

    if (setScale(L_CFL, RF_FREE, rfpulse, maxB1[L_CFL], 
                 cflscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfl");
        return FAILURE;
    }

    ia_rf1cfl  = _ia_rf1cfl.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp))), ia_rf1cfl) : (int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp));

    entry_point_table[L_CFL].epxmtadd = (short) rint((double)xmtaddCFL);

    entry_point_table[L_CFL].epprexres = (s16)CFLxres; /* MRIhc54366 */

    strcpy(entry_point_table[L_CFL].epname,"cfl");
    entry_point_table[L_CFL].epfilter=(n8)filter_cfl_fid;
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFL],
                  L_CFL,
                  (int)RF_FREE,
                  rfpulse,
                  cfl_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfl");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp459_min_seqgrad=min_seqgrad,&_temp459_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfl, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  RCVNpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpredownload( void )
{
    entry_point_table[L_RCVN] = entry_point_table[L_MPS2];
    entry_point_table[L_RCVN].enableReceiveFreqBands  = _enableReceiveFreqBands.fixedflag ?  ((void)(0), enableReceiveFreqBands) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqLower  = _offsetReceiveFreqLower.fixedflag ?  ((void)(0), offsetReceiveFreqLower) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqHigher  = _offsetReceiveFreqHigher.fixedflag ?  ((void)(0), offsetReceiveFreqHigher) : 0;

    xmtaddRCVN  = _xmtaddRCVN.fixedflag ?  ((void)(xmtaddCFL), xmtaddRCVN) : xmtaddCFL;
    entry_point_table[L_RCVN].epxmtadd = (short) rint((double)xmtaddRCVN);

    strcpy(entry_point_table[L_RCVN].epname,"rcvn");
    
    entry_point_table[L_RCVN].epfilter  = (n8)filter_rcvn_fid;
    entry_point_table[L_RCVN].epprexres = rcvn_xres;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp460_min_seqgrad=min_seqgrad,&_temp460_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqrcvn, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  CFHpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpredownload( void )
{
    /* Sample time for cfh */
    pitsp2 = echo1cfh.tdaq/echo1cfh.outputs;

    xmtaddCFH  = _xmtaddCFH.fixedflag ?    ((void)(-200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten()), xmtaddCFH) : -200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFH > cfdbmax)
    {
        cfhscale  = _cfhscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0)), cfhscale) : (float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0);
        xmtaddCFH  = _xmtaddCFH.fixedflag ?  ((void)(cfdbmax), xmtaddCFH) : cfdbmax;
    }
    else
    {
        cfhscale  = _cfhscale.fixedflag ?  ((void)(1.0), cfhscale) : 1.0;
    }

    if (setScale(L_CFH, RF_FREE, rfpulse, maxB1[L_CFH], 
                 cfhscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfh");
        return FAILURE;
    }

    ia_rf1cfh  = _ia_rf1cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp))), ia_rf1cfh) : (int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp));
    ia_rf2cfh  = _ia_rf2cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp))), ia_rf2cfh) : (int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp));
    if(presscfh_ctrl != PRESSCFH_NONE)
    {
        ia_rf3cfh  = _ia_rf3cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp))), ia_rf3cfh) : (int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp));
        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            ia_rf4cfh  = _ia_rf4cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp))), ia_rf4cfh) : (int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp));
        }
    }

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ia_rfcssatcfh = (int)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp));
    }
#endif
    if (PSD_ON == PSir)
    {
        ia_rf0cfh  = _ia_rf0cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp))), ia_rf0cfh) : (int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp));
    }

    if( (presscfh_ctrl != PRESSCFH_SHIMVOL) && (presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE) )
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES));
    }
    else
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES));
    }

    if( ( (opcoax != 0) && cfh_newmode ) || (presscfh != PRESSCFH_NONE) )
    {
        if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB )
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
        }
        else if(presscfh_ctrl == PRESSCFH_SHIMVOL)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            if((presscfh != presscfh_ctrl) && presscfh_debug)
            {
                printf("\n  presscfh %d changes to presscfh_ctrl %d \n",presscfh, presscfh_ctrl);
                fflush(stdout);
            }
        }
        else if (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            cfh_rf4freq  = _cfh_rf4freq.fixedflag ?          ((void)(GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES)), cfh_rf4freq) : GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES);
        }
        else
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?              
    ((void)((GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES))), cfh_rf2freq) : (GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES));
        /* factor 10 is because rloc/phasoff is in mm */
    }
    }
    else
    {
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground 
        */
        cfh_rf2freq  = _cfh_rf2freq.fixedflag ?  ((void)(0), cfh_rf2freq) : 0;
    }

    entry_point_table[L_CFH].epxmtadd = (short) rint((double)xmtaddCFH);
    strcpy(entry_point_table[L_CFH].epname,"cfh");
    entry_point_table[L_CFH].epfilter=(n8)filter_cfh_fid;
    entry_point_table[L_CFH].epprexres = (s16)CFHxres; /* MRIhc08633 */
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFH],
                  L_CFH,
                  (int)RF_FREE,
                  rfpulse,
                  cfh_tr) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfh");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp461_min_seqgrad=min_seqgrad,&_temp461_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfh, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    switch (getTxCoilType()) /* Only 0.5/0.2T will use. */ /* vmx 07/27/95 YO */
    {
        case TX_COIL_LOCAL:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((10.0/256.0)), cfh_ec_position) : (10.0/256.0);
            break;
        default:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((16.0/256.0)), cfh_ec_position) : (16.0/256.0);
            break;
    }

    return SUCCESS;
}

/*
 *  PSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpredownload( void )
{
    STATUS ps_status;
    INT i;
    INT j;
    INT index, vidx;
    
    /* Check for multiple Tx coils. This routine is optimized only for
     * single Tx coil. */
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "prescan");
        return FAILURE;
    }
    
    /***********************************************************************
     * Generic SECTION
     ***********************************************************************/

    if(PSD_ON == exist(oprtcgate)) {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_ON), phys_record_flag) : PSD_ON; /* flag for rt data recording */
    } else {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_OFF), phys_record_flag) : PSD_OFF;
    }

    /* go through entry point table and set frequency offset based on receiver */
    for( i = 0; i < ENTRY_POINT_MAX; i++ )
    {
        PSfreq_offset[i] = cfreceiveroffsetfreq;
    }

    pw_omegarf0cfh  = _pw_omegarf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_omegarf0cfh) : pw_rf0cfh; /* adiabatic pulse */

    PSslice_ind  = _PSslice_ind.fixedflag ?  ((void)(PSslice_num), PSslice_ind) : PSslice_num;  /* MRIge90312 -- for smart prescan */

    PStloc     = _PStloc.fixedflag ?       ((void)(scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift), PStloc) : scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift;
    PSrloc     = _PSrloc.fixedflag ?       ((void)(scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift), PSrloc) : scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift;
    PSphasoff  = _PSphasoff.fixedflag ?    ((void)(scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift), PSphasoff) : scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift;

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_OFF == local_tg) )
    {
        cvunlock(PStloc_mod);
        cvunlock(PSrloc_mod);
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(getAps1ModPsTloc()), PStloc_mod) : getAps1ModPsTloc();
        PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(getAps1ModPsRloc()), PSrloc_mod) : getAps1ModPsRloc();
        PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(0), PSphasoff_mod) : 0; /* phase offset is not used */
        if(PSD_AXIAL == opplane)  /* To handle table delta */
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            if(2 == opentry)    /* Feet First */
            {
                PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(-PStloc), PStloc_mod) : -PStloc;
            }
        }
    }
    else if (PSD_ON == local_tg)
    {
        if (oppscvquant > 0)  /* use shim vol */
        {
            /* The default case for Localized TG = use Shim Vol info */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(psc_info[0].oppsctloc), PStloc_mod) : psc_info[0].oppsctloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(psc_info[0].oppscrloc), PSrloc_mod) : psc_info[0].oppscrloc;    
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(psc_info[0].oppscphasoff), PSphasoff_mod) : psc_info[0].oppscphasoff;    
        }
        else
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(PSrloc), PSrloc_mod) : PSrloc;
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(PSphasoff), PSphasoff_mod) : PSphasoff;
        }
    }
    else  /* use imaging locs */
    { 
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
        PSrloc_mod  = _PSrloc_mod.fixedflag ?      ((void)(opspf?PSphasoff:PSrloc), PSrloc_mod) : opspf?PSphasoff:PSrloc;    
    }
    /* end aps1_mod changes (GE) */

   /* Create rsp_psc_info table based on psc_info */
    for ( i=0; i < exist(oppscvquant); i ++) {
        rsp_psc_info[i].rsppsctloc = psc_info[i].oppsctloc;
        rsp_psc_info[i].rsppscrloc = psc_info[i].oppscrloc;
        rsp_psc_info[i].rsppscphasoff = psc_info[i].oppscphasoff;

        rsp_psc_info[i].rsppsclenx = psc_info[i].oppsclenx;
        rsp_psc_info[i].rsppscleny = psc_info[i].oppscleny;
        rsp_psc_info[i].rsppsclenz = psc_info[i].oppsclenz; 
    }

    /* Check the rotation matrix for rsp_psc_info */
    for (i=0; i< exist(oppscvquant); i++) {
        for (j=0; j<9; j++) {
            rsp_psc_info[i].rsppscrot[j] = hostToRspRotMat(psc_info[0].oppscrot[j]);
        }
    } 

    /* fill in the prescan rotation array for the prescan slice.
       PSrot is an ipgexport defined in epic.h  */

    /*
     * MRIge43971 BJM: loop over 2D PSrot array to be consistent with other
     *                 rotation matrices and since scalerotmats() expects a 2D
     *                 argument.
     */
    for (index = 0; index < 9; index++)
    {
        PSrot[0][index] = hostToRspRotMat(scan_info[PSslice_num].oprot[index]);
        PSrot_mod[0][index] = hostToRspRotMat(ps1scan_info[0].oprot[index]); 
        rsp_PSrot[0][index] = hostToRspRotMat(cfh_info[0].oprot[index]);
        rsp_rcvnrot[0][index] = hostToRspRotMat(rcvnscan_info[0].oprot[index]);


        /* set up rot for CFH */
        for( vidx = 1; vidx < oppscvquant; vidx++ )
        {
            rsp_PSrot[vidx][index] = hostToRspRotMat(cfh_info[vidx].oprot[index]);

        }
    }

    /* Scale Rot matrix for RCVN */
    if(scalerotmats(rsp_rcvnrot, &rcvnloggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for CFH */
    if(scalerotmats(rsp_PSrot, &cfhloggrd, &phygrd, IMax(2,1,exist(oppscvquant)), cfhobl_debug) == FAILURE) /* YMSmr09211  04/26/2006 YI */
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }
    
    /* Scale Rot matrix for CFL */
    if(scalerotmats(PSrot, &loggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for ps1 & FTG  & XTG */
    if(scalerotmats(PSrot_mod, &ps1loggrd, &phygrd, 1, ps1obl_debug) == FAILURE) 
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    PStrigger  = _PStrigger.fixedflag ?  ((void)(TRIG_LINE), PStrigger) : TRIG_LINE;

    /* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
    pitr = 2000000;	        /* 1st pass prescan TR 	*/
    pichop = 0;		/* No chop		*/

    /* find minimum rfamp te time based on duty cycle */
    min180te  = _min180te.fixedflag ?    
                                 
                                ((void)(RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2), min180te) : RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1predownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1predownload");
        return ps_status;
    }


    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNpredownload");
        return ps_status;
    }

    /* xmtaddRef is used for calculating TG value to be stored in smart prescan DB wrt a
     * reference maxB1 used in TG entry point */
    xmtaddRef = -200*log10(cfmaxb1ref/100.0/maxB1Seq) + getCoilAtten();

    /* HCSDM00184619 : Tools PSD dont inline PSpreDwonload.
     * This should move to a routine which  psdIF can handle. */

    /* Copy coilInfo, volRecCoilInfo, txCoilInfo to target side */
    copyCoilInfo();

    chksum_rampdir_tgt = chksum_rampdir;
    cframpdir_tgt = cframpdir;

    if(exist(opquickstep))  /* skip TG for quickstep */
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_psctg) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_psctg) : APS_CONTROL_PSC;
    }
    pidotg = doTG(psd_psctg);  /* set PSC TG control flag */

    return SUCCESS;

}   /* end PSpredownload() */


/*
 *  FTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpredownload( void )
{
    /* Set xmtaddFTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddFTG is too big.
       We are assuming that the pulse shapes used in CFH are the
       same as in scan. */
    xmtaddFTG  = _xmtaddFTG.fixedflag ?    ((void)(-200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten()), xmtaddFTG) : -200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddFTG > cfdbmax)
    {
        ftgscale  = _ftgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0)), ftgscale) : (float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0);
        xmtaddFTG  = _xmtaddFTG.fixedflag ?  ((void)(cfdbmax), xmtaddFTG) : cfdbmax;
    }
    else
    {
        ftgscale  = _ftgscale.fixedflag ?  ((void)(1.0), ftgscale) : 1.0;
    }

    if (setScale(L_FTG,RF_FREE,rfpulse,maxB1[L_FTG],ftgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale ftg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1ftg  = _ia_rf1ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp))), ia_rf1ftg) : (int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp));
    ia_rf2ftg  = _ia_rf2ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp))), ia_rf2ftg) : (int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp));
    ia_rf3ftg  = _ia_rf3ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp))), ia_rf3ftg) : (int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp));
    
    entry_point_table[L_FTG].epxmtadd = (short)rint((double)xmtaddFTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_FTG],
                  L_FTG,
                  (int)RF_FREE,
                  rfpulse,
                  ftgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ftg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddFTG), xmtadd) : xmtaddFTG;

    entry_point_table[L_FTG].epfilter = (n8)filter_echo1ftg; /* 11/24/94 YI */
    entry_point_table[L_FTG].epprexres = 256;
    
    FTGxmtadd  = _FTGxmtadd.fixedflag ?  ((void)(entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd), FTGxmtadd) : entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp462_min_seqgrad=min_seqgrad,&_temp462_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqftg, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* Use volRec coil for FTG */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_FTG], 0);
    } 

    return SUCCESS;
}   /* end FTGpredownload() */


/*
 *  XTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpredownload( void )
{
    {
        float trsarscale = 1.0;
        int xtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&xtg_maxseqsar, RF_FREE, rfpulse, L_XTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar xtg");
            return FAILURE;
        }

        if( isLowSarEnabled() )
        {
            trsarscale = 1.2;   /* HCSDM00381012: adding 20% tr to prevent UPM trip for low SAR */
        }

        if(xtgtr < (int)(xtg_maxseqsar*trsarscale))
        {
            xtgtr  = _xtgtr.fixedflag ?  ((void)(RUP_GRD((int)(xtg_maxseqsar*trsarscale))), xtgtr) : RUP_GRD((int)(xtg_maxseqsar*trsarscale));
        }
    }
    
    /* Set xmtaddXTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddXTG is too big. */
    xmtaddXTG  = _xmtaddXTG.fixedflag ?    ((void)(-200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten()), xmtaddXTG) : -200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten();

    if (xmtaddXTG > cfdbmax)
    {
        xtgscale  = _xtgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0)), xtgscale) : (float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0);
        xmtaddXTG  = _xmtaddXTG.fixedflag ?  ((void)(cfdbmax), xmtaddXTG) : cfdbmax;
    }
    else
    {
        xtgscale  = _xtgscale.fixedflag ?  ((void)(1.0), xtgscale) : 1.0;
    }

    if (setScale(L_XTG,RF_FREE,rfpulse,maxB1[L_XTG],xtgscale) == FAILURE)  
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale xtg");
        return FAILURE;
    }  
    
    /* Set the amplitude scale factors. */
    ia_rf1xtg  = _ia_rf1xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp))), ia_rf1xtg) : (int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp));
    ia_rf2xtg  = _ia_rf2xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp))), ia_rf2xtg) : (int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp));
    ia_rf4xtg  = _ia_rf4xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp))), ia_rf4xtg) : (int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp));
    ia_rf3xtg  = _ia_rf3xtg.fixedflag ?  ((void)(-ia_rf4xtg), ia_rf3xtg) : -ia_rf4xtg;
    a_rf3xtg   = _a_rf3xtg.fixedflag ?  ((void)(-a_rf4xtg), a_rf3xtg) : -a_rf4xtg;
    
    entry_point_table[L_XTG].epxmtadd = (short)rint((double)xmtaddXTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_XTG],
                  L_XTG,
                  (int)RF_FREE,
                  rfpulse,
                  xtgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon xtg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddXTG), xmtadd) : xmtaddXTG;

    entry_point_table[L_XTG].epfilter = (n8)filter_echo1xtg; /* 11/24/94 YI */
    entry_point_table[L_XTG].epprexres = 256;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp463_min_seqgrad=min_seqgrad,&_temp463_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqxtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    if ( (2 == getAps1Mod()) && (PSD_OFF == local_tg) )
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_ON), xtg_volRecCoil) : PSD_ON;
    }
    else
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_OFF), xtg_volRecCoil) : PSD_OFF;
    }

    if(PSD_ON == xtg_volRecCoil)
    {
        /* Use volRec coil for XTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_XTG], 0);
        } 
    }

    return SUCCESS;
}   /* end XTGpredownload() */


/*
 *  ASpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpredownload( void )
{
    FLOAT asscale;
 
    /******************************************************************/
    /* Set xmtaddas according to maximum B1 and rescale for powermon, */
    /* adding additional (audio) scaling if xmtaddas is too big.      */
    /* We are assuming that the pulse shapes used in CFH are the      */
    /* same as in scan.                                               */
    /******************************************************************/

    strcpy(entry_point_table[L_AUTOSHIM].epname, "autoshim");

    xmtaddas  = _xmtaddas.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten()), xmtaddas) : -200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddas > cfdbmax) 
    {
        asscale = (float) pow(10.0, (cfdbmax - xmtaddas)/200.0);
        xmtaddas  = _xmtaddas.fixedflag ?  ((void)(cfdbmax), xmtaddas) : cfdbmax;
    } 
    else
    {
        asscale = 1.0;
    }

    if (setScale(L_AUTOSHIM, RF_FREE, rfpulse, maxB1[L_AUTOSHIM],
                 asscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale autoshim");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1as  = _ia_rf1as.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp))), ia_rf1as) : (int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp));

    entry_point_table[L_AUTOSHIM].epxmtadd=(short)rint((double)xmtaddas);
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_AUTOSHIM],
                  L_AUTOSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_as ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon autoshim");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp464_min_seqgrad=min_seqgrad,&_temp464_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqaushim, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_AUTOSHIM].epfilter = (n8)filter_echo1as;
    entry_point_table[L_AUTOSHIM].epprexres = asxres;
    
    /* Use volRec coil for autoshim */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_AUTOSHIM], 0);
    } 

    if(exist(opquickstep))  /* skip AutoShim for quickstep */
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_pscshim) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_pscshim) : APS_CONTROL_PSC;
    }
    pidoshim = doAS(psd_pscshim);  /* set PSC AutoShim control flag */ 

    return SUCCESS;
}   /* end ASpredownload() */

/*
 *  RSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpredownload( void )
{
    FLOAT rsscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);


    {
        INT rs_maxseqsar = 0;

        if(FAILURE == maxseqsar(&rs_maxseqsar, RF_FREE, rfpulse, L_RFSHIM))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar RF Shim");
            return FAILURE;
        }
        if(tr_rs < rs_maxseqsar)
        {
            tr_rs  = _tr_rs.fixedflag ?  ((void)(RUP_GRD(rs_maxseqsar)), tr_rs) : RUP_GRD(rs_maxseqsar);
        }
    }

    DD_nCh  = _DD_nCh.fixedflag ?  ((void)(DD_channels), DD_nCh) : DD_channels;

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_RFSHIM].epname,  "RFshim");

    xmtaddrs  = _xmtaddrs.fixedflag ?    ((void)(-200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten()), xmtaddrs) : -200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddrs > cfdbmax) 
    {
        rsscale = (float) pow(10.0, (cfdbmax - xmtaddrs)/200.0);
        xmtaddrs  = _xmtaddrs.fixedflag ?  ((void)(cfdbmax), xmtaddrs) : cfdbmax;
    } 
    else
    {
        rsscale = 1.0;
    }

    if (setScale(L_RFSHIM, RF_FREE, rfpulse, maxB1[L_RFSHIM],
                 rsscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale B1Map");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbrs  = _ia_rfbrs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp)), ia_rfbrs) : max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp);
    ia_thetarfbrs  = _ia_thetarfbrs.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbrs) : max_pg_iamp;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    ia_rf1rs  = _ia_rf1rs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp)), ia_rf1rs) : max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp);

    entry_point_table[L_RFSHIM].epxmtadd=(short)rint((double)xmtaddrs);

    if( powermon( &entry_point_table[L_RFSHIM],
                  L_RFSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_rs ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon DynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp465_min_seqgrad=min_seqgrad,&_temp465_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqrs, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_RFSHIM].epfilter = (n8)filter_echo1rs;
    entry_point_table[L_RFSHIM].epprexres = rfshim_xres;

    /* set up B1 Map slice orientation and location */
    for (j = 0; j < rfshim_slquant; j++)
    {
        if(PSD_ON == rsaxial_flag)
        {
            rsrsp_info[j].rsprloc = 0.0;
            rsrsp_info[j].rspphasoff = 0.0;
            rsrsp_info[j].rsptloc = 0.0;

            if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast")
               && (2 == exist(oppos)))  /* Prone breast scans */

            {
                rsrsp_info[j].rsprloc = -120.0;  /* offset in A/P diresction for breast coils */
            }
        }
        else
        {
            rsrsp_info[j].rsprloc = scan_info[PSslice_num].oprloc + scan_info[PSslice_num].oprloc_shift;
            rsrsp_info[j].rspphasoff = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            rsrsp_info[j].rsptloc = scan_info[PSslice_num].optloc + scan_info[PSslice_num].optloc_shift;
        }

        for (i = 0; i < 9; i++)
        {
            rsrsprot[j][i] = hostToRspRotMat(rsscan_info[0].oprot[i]); /* use Rxed slice rot */ 
        }
    }

    scalerotmats(rsrsprot, &rsloggrd, &phygrd, rfshim_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    rfshim_b1factor  = _rfshim_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs), rfshim_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs; 

    return SUCCESS;
}   /* end RSpredownload() */

/*
 *  DTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpredownload( void )
{
    FLOAT dtgscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    FLOAT *dynTG_loc = NULL;

    {
        INT dtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&dtg_maxseqsar, RF_FREE, rfpulse, L_DYNTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar dynamic tg");
            return FAILURE;
        }
        if(tr_dtg < dtg_maxseqsar)
        {
            tr_dtg  = _tr_dtg.fixedflag ?  ((void)(RUP_GRD(dtg_maxseqsar)), tr_dtg) : RUP_GRD(dtg_maxseqsar);
        }
    }

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_DYNTG].epname,  "DynTG");

    xmtadddtg  = _xmtadddtg.fixedflag ?    ((void)(-200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten()), xmtadddtg) : -200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten();
    if (xmtadddtg > cfdbmax) 
    {
        dtgscale = (float) pow(10.0, (cfdbmax - xmtadddtg)/200.0);
        xmtadddtg  = _xmtadddtg.fixedflag ?  ((void)(cfdbmax), xmtadddtg) : cfdbmax;
    } 
    else
    {
        dtgscale = 1.0;
    }

    if (setScale(L_DYNTG, RF_FREE, rfpulse, maxB1[L_DYNTG],
                 dtgscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale DynTG");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbdtg  = _ia_rfbdtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp)), ia_rfbdtg) : max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp);
    ia_thetarfbdtg  = _ia_thetarfbdtg.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbdtg) : max_pg_iamp;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;
    ia_rf1dtg  = _ia_rf1dtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp)), ia_rf1dtg) : max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp);

    entry_point_table[L_DYNTG].epxmtadd=(short)rint((double)xmtadddtg);

    if( powermon( &entry_point_table[L_DYNTG],
                  L_DYNTG,
                  (int)RF_FREE,
                  rfpulse,
                  tr_dtg ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon dynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp466_min_seqgrad=min_seqgrad,&_temp466_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqdtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_DYNTG].epfilter = (n8)filter_echo1dtg;
    entry_point_table[L_DYNTG].epprexres = dynTG_xres;

    /* Now copy into Map TG */
    entry_point_table[L_MAPTG] = entry_point_table[L_DYNTG];
    strcpy(entry_point_table[L_MAPTG].epname,  "mapTg");

    dynTG_loc =  (float*)AllocNode(dynTG_slquant*sizeof(float));
    if (NULL == dynTG_loc)
    {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "AllocNode for dynTG_loc" );
        return FAILURE;
    }

    if(PSD_OFF == enableMapTg)
    {
        dynTG_sliceloc(dynTG_loc, dynTG_slquant, exist(opslquant), 1);
    }
    /* set up B1 Map slice orientation and location */
    for (j = 0; j < dynTG_slquant; j++)
    {
        if(PSD_ON == enableMapTg)
        {
            dtgrsp_info[j].rsprloc = 0.0;
            dtgrsp_info[j].rspphasoff = 0.0;
            dtgrsp_info[j].rsptloc = 0.0;

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(maptgscan_info[0].oprot[i]); /* use axial slice rot */
            }
        }
        else
        {
            int index0, index1;
            index0 = (int)dynTG_loc[j];
            if(index0<0)
            {
                index0=0;
            }
            index1 = index0+1;
            if(index1>=exist(opslquant))
            {
                index1=exist(opslquant)-1;
            }
            dtgrsp_info[j].rsprloc = scan_info[index0].oprloc + scan_info[index0].oprloc_shift;
            dtgrsp_info[j].rspphasoff = scan_info[index0].opphasoff + scan_info[index0].opphasoff_shift;
            dtgrsp_info[j].rsptloc = scan_info[index0].optloc + scan_info[index0].optloc_shift +
                (dynTG_loc[j]-(float)index0) *
                (scan_info[index1].optloc + scan_info[index1].optloc_shift - scan_info[index0].optloc - scan_info[index0].optloc_shift);

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(scan_info[index0].oprot[i]); /* use Rxed slice rot */ 
            }
        }
    }

    FreeNode(dynTG_loc);

    scalerotmats(dtgrsprot, &dtgloggrd, &phygrd, dynTG_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    dynTG_b1factor  = _dynTG_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg), dynTG_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg; 

    if( (PSD_ON == enableMapTg) && (PSD_ON == xtg_volRecCoil))
    {
        /* Use volRec coil for mapTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_MAPTG], 0);
        } 
    }

    return SUCCESS;
}   /* end DTGpredownload() */



/*
 *  ExtCalpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpredownload( void )
{
    INT i, j;
    FLOAT calscale = 1.0;

    /* SAR check */
    {
        INT cal_maxseqsar = 0;

        if(FAILURE == maxseqsar(&cal_maxseqsar, RF_FREE, rfpulse, L_EXTCAL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar Cal");
            return FAILURE;
        }
        if(tr_cal < cal_maxseqsar)
        {
            tr_cal  = _tr_cal.fixedflag ?  ((void)(RUP_GRD(cal_maxseqsar)), tr_cal) : RUP_GRD(cal_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_EXTCAL].epname,  "extcal");

    xmtaddcal  = _xmtaddcal.fixedflag ?    ((void)(-200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten()), xmtaddcal) : -200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcal > cfdbmax)
    {
        calscale = (float) pow(10.0, (cfdbmax - xmtaddcal)/200.0);
        xmtaddcal  = _xmtaddcal.fixedflag ?  ((void)(cfdbmax), xmtaddcal) : cfdbmax;
    } 
    else
    {
        calscale = 1.0;
    }

    if (setScale(L_EXTCAL, RF_FREE, rfpulse, maxB1[L_EXTCAL],
                 calscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cal");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1cal  = _ia_rf1cal.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp)), ia_rf1cal) : max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp);

    entry_point_table[L_EXTCAL].epxmtadd=(short)rint((double)xmtaddcal);

    if( powermon( &entry_point_table[L_EXTCAL],
                  L_EXTCAL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_cal ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cal");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp467_min_seqgrad=min_seqgrad,&_temp467_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcal, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_EXTCAL].epfilter = (n8)filter_echo1cal;
    entry_point_table[L_EXTCAL].epprexres = cal_xres;


    if(cal_tr_interleave)  /* always set body coil ON for cal scan */
    {
        entry_point_table[L_EXTCAL].epRxCoilType = (n32)volRecCoilInfo[0].rxCoilType;
    }

    for( j = 0; j < cal_slq; j++)
    {
        calrsp_info[j].rsptloc = (calscan_info[cal_slq/2].optloc + calscan_info[cal_slq/2].optloc_shift
                                  + calscan_info[cal_slq/2-1].optloc + calscan_info[cal_slq/2-1].optloc_shift)/2.0;
        calrsp_info[j].rsprloc = calscan_info[0].oprloc + calscan_info[0].oprloc_shift;
        calrsp_info[j].rspphasoff = calscan_info[0].opphasoff + calscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            calrsprot[j][i] = hostToRspRotMat(calscan_info[0].oprot[i]); 
        }
    }

    scalerotmats(calrsprot, &calloggrd, &original_pgrd, cal_slq, ps1obl_debug);

    /* corner cutting */
    cal_pfkr_fraction  = _cal_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), cal_pfkr_fraction) : PI/4.0;  /* same as task based 3D Cal */
    cal_pfkr_flag  = _cal_pfkr_flag.fixedflag ?  ((void)(PSD_ON), cal_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( cal_zyindex,
                                    cal_yres,
                                    cal_slq,
                                    cal_yfov,
                                    cal_vthick,
                                    cal_pfkr_flag,
                                    cal_pfkr_fraction,
                                    _cal_sampledPts.fixedflag ? (_temp468_cal_sampledPts=cal_sampledPts,&_temp468_cal_sampledPts) : &cal_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }

    return SUCCESS;
}   /* end ExtCalpredownload() */


/*
 *  AutoCoilpredownload
 *  
 *  Type: Public Function
 *  
 *  Description: Predownload settings for AutoCoil entry point
 *  
 */
STATUS
AutoCoilpredownload( void )
{
    INT i, j;
    FLOAT coilscale = 1.0;

    /* SAR check */
    {
        INT coil_maxseqsar = 0;

        if(FAILURE == maxseqsar(&coil_maxseqsar, RF_FREE, rfpulse, L_AUTOCOIL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar AutoCoil");
            return FAILURE;
        }
        if(tr_coil < coil_maxseqsar)
        {
            tr_coil  = _tr_coil.fixedflag ?  ((void)(RUP_GRD(coil_maxseqsar)), tr_coil) : RUP_GRD(coil_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_AUTOCOIL].epname,  "Autocoil");

    xmtaddcoil  = _xmtaddcoil.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten()), xmtaddcoil) : -200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcoil > cfdbmax)
    {
        coilscale = (float) pow(10.0, (cfdbmax - xmtaddcoil)/200.0);
        xmtaddcoil  = _xmtaddcoil.fixedflag ?  ((void)(cfdbmax), xmtaddcoil) : cfdbmax;
    } 
    else
    {
        coilscale = 1.0;
    }

    if (setScale(L_AUTOCOIL, RF_FREE, rfpulse, maxB1[L_AUTOCOIL],
                 coilscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale coil");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1coil  = _ia_rf1coil.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp)), ia_rf1coil) : max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp);

    entry_point_table[L_AUTOCOIL].epxmtadd=(short)rint((double)xmtaddcoil);

    if( powermon( &entry_point_table[L_AUTOCOIL],
                  L_AUTOCOIL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_coil ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon coil");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp469_min_seqgrad=min_seqgrad,&_temp469_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcoil, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* setup entry point table for Auto Coil */
    entry_point_table[L_AUTOCOIL].epfilter = (n8)filter_echo1coil;
    entry_point_table[L_AUTOCOIL].epprexres = coil_xres;

    /* Full coil mode for auto coil */
    entry_point_table[L_AUTOCOIL].epGeneralBankIndex = fullRecCoilInfo[0].hubIndex;
    entry_point_table[L_AUTOCOIL].epGeneralBankIndex2 = fullRecCoilInfo[0].hubIndex;
    entry_point_table[L_AUTOCOIL].epstartrec = 0;
    entry_point_table[L_AUTOCOIL].ependrec = fullRecCoilInfo[0].numChannels;

    for( j = 0; j < coil_slq; j++)
    {
        coilrsp_info[j].rsptloc = (coilscan_info[coil_slq/2].optloc + coilscan_info[coil_slq/2].optloc_shift
                                  + coilscan_info[coil_slq/2-1].optloc + coilscan_info[coil_slq/2-1].optloc_shift)/2.0;
        coilrsp_info[j].rsprloc = coilscan_info[0].oprloc + coilscan_info[0].oprloc_shift;
        coilrsp_info[j].rspphasoff = coilscan_info[0].opphasoff + coilscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            coilrsprot[j][i] = hostToRspRotMat(coilscan_info[0].oprot[i]); 
        }
    }

    scalerotmats(coilrsprot, &coilloggrd, &phygrd, coil_slq, ps1obl_debug);

    /* corner cutting */
    coil_pfkr_fraction  = _coil_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), coil_pfkr_fraction) : PI/4.0;
    coil_pfkr_flag  = _coil_pfkr_flag.fixedflag ?  ((void)(PSD_ON), coil_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( coil_zyindex,
                                    coil_yres,
                                    coil_slq,
                                    coil_yfov,
                                    coil_vthick,
                                    coil_pfkr_flag,
                                    coil_pfkr_fraction,
                                    _coil_sampledPts.fixedflag ? (_temp470_coil_sampledPts=coil_sampledPts,&_temp470_coil_sampledPts) : &coil_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }


    return SUCCESS;
}   /* end AutoCoilpredownload() */


/* CoilSwitchGetTR (MRIhc15304)
 * 
 * Description:
 *   This function returns the TR for the coilSwitch SSP sequence based on
 *   the setRcvPortFlag as passed to CoilSwitchSetCoil.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  (O) return: TR in usec
 *  (I) setRcvPortFlag - flag to indicate that setrcvportimm will be
 *        executed when switching coils.  See CoilSwitchSetCoil
 */
int
CoilSwitchGetTR(const int setRcvPortFlag)
{
    int wait_rspimm = 0;
    
    /* When asynchronous RSP function calls are needed, the wait time is
     * extended to accomodate the worst case RSP time */
    if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
    {
        wait_rspimm = csw_wait_sethubindeximm;
    }

    if( setRcvPortFlag )
    {
        wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
    }

    return csw_tr + wait_rspimm;
}

/* doTG 
 *
 * Description:
 *  This function returns the doTG flag 
 *     PSD_CONTROL_PSC_SKIP -1: PSD force to skip TG
 *     APS_CONTROL_PSC       0: follow default smart prescan rules for TG
 *     PSD_CONTROL_PSC_RUN   1: force to run TG entry point for specific applications
 */
int
doTG(int psd_psc_control)
{
    int TG_control = psd_psc_control;
    if( ( exist(opdiffuse)
          || exist(opasl) 
          || (PSD_2D == exist(opimode) && PSD_SE == exist(oppseq) && PSD_OFF == exist(opfast)) 
          || (PSD_3D == exist(opimode) && PSD_SE == exist(oppseq) && exist(opinhance)) /* delta flow */ 
          || (PSD_SPECTRO == exist(opimode))
          || (PSD_OFF != exist(opflair)) || PSD_3PLANE == exist(opplane))
        && (!isValueSystem())
        && (APS_CONTROL_PSC == TG_control) )
    {
        TG_control = PSD_CONTROL_PSC_RUN;
    }

    if((TG_control != PSD_CONTROL_PSC_SKIP) && (TG_control != PSD_CONTROL_PSC_RUN) && (TG_control != APS_CONTROL_PSC))
    {
        TG_control = APS_CONTROL_PSC;
    }

    return TG_control;
}

/* doAS
 *
 * Description:
 *  This function returns the doAS flag 
 *     PSD_CONTROL_PSC_SKIP    -1: PSD force to skip autoshim 
 *     APS_CONTROL_PSC          0: follows default smart prescan rules for AS 
 *     PSD_CONTROL_PSC_RUN      1: forces to run Autoshim entry point for specific applications
 *     PSD_CONTROL_PSC_SPECIAL  2: forces to run global Autoshim for specific applications (breast DWI) 
 */
int
doAS(int psd_psc_control)
{
    int AS_control = psd_psc_control;
    if( ( PSD_ON == pimrsapsflg
          || PSD_ON == exist(opepi)
          || PSD_ON == exist(opspiral)
          || PSD_SSFP == oppseq
          || PSD_ON == exist(opvrg)
          || exist(opfat) || exist(opfatcl)
          || exist(opspecir) || exist(opwater))
        && (APS_CONTROL_PSC == AS_control)
        && (GRADSHIM_OFF != exist(opgradshim)) )
    {
        AS_control = PSD_CONTROL_PSC_RUN;
    }  /* Auto Shim is required for MRS, EPI, Spiral, VERSE and fiesta and Chem Sat */

    if((AS_control != PSD_CONTROL_PSC_SKIP) && (AS_control != PSD_CONTROL_PSC_RUN) 
       && (AS_control != APS_CONTROL_PSC) && (AS_control != PSD_CONTROL_PSC_SPECIAL))
    {
        AS_control = APS_CONTROL_PSC;
    }

    return AS_control;
}

/* generate zy encoding index for 3D acquisition for sequential order */
STATUS
generateZyIndex(ZY_INDEX * zy_index,
                const int zy_views,
                const int zy_slices,
                const float yFov,
                const float zFov,
                const int psc_pfkr_flag,
                const float psc_pfkr_fraction,
                int *zy_sampledPoints)
{
    n8 *xzPlanes = NULL;
    int i, j;
    int maxView = 0;
    float dist_ky, dist_kz;
    int superindex = 0;
    int sampledPts = 0;

    int zy_encodes = zy_views * zy_slices;
    float maskDist = 0;  /* Fake distance for sorting  masked encodess */
    float skipDist = 0;  /* Fake distance for sorting  encodes skipped due to
                            parallel imaging */

    float delta_ky = 1.0/yFov;  /* inverse mm */
    float delta_kz = 1.0/zFov;  /* inverse mm also */
    float origin_y = (float)(zy_views-1)/2.0 - 0.01;
    float origin_z = (float)(zy_slices-1)/2.0 - 0.01;
    float kr_fraction = 0.0;
    float max_dist_ky = 0.0;
    float max_dist_kz = 0.0;
    float sq_max_dist_ky = 0.0;
    float sq_max_dist_kz = 0.0;
    float sq_normdist_ky = 0.0;


    /*  Use dynamic memory allocation for zy_sort & zy_export */
    ZY_DIST1 *cal_zy_sort = NULL;
    if ((cal_zy_sort = (ZY_DIST1 *) malloc(sizeof(ZY_DIST1) * zy_encodes)) == NULL) {
        printf("%s: Failure allocating cal_zy_sort.\n", "generateZyIndex");
        return FAILURE;
    }
    memset(cal_zy_sort, 0, sizeof(ZY_DIST1) * zy_encodes);


    kr_fraction = sqrt(psc_pfkr_fraction*4.0/PI);
    max_dist_ky = 0.505*kr_fraction*delta_ky*(float)(zy_views-1);
    max_dist_kz = 0.505*kr_fraction*delta_kz*(float)(zy_slices-1);
    sq_max_dist_ky = max_dist_ky * max_dist_ky;
    sq_max_dist_kz = max_dist_kz * max_dist_kz;
    maskDist = 100.0*sqrt(sq_max_dist_ky + sq_max_dist_kz);

    if (maskDist < 10.0 * (float)(zy_encodes))
    {
        maskDist = 10.0 * (float)(zy_encodes);
    }

    skipDist = 2.0 * maskDist;

    superindex = 0;
    sampledPts = 0;

    for (i=0; i<zy_views; i++)
    {
        /*views start at 0*/
        dist_ky = delta_ky*(i - origin_y);
        sq_normdist_ky = pow(dist_ky, 2)/ sq_max_dist_ky;

        for (j=0; j<zy_slices; j++)
        {

            cal_zy_sort[superindex].view = i; /* sequential ordering: views start at 0*/
            cal_zy_sort[superindex].slice = j;  /*slices start at 0*/
            cal_zy_sort[superindex].flags  = 0; /* Initialized all flags to off */
            cal_zy_sort[superindex].distance =  (float) superindex;


            if (psc_pfkr_flag)
            {
                dist_kz = delta_kz*((float)(cal_zy_sort[superindex].slice) - origin_z);

                if ((sq_normdist_ky + (dist_kz*dist_kz)/ sq_max_dist_kz) > 1.0)
                {
                    cal_zy_sort[superindex].flags |= ZY_REMOVED;
                    cal_zy_sort[superindex].distance = maskDist;
                }
                else
                {
                    sampledPts +=1;
                }
            }
            else
            {
                sampledPts +=1;
            }

            superindex +=1;
        }
    }
    /* Sort to push the skipped and mask points to the end */
    qsort(cal_zy_sort, zy_encodes, sizeof(ZY_DIST1), psc_dist_compare);

    for (i=0; i < zy_encodes; i++)
    {
        zy_index[i].view = cal_zy_sort[i].view;
        zy_index[i].slice = cal_zy_sort[i].slice;
        zy_index[i].flags = cal_zy_sort[i].flags;
    }

    free(cal_zy_sort);

    maxView = 0;

    /* set flag for xz plane done */
    for (i=0; i < sampledPts; i++)
    {
        if (zy_index[i].view > maxView)
        {
            maxView = zy_index[i].view;
        }
    }
    /* Increment maxView such that it is the # of views to allocate */
    maxView++;

    /* Allocate buffer to keep track of XZ-planes completed */
    xzPlanes = (n8 *) malloc(sizeof(n8) * maxView);

    /* Initialize all XZ-planes */
    memset(xzPlanes, 1, sizeof(n8) * maxView);

    for (i = sampledPts - 1; i >= 0; i--)
    {
        if (xzPlanes[zy_index[i].view])
        {
            zy_index[i].flags |= ZY_XZ_PLANE_DONE;
            xzPlanes[zy_index[i].view] = 0;
        }
        else
        {
            zy_index[i].flags &= ~ZY_XZ_PLANE_DONE;
        }
    }

    free(xzPlanes);
    
    if(PSdebugstate)
    {
        const CHAR * export_filename = "pscCal.info";
        FILE * fid;
        fid = fopen(export_filename, "w");

        for (i = 0; i < zy_encodes; i++)
        {
            fprintf(fid, "PSC cal Info: superindex= %d view= %d slice=%d flags= %d \n",
                    i, zy_index[i].view, zy_index[i].slice, zy_index[i].flags);
        }

        fclose(fid);

    }

    *zy_sampledPoints = sampledPts;   /* fully sampled zy */


    return SUCCESS;
}

int psc_dist_compare(const void *dist1, const void *dist2)
{
        return (((ZY_DIST1 *)dist2)->distance < ((ZY_DIST1 *)dist1)->distance )? 1: -1;
}



#include "InitAdvisories.h"

/*-------------------------------------------------------------------
 * PROCEDURE: InitAdvPnlCVs
 * INPUT: none
 * OUTPUT: none
 * RETURN: none
 * SYNOPSIS: This function sets the advisory panel minimum and maximum values
 *           for advisory panel cvs which are not set in cveval. This gives us
 *           the opportunity to start placing items into the 8.0 EPIC Advisory
 *           Panel popup as desired.
 *
 *           Example:
 *                 if (exist(opssfse)!=PSD_OFF && exist(opnex)!=0.5) {
 *                      avminnex = avmaxnex = 0.5;
 *                      return ADVISORY_FAILURE;
 *                 }
 *           The above will ensure that (Nex 0.5) appears in the popup as a valid choice.
 *
 *---------------------------------------------------------------------*/
void 
InitAdvPnlCVs( void )
{
 avmaxnecho = _opnecho.maxval;
 avmaxte = _opte.maxval;
 avmaxte2 = _opte2.maxval;
 avmaxti = _opti.maxval;
 avmaxtr = _optr.maxval;
 avmaxfov = _opfov.maxval;
 avmaxyres = _opyres.maxval;
 avmaxxres = _opxres.maxval;
 avmaxrbw = _oprbw.maxval; 
 avmaxrbw2 = _oprbw2.maxval;
 avmaxsldelay = _opsldelay.maxval;
 avmaxetl = _opetl.maxval;
 avmaxslicecnt = _opslicecnt.maxval;
 avmaxnshots = _opnshots.maxval;
 avmaxphasefov = _opphasefov.maxval;
 avmaxslthick = _opslthick.maxval;
 avmaxnex = _opnex.maxval;
 avmaxflip = _opflip.maxval;
 avminnecho = _opnecho.minval;
 avminte = _opte.minval;
 avminte2 = _opte2.minval;
 avminti = _opti.minval;
 avmintr = _optr.minval;
 avminfov = _opfov.minval;
 avmaxslquant = _opslquant.maxval;
 avminslquant = _opslquant.minval;
 avminrbw = _oprbw.minval; 
 avminrbw2 = _oprbw2.minval;
 avminsldelay  = _avminsldelay.fixedflag ?  ((void)(_opsldelay.minval), avminsldelay) : _opsldelay.minval;
 avminetl = _opetl.minval;
 avminyres = _opyres.minval;
 avminslicecnt = _opslicecnt.minval;
 avminxres = _opxres.minval;
 avminnshots = _opnshots.minval;
 avminphasefov = _opphasefov.minval;
 avminslthick = _opslthick.minval;
 avminnex = _opnex.minval;
 avminflip = _opflip.minval;
 avminslspace = _opslspace.minval;
 avmaxslspace = _opslspace.maxval;
 avminbspti = _opbspti.minval;
 avmaxbspti = _opbspti.maxval;
 avminvest = _opvest.minval;
 avmaxvest = _opvest.maxval;
 avminnpwfactor = _opnpwfactor.minval;
 avmaxnpwfactor = _opnpwfactor.maxval;

 return;
}




/**
 *******************************************************************************************************
 @brief #### Mandatory GE function. Includes predownload.in

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS calcPulseParams(void) {

#include "predownload.in" /* include 'canned' predownload code */

  return SUCCESS;

} /* calcPulseParams() */




/**
 *******************************************************************************************************
 @brief #### Simulate scan locations in simulation (WTools)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS simscan(void) {

#ifndef PSD_HW

  int i, j;
  int num_slice;
  float z_delta;    /* change in z_loc between slices */
  float r_delta;    /* change in r_loc between slices */
  double alpha, beta, gamma; /* rotation angles about x, y, z respectively */

  num_slice = opslquant;

  r_delta = opfov/ num_slice;
  z_delta = opslthick + opslspace;

  ks_scan_info[0].optloc = - 0.5 * z_delta * (num_slice - 1);
  ks_scan_info[0].oprloc = 0;

  for (i = 1; i < 9; i++)
    ks_scan_info[0].oprot[i] = 0.0;

  switch (exist(opplane)) {
  case PSD_AXIAL:
    ks_scan_info[0].oprot[0] = 1.0;
    ks_scan_info[0].oprot[4] = 1.0;
    ks_scan_info[0].oprot[8] = 1.0;
    break;
  case PSD_SAG:
    ks_scan_info[0].oprot[2] = 1.0;
    ks_scan_info[0].oprot[4] = 1.0;
    ks_scan_info[0].oprot[6] = 1.0;
    break;
  case PSD_COR:
    ks_scan_info[0].oprot[2] = 1.0;
    ks_scan_info[0].oprot[6] = 1.0;
    ks_scan_info[0].oprot[7] = 1.0;
    break;
  case PSD_OBL:
    alpha = PI/ 4.0; /* rotation about x (applied first) */
    beta = 0;   /* rotation about y (applied 2nd) */
    gamma = 0;  /* rotation about z (applied 3rd) */
    ks_scan_info[0].oprot[0] = cos(gamma) * cos(beta);
    ks_scan_info[0].oprot[1] = cos(gamma) * sin(beta) * sin(alpha) -
                            sin(gamma) * cos(alpha);
    ks_scan_info[0].oprot[2] = cos(gamma) * sin(beta) * cos(alpha) +
                            sin(gamma) * sin(alpha);
    ks_scan_info[0].oprot[3] = sin(gamma) * cos(beta);
    ks_scan_info[0].oprot[4] = sin(gamma) * sin(beta) * sin(alpha) +
                            cos(gamma) * cos(alpha);
    ks_scan_info[0].oprot[5] = sin(gamma) * sin(beta) * cos(alpha) -
                            cos(gamma) * sin(alpha);
    ks_scan_info[0].oprot[6] = -sin(beta);
    ks_scan_info[0].oprot[7] = cos(beta) * sin(alpha);
    ks_scan_info[0].oprot[8] = cos(beta) * cos(alpha);
    break;
  }

  for (i = 1; i < num_slice; i++) {
    ks_scan_info[i].optloc = ks_scan_info[i - 1].optloc + z_delta;
    ks_scan_info[i].oprloc = i * r_delta;
    for (j = 0; j < 9; j++)
      ks_scan_info[i].oprot[j] = ks_scan_info[0].oprot[j];
  }

#endif /* ifdef SIM */

  return SUCCESS;

} /* simscan() */



/**
 *******************************************************************************************************
 @brief #### Initialize logical and physical gradient specifications

 This function calls inittargets() to get the physical gradient characteristics from the MR-system, 
 followed by a call to obloptimize() (slice angulation dependence) to get the logical gradient 
 specifications for the current slice angulation.

 The ramp times (loggrd.xrt/yrt/zrt) are quite conservative (and longer than the ramptimes for phygrd).
 Preliminary testing indicates that the difference between the loggrd and phygrad structs can be reduced 
 by a factor of two (not very scientific!) as a standard measure.

 For further control over the slewrate, the `srfact` argument is passed to ks_init_slewratecontrol(), 
 which can both slow down and increase the gradient slewrate.

 @param[out] loggrd The global logical gradient specification struct (dependent on slice angulation via
 global SCAN_INFO scan_info[] struct).

 @param[out] phygrd The global physical gradient struct
 @param[in] srfact
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_init_gradspecs(LOG_GRAD *loggrd, PHYS_GRAD *phygrd, float srfact) {
  int initnewgeo = 1;

  /* default gradient specs */
  inittargets(loggrd, phygrd);

  /* optimal loggrd based on current slice angulations */
  if (obloptimize(loggrd, phygrd, scan_info, exist(opslquant),
                  ((obl_method==PSD_OBL_RESTRICT) ? 4 /*oblique plane*/ : opphysplane), exist(opcoax), (int) obl_method,
                  exist(obl_debug), &initnewgeo, cfsrmode) == FAILURE) {
    return ks_error("ks_init_loggrd: obloptimize failed");
  }

  /* obloptimize() ramptimes too conservative, let's cut the difference
     between loggrd.xrt and phygrd.xrt in half */
  loggrd->xrt = (loggrd->xrt - phygrd->xrt)/ 2 + phygrd->xrt;
  loggrd->yrt = (loggrd->yrt - phygrd->yrt)/ 2 + phygrd->yrt;
  loggrd->zrt = (loggrd->zrt - phygrd->zrt)/ 2 + phygrd->zrt;

  /* reduce slewrate if srfact < 1 */
  if (ks_init_slewratecontrol(loggrd, phygrd, srfact) == FAILURE)
    return FAILURE;

  return SUCCESS;

} /* GEReq_init_gradspecs() */




/**
 *******************************************************************************************************
 @brief #### Sets up the menu for parallel imaging (ARC or ASSET) with max/min range

 @param[in] integeraccel Flag to make acceleration menu contain only integer acceleration factors
                          enums: KS_ARCMENU_FRACTACCEL (0), KS_ARCMENU_INTACCEL (1)
 @param[in] maxaccel     Maximum allowed acceleration factor for the sequence
 @retval    STATUS      `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_init_accelUI(int integeraccel, int maxaccel) {

  /* Acceleration menu */
  cfaccel_ph_maxstride = maxaccel;
  cvmax(opaccel_ph_stride, cfaccel_ph_maxstride);
  avminaccel_ph_stride = 1.0;
  avmaxaccel_ph_stride = cfaccel_ph_maxstride;
  piarccoilrestrict = 1; /* disable ARC option for single-channel coil (cf. epic.h) */

  if (KS_3D_SELECTED) { /* PSD_3D or PSD_3DM */
    cfaccel_sl_maxstride = maxaccel;
    cvmax(opaccel_sl_stride, cfaccel_sl_maxstride);
    avminaccel_sl_stride = 1.0;
    avmaxaccel_sl_stride = cfaccel_sl_maxstride;
  }

  if ((oparc || opasset == ASSET_SCAN) && maxaccel > 1) {
    if (integeraccel) {
      piaccel_phnub = 1 + maxaccel;
      piaccel_phval2 = 1.0;
      piaccel_phval3 = 2.0;
      piaccel_phval4 = 3.0;
      piaccel_phval5 = 4.0;
      piaccel_phval6 = 5.0;
      piaccel_phedit = 0; /* don't allow user to type in value */
    } else {
      piaccel_phnub = IMin(2, 6, maxaccel * 2);
      piaccel_phval2 = 1.0;
      piaccel_phval3 = 1.5;
      piaccel_phval4 = 2.0;
      piaccel_phval5 = 2.5;
      piaccel_phval6 = 3.0;
      piaccel_phedit = 1;
    }
    piaccel_ph_stride = 2.0;
    if (KS_3D_SELECTED) {
      if (integeraccel) {
        piaccel_slnub = 1 + maxaccel;
        piaccel_slval2 = 1.0;
        piaccel_slval3 = 2.0;
        piaccel_slval4 = 3.0;
        piaccel_slval5 = 4.0;
        piaccel_slval6 = 5.0;
        piaccel_sledit = 0; /* don't allow user to type in value */
      } else {
        piaccel_slnub = IMin(2, 6, maxaccel * 2);
        piaccel_slval2 = 1.0;
        piaccel_slval3 = 1.5;
        piaccel_slval4 = 2.0;
        piaccel_slval5 = 2.5;
        piaccel_slval6 = 3.0;
        piaccel_sledit = 1;
      }
      piaccel_sl_stride = 1.0;
    } else {
      piaccel_slnub = 0;
    }
  } else {
    piaccel_phnub = 0;
    piaccel_slnub = 0;
    cvoverride(opaccel_ph_stride, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
    cvoverride(opaccel_sl_stride, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
  }

  return SUCCESS;

} /* GEReq_init_accelUI() */





/**
 *******************************************************************************************************
 @brief #### Calculate the number of slices per TR and TR padding time (2D imaging)

 This function calculates the number of slices that can fit in one TR (optr) based on the duration and
 occurences of the sequence modules in the sequence collection (KS_SEQ_COLLECTION) determined by calling
 the sequence sliceloop (wrapper) function.

 As the number of arguments to the sequence's sliceloop is psd-dependent, the function pointer
 `play_loop` must be a wrapper function to the sliceloop function taking standardized input arguments
 `(int) nargs` and `(void **) args`. This sliceloop wrapper function must be on the form:
 `int sliceloop_nargs(int slperpass, int nargs, void **args);`
 returning the duration in [us] to play out `slperpass` number of slices.
 If the sliceloop function does not need any additional input arguments, `nargs = 0`, and `args = NULL`.

 The minimum allowed TR is determined by ks_eval_mintr(), which honors SAR/heating limitations. If
 `opautotr = 1`, `optr` will be updated here, otherwise if `optr` is too short, an error will be returned
 to the operator.

 The calling function can specify the minimum acqs that are allowed, as well as a minimum and maximum TR
 interval. Setting `maxtr = 0` disables the upper TR limit. Setting `requested_minacqs <= 1`, disables
 the min acqs requirement.

 This function should be called at the end of cveval() after all sequence modules have been set up and
 dry-runned on host by calling each sequence module's `****_pg()` function. See also the documentation for
 KS_SEQ_CONTROL and KS_SEQ_COLLECTION.

 @param[out] slperpass Number of slices that can fit within each TR
 @param[out] timetoadd_perTR The total time in[us] that must be distributed manually to one or more
             sequence modules after the call to GEReq_eval_TR() in order to meet the desired TR
 @param[in] requested_minacqs The desired minimum number of acquisitions (passes)
 @param[in] mintr Lowest allowed TR in [us]
 @param[in] maxtr Highest allowed TR in [us]. 0: Disabled
 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] play_loop Function pointer to (the wrapper function to) the sliceloop function of the sequence
 @param[in] nargs Number of extra input arguments to the sliceloop wrapper function.
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                       the sequence's sliceloop function
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_TRrange(int *slperpass, int *timetoadd_perTR, int requested_minacqs, int mintr, int maxtr, KS_SEQ_COLLECTION *seqcollection,
                                 int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {
  STATUS status;
  int numacqs = 0;
  int i;
  int numrfexclocations = (KS_3D_SELECTED) ? exist(opvquant) : exist(opslquant);
  int slicetime;
  int nslices_perTR = KS_NOTSET;
  int nslices_shortest_scantime = KS_NOTSET;
  int lowest_scantime = KS_NOTSET;
  int singleslice_time = KS_NOTSET;
  int requested_maxslices = KS_NOTSET;
  int maxslices_time = KS_NOTSET;

  /* if another function has already performed TR timing calcs, don't do it again */
  if (seqcollection->evaltrdone == TRUE) {
    return SUCCESS;
  }
  
  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  if (mintr < 0 || maxtr < 0) {
    return ks_error("%s: min/max TR cannot be negative", __FUNCTION__);
  } else if ((maxtr > 0) && (maxtr <= mintr)) {
    return ks_error("%s: max TR must be > minTR, or 0 (disabled)", __FUNCTION__);
  }

  /* make sure seqctrl.duration at least equal to seqctrl.min_duration */
  status = ks_eval_seqcollection_durations_atleastminimum(seqcollection);
  if (status != SUCCESS) return FAILURE;

  singleslice_time = ks_eval_mintr(1, seqcollection, ks_gheatfact, play_loop, nargs, args);
  if (singleslice_time <= 0) return FAILURE;

  if ((maxtr > 0) && (maxtr < singleslice_time)) {
    return ks_error("%s: Max TR must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }
  if ((mintr > 0) && (mintr < singleslice_time)) {
    return ks_error("%s: Min TR must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }
    if ((maxtr > 0) && ((maxtr - mintr) < singleslice_time)) {
    return ks_error("%s: The TR interval must be > %.1f ms", __FUNCTION__, singleslice_time/ 1000.0);
  }

  /* #acqs cannot exceed #slices. If sequential scanning, #acqs = #slices */
  if (requested_minacqs < 1) {
    requested_minacqs = 1;
  } else if ((requested_minacqs > numrfexclocations) || (opirmode == TRUE)) {
    requested_minacqs = numrfexclocations;
  }
  requested_maxslices = CEIL_DIV(numrfexclocations, requested_minacqs);
  maxslices_time = ks_eval_mintr(requested_maxslices, seqcollection, ks_gheatfact, play_loop, nargs, args);



  if (opautotr) {  /* AutoTR: User selected pitrval2 = PSD_MINIMUMTR */

    if (maxtr > 0 || mintr > 0) { /* in-range autoTR */

      /* Check which combination that results in the lowest scan time, and max/min # slices in range */
      for (i = 1; i <= numrfexclocations; i++) {
        numacqs = CEIL_DIV(numrfexclocations, i);
        slicetime = ks_eval_mintr(i, seqcollection, ks_gheatfact, play_loop, nargs, args);
        if (slicetime >= mintr && (maxtr == 0 || slicetime <= maxtr) && (numacqs >= requested_minacqs)) {
          if (lowest_scantime == KS_NOTSET) {
            nslices_shortest_scantime = i;
            lowest_scantime = slicetime * numacqs;
          } else if (slicetime * numacqs <= lowest_scantime * 1.01) {
            /* 1.01 to avoid round-off effects of slicetime and to slightly favor fewer acqs and longer TRs
            when the scantime is nearly identical */
            nslices_shortest_scantime = i;
            lowest_scantime = slicetime * numacqs;
          }
        }
      }

      if (lowest_scantime == KS_NOTSET) {
        /* failed to find solution within the interval, the range is probably too high for the set
           of slices.  Need to add padding to reach mintr. This
             is done by setting optr = avmintr = mintr (see also timetoadd_perTR below)*/
        if (maxslices_time < mintr) {
          nslices_perTR = requested_maxslices;
          avmintr = mintr;
        } else {
          return ks_error("%s: Programming error", __FUNCTION__);
        }
      } else {
        nslices_perTR = nslices_shortest_scantime;
        avmintr = ks_eval_mintr(nslices_perTR, seqcollection, ks_gheatfact, play_loop, nargs, args);
      }

    } else { /* minimum TR (using requested_minacqs) */

      nslices_perTR = requested_maxslices;
      avmintr = ks_eval_mintr(nslices_perTR, seqcollection, ks_gheatfact, play_loop, nargs, args);

    }

    avmaxtr = avmintr;
    cvoverride(optr, avmintr, PSD_FIX_ON, PSD_EXIST_ON);

  } else { /* Manual TR */

    avmintr = singleslice_time;
    avmaxtr = _optr.maxval;

    /* how many slices can we MAXIMALLY fit in one TR ? */
    if (opirmode == 1) { /* sequential */
      nslices_perTR = 1;
    } else {
      if (existcv(optr)) {
        if (optr < avmintr)
          return ks_error("%s: Increase the TR to %.1f ms", __FUNCTION__, avmintr/ 1000.0);
        if ((mintr > 0) && (optr < mintr))
          return ks_error("%s: Increase the TR to %.1f ms", __FUNCTION__, mintr/ 1000.0);
        if ((maxtr > 0) && (optr > maxtr))
          return ks_error("%s: Decrease the TR to %.1f ms", __FUNCTION__, maxtr/ 1000.0);
      }      
      nslices_perTR = ks_eval_maxslicespertr(exist(optr), seqcollection, ks_gheatfact, play_loop, nargs, args);
      nslices_perTR = IMax(2, 1, nslices_perTR); /* safeguard against < 1 */
    }

  } /* Auto/Manual TR */


  /* how many acqs (runs) do we need to get all prescribed slices ? */
  numacqs = CEIL_DIV(numrfexclocations, nslices_perTR);

  /* how many slices SHOULD we play out per pass (keeping numrfexclocations and numacqs)?
     This may be less than nslices_perTR depending on divisibility */
  *slperpass = CEIL_DIV(numrfexclocations, numacqs); /* round up */

  /* run once more with the actual number of slices per TR, mostly so that ks_eval_gradrflimits() will set the
  description of `optr` correctly */
  ks_eval_mintr(*slperpass, seqcollection, ks_gheatfact, play_loop, nargs, args);

  /* run before each call to function pointer `play_loop()` (next line) to set all `seqctrl.ninst` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);

  /* Update seqcollection.seqctrl[*].ninst given '*slperpass' number of slices
     time [us] for one sequence playout incl. the SSI time and necessary dead time to
     make up the expected TR. To be used in KS_SEQLENGTH() in pulsegen() */
  *timetoadd_perTR = exist(optr) - play_loop(*slperpass, nargs, args);

  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;

  /* Flag that we have completed this function */
  seqcollection->evaltrdone = TRUE;



  /* Set UI and advisory panel variables */
  avail_image_time = RDN_GRD(exist(optr));
  act_tr = avail_image_time;
  ihtr  = _ihtr.fixedflag ?  ((void)(act_tr), ihtr) : act_tr; /* image header TR */

  avminslquant = 1;
  if (KS_3D_SELECTED == FALSE) {
  avmaxslquant = nslices_perTR; /* UI value ("Max # Slices:") */
  avmaxacqs = numacqs; /* UI value ("# of Acqs:") */
  } else {
    avmaxslquant = 2048;
    avmaxacqs = 1;
  }

  return SUCCESS;

} /* GEReq_eval_TRrange() */




STATUS GEReq_eval_TR(int *slperpass, int *timetoadd_perTR, int requested_minacqs, KS_SEQ_COLLECTION *seqcollection,
                                 int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {
 
  return GEReq_eval_TRrange(slperpass, timetoadd_perTR, requested_minacqs, 0, 0, seqcollection, play_loop, nargs, args);


} /* GEReq_eval_TR() */




/**
 *******************************************************************************************************
 @brief #### Performs RF scaling of all RF pulses in the KS_SEQ_COLLECTION and Prescan
 
 RF scaling is a complicated process across RF pulses in scan (multiple sequence modules) and prescan, 
 where the desired flip angles should be met partly using the maxB1 info for each RF pulse and scale
 it relative to the prescan result. This is done via a combination of scan and prescan attenuation factors 
 (xmtaddScan) in the `entry_point_table[]`, an extra global scaling factor, and change of the (instruction)
 amplitude of each RF pulse.

 This function performs all these tasks using a KS_SEQ_COLLECTION as input. The sequence collection struct
 contains one KS_SEQ_CONTROL struct for each sequence module, which via the field `gradrf.rfptr[]` has
 access to all KS_RF objects in the sequence module. As the `***_pg()` function for each sequence module
 should have been called prior to this function, the number of occurrences of each RF pulse is known.
 Moreover, the rfstat specification for every RF pulse is located in:
 seqcollection->seqctrl[]->gradrf->rfptr[]->rf.rfpulse
 which is used by ks_eval_seqcollection2rfpulse() to rewrite the global `rfpulse[]` struct array required
 by GE's RF scaling functions peakB1() and setScale().

 At the end of this function, the seqcollection mode is locked, preventing accidental addition of new
 sequence modules to the seqcollection using ks_eval_addtoseqcollection(). Moreover, each sequence module
 will have its `rfscalingdone` field set to TRUE to signal to ks_pg_rf() that the RF pulse belonging to 
 that sequence module has indeed been RF scaled properly. This extra safety mechanism makes it difficult
 to use ks_pg_rf() without first passing through this function and have the seqcollection struct set up.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_rfscaling(KS_SEQ_COLLECTION *seqcollection) {
  int i;
  STATUS status;


  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  /* use global rfpulse[] array (that is also featuring in Prescan.e) */
  for (i = 0; i < KS_MAXUNIQUE_RF; i++) {
    rfpulse[i].activity = 0;
  }

  /* Update the global RF pulse array rfpulse[] with the contents of the RF pulses in the sequence modules.
     This also includes resetting all .activity fields to zero for the first KS_MAXUNIQUE_RF elements in rfpulse[] */
  status = ks_eval_seqcollection2rfpulse(rfpulse, seqcollection);
  if (status != SUCCESS) return status;


  /* find the peak B1 for each entry point and the max B1 across all entry points */
#if EPIC_RELEASE >= 24
  status = findMaxB1Seq(&maxB1Seq, maxB1, MAX_ENTRY_POINTS, rfpulse, RF_FREE);
  if (status != SUCCESS) {
    return ks_error("%s: findMaxB1Seq() failed", __FUNCTION__);
  }
#else
  {
    int entry;
    maxB1Seq = 0.0;
    for (entry = 0; entry < MAX_ENTRY_POINTS; entry++) {
      status = peakB1(&maxB1[entry], entry, RF_FREE, rfpulse);
      if (status != SUCCESS) {
        return ks_error("%s: peakB1() failed", __FUNCTION__);
      }
      if (maxB1[entry] > maxB1Seq) {
        maxB1Seq = maxB1[entry];
      }
    } /* for */
  }
#endif

  /* RF: How much do we need to attenuate the RF pulses in scan. */
  double my_xmtaddScan = -200 * log10(maxB1[L_SCAN]/ maxB1Seq) + getCoilAtten();
  if (my_xmtaddScan > cfdbmax) {
    extraScale  = _extraScale.fixedflag ?       ((void)((float)pow(10.0,(cfdbmax-my_xmtaddScan)/200.0)), extraScale) : (float)pow(10.0,(cfdbmax-my_xmtaddScan)/200.0); /* N.B.: 'extraScale' is declared as CV in Prescan.e */
    my_xmtaddScan = cfdbmax;
  } else {
    extraScale  = _extraScale.fixedflag ?  ((void)(1.0), extraScale) : 1.0;
  }

  /* RF: Scale the rfpulse amplitudes */
  status = setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], extraScale);
  if (status != SUCCESS) {
    return ks_error("%s: setScale failed", __FUNCTION__);
  }

  /* fill entry_point_table */
  status = entrytabinit(entry_point_table, (int)ENTRY_POINT_MAX);
  if (status != SUCCESS) {
    return ks_error("%s: entrytabinit() failed", __FUNCTION__);
  }
  strcpy( entry_point_table[L_SCAN].epname, "scan");
  entry_point_table[L_SCAN].epxmtadd = (short)rint( (double) my_xmtaddScan);
  entry_point_table[L_SCAN].epstartrec = rhdab0s;
  entry_point_table[L_SCAN].ependrec = rhdab0e;
  entry_point_table[L_SCAN].epfastrec = 0;
  entry_point_table[L_APS2] = entry_point_table[L_MPS2] = entry_point_table[L_SCAN];
  strcpy(entry_point_table[L_APS2].epname, "aps2");
  strcpy(entry_point_table[L_MPS2].epname, "mps2");

  /* Prescan: Final RF scaling of the Prescan entries, using the maxB1[] and maxB1Seq values computed above */
{ /* Start of code inlined from Prescan.e PSpredownload */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                         PSpredownload                             *
     *                                                                   *
     * Write here the code unique to the Host PSD process. All code to   *
     * be executed in predownload() must be written here.                *
     *********************************************************************/
    if (FAILURE==PSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==FTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==XTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ASpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==RSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==DTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==AutoCoilpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ExtCalpredownload())
    {
        return FAILURE;
    }

} /* End of code inlined from Prescan.e PSpredownload */


  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;

  /* Flag each sequence module that RF scaling has been done */
  for (i = 0; i < seqcollection->numseq; i++) {
    seqcollection->seqctrlptr[i]->rfscalingdone = TRUE;
  }

  return SUCCESS;

} /* GEReq_eval_rfscaling() */




/**
 *******************************************************************************************************
 @brief #### Checks that sequence modules sum up to TR, honoring SAR/heating limits
 
 This function is called by GEReq_eval_checkTR_SAR() (non-inversion use) and ksinv_eval_checkTR_SAR()
 (inversion use) to check that the sequence modules played out in the slice loop sum up to the specified
 TR (optr) accounting for SAR/heating limits. Moreover, the SAR values are updated in the UI, and the 
 CV ks_sarcheckdone is set to TRUE. This CV is set to FALSE in GEReq_cvinit() and check whether it is
 TRUE in GEReq_predownload() to make sure SAR calculation have been performed before scanning.

 @param[in,out] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] intended_time Usually repetition time (optr) if this function was called from 
            GEReq_eval_checkTR_SAR(), but should correspond to the intended time to play the corresponding
            number of sequence instances now set in seqcollection[]->seqctrl.ninst
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_checkTR_SAR_calcs(KS_SEQ_COLLECTION *seqcollection, int intended_time) {
  KS_SAR sar;
  int duration_withinlimits;
  int nettime;
  STATUS status;

  if (seqcollection->evaltrdone == FALSE) {
    return ks_error("%s: Please call GEReq_eval_TR() before calling this function", __FUNCTION__);
  }

  /* Print out the sequence collection time table. In simulation it appears in the WTools main window */
#ifdef PSD_HW
    FILE *fp = fopen("/usr/g/mrraw/seqcollection.txt", "w");
    ks_print_seqcollection(seqcollection, fp);
    fclose(fp);
#else
    ks_print_seqcollection(seqcollection, stderr);
#endif

  /*
  The duration based on the sequence collection struct, which is the product .nseqinstances and .duration fields in each sequence
  modules, summed over all sequence modules.
  The .nseqinstances field becomes > 0 by the call to: GEReq_eval_TR()->ks_eval_mintr()->play_loop()->ks_scan_playsequence()
  The .duration field is initially set to .min_duration by GEReq_eval_TR()->ks_eval_seqcollection_durations_atleastminimum(), but the
  .duration field of at least one sequence module should have been set larger than its .min_duration based on the amount of
  timetoadd_perTR returned by GEReq_eval_TR()  */
  nettime = ks_eval_seqcollection_gettotalduration(seqcollection);
  if (nettime <= 0) {
    
    return FAILURE;
  }

  /* duration_withinlimits = nettime + grad/RF SAR/heat penalty time */
  duration_withinlimits = ks_eval_gradrflimits(&sar, seqcollection, ks_gheatfact);
  if (duration_withinlimits == KS_NOTSET) {
    return FAILURE;
  }

  /* Make sure the global RF pulse array rfpulse[] is updated with the contents of the RF pulses in the sequence modules.
     This also includes resetting all .activity fields to zero for the first KS_MAXUNIQUE_RF elements in rfpulse[] */
  status = ks_eval_seqcollection2rfpulse(rfpulse, seqcollection);
  if (status != SUCCESS) return status;


  /* report to UI */
  piasar = (float) sar.average;
  picasar = (float) sar.coil;
  pipsar = (float) sar.peak;
#if EPIC_RELEASE >= 24
  pib1rms = (float) sar.b1rms;
#endif

  if (existcv(opslquant) == FALSE) {
    /* if #slices has not been set yet, hold on complaining */
    return SUCCESS;
  }

  if (nettime < duration_withinlimits) {
    return ks_error("%s: Duration of seq. modules (%d) < grad/rf limits (%d)", __FUNCTION__, nettime, duration_withinlimits);
  }
  if (nettime < intended_time) {
    return ks_error("%s: Duration of seq. modules (%d) < %d", __FUNCTION__, nettime, intended_time);
  }

  if (nettime - intended_time > MAX_TR_OVERSHOOT) {
    /* small excess in nettime is expected due to roundups of .duration to nearest 4us, but we cannot accept too much */
    /* return */ ks_error("%s: Duration of seq. modules (%d) %d us too long", __FUNCTION__, nettime, nettime - intended_time);
  }

#if EPIC_RELEASE > 27 || (EPIC_RELEASE == 27 && EPIC_PATCHNUM > 1)
  status = setupPowerMonitor(&entry_point_table[L_SCAN], sar.average);
#else  
  status = setupPowerMonitor(&entry_point_table[L_SCAN], L_SCAN, RF_FREE, rfpulse,
                             nettime, sar.average, sar.coil, sar.peak);
#endif                             
  if (status != SUCCESS) {
    return ks_error("%s: setupPowerMonitor failed", __FUNCTION__);
  }

  /* prevent further addition of new sequence modules */
  seqcollection->mode = KS_SEQ_COLLECTION_LOCKED;


  /* Flag that SAR check has been done */
  ks_sarcheckdone = TRUE;

  return SUCCESS;

} /* GEReq_eval_checkTR_SAR_calcs() */




/**
 *******************************************************************************************************
 @brief #### Runs the slice loop and validates TR and SAR/hardware limits

 This function first makes sure that the `.nseqinstances` field for each sequence module in the sequence
 collection corresponds to the number of times played out in the sequence's sliceloop function.

 In simulation (WTools), ks_print_seqcollection() will print out a table of the sequence modules in
 the sequence collection in the WToolsMgd window.

 Finally, GEReq_eval_checkTR_SAR_calcs() is called to check that the TR is correct and within SAR/hardware
 limits.

 N.B.: For inversion sequences, ksinv_eval_checkTR_SAR() is used to do the same thing, with the difference
 that ksinv_scan_sliceloop() is used instead.

 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @param[in] nslices Number of slices in TR
 @param[in] play_loop Function pointer to (the wrapper function to) the sliceloop function
 @param[in] nargs Number of extra input arguments to the sliceloop wrapper function.
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                       the sliceloop function
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_eval_checkTR_SAR(KS_SEQ_COLLECTION *seqcollection, int nslices, int (*play_loop)(int /*nslices*/, int /*nargs*/, void ** /*args*/), int nargs, void **args) {

  if (seqcollection == NULL || seqcollection->numseq == 0) {
    return ks_error("%s: Please add pulse sequence modules to the sequence collection before calling this function", __FUNCTION__);
  }

  /* set all `seqctrl.nseqinstances` to 0 */
  ks_eval_seqcollection_resetninst(seqcollection);
  play_loop(nslices, nargs, args); /* => seqctrl.nseqinstances = # times each seq. module has been played out */

  return GEReq_eval_checkTR_SAR_calcs(seqcollection, optr);

} /* GEReq_eval_checkTR_SAR() */




/**
 *******************************************************************************************************
 @brief #### Sets mandatory global GE arrays for data acquisition

 The following global GE arrays are set based on slperpass (arg 1) and global op** variables:
    - `data_acq_order[]`: Critical for scanning
    - `rsp_info[]`: Copied from scan_info[] (the graphically prescibed slices), for conformance. Is a 
       temporally sorted version
       of scan_info[] with integer rotation matrices. Not needed for scanning.
    - `rsptrigger[]`: Set to TRIG_INTERN for now.

    data_acq_order[] is only available on HOST, why this function also copies data_acq_order[] to 
    ks_data_acq_order[], which is an `ipgexport` array accessible on both HOST and TGT. This can be used
    by ks_scan_getsliceloc() to be independent on rsp_info[] during scan.

 The slice plan is stored as a text file ("ks_sliceplan.txt") in the current directory in simulation and in
 /usr/g/mrraw on the MR scanner by calling ks_print_sliceplan().

 @param[in] slice_plan The current slice plan (KS_SLICE_PLAN) set up for the sequence (see ks_calc_sliceplan())
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_store_sliceplan(KS_SLICE_PLAN slice_plan) {
  int i, j, time;

  if (CEIL_DIV(slice_plan.nslices, slice_plan.nslices_per_pass) != slice_plan.npasses) {
    return ks_error("%s: inconsistent slice plan - #acqs", __FUNCTION__);
  }

  if (!KS_3D_SELECTED && slice_plan.nslices != exist(opslquant)) {
    return ks_error("%s: inconsistent slice plan - #slices", __FUNCTION__);
  }

  /* initialize rsp_info, rtsprot and rsptrigger */
  for (i = 0; i < DATA_ACQ_MAX; i++) {
    rsp_info[i].rsptloc = 0;
    rsp_info[i].rsprloc = 0;
    rsp_info[i].rspphasoff = 0;
    rsptrigger[i] = TRIG_INTERN;
    for (j = 0; j < 9; j++)
      rsprot[i][j] = 0;
  }

  /* copy to global data_acq_order, which must be correct for main sequence or scan will not start */
  for (i = 0; i < slice_plan.nslices; i++) {
    data_acq_order[i].slloc = slice_plan.acq_order[i].slloc;
    data_acq_order[i].slpass = slice_plan.acq_order[i].slpass;
    data_acq_order[i].sltime = slice_plan.acq_order[i].sltime;
  } /* for slice locations */

  for (i = slice_plan.nslices; i < SLICE_FACTOR*DATA_ACQ_MAX; i++) {
    data_acq_order[i].slloc = 0;
    data_acq_order[i].slpass = 0;
    data_acq_order[i].sltime = 0;
  } /* for rest of data_acq_order */

  time = 0;
  for (i = 0; i < slice_plan.npasses; ++i) {
    for (j = 0; j < slice_plan.nslices_per_pass; ++j) {
      int slloc = ks_scan_getsliceloc(&slice_plan, i, j);
      if (slloc == KS_NOTSET) {continue;}

      rsp_info[time].rsptloc = scan_info[slloc].optloc;
      rsp_info[time].rsprloc = scan_info[slloc].oprloc;
      rsp_info[time].rspphasoff = scan_info[slloc].opphasoff;

      scale(&scan_info[slloc].oprot, &rsprot[time], 1, &loggrd, &phygrd, 0);

      /* Future: here we could change to a variable to support gating. TRIG_ECG, TRIG_AUX etc */
      rsptrigger[time] = TRIG_INTERN;

      ++time;
    }
  }

  STATUS status = calcChecksumScanInfo(&chksum_scaninfo, scan_info, slice_plan.nslices, psdcrucial_debug);
  if (status != SUCCESS) {
    epic_error(1, "PSD data integrity violation detected in PSD, Please try again or restart the system.",
               EM_PSD_PSDCRUCIAL_DATA_FAILURE, EE_ARGS(1), SYSLOG_ARG);
    return status;
  }

  /* Save acquisition table to disk for debugging */
#ifdef PSD_HW
  FILE *daqfp = fopen("/usr/g/mrraw/ks_sliceplan.txt", "w");
#else
  FILE *daqfp = fopen("./ks_sliceplan.txt", "w");
#endif

  ks_print_sliceplan(slice_plan, daqfp);

  fclose(daqfp);


  /* set GE acqs and slquant1 CVs for look and feel */
  _slquant1.fixedflag = 0;
  _acqs.fixedflag = 0;
  slquant1  = _slquant1.fixedflag ?  ((void)(slice_plan.nslices_per_pass), slquant1) : slice_plan.nslices_per_pass;
  acqs  = _acqs.fixedflag ?  ((void)(slice_plan.npasses), acqs) : slice_plan.npasses;
  /* prescan */
  picalmode = 0;
  pislquant = slquant1;

  return SUCCESS;

}



/**
 *******************************************************************************************************
 @brief #### Sets mandatory global GE arrays for data acquisition (3D imaging)

 The following global GE arrays are set based on slperpass (arg 1) and global op** variables:
    - `data_acq_order[]`: Critical for scanning
    - `rsp_info[]`: Copied from scan_info[] (the graphically prescibed slices), for conformance. Is a 
       temporally sorted version
       of scan_info[] with integer rotation matrices. Not needed for scanning.
    - `rsptrigger[]`: Set to TRIG_INTERN for now.

    data_acq_order[] is only available on HOST, why this function also copies data_acq_order[] to 
    ks_data_acq_order[], which is an `ipgexport` array accessible on both HOST and TGT. This can be used
    by ks_scan_getsliceloc() to be independent on rsp_info[] during scan.

 
 GEReq_predownload_store_sliceplan3D() has different input args compared to the 2D version. Here,
 a temporary slice plan is created based on slices_in_slab and slabs in order to create the proper
 content of data_acq_order[]. Note that it wouldn't have worked to pass ks_slice_plan for 3D. This is because
 we need a ks_slice_plan that is consistent with RF excitations for 2D, 3D, 3DMS in each sequence's 
 looping structure in scan. For 3D, this very ks_slice_plan can then not also create the proper data_acq_order
 array here. This is why we pass in slices_in_slab and slabs instead and create e temp slice plan solely
 for the purpose of data_acq_order.

 @param[in] slices_in_slab Number of slices in a slab
 @param[in] slabs Number slabs
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_store_sliceplan3D(int slices_in_slab, int slabs) {
  KS_SLICE_PLAN slice_plan;

  /* TODO: unclear for 3D MS, inteleaved and sequential */
  ks_calc_sliceplan_interleaved(&slice_plan, slices_in_slab * slabs, slices_in_slab, 1);

  return GEReq_predownload_store_sliceplan(slice_plan);

  }


/**
 *******************************************************************************************************
 @brief #### Assigns a global filter slot for a main sequence

 This function must be called in predownload() after GE's initfilter() function, which resets all filter
 slots for scan and prescan entry points. The initfilter() function is called in GEReq_cvinit().

 Given the FILTER_INFO of the acquisition window for the main pulse sequence (arg 1), this function 
 assigns a new slot number (that matches one of the hardware slots in the data receive chain.

 The `.epfilter` and `.epprexres` of GE's global struct array `entry_point_table[]` is also set.

 @param[in] filt Pointer to FILTER_INFO struct (`.filt` field in KS_READ)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setfilter(FILTER_INFO *filt) {

  setfilter(filt, SCAN);

  entry_point_table[L_SCAN].epfilter = (unsigned char) filt->fslot;
  entry_point_table[L_SCAN].epprexres = filt->outputs;


  /* APS2 & MPS2 */
  entry_point_table[L_APS2] = entry_point_table[L_MPS2] = entry_point_table[L_SCAN];  /* copy scan into APS2 & MPS2 */
  strcpy(entry_point_table[L_APS2].epname, "aps2");
  strcpy(entry_point_table[L_MPS2].epname, "mps2");

  return SUCCESS;

} /* GEReq_predownload_setfilter() */




/**
 *******************************************************************************************************
 @brief #### Generates the vrgf.param file for rampsampling correction

 When the `.rampsampling` field of a KS_READTRAP is set to 1, 1D gridding in the frequency encoding 
 direction is necessary before FFT to obtain an equidistant k-space. 
 GE's product reconstruction uses a file (`vrgf.param`) for this, which is generated by this function.

 See also GEReq_predownload_setrecon_readphase(), which sets VRGF-specific global variables.

 @param[in] readtrap
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_genVRGF(const KS_READTRAP * const readtrap) {
  FILE *fpVRGF;
  float beta = 1.0;
  float alpha = 2.0/ (beta + 1.0);
#ifdef SIM
  fpVRGF = fopen("./vrgf.param", "w");
#else
  fpVRGF = fopen("/usr/g/bin/vrgf.param", "w");
#endif

  /* based on: /ESE.../.../psdsupport/genVRGF.c  */

  /* NOTE: The static file /usr/g/bin/vrgf.param2, i.e. with a trailing "2", containing the following 
     must exist on the system in order for the executable /usr/g/bin/vrgf to generate vrgf.dat from 
     the vrgf.param we are about to write:
     VRGFNORM=   1
     GAIN=     1.0
     VRGFWN=     1
     ALPHA=   0.46
     BETA=     1.0
     VRGFODS=  0.0
     VRGFCC=     0
     VRGFGS=     1
     VRGFSGG=    0
     VRGFBWF= -1.0
  */


  fprintf(fpVRGF, "VRGFIP=    %d\n", readtrap->acq.filt.outputs);
  fprintf(fpVRGF, "VRGFOP=    %d\n", readtrap->res);
  fprintf(fpVRGF, "PERIOD=    %f\n", readtrap->acq.filt.tsp);
  fprintf(fpVRGF, "WAVE_CHOICE=  %d\n", 1);
  fprintf(fpVRGF, "G1=        %d\n", 1);
  fprintf(fpVRGF, "G2=        %f\n", readtrap->grad.amp);
  fprintf(fpVRGF, "G3=        %f\n", (readtrap->grad.plateautime/ 2)/ 1.0e6);
  fprintf(fpVRGF, "G4=        %f\n", readtrap->grad.ramptime/ 1.0e6);
  fprintf(fpVRGF, "G5=        %f\n", alpha);
  fprintf(fpVRGF, "G6=        %f\n", beta);
  fprintf(fpVRGF, "G7=        %f\n", 0.0);
  fprintf(fpVRGF, "G8=        %f\n", readtrap->acq.rbw * 1.0e3);
  fprintf(fpVRGF, "G9=        %f\n", 0.0);

  if (fclose(fpVRGF) != 0) {
    ks_error("Can't close vrgf.param");
  }

  return SUCCESS;

} /* GEReq_predownload_genVRGF() */




/**
 *******************************************************************************************************
 @brief #### Generates the rowflip.param file for KS_EPI

 GE's reconstruction (and data dumping) of EPI data (where every other readout is negative) needs to
 know which k-space lines that have been acquired with a negative gradient to perform a row flip
 on these lines before proceeding with Pfile writing and FFT processing.

 @param[in] epi Pointer to KS_EPI
 @param[in] blipsign KS_EPI_POSBLIPS or KS_EPI_NEGBLIPS
 @param[in] assetflag Flag for ASSET mode or not (0: off, 2: ASSET_SCAN (on))
 @param[in] dorowflip If 0, write just ones to let rowflipping process for Pfiles being executed without actual flipping
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_genrowflip(KS_EPI *epi, int blipsign, int assetflag, int dorowflip) {
  FILE *rowflipfp;
  int i = 0;
  int j = 0;
  int kyview = 0;
  int view1st, viewskip;
  int readsign = 1;
  int rowskip, res;
#ifdef SIM
  rowflipfp = fopen("./rowflip.param", "w");
#else
  rowflipfp = fopen("/usr/g/bin/rowflip.param", "w");
#endif

  fprintf(rowflipfp, "# EPI recon control\n");
  fprintf(rowflipfp, "#\n");
  fprintf(rowflipfp, "# ky line number/flip operation\n");
  fprintf(rowflipfp, "%d %d\n", 0, 1);

  if (assetflag == ASSET_SCAN) {
    rowskip = 1;
    res = epi->blipphaser.res/ epi->blipphaser.R;
  } else {
    rowskip = epi->blipphaser.R;
    res = epi->blipphaser.res;
  }

  for (i = 0; i < epi->etl; i++) {
    for (j = 0; j < rowskip; j++) {
      kyview = i * rowskip + j;
      readsign = (i % 2) ? -1 : 1;
      if (blipsign == KS_EPI_POSBLIPS && (epi->etl % 2 == 0)) {
        readsign *= -1;
      }
      fprintf(rowflipfp, "%d %d\n", kyview + 1, (dorowflip) ? readsign : 1);
    }
  }
  for (kyview = i * rowskip + j; kyview < res; kyview++)
    fprintf(rowflipfp, "%d %d\n", kyview + 1, 1);

  fprintf(rowflipfp, "#\n#\n#intleave 1stview skip gpol bpol gy1f rfpol tf nechoes init_echo_pol\n" );

  for (j = 0; j < rowskip; j++) {
    if (blipsign == KS_EPI_POSBLIPS && (epi->etl % 2 == 0)) {
      view1st = (assetflag == ASSET_SCAN) ? (epi->blipphaser.numlinestoacq - 1) : (epi->blipphaser.linetoacq[(epi->blipphaser.numlinestoacq - 1)] + j);
      viewskip = -rowskip;
    } else {
      view1st = (assetflag == ASSET_SCAN) ? 0 : (epi->blipphaser.linetoacq[0] + j);
      viewskip = rowskip;
    }
    fprintf(rowflipfp, "%d %d %d %d %d %d %d %d %d %d\n", j, view1st + 1, viewskip, 1, blipsign, 0 /* max int dephaser */, 1 /* rfpol*/, 0 /* tf */, epi->etl, 1);
  }

  fprintf(rowflipfp, "# esp (usec)\n");
  fprintf(rowflipfp, "%d \n", epi->read.grad.duration);
  fprintf(rowflipfp, "# tsp (usec)\n");
  fprintf(rowflipfp, "%f \n", epi->read.acq.filt.tsp);
  fprintf(rowflipfp, "# input samples\n");
  fprintf(rowflipfp, "%d \n", epi->read.acq.filt.outputs);
  fprintf(rowflipfp, "# readout amplitude (G/cm)\n");
  fprintf(rowflipfp, "%f \n", epi->read.grad.amp);
  fprintf(rowflipfp, "# Row FT size\n");
  fprintf(rowflipfp, "%d \n", epi->read.res);
  fprintf(rowflipfp, "# rhhnover \n");
  fprintf(rowflipfp, "%d \n", epi->blipphaser.nover);
  fprintf(rowflipfp, "# etl\n");
  fprintf(rowflipfp, "%d \n", epi->etl);
  fprintf(rowflipfp, "# number of interleaves\n");
  fprintf(rowflipfp, "%d \n", epi->blipphaser.R);
  fprintf(rowflipfp, "# low pass filter setting (kHz), or -1 for std. rcvr.\n");
  fprintf(rowflipfp, "%d \n", -1);
  fprintf(rowflipfp, "# total number of images\n");
  fprintf(rowflipfp, "%d \n", opslquant);
  fprintf(rowflipfp, "# end of file");

  fclose(rowflipfp);

  return SUCCESS;

} /* GEReq_predownload_genrowflip() */





/*******************************************************************************************************
 ************************************ Modify rh/ih/pi/op vars for recon           **********************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Writes a kacq_yz.txt.***** file for use with GE's product ARC recon

 If phaser.R > 1, a file is written to disk with phase encoding steps in an ARC accelerated
 scan ("kacq_yz.txt.*****"). This function has been adapted from GE's ARC.e, but supports only 2D
 (i.e. 1D-acceleration)
 
 @param[in]  readtrap Pointer to readout trapezoid. Used to determine k-space peak along kx
 @param[in]  phaser   Pointer to phase encoding object (KS_PHASER) with acceleration
 @param[in]  zphaser   Pointer to z phase encoding object (KS_PHASER) with acceleration. NULL for 2D
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_writekacq(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser) {

  FILE *fp;
  CHAR kacqFilename[BUFSIZ];
  int view;
  int arc_kx_peak_pos = 0; /* sample point units */
  int arc_ky_peak_pos = -1;
  const CHAR kacqArcFilename[BUFSIZ] = "kacq_yz.txt";
  int num_echoes = 1; /* we don't understand what a value > 1 would mean. cf. ARC.e */
  int echo_index, slice;
  int numzencodes = (zphaser != NULL) ? zphaser->numlinestoacq : 1;

#ifdef PSD_HW
  const CHAR kacqPath[BUFSIZ] = "/usr/g/psddata/";
  const CHAR kacqRawPath[BUFSIZ] = "/usr/g/mrraw/";
  sprintf(kacqFilename, "%s%s.%d", kacqPath, kacqArcFilename, rhkacq_uid);
#else
  const CHAR kacqPath[BUFSIZ] = "./";
  const CHAR kacqRawPath[BUFSIZ] = "./";
  sprintf(kacqFilename, "%s%s", kacqPath, kacqArcFilename);
#endif

  fp = fopen(kacqFilename, "w");

  /* position of k-space center in sample points along kx
     time2center - acqdelay is the time in [us] from start of acq window to the center of k-space
     acq.filt.tsp is the time in [us] for one sample point (with or without ramp sampling */
  arc_kx_peak_pos = (readtrap->time2center - readtrap->acqdelay)/ readtrap->acq.filt.tsp;

  /* disabled flag ? */
  arc_ky_peak_pos = -1;

  /* kacq header */
  fprintf(fp, "GE_KTACQ\t201\t0\n");
  fprintf(fp, "num_sampling_patterns\t%d\n", num_echoes);
  fprintf(fp, "num_mask_patterns\t%d\n", 0);
  fprintf(fp, "kx_peak_pos\t%d\n", arc_kx_peak_pos);
  /* fprintf(fp, "ky_peak_pos\t%d\n", arc_ky_peak_pos); */
  fprintf(fp, "---\n");

  /* Reconstruction schedule */
  fprintf(fp, "# Reconstruction schedule\n");
  fprintf(fp, "# t, Echo, Cal Table, Cal Pass, Accel Table, Accel Pass, Mask Table\n");
  fprintf(fp, "RECON_SCHEDULE\t%d\t%d\n", num_echoes, 7);
  fprintf(fp, "---\n");
  for (echo_index = 0; echo_index < num_echoes; echo_index++) {
    fprintf(fp,"%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 0, echo_index, -1, 0, echo_index, 0, -1);
  }

  /* Accelerated sampling pattern */
for (echo_index = 0; echo_index < num_echoes; echo_index++) {

  fprintf(fp, "# Sampling Pattern 0 (Accel)\n");
  fprintf(fp, "# View Offset, Pass Offset, ky, kz\n");

    fprintf(fp, "SAMPLING_PATTERN\t%d\t%d\n", phaser->numlinestoacq * numzencodes, 4);
    fprintf(fp, "max_stride\t%d\t%d\n", phaser->R, (zphaser != NULL) ? zphaser->R : 1);
  int dimy;
  if (phaser->nover != 0)
    dimy = phaser->res/ 2 + abs(phaser->nover); /* half nex */
  else
    dimy = phaser->res;
    fprintf(fp, "pattern_dimensions\t%d\t%d\n", dimy, (zphaser != NULL) ? exist(opslquant) : 1);
  fprintf(fp, "---\n");
    for (slice = 0; slice < numzencodes; slice++) {
  for (view = 0; view < phaser->numlinestoacq; view++) {
        if (zphaser != NULL)
          fprintf(fp, "%d\t%d\t%d\t%d\n", phaser->linetoacq[view] + 1 + (zphaser->linetoacq[view] * num_echoes + echo_index) * rhdayres, 0, phaser->linetoacq[view], zphaser->linetoacq[slice]);
        else
          fprintf(fp, "%d\t%d\t%d\t%d\n", phaser->linetoacq[view] + 1 + echo_index * rhdayres, 0, phaser->linetoacq[view], 0);
  }
    }

  } /* echo */

  fclose(fp);

  /* Automatically copy kacq file to a unique filename in
     /usr/g/mrraw if autolock is on */
  if (autolock == TRUE) {
    /* Copy file by reading to and writing from a buffer */
    CHAR kacqMrrawFilename[BUFSIZ];
    CHAR kacqRawFilename[BUFSIZ];
    FILE *srcFile = NULL;
    FILE *dstFile = NULL;
    size_t elemRead, elemWritten;
    size_t bufSz = 8192;
    char buf[8192];

    sprintf(kacqRawFilename, "%s.%d", kacqArcFilename, rhkacq_uid);
    sprintf(kacqMrrawFilename, "%s%s", kacqRawPath, kacqRawFilename);

    srcFile = fopen(kacqFilename, "rb");
    dstFile = fopen(kacqMrrawFilename, "wb");

    elemRead = bufSz;
    while (elemRead == bufSz) {
      elemRead = fread(buf, sizeof(char), bufSz, srcFile);
      elemWritten = fwrite(buf, sizeof(char), elemRead, dstFile);
    }
    fclose(srcFile);
    fclose(dstFile);

  } /* autolock */

    return SUCCESS;

} /* GEReq_predownload_setrecon_writekacq() */




/**
 *******************************************************************************************************
 @brief #### Sets rh*** variables related to parallel imaging acceleration

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] phaser   Pointer to KS_PHASER (phase)
 @param[in] zphaser   Pointer to KS_PHASER (slice). NULL for 2D
 @param[in] datadestination Value to assign to `rhexecctrl` (c.f. epic.h)
   
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_accel(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser, int datadestination) {
  STATUS status;

  /* make sure we will be able to set all these CVs */
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;

  if (phaser->R <= 1 && (zphaser == NULL || zphaser->R <= 1)) {
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
    rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(1.0), rhassetsl_R) : 1.0;
    return SUCCESS;
  }

  rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* once more, just in case */

  if (datadestination & RHXC_XFER_IM) {
    /* if we are going to use GE recon (RHXC_XFER_IM = 8) */

    if (phaser->nacslines > 0) { /* ARC */

      /* ARC uses full BAM, i.e. stores the acquired lines at their proper locations in k-space with zero lines in between */
      rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
      rhdayres  = _rhdayres.fixedflag ?              ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);

      rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC; /* tell recon we are doing ARC only if we have ACS lines  */
      status = GEReq_predownload_setrecon_writekacq(readtrap, phaser, zphaser);
      if (status != SUCCESS) return status;

    } else { /* ASSET */

      /* ASSET uses compressed BAM, i.e. stores only the acquired lines */
      rhhnover  = _rhhnover.fixedflag ?   ((void)(abs(phaser->nover)/phaser->R), rhhnover) : abs(phaser->nover)/phaser->R;
      rhnframes  = _rhnframes.fixedflag ?            ((void)((phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R)), rhnframes) : (phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R);
      rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;

      rhasset  = _rhasset.fixedflag ?  ((void)(ASSET_SCAN), rhasset) : ASSET_SCAN; /* if we don't have ACS lines, we will need to recon the data using some external calibration */
    }

  } else {

    /* store data as ARC (full BAM) */
    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
    rhdayres  = _rhdayres.fixedflag ?               ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);

    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0; /* we are going to do the reconstruction offline */
  }

  rhasset_R  = _rhasset_R.fixedflag ?   ((void)(1.0/phaser->R), rhasset_R) : 1.0/phaser->R; /* inverse of acceleration factor */
  rhassetsl_R  = _rhassetsl_R.fixedflag ?         ((void)((zphaser!=NULL)?(1.0/zphaser->R):1), rhassetsl_R) : (zphaser!=NULL)?(1.0/zphaser->R):1;

  return SUCCESS;

} /* GEReq_predownload_setrecon_accel() */



void  GEReq_predownload_setrecon_phase(const KS_PHASER * const phaser, const float readfov, const int datadestination) {
  /* make sure we will be able to set all these CVs */
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;

  if (phaser->nover != 0) { /* partial Fourier ky */
    rhnframes  = _rhnframes.fixedflag ?   ((void)(phaser->res/2), rhnframes) : phaser->res/2;
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPFRACTNEX), rhtype) : rhtype|RHTYPFRACTNEX;
  } else {
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->res), rhnframes) : phaser->res;
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
  }

  rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
  rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;


  rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(datadestination), rhexecctrl) : datadestination;
  if (op3dgradwarp && !(rhexecctrl & RHXC_XFER_IM)) {
    /* 3D gradwarp requires at least one of the following bits set:
       #define RHXC_XFER_IM                    0x0008  8 (GE online recon)
       #define RHXC_SAVE_IM                    0x0010  16
    */
    (rhexecctrl) |= RHXC_SAVE_IM; /* parentheses around rhexecctrl prevents EPIC preprocessor to add fixedflag check */
  }

  rhphasescale  = _rhphasescale.fixedflag ?   ((void)(phaser->fov/readfov), rhphasescale) : phaser->fov/readfov;
  if (phaser->R <= 1) {
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
    return;
  }

  rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* once more, just in case */

  if (datadestination & RHXC_XFER_IM) {
    /* if we are going to use GE recon (RHXC_XFER_IM = 8) */
    if (phaser->nacslines > 0) { /* ARC */
      /* ARC uses full BAM, i.e. stores the acquired lines at their proper locations in k-space with zero lines in between */
      rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
      rhdayres  = _rhdayres.fixedflag ?              ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);
      rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC; /* tell recon we are doing ARC only if we have ACS lines  */
    } else { /* ASSET */
      /* ASSET uses compressed BAM, i.e. stores only the acquired lines */
      rhhnover  = _rhhnover.fixedflag ?   ((void)(abs(phaser->nover)/phaser->R), rhhnover) : abs(phaser->nover)/phaser->R;
      rhnframes  = _rhnframes.fixedflag ?            ((void)((phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R)), rhnframes) : (phaser->nover!=0)?(phaser->res/(2*phaser->R)):(phaser->res/phaser->R);
      rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;
      rhasset  = _rhasset.fixedflag ?  ((void)(ASSET_SCAN), rhasset) : ASSET_SCAN; /* if we don't have ACS lines, we will need to recon the data using some external calibration */
    }
  } else {
    /* store data as ARC (full BAM) */
    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->numlinestoacq), rhnframes) : phaser->numlinestoacq; /* # of acquired lines */
    rhdayres  = _rhdayres.fixedflag ?               ((void)((phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1)), rhdayres) : (phaser->nover!=0)?(phaser->res/2+abs(phaser->nover)+1):(phaser->res+1);
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0; /* we are going to do the reconstruction offline */
  }

  rhasset_R  = _rhasset_R.fixedflag ?   ((void)(1.0/phaser->R), rhasset_R) : 1.0/phaser->R; /* inverse of acceleration factor */
} /* GEReq_predownload_setrecon_phase() */



void GEReq_predownload_setrecon_readwave(const KS_READWAVE* const readwave, const int yres, int imsize_policy, int datadestination) {
  int max_xy;

  /* make sure we will be able to set all these CVs */
  _rhfrsize.fixedflag = FALSE;
  _rhdaxres.fixedflag = FALSE;
  _rhvrgf.fixedflag = FALSE;
  _rhvrgfxres.fixedflag = FALSE;

  /* raw data freq (x) size (works for both non-VRGF and VRGF) */
  rhfrsize  = _rhfrsize.fixedflag ?  ((void)(readwave->acq.filt.outputs), rhfrsize) : readwave->acq.filt.outputs;
  rhdaxres  = _rhdaxres.fixedflag ?  ((void)(readwave->acq.filt.outputs), rhdaxres) : readwave->acq.filt.outputs;

  /* ramp sampling */
  rhvrgf  = _rhvrgf.fixedflag ?  ((void)(readwave->rampsampling), rhvrgf) : readwave->rampsampling;
  rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(readwave->res), rhvrgfxres) : readwave->res;

  piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0; /* 1 causes scan to spawn the vrgf process upon download */
  rhtype1  = _rhtype1.fixedflag ?    ((void)(~(RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1&~(RHTYP1FVRGF+RHTYP1PCORVRGF);
  rhuser32  = _rhuser32.fixedflag ?  ((void)(0.0), rhuser32) : 0.0;
  rhuser33  = _rhuser33.fixedflag ?  ((void)(0.0), rhuser33) : 0.0;
  rhuser34  = _rhuser34.fixedflag ?  ((void)(0.0), rhuser34) : 0.0;
  rhuser35  = _rhuser35.fixedflag ?  ((void)(0.0), rhuser35) : 0.0;
  
  /* image size */
  max_xy = IMax(2, readwave->res, yres);

  rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1; /* enable reduced image size, so we are in control */
  if (imsize_policy == KS_IMSIZE_MIN256) {
    max_xy = (max_xy > 256) ? 512 : 256; /* final image size is either 512 or 256 */
  } else if (imsize_policy == KS_IMSIZE_POW2) {
    max_xy = ks_calc_nextpow2((unsigned int) max_xy); /* round up to nearest power of 2 if imsize_policy = KS_IMSIZE_POW2 */
  }

  /* recon image size with optional zerofilling */
  if (opzip512 && max_xy < 512) {
    max_xy = 512;
  } else if (opzip1024 && max_xy < 1024) {
    max_xy = 1024;
  }
  rhimsize  = _rhimsize.fixedflag ?  ((void)(max_xy), rhimsize) : max_xy;
  rhrcxres  = _rhrcxres.fixedflag ?  ((void)(rhimsize), rhrcxres) : rhimsize;
  rhrcyres  = _rhrcyres.fixedflag ?  ((void)(rhimsize), rhrcyres) : rhimsize;

  /* freq. partial Fourier */
  if (abs(readwave->nover) > 0) {
    /* fractional echo (partial Fourier kx) */
    pitfeextra = rhfrsize * abs(readwave->nover)/ (float)(readwave->res/2 + abs(readwave->nover));
  } else {
    pitfeextra = 0;
  }
  rhfeextra  = _rhfeextra.fixedflag ?  ((void)(pitfeextra), rhfeextra) : pitfeextra;
  rhheover  = _rhheover.fixedflag ?  ((void)(readwave->nover), rhheover) : readwave->nover;

  /* chopping control */
  rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPCHP), rhtype) : rhtype|RHTYPCHP; /* ( |= 1) no chopping processing needed in recon */

  /* 3D recon flag */
  if(opimode == PSD_3D || opimode == PSD_3DM)
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYP3D), rhtype) : rhtype|RHTYP3D;
  else
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYP3D), rhtype) : rhtype&~RHTYP3D;



} /* GEReq_predownload_setrecon_readwave() */


/**
 *******************************************************************************************************
 @brief #### Sets required global rh*** variables for Cartsian imaging

 For Cartesian pulse sequences, using one KS_READTRAP and one KS_PHASER (each of which may have multiple
 instances), the required rh*** variables are set based on the content of the sequence objects 
 KS_READTRAP (arg 1) and KS_PHASER (arg 2). The fields in each sequence object, including e.g. partial 
 Fourier and rampsampling, controls the setting of GE's rh*** variables. In addition, the third argument
 specifies the desired upsampling policy for small matrix sizes.

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] phaser Pointer to KS_PHASER
 @param[in] zphaser Pointer to KS_PHASER (slice). NULL for 2D
 @param[in] imsize_policy Choose between `KS_IMSIZE_NATIVE`, `KS_IMSIZE_POW2`, `KS_IMSIZE_MIN256`
 @param[in] datadestination Value for the rhexecctrl variable. Bitmasks for: KS_SAVEPFILES (dump Pfiles) and KS_GERECON (product recon)
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_readphase(const KS_READTRAP * const readtrap, const KS_PHASER * const phaser, const KS_PHASER * const zphaser, int imsize_policy, int datadestination) {
  int max_xy;

  /* make sure we will be able to set all these CVs */
  _rhfrsize.fixedflag = FALSE;
  _rhdaxres.fixedflag = FALSE;
  _rhdayres.fixedflag = FALSE;
  _rhnframes.fixedflag = FALSE;
  _rhhnover.fixedflag = FALSE;
  _rhvrgf.fixedflag = FALSE;
  _rhvrgfxres.fixedflag = FALSE;
  _rhasset.fixedflag = FALSE;
  _rhasset_R.fixedflag = FALSE;

  /* raw data freq (x) size (works for both non-VRGF and VRGF) */
  rhfrsize  = _rhfrsize.fixedflag ?  ((void)(readtrap->acq.filt.outputs), rhfrsize) : readtrap->acq.filt.outputs;
  rhdaxres  = _rhdaxres.fixedflag ?  ((void)(readtrap->acq.filt.outputs), rhdaxres) : readtrap->acq.filt.outputs;

  /* ramp sampling */
  rhvrgf  = _rhvrgf.fixedflag ?  ((void)(readtrap->rampsampling), rhvrgf) : readtrap->rampsampling;
  rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(readtrap->res), rhvrgfxres) : readtrap->res;

  if (readtrap->rampsampling) {
    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(1), piforkvrgf) : 1; /* 1 causes scan to spawn the vrgf process upon download */
    rhtype1  = _rhtype1.fixedflag ?    ((void)((RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1|(RHTYP1FVRGF+RHTYP1PCORVRGF); /* VRGF and VRGFafterPC */

    /* write vrgf.param */
    GEReq_predownload_genVRGF(readtrap);

    /* VRGF (rampsampling): Store shape of the read lobe to determine the k-space travel along kx (freq. dir.) for offline VRGF correction */
    rhuser32  = _rhuser32.fixedflag ?  ((void)(readtrap->acq.filt.tsp), rhuser32) : readtrap->acq.filt.tsp; /* time between sample points [often 2us] */
    rhuser33  = _rhuser33.fixedflag ?  ((void)(readtrap->grad.amp), rhuser33) : readtrap->grad.amp; /* Readout gradient amplitude */
    rhuser34  = _rhuser34.fixedflag ?     ((void)((float)(readtrap->grad.plateautime/2)/1.0e6), rhuser34) : (float)(readtrap->grad.plateautime/2)/1.0e6; /* half plateau time */
    rhuser35  = _rhuser35.fixedflag ?    ((void)((float)(readtrap->grad.ramptime)/1.0e6), rhuser35) : (float)(readtrap->grad.ramptime)/1.0e6; /* attack/decay time */
  } else {
    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0; /* 1 causes scan to spawn the vrgf process upon download */
    rhtype1  = _rhtype1.fixedflag ?    ((void)(~(RHTYP1FVRGF+RHTYP1PCORVRGF)), rhtype1) : rhtype1&~(RHTYP1FVRGF+RHTYP1PCORVRGF);
    rhuser32  = _rhuser32.fixedflag ?  ((void)(0.0), rhuser32) : 0.0;
    rhuser33  = _rhuser33.fixedflag ?  ((void)(0.0), rhuser33) : 0.0;
    rhuser34  = _rhuser34.fixedflag ?  ((void)(0.0), rhuser34) : 0.0;
    rhuser35  = _rhuser35.fixedflag ?  ((void)(0.0), rhuser35) : 0.0;
  }


  /* image size */
  if (phaser != NULL) {
    max_xy = IMax(2, readtrap->res, phaser->res);
  } else {
    max_xy = readtrap->res;
  }

  rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1; /* enable reduced image size, so we are in control */
  if (imsize_policy == KS_IMSIZE_MIN256) {
    max_xy = (max_xy > 256) ? 512 : 256; /* final image size is either 512 or 256 */
  } else if (imsize_policy == KS_IMSIZE_POW2) {
    max_xy = ks_calc_nextpow2((unsigned int) max_xy); /* round up to nearest power of 2 if imsize_policy = KS_IMSIZE_POW2 */
  }

  /* recon image size with optional zerofilling */
  if (opzip512 && max_xy < 512) {
    max_xy = 512;
  } else if (opzip1024 && max_xy < 1024) {
    max_xy = 1024;
  }
  rhimsize  = _rhimsize.fixedflag ?  ((void)(max_xy), rhimsize) : max_xy;
  rhrcxres  = _rhrcxres.fixedflag ?  ((void)(rhimsize), rhrcxres) : rhimsize;
  rhrcyres  = _rhrcyres.fixedflag ?  ((void)(rhimsize), rhrcyres) : rhimsize;

  /* freq. partial Fourier */
  if (abs(readtrap->nover) > 0) {
    /* fractional echo (partial Fourier kx) */
    pitfeextra = rhfrsize - readtrap->res/ 2;
  } else {
    pitfeextra = 0;
  }
  rhfeextra  = _rhfeextra.fixedflag ?  ((void)(pitfeextra), rhfeextra) : pitfeextra;

  /* chopping control */
  rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPCHP), rhtype) : rhtype|RHTYPCHP; /* ( |= 1) no chopping processing needed in recon */

  /* 3D recon flag */
  if (KS_3D_SELECTED)
    rhtype  = _rhtype.fixedflag ?  ((void)(RHTYP3D), rhtype) : rhtype|RHTYP3D;
  else
    rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYP3D), rhtype) : rhtype&~RHTYP3D;

  /* phase encoding (see also GEReq_predownload_setrecon_accel(), which may override these values) */
  if (phaser != NULL) {
    if (phaser->nover != 0) { /* partial Fourier ky */
      rhnframes  = _rhnframes.fixedflag ?   ((void)(phaser->res/2), rhnframes) : phaser->res/2;
      rhtype  = _rhtype.fixedflag ?  ((void)(RHTYPFRACTNEX), rhtype) : rhtype|RHTYPFRACTNEX;
    } else {
      rhnframes  = _rhnframes.fixedflag ?  ((void)(phaser->res), rhnframes) : phaser->res;
      rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
    }

    rhhnover  = _rhhnover.fixedflag ?  ((void)(abs(phaser->nover)), rhhnover) : abs(phaser->nover);
    rhdayres  = _rhdayres.fixedflag ?      ((void)(rhnframes+rhhnover+1), rhdayres) : rhnframes+rhhnover+1;

    rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(datadestination), rhexecctrl) : datadestination;
    if (op3dgradwarp && !(rhexecctrl & RHXC_XFER_IM)) {
      /* 3D gradwarp requires at least one of the following bits set:
         #define RHXC_XFER_IM                    0x0008  8 (GE online recon)
         #define RHXC_SAVE_IM                    0x0010  16
      */
      (rhexecctrl) |= RHXC_SAVE_IM; /* parentheses around rhexecctrl prevents EPIC preprocessor to add fixedflag check */
    }

#if EPIC_RELEASE >= 26
    if (datadestination & RHXC_XFER_IM) {
      rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~8192), rhdacqctrl) : rhdacqctrl&~8192; /* enable GE's Orchestra Live recon */
    } else {
      rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(8192), rhdacqctrl) : rhdacqctrl|8192; /* disable GE's Orchestra Live recon */
    }
#endif

    /* Set up ARC/ASSET flags if R > 1 otherwise shut them off */
    GEReq_predownload_setrecon_accel(readtrap, phaser, zphaser, datadestination);

    rhphasescale  = _rhphasescale.fixedflag ?   ((void)(phaser->fov/readtrap->fov), rhphasescale) : phaser->fov/readtrap->fov;

  } /* phaser != NULL */

} /* GEReq_predownload_setrecon_readphase() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation
 
 Uses the global UI CVs `opnecho`, `opnex`, `opte` and `opte2`

 @param[in] tsp Dwell time in [us], i.e. the duration of one sample (which is also 1/rBW)
 @param[in] readdur Duration in [us] of the readout window
 @param[in] time2center Time in [us] to the center of the echo
 @param[in] echogap Gap between two echoes
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations(int tsp, int readdur, int time2center, int echogap) {

  int duration1, duration2;
  int echo_timeoffset2evenecho, echo_timeoffset2oddecho;
  int roundinglimit = 40000;

  /* rBW annotation */
  ihvbw1  = _ihvbw1.fixedflag ?     ((void)(1.0e3/(tsp*2.0)), ihvbw1) : 1.0e3/(tsp*2.0);
  ihvbw2  = _ihvbw2.fixedflag ?  ((void)(ihvbw1), ihvbw2) : ihvbw1;
  ihvbw3  = _ihvbw3.fixedflag ?  ((void)(ihvbw1), ihvbw3) : ihvbw1;
  ihvbw4  = _ihvbw4.fixedflag ?  ((void)(ihvbw1), ihvbw4) : ihvbw1;
  ihvbw5  = _ihvbw5.fixedflag ?  ((void)(ihvbw1), ihvbw5) : ihvbw1;
  ihvbw6  = _ihvbw6.fixedflag ?  ((void)(ihvbw1), ihvbw6) : ihvbw1;
  ihvbw7  = _ihvbw7.fixedflag ?  ((void)(ihvbw1), ihvbw7) : ihvbw1;
  ihvbw8  = _ihvbw8.fixedflag ?  ((void)(ihvbw1), ihvbw8) : ihvbw1;
  ihvbw9  = _ihvbw9.fixedflag ?  ((void)(ihvbw1), ihvbw9) : ihvbw1;
  ihvbw10  = _ihvbw10.fixedflag ?  ((void)(ihvbw1), ihvbw10) : ihvbw1;
  ihvbw11  = _ihvbw11.fixedflag ?  ((void)(ihvbw1), ihvbw11) : ihvbw1;
  ihvbw12  = _ihvbw12.fixedflag ?  ((void)(ihvbw1), ihvbw12) : ihvbw1;
  ihvbw13  = _ihvbw13.fixedflag ?  ((void)(ihvbw1), ihvbw13) : ihvbw1;
  ihvbw14  = _ihvbw14.fixedflag ?  ((void)(ihvbw1), ihvbw14) : ihvbw1;
  ihvbw15  = _ihvbw15.fixedflag ?  ((void)(ihvbw1), ihvbw15) : ihvbw1;
  ihvbw16  = _ihvbw16.fixedflag ?  ((void)(ihvbw1), ihvbw16) : ihvbw1;

  /* NEX annotation */
  ihnex  = _ihnex.fixedflag ?  ((void)(opnex), ihnex) : opnex;

  /* TE */
  ihte1  = _ihte1.fixedflag ?        ((void)((opte>roundinglimit)?ks_calc_roundupms(opte):opte), ihte1) : (opte>roundinglimit)?ks_calc_roundupms(opte):opte;

  duration1 = (readdur - time2center) * 2 + echogap; /* 2x (time from k-space center to edge for 1st echo) + additional echo gap */
  duration2 = time2center * 2 + echogap; /* 2x (time from start to k-space center for 1st echo) + additional echo gap */

  if ((eeff == 1 && oeff == 0) || (eeff == 0 && oeff == 1) || (acq_type == TYPSPIN)) { /* alternating readout gradient polarity across echoes (like often in GRE), or SpinEcho */
    echo_timeoffset2evenecho = duration1; /* between 1 and 2, 3 and 4 etc. */
    echo_timeoffset2oddecho  = duration2; /* between 2 and 3, 4 and 5 etc. */
  } else { /* same readout gradient polarity across echoes */
    /* we have a GRE sequence, and there are likely flyback gradients
       between each readout to allow for the readout gradient polarity to have the same sign for all echoes */
    echo_timeoffset2evenecho = readdur + echogap; /* between 1 and 2, 3 and 4 etc. */
    echo_timeoffset2oddecho  = readdur + echogap; /* between 2 and 3, 4 and 5 etc. */
  }

  if (opnecho == 2) {
    if (pite2nub && existcv(opte2) && opte2 > 0) { /* use opte2 if the button is visible and it was selected */
      ihte2  = _ihte2.fixedflag ?  ((void)(opte2), ihte2) : opte2;
    } else {
      /* partial Fourier note: 2nd readout will have its relative k-space center mirrored */
      ihte2  = _ihte2.fixedflag ?    ((void)(opte+echo_timeoffset2evenecho), ihte2) : opte+echo_timeoffset2evenecho;
    }
  } else if (opnecho > 2) {
    int pos = opte + echo_timeoffset2evenecho;
    ihte2  = _ihte2.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte2) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte3  = _ihte3.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte3) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte4  = _ihte4.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte4) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte5  = _ihte5.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte5) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte6  = _ihte6.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte6) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte7  = _ihte7.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte7) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte8  = _ihte8.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte8) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte9  = _ihte9.fixedflag ?         ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte9) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte10  = _ihte10.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte10) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte11  = _ihte11.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte11) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte12  = _ihte12.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte12) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte13  = _ihte13.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte13) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte14  = _ihte14.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte14) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte15  = _ihte15.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte15) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos; pos += echo_timeoffset2oddecho;
    ihte16  = _ihte16.fixedflag ?        ((void)((pos>roundinglimit)?ks_calc_roundupms(pos):pos), ihte16) : (pos>roundinglimit)?ks_calc_roundupms(pos):pos;
  }

  /* rhte/rhte2 end up in the raw section of the rawdata header (rdb_hdr_te, rdb_hdr_te2)
     while opte/opte in the image section (te,te2). For opnecho > 2, the te2 field is sometimes 0, why
     we also need to rely on rdb_hdr_te2 for offline reconstruction */
  rhte  = _rhte.fixedflag ?  ((void)(ihte1), rhte) : ihte1;
  rhte2  = _rhte2.fixedflag ?  ((void)(ihte2), rhte2) : ihte2;


  /* Flip Angle */
  ihflip  = _ihflip.fixedflag ?  ((void)(opflip), ihflip) : opflip;

} /* GEReq_predownload_setrecon_annotations() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation based on a KS_READTRAP
 
 This is a wrapper function to GEReq_predownload_setrecon_annotations() using a KS_READTRAP

 @param[in] readtrap Pointer to KS_READTRAP
 @param[in] echogap Gap between two echoes
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations_readtrap(KS_READTRAP *readtrap, int echogap) {

  GEReq_predownload_setrecon_annotations(readtrap->acq.filt.tsp, readtrap->grad.duration, readtrap->time2center, echogap);

} /* GEReq_predownload_setrecon_annotations_readtrap() */




/**
 *******************************************************************************************************
 @brief #### Sets ih*** variables for TE and rBW annotation based on a KS_EPI
 
 This is a wrapper function to GEReq_predownload_setrecon_annotations() using a KS_EPI

 @param[in] epi Pointer to KS_EPI
 @param[in] echogap Gap between two EPI trains
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_annotations_epi(KS_EPI *epi, int echogap) {
  int maxtime_dephasers = IMax(2, epi->readphaser.duration, epi->blipphaser.grad.duration);
  int maxtime_rephasers = IMax(2, epi->readphaser.duration, epi->blipphaser.grad.duration);
  int halfkspace_duration = ((epi->read.grad.duration + epi->read_spacing) * epi->etl/ 2) - epi->read_spacing/ 2;
  /* time for extra lines beyond half-kspace for partial Fourier in ky */
  int overscan_duration = ((epi->read.grad.duration + epi->read_spacing) * (epi->blipphaser.nover/ epi->blipphaser.R)) - epi->read_spacing/ 2;
  int epiduration, time2center;

  if (opautote == PSD_MINTE) {
    epiduration = (maxtime_dephasers + overscan_duration + halfkspace_duration + maxtime_rephasers);
    time2center = maxtime_dephasers + overscan_duration;
  } else {
    epiduration = (maxtime_dephasers + 2 * halfkspace_duration + maxtime_rephasers);
    time2center = maxtime_dephasers + halfkspace_duration;
  }
  GEReq_predownload_setrecon_annotations(epi->read.acq.filt.tsp, epiduration, time2center, echogap);


} /* GEReq_predownload_setrecon_annotations_epi() */




/**
 *******************************************************************************************************
 @brief #### Sets rh*** variables related to multi-volume imaging

 The combination of rh*** variables allow for 50,000 image planes in GE's database.

 However, Pfile data stops writing after 512 planes. To store more than 512 image planes as rawdata, 
 RDS (Raw Data Server) or multivolume Pfiles can be used instead. It is possible that other mechanisms 
 will be available through GE's upcoming Orchestra Live in the future.

 @param[in] numvols    Number of volumes (`opfphases`)
 @param[in] slice_plan The slice plan (KS_SLICE_PLAN), set up using ks_calc_sliceplan() or similar
 @return void
********************************************************************************************************/
void GEReq_predownload_setrecon_voldata(int numvols, const KS_SLICE_PLAN slice_plan) {
  int numechoes;

  if (numvols < 1)
    numvols = 1;

  /* GE's CVs for #slices/TR and #passes (acqs) */
  _slquant1.fixedflag = 0;
  _acqs.fixedflag = 0;
  slquant1  = _slquant1.fixedflag ?  ((void)(slice_plan.nslices_per_pass), slquant1) : slice_plan.nslices_per_pass;
  acqs  = _acqs.fixedflag ?  ((void)(slice_plan.npasses), acqs) : slice_plan.npasses;
  /* prescan */
  picalmode = 0;
  pislquant = slquant1;

  /* rhscnframe and rhpasframe are used when scanning in auto-pass mode w/o specific pass-packets (like GEendpass).
  To enable auto-pass mode, set rhtype1 |= RHTYP1AUTOPASS and set these variables to the proper value.
  It is unclear how this would work with partial Fourier and ARC, and has not been tested. */
  rhscnframe  = _rhscnframe.fixedflag ?   /* rhnslices*ceil(opnex)*rhdayres */((void)(0), rhscnframe) : 0;
  rhpasframe  = _rhpasframe.fixedflag ?   /* slquant1*ceil(opnex)*rhdayres */((void)(0), rhpasframe) : 0;
  rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP1AUTOPASS), rhtype1) : rhtype1&~RHTYP1AUTOPASS; /* diable auto-pass. I.e. require the use of pass packets (which is standard anyway) in scan to dump Pfiles */

  /* raw size */
  numechoes = IMax(2, rhnecho, opnecho);
  if (!KS_3D_SELECTED) {
    rhrawsize = slquant1 * numechoes * (2 * rhptsize) * rhdaxres * rhdayres;
  } else {
    rhrawsize = opslquant * numechoes * (2 * rhptsize) * rhdaxres * rhdayres;
  }

  {
    char tmpstr[100];
    sprintf(tmpstr, "rhrawsize = %d bytes/channel (KSFoundation)", (int) rhrawsize);
    cvdesc(rhrawsizeview, tmpstr);
  }

  /* Volumes & total size */
  rhnphases  = _rhnphases.fixedflag ?  ((void)(numvols), rhnphases) : numvols;  /* must be = numvols (not numvols*acqs=#pfiles !!)
         - if 1 when numvols >1:
         Prep Action failed: error please try again. ErrorLog="The integer value for ps_to_rs[0] in the header = 0 "
         - if numvols*acqs when acqs > 1 and numvols == 1:
         Scan failed (after few secs, no images)  */
  rhnpasses  = _rhnpasses.fixedflag ?    ((void)(rhnphases*slice_plan.npasses), rhnpasses) : rhnphases*slice_plan.npasses;  /* must be == # volumes (Pfiles) dumped or system hangs and needs rebooting ! */
  rhreps     = _rhreps.fixedflag ?  ((void)(rhnphases), rhreps) : rhnphases;
  if (!KS_3D_SELECTED) {
    rhnslices  = _rhnslices.fixedflag ?    ((void)(slice_plan.nslices*rhnphases), rhnslices) : slice_plan.nslices*rhnphases;
  } else {
    rhnslices  = _rhnslices.fixedflag ?      ((void)(opslquant*opvquant*rhnphases), rhnslices) : opslquant*opvquant*rhnphases;
  }
  rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase */

  rhtype1  = _rhtype1.fixedflag ?   ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* zerofill BAM for clean Pfiles */
  rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_ZCHOP), rhformat) : rhformat&~RHF_ZCHOP; /* no z chopping by default */
  rhformat  = _rhformat.fixedflag ?  ((void)(RHF_SINGLE_PHASE_INFO), rhformat) : rhformat|RHF_SINGLE_PHASE_INFO;

  /* Gradwarp Mode */
  rhuser47  = _rhuser47.fixedflag ?  ((void)(cfgradcoil), rhuser47) : cfgradcoil;
  
  /* copy useful variables to raw header for recon */
  /* rhuser32-35 are reserved for off-line VRGF correction (Karolinska) */
  rhuser48  = _rhuser48.fixedflag ?  ((void)(pitscan), rhuser48) : pitscan; /* scan time */

} /* GEReq_predownload_setrecon_voldata() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function that set up rh*** variable for a KS_EPI object using other functions

 Calls GEReq_predownload_setrecon_readphase(), GEReq_predownload_setrecon_voldata() and 
 GEReq_predownload_setrecon_annotations_epi(), and GEReq_predownload_genrowflip(). Additionally, 
 some rh*** variables are overridden for EPI.

 @param[in] epi             Pointer to KS_EPI
 @param[in] numvols2store   Number of volumes to store (including calibration vols such as ghostcorr)
 @param[in] slice_plan      The slice plan (KS_SLICE_PLAN) set up using ks_slice_plan() or similar
 @param[in] echogap         Gap between two EPI trains in [us]
 @param[in] blipsign        KS_EPI_POSBLIPS or KS_EPI_NEGBLIPS
 @param[in] datadestination Value passed on to GEReq_predownload_setrecon_readphase() to set rhexecctrl
 @param[in] multishotflag   0: Parallel imaging mode 1: Multishot mode
 @param[in] ghostcorrflag   Integrated refscan (Nyquist ghost correction). 0:Off, 1:On
 @param[in] imsize_policy   Choice between `KS_IMSIZE_NATIVE`, `KS_IMSIZE_POW2`, `KS_IMSIZE_MIN256`
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload_setrecon_epi(KS_EPI *epi, int numvols2store, const KS_SLICE_PLAN slice_plan, int echogap, int blipsign, int datadestination, int multishotflag, int ghostcorrflag, int imsize_policy) {

#if EPIC_RELEASE >= 26  
        if (datadestination & RHXC_XFER_IM) {
          return ks_error("%s: Online recon not supported for KS_EPI data on DV26 or later", __FUNCTION__); 
        }
#endif

  GEReq_predownload_setrecon_readphase(&epi->read, &epi->blipphaser, NULL, imsize_policy, datadestination); /* also sets rhasset when R > 1 */
  GEReq_predownload_setrecon_voldata(numvols2store, slice_plan); /* opfphases = number of volumes */
  GEReq_predownload_setrecon_annotations_epi(epi, echogap);


  /* EPI specific rh* vars  */
  rhileaves  = _rhileaves.fixedflag ?  ((void)(epi->blipphaser.R), rhileaves) : epi->blipphaser.R;
  rhkydir  = _rhkydir.fixedflag ?        ((void)((blipsign==KS_EPI_POSBLIPS)?2:0), rhkydir) : (blipsign==KS_EPI_POSBLIPS)?2:0;
  rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase */

  if (multishotflag > 0) {
    /* .R for multi-shot. Override values set in GEReq_predownload_setrecon_readphase()->GEReq_predownload_setrecon_accel() */
    _rhasset.fixedflag = FALSE;
    _rhasset_R.fixedflag = FALSE;
    rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
  }

  /* Turn on row-flipping if ETL > 1 */
  if (epi->etl > 1) {
    rhformat  = _rhformat.fixedflag ?  ((void)(RHF_USE_FLIPTABLE), rhformat) : rhformat|RHF_USE_FLIPTABLE;
    if (datadestination & RHXC_XFER_IM) {
      /* Online recon: Single-shot w/ or w/o ASSET */
      GEReq_predownload_genrowflip(epi, blipsign, rhasset, TRUE);
    } else {
      /* Offline recon, say we do rowflip in rhformat, because otherwise GERecon('EPI.ComputeCoefficients') does not
      work (requires RHF_USE_FLIPTABLE to be set).
      But let's not set any negative entries in the file for offline use to avoid rowflipping to actually occur:
      DV26+: This file is ignored for scan archives
      Pre DV26: We don't want the rows to be flipped correctly in the Pfile currently since we don't understand
      why the lines are flipped wrong for mulitshot EPI. We deal with rowflipping ourselves in the recon
      */
      GEReq_predownload_genrowflip(epi, blipsign, rhasset, FALSE);      
    }
  } else {
    rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_USE_FLIPTABLE), rhformat) : rhformat&~RHF_USE_FLIPTABLE;
  }

  /* fermi filter */
  rhfermr  = _rhfermr.fixedflag ?  ((void)(opxres/2), rhfermr) : opxres/2;


  /* override flip control set in GEReq_predownload()->{@inline loadrheader.e rheaderinit} 
  N.B.: ks_scan_epi_loadecho() changes the view indices based on the blipsign argument. Hence, 
  there is no need to inform recon that k-space data should be flipped (as opposed to the product
  epi.e/epi2.e, which use oepf = 1 when pepolar = 1) */
  eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
  eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
  oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
  oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;
  set_echo_flip(_rhdacqctrl.fixedflag ? (_temp471_rhdacqctrl=rhdacqctrl,&_temp471_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff); /* clear bit 1 - flips image in phase dir */

#if EPIC_RELEASE >= 26
    rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(8192), rhdacqctrl) : rhdacqctrl|8192; /* disable Orchestra recon */
#endif

  /* save echo spacing value into rhesp */
  rhesp  = _rhesp.fixedflag ?  ((void)(epi->read.grad.duration), rhesp) : epi->read.grad.duration;



  /* default but see below */
  rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(1), rhpctemporal) : 1;
  rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0;
  rhref  = _rhref.fixedflag ?  ((void)(0), rhref) : 0;
  rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1&~RHTYP1DIFFUSIONEPI;

  /* Nyquist ghost correction using integrated ref scan combined with online recon (RHXC_XFER_IM) requires diffusion mode
     so here we pretend we are doing this */
  if (ghostcorrflag) {

    rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1|RHTYP1DIFFUSIONEPI; 

  #if EPIC_RELEASE < 26
    if (datadestination & RHXC_XFER_IM) {

        if ((multishotflag > 0) && (epi->blipphaser.R > 1)) {
      
          /* GE's online recon cannot do this type of ghost correction for multi-shot */
          return ks_error("%s: GhostCal+OnlineRecon requires single-shot", __FUNCTION__);
      
        } else {

          if (opdiffuse != KS_EPI_DIFFUSION_ON) {
            /* we have a non-diffusion EPI scan (e.g. SE-EPI or GE-EPI) that we want to use with GE's integrated
            refscan (rhref = 5), which only allows single-shot DW-EPI
            DV26 Update: The new Orchestra recon does not accept normal DAB packets, only HyperDAB packets (loadhsdab())
            which is not supported by the use of KS_EPI objects. This means that as of DV26+, GE's online recon cannot be used
            to recon EPI data with KS_EPI (i.e. not ksepi.e) */
            cvoverride(opdiffuse, KS_EPI_DIFFUSION_PRETEND_FOR_RECON, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(optensor, 16, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(rhnumdifdirs, 1, PSD_FIX_ON, PSD_EXIST_ON); /* Prep Action Failed if 0 */
            cvoverride(opdifnumdirs, 0, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opdifnumt2, opfphases, PSD_FIX_ON, PSD_EXIST_ON);
          }                

          rhref  = _rhref.fixedflag ?  ((void)(5), rhref) : 5;/* inform GE's product recon that we want this type of ghost correction */

        } /* Online recon prior to DV26 */
   }
  #endif

  }



  return SUCCESS;

} /* GEReq_predownload_setrecon_epi() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cvinit()

 In the beginning of `cvinit()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cvinit();
 if (status != SUCCESS) return status;
 \endcode

 This function sets up various global GE stuff, including e.g. the gradient specs. The gradient specs
 are controlled by `ks_srfact` and `ks_qfact`. `ks_srfact` Should have a value that will allow scanning on
 all MR systems without PNS effects. Also, `ks_srfact` does not affect the EPI train in ksepi.e, since it
 controls the slewrate and gradient max separately. `ks_qfact` is supposed to be 1 by default, with the 
 purpose to from an optimal setting reduce the slewrate to reduce the acoustic noise. A default value of
 1.0 will make the system perform best but with high acoustic noise. A value of about 8-10 may be a good
 trade-off between acoustic noise reduction and reasonable image quality.

 In this function, `ks_sarcheckdone` is set to FALSE. This CV is checked in GEReq_predownload() and 
 ks_pg_rf(), which both will complain if it is not has been set to TRUE. GEReq_eval_checkTR_SAR_calcs() 
 sets this CV to TRUE.

 It is important that an error returned from GEReq_cvinit() also results in an error in `cvinit()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cvinit(void) {

  /* ART: Acoustic noise reduction
    Imaging option button "Acoustic reduction":
      - PSD_IOPT_MILDNOTE in sequence_iopts[]
      - Sets CV opsilent = TRUE
    When acoustic noise reduction (ART) imaging option is checked, enable the ART tab in the UI too
    by forcing cfnumartlevels = 2
    - "Moderate" radio button on ART tab: CV opsilentlevel = 1
    - "High" radio button on ART tab: CV opsilentlevel = 2
   */
  cvoverride(cfnumartlevels, 2, PSD_FIX_OFF, PSD_EXIST_ON);
  pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels;
  
  if (opsilent) {
    _ks_qfact.existflag = TRUE;
    if (opsilentlevel == 1) {
      /* moderate */
      ks_qfact  = _ks_qfact.fixedflag ?  ((void)(8), ks_qfact) : 8;
    } else {
      /* high */
      ks_qfact  = _ks_qfact.fixedflag ?  ((void)(20), ks_qfact) : 20;
    }
  } else {
    ks_qfact  = _ks_qfact.fixedflag ?  ((void)(1), ks_qfact) : 1;
  }


  {
    { /* Start of code inlined from vmx.e SysParmInit */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            cvdef(opfov, FOV_MAX_VMX);
            cvmax(opfov, FOV_MAX_VMX);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_VMX), opfov) : FOV_MAX_VMX;
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        else
        {
            cvdef(opfov, cfsystemmaxfov);
            cvmax(opfov, cfsystemmaxfov);
            opfov  = _opfov.fixedflag ?  ((void)(cfsystemmaxfov), opfov) : cfsystemmaxfov;

            cvdef(asfov, cfsystemmaxfov);
            cvmax(asfov, cfsystemmaxfov);
            asfov  = _asfov.fixedflag ?  ((void)(cfsystemmaxfov), asfov) : cfsystemmaxfov;
           
            cvdef(tgfov, cfsystemmaxfov);
            cvmax(tgfov, cfsystemmaxfov);
            tgfov  = _tgfov.fixedflag ?  ((void)(cfsystemmaxfov), tgfov) : cfsystemmaxfov;
            
            cvmax(opmonfov, cfsystemmaxfov);
            
            cvmax(rhscanfov, cfsystemmaxfov * FOV_MAX_SCALE);

            cvmax(rhdispfov, cfsystemmaxfov * FOV_MAX_SCALE);
        }
        if(cffield == 2000)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
        }
        if(cffield <= 2000)
        {
            _opcfsel.fixedflag = 0;
            opcfsel  = _opcfsel.fixedflag ?  ((void)(PSD_CFPK), opcfsel) : PSD_CFPK;
            _opcfsel.existflag = 1;
            _opcfsel.fixedflag = 1;
        }
        if(cffield == 2000)
        {
            /* Maximum integrated (B1)^2 per pulse (uT^2sec) */
            txCoilInfo[getTxIndex(coilInfo[0])].maxB1Squared = 8.0; 
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode  = _psddebugcode.fixedflag ?  ((void)(value), psddebugcode) : value;
            }
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE2");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode2  = _psddebugcode2.fixedflag ?  ((void)(value), psddebugcode2) : value;
            }
        }

#ifdef VMX_VERSION_MFO
        debug_scan = (int)((psddebugcode2 & 1/*PSDDEBUG_SCAN*/)!=0);
        debug = (int)((psddebugcode2 & 2/*PSDDEBUG_IPG*/)!=0);
#endif
        debug_grad_spec  = _debug_grad_spec.fixedflag ?    /*PSDDEBUG_GSPEC*/((void)((int)((psddebugcode2&8)!=0)), debug_grad_spec) : (int)((psddebugcode2&8)!=0);
        if(cffield <= 3500)pisupnub = 0;

        switch (cfsrmode)
        {
            case PSD_SR50:
                if((PSD_BRM2_COIL == cfgcoiltype) && (5551 == cfgradamp))
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                }
                else
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_HDE), value_system_flag) : VALUE_SYSTEM_HDE;
                }
                break;
            case PSD_SR100:
                if(cffield == 15000 && PSD_VRMW_COIL != cfgcoiltype)
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                }
                else
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
                }
                break;
            default:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
        }

        if( VALUE_SYSTEM_HDE == value_system_flag )
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_ON), val15_lock) : PSD_ON;
        }
        else
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }

       /* SVBranch HCSDM00357453 Mild Note */
        if (PSD_OFF == cfnumartlevels)
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_OFF), mild_note_support) : PSD_OFF;
        }
        else
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_ON), mild_note_support) : PSD_ON;
        }
        pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels; /* This parameter will be used by host to manage ART UI */

        if(isRioSystem())
        {
           sphericalGradient  = _sphericalGradient.fixedflag ?  ((void)(PSD_ON), sphericalGradient) : PSD_ON;
        } 
        else
        {  
           sphericalGradient  = _sphericalGradient.fixedflag ?  ((void)(PSD_OFF), sphericalGradient) : PSD_OFF;
        }  
        
        /* Update default values based on the system configuration */
        configSystem();

        /* SVBranch HCSDM00107762 */
        if( isValueSystem() )
        {
             cfcoilswitchmethod   = _cfcoilswitchmethod.fixedflag ?  ((void)(COIL_SWITCH_RSP_SETHUBINDEXIMM), cfcoilswitchmethod) : COIL_SWITCH_RSP_SETHUBINDEXIMM;
        }

        /* Set flags for scan volume shift */
        set_vol_shift_cvs();

    } /* End of code inlined from vmx.e SysParmInit */

  }

  EpicConf();

  /* set gradient limitations (calling GEs obloptimize() & further ramptime modifications) */
  GEReq_init_gradspecs(&loggrd, &phygrd, ks_srfact/ ks_qfact);

  /* resets all filter #. From this point, ok to call setfilter() */
  initfilter();

  /* setsysparams() sets psd_grd_wait and psd_rf_wait for the system */
  setsysparms();
#ifdef SIM
  /* In simulation, we don't want them to confuse the timing in WTools */
  _psd_grd_wait.fixedflag = 0;
  _psd_rf_wait.fixedflag = 0;
  psd_grd_wait  = _psd_grd_wait.fixedflag ?  ((void)(0), psd_grd_wait) : 0;
  psd_rf_wait  = _psd_rf_wait.fixedflag ?  ((void)(0), psd_rf_wait) : 0;
#endif

#include "cvinit.in"  /* Runs the code generated by macros in preproc.*/

  /* GE CVs that could use a wider min/max range: */
  cvmax(rhfrsize, 32768);
  cvmax(rhdaxres, 32768);
  cvmax(opphasefov, 5); /* to allow larger FOV in phase enc dir that freq */
  cvmax(rhnslices, 50000); /* 50,000, which is 5x of RHF_MAX_IMAGES_MULTIPHASE = 10000 */
  cvmax(rhreps, 2048); /* max 2048 vols */
  cvmax(rhnphases, 2048); /* max 2048 vols */
  cvmax(opfphases, 2048); /* max 2048 vols */
  cvmax(opyres, 1024); /* max 1024 yres */
  cvmax(opslthick, 200); /* max 200 mm slice thickness */
  cvmax(optr, 60000000); /* max 60s TR */
  cvmax(ihtr, 60000000);
  cvmax(rhref, 5); /* Allow 1st-volume ghost correction as GE's diffusion EPI (only works for single shot) */
  cvmax(opbval, 30000);
  cvmax(opileave, 1);

  /* activate Advisory panel */
  piadvise = PSD_ON;
  piadvmin  = (1 << PSD_ADVTE); /* TE Advisory on */
  piadvmin |= (1 << PSD_ADVTR);  /* TR Advisory on */
  piadvmin |= (1 << PSD_ADVRCVBW);/* rBW Advisory on */
  piadvmin |= (1 << PSD_ADVFOV);/* FOV Advisory on */
  piadvmax = piadvmin;

  {
    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        pipscshimtgnub = PSD_ON;
        if(PSD_SPECTRO == exist(opimode))
        {
            pipscshimtgnub = PSD_OFF;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));

        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if( (cffield == B0_30000) && 
            (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_SPINE) && strstr(attribute_codeMeaning, "Lumbar spine")) &&
            (PSD_OFF == local_tg) )
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }
        else
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
        RScvinit();
        DTGcvinit();
        AutoCoilcvinit();
        ExtCalcvinit();
    } /* End of code inlined from Prescan.e PScvinit */

  }


  /* KSFoundation indicator variable for completed SAR checks (c.f. GEReq_eval_checkTR_SAR_calcs(), which sets it to TRUE) */
  ks_sarcheckdone = FALSE;

 /* GE's psd_name seems not be available on TGT, to let's copy this one */
#if EPIC_RELEASE > 27 || (EPIC_RELEASE == 27 && EPIC_PATCHNUM > 1)
/* #if EPIC_RELEASE >= 27 */
/* Since RX27R02, GE's psd_name no longer exists */
{
  strcpy(ks_psdname, get_psd_name());
}
#else
  strcpy(ks_psdname, psd_name);
#endif


  return SUCCESS;

} /* GEReq_cvinit() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cveval()

 In the beginning of `cveval()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cveval();
 if (status != SUCCESS) return status;
 \endcode

 This function up various global GE stuff, and copies also the struct array `scan_info`, holding the
 prescribed slice locations to `ks_scan_info`, the latter which can also be accessible on TGT.

 Simulation (WTools): If we have ks_simscan = 1 (default), simscan() will have make up slice locations in
 ks_scan_info based on opslthick, opslspace and opslquant. Note, GE clears scan_info between cvcheck() 
 and predownload() when in simulation. Hence, we now have the opposite case, i.e. we have some slice info
 data in ks_scan_info but nothing in scan_info.

 It is important that an error returned from GEReq_cveval() also results in an error in `cveval()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cveval(void) {

  {
    { /* Start of code inlined from vmx.e SysParmEval */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        if(cffield == 2000)
        {
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            avmaxfov = FOV_MAX_PROFILE;
        }

        if( (exist(opimode) != PSD_3D) && (exist(opimode) != PSD_3DM)
           && (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP)
           && (cffield <= B0_5000) ) 
        {
            if( exist(opslthick) < MINTHICK_VMX )
            { 
                epic_error(use_ermes, "Increase the slice thickness to %.1f",
                           EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, MINTHICK_VMX);
                return FAILURE;
            }
        }

        /* PURE */
        pipure = coilInfo[0].pureCompatible;

        /* PURE Mix */
        strcpy(model_parameters.psd_name, get_psd_name());
        model_parameters.irmode = exist(opirmode);
        model_parameters.irprep = exist(opirprep);
        model_parameters.fatsat_flag = exist(opfatcl) || exist(opfat) || exist(opspecir) || exist(opssrf);
        model_parameters.flex_flag = exist(opmedal);
        model_parameters.ideal_flag = exist(opdixon);
        model_parameters.pure_support = pipure;
        model_parameters.cffield  = _cffield.fixedflag ?  ((void)(cffield), cffield) : cffield;
        model_parameters.pseq_type = exist(oppseq);
        model_parameters.realtime_flag = exist(oprealtime);
        model_parameters.imode = exist(opimode);
        model_parameters.plane = exist(opplane);

        if (FAILURE == getPUREMixCompatibility(model_parameters, coilInfo, exist(opanatomy), &pipure, &pure_mix))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getPUREMixCompatibility");
            return FAILURE;
        }

        if (B0_30000 == cffield)
        {

            if (PURE2 == exist(oppure) && pure_mix.enable)
            {
                cvmod(opuser40, -100.0, 100.0, 0.0, "PURE compensation", 0, "");
                opuser40  = _opuser40.fixedflag ?  ((void)(_opuser40.defval), opuser40) : _opuser40.defval;
                activate_reserved_usercv(40);

                if ((_opuser40.minval > exist(opuser40)) ||
                    (_opuser40.maxval < exist(opuser40)))
                {
                    cvoverride(opuser40, _opuser40.defval, PSD_FIX_ON, PSD_EXIST_ON);
                    epic_error(use_ermes, "%s is out of range.",
                               EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "PURE compensation");
                    return FAILURE;
                }
            }
            else
            {
                cvmod(opuser40, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 40", 0, "");
                cvoverride(opuser40, _opuser40.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                deactivate_reserved_usercv(40);
            }
        }

        if (isDVSystem() && (B0_15000 == cffield) &&
            (PSD_PURE_COMPATIBLE_1 & pipure) &&
            (!strncmp("memp_pure", get_psd_name(), 9) || !strncmp("fse_pure", get_psd_name(), 8)))
        {   
            pipure = PSD_PURE_COMPATIBLE_2;
        }
        else if ((isK15TSystem()) &&
                 (PSD_PURE_COMPATIBLE_1 & pipure) && (opfov <= 300) &&
                 (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) ||
                  isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES)))
        {
            pipure = PSD_PURE_COMPATIBLE_2;
        }
        else if ((isSVSystem()) && (PSD_PURE_COMPATIBLE_1 & pipure) &&
                 (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)))
        {
            if((!strncmp("dwi_pure",get_psd_name(),8) || !strncmp("fsemaster_pure",get_psd_name(),14) || 
                !strncmp("t1memp_pure",get_psd_name(),11) || !strncmp("2dfast_pure",get_psd_name(),11) || 
                !strncmp("3dfse_pure",get_psd_name(),10) || !strncmp("3dradial_pure",get_psd_name(),13) ||
                !strncmp("efgre3d_pure",get_psd_name(),12) || !strncmp("csmemp_pure",get_psd_name(),11) || 
                !strncmp("3dtof_pure",get_psd_name(),10) || !strncmp("ssfse_pure",get_psd_name(),10) || 
                !strncmp("epi_pure",get_psd_name(),8) || !strncmp("asl_pure",get_psd_name(),8)) && (exist(oppure) != 0))
            {
                pipure = PSD_PURE_COMPATIBLE_2;

                /* Adding an advanced CV31 for Customer to adjust the Lamda of Pure-mix for the Head Shading issue for above type-in PSD.
                   Because not all the HNA coils have the same shading level, an advanced CV will be more flexible and robust.
                   ZT 06/Mar/2018 */

                piuset2 |= use31;
                opuser31  = _opuser31.fixedflag ?  ((void)(100.0), opuser31) : 100.0;
                cvmod(opuser31, 1.0, 100.0, 100.0, "Head Uniformity Improvement",0," ");
                if (existcv(opuser31) && ((exist(opuser31) < 1) || (exist(opuser31) > 100) || 
                    (!floatsAlmostEqualEpsilons(exist(opuser31),(int)exist(opuser31),2))))
                {
                    epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser31.descr );
                    return FAILURE;
                }
            }
            else
            {
                piuset2 &= ~use31;
                cvmod(opuser31, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 31", 0, "");
                cvoverride(opuser31, _opuser31.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

        }

        if ((PSD_SPECTRO == exist(opimode)) ||
            (PSD_3PLANE == exist(opplane)) ||
            (PSD_ON == exist(opassetcal)) || (PSD_ON == exist(oppurecal)) ||
            ((PSD_ON == exist(oprealtime)) && (PSD_OFF == exist(opfluorotrigger))) ||
            (PSD_ON == exist(opmultistation)) ||
            (1 == coilInfo[0].numChannels))
        {
            pipure = 0;
        }

        /* pure is set off for MAVRIC.  */
        if (model_parameters.fse3d.mavric_flag)
        {
            pipure = 0;
        }

        /* pure2 is set off for FIESTA-C.  */
        if (model_parameters.gre3d.pcfiesta_flag)
        {
            pipure &= ~PSD_PURE_COMPATIBLE_2;
        }

        /* SCENIC */
        model_parameters.anatomy = exist(opanatomy);
        model_parameters.pure_support = pipure;
        scenic.sysconfig = cfscenic;
        scenic.opscenic  = _opscenic.fixedflag ?  ((void)(exist(opscenic)), opscenic) : exist(opscenic);
        scenic.opscic  = _opscic.fixedflag ?  ((void)(exist(opscic)), opscic) : exist(opscic);
        scenic.itkn4.allow = ((cfn4_num_levels_max>0) && cfn4_allowed);
        scenic.scic.allow = ((cfscic_focus>0.0) && cfscic_allowed);
        scenic.itkn4.gain_clamp_value = cfn4_gain_clamp_value;
        scenic.itkn4.gain_clamp_mode = cfn4_gain_clamp_mode;

        if((exist(opsilent) || exist(opsilentmr)) && (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)))
        {
            model_parameters.pure_support = 0;
        }
        else
        {
            model_parameters.pure_support = pipure;
        }

        if (FAILURE == getScenicCompatibility(model_parameters, &scenic))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getScenicCompatibility");
            return FAILURE;
        }
        piscenic  = _piscenic.fixedflag ?  ((void)(scenic.piscenic), piscenic) : scenic.piscenic;
        piscic  = _piscic.fixedflag ?  ((void)(scenic.piscic), piscic) : scenic.piscic;

        /*
         * scenic.scenic_type and scenic.itkn4.gain_clamp_value
         * will be set in getScenicType()
         */
        if (FAILURE == getScenicType(model_parameters, &scenic))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getScenicType");
            return FAILURE;
        }
        rhscenic_type  = _rhscenic_type.fixedflag ?  ((void)(scenic.scenic_type), rhscenic_type) : scenic.scenic_type;

        if (SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
            override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;
        }
        else if (PSD_OFF == override_opcalrequired)
        {
            cvoverride(opcalrequired, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        }

        if( psd_board_type == PSDCERD || psd_board_type == PSDDVMR )
        {
            
            if( cftpssize <= 0 )
            {
                if (VALUE_SYSTEM_HDE == value_system_flag) {
                    cftpssize = 133954560;
                }else {
                    cftpssize = 1670381568.0;
                }
            }
        }

        /* MRIhc41001 - maximum attenuation available for PSD
         * (xmtadd) usage is the hardware maximum minus 200 for
         * TG. (ampCal is unused and coil attenuation is included
         * in xmtadd.
         */
        cfdbmax = IMax(2, 0, cfrfMaxAttenuation - 200);

        /* Dynamic Plan */
        if( (exist(opdynaplan) == PSD_ON) && existcv(opdynaplan) ) {
            if(checkOptionKey( SOK_MPHVAR )){
                epic_error( use_ermes,
                            "%s is not available without the option key.",
                            EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                            STRING_ARG, "Multi-Phase (variable delays)" );
                return FAILURE;
            }
            if( (exist(opfmri) == PSD_ON) && existcv(opfmri) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"fMRI");
                return FAILURE;
            }
            if( (exist(opectricks) == PSD_ON) && existcv(opectricks) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"ECTRICKS");
                return FAILURE;
            }
            if( (exist(opmph) == PSD_ON) && existcv(opmph) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Multi Phase");
                return FAILURE;
            }
            if( (exist(opcgate) == PSD_ON) && existcv(opcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Cardiac Gating");
                return FAILURE;
            }
            if( (exist(oprtcgate) == PSD_ON) && existcv(oprtcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Respiratory Triggering");
                return FAILURE;
            }
            if( (exist(oprealtime) == PSD_ON) && existcv(oprealtime) && (exist(opfluorotrigger) == PSD_OFF) && existcv(opfluorotrigger) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Realtime");
                return FAILURE;
            }
            /* MRIhc08845  08/03/2005 YI */
            if( (exist(opcosmic) == PSD_ON) && existcv(opcosmic) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"COSMIC");
                return FAILURE;
            }
            if( (exist(opswift) == PSD_ON) && existcv(opswift) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"SWIFT");
                return FAILURE;
            }
            if( (exist(opmerge) == PSD_ON) && existcv(opmerge) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"MERGE");
                return FAILURE;
            }
            /* MRIhc09973  09/07/2005 YI */
            if( (exist(opplane) == PSD_3PLANE) && existcv(opplane) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Localizer");
                return FAILURE;
            }
            if( (exist(optensor) > PSD_OFF) && existcv(optensor) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"TENSOR");
                return FAILURE;
            }
            if(NON_VALUE_SYSTEM == value_system_flag){
                if( (2 == exist(opnecho)) && (PSD_3D != exist(opimode)) && 
                    ((PSD_GE == exist(oppseq)) ||
                     (PSD_SPGR == exist(oppseq))) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"FGRE Dual Echo");
                    return FAILURE;
                }
                /* MRIhc09972  09/06/2005 YI */
                if( ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq))) && (exist(opimode) == PSD_2D) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"Fast TOF");
                    return FAILURE;
                }
                if( (exist(opdiffuse) == PSD_ON) && existcv(opdiffuse) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"DWI");
                    return FAILURE;
                }
            }
        } /* End of Dynamic Plan */

        /* HCSDM00323513 */
        if (opslquant*opvquant > SLTAB_MAX)
        {
            avmaxslquant = (int)(SLTAB_MAX/(IMax(2,opvquant,1)));
            epic_error(use_ermes,"Maximum slice quantity is %-d",
                       EM_PSD_SLQUANT_OUT_OF_RANGE, 1, INT_ARG, avmaxslquant);
            return ADVISORY_FAILURE;
        }

        /* Update default values based on the system configuration */
        configSystem();

        /* HCSDM00338330: moved 3DGW enable/disable control from Host.  */
        /* 3DGW is disabled when one of the following conditions is met */
        /* << 2D or Cine imaging mode >>                                */
        /*    - gap / thickness > maxSliceGap2ThickPercent/100          */
        /*    - non-coaxial                                             */
        /*    - multi group                                             */
        /* << 3D imaging mode >>                                        */
        /*    - multi slab                                              */
        if( FALSE == Is3DGWAllowed(0) )
        {
            pi3dgradwarpnub  = _pi3dgradwarpnub.fixedflag ?  ((void)(0), pi3dgradwarpnub) : 0;
            cvdef(pi3dgradwarpnub, 0);
        }

        fov_freq_scale   = _fov_freq_scale.fixedflag ?  ((void)(scan_info[0].opfov_freq_scale), fov_freq_scale) : scan_info[0].opfov_freq_scale;
        fov_phase_scale  = _fov_phase_scale.fixedflag ?  ((void)(scan_info[0].opfov_phase_scale), fov_phase_scale) : scan_info[0].opfov_phase_scale;
        slthick_scale    = _slthick_scale.fixedflag ?  ((void)(scan_info[0].opslthick_scale), slthick_scale) : scan_info[0].opslthick_scale;

    } /* End of code inlined from vmx.e SysParmEval */

    { /* Start of code inlined from Prescan.e PScveval */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScveval                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cveval() must be written here.                     *
         *********************************************************************/

        /* MRIhc49539: check current nucleus against coil DB: */
        n32 psd_nucleus = specnuc;

        if(psd_nucleus != coilInfo[0].rxNucleus)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD", STRING_ARG, "the selected coil");
            return FAILURE; 
        }
         
        TGspf  = _TGspf.fixedflag ?        ((void)(((0==getAps1Mod())&&opspf)), TGspf) : ((0==getAps1Mod())&&opspf);
    	read_axis = TGspf ? YGRAD : XGRAD;
        if(read_axis == XGRAD)
        {
            killer_axis = YGRAD;
        }
        else
        {
            killer_axis = XGRAD;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));
                
        /* set up axis for XTG */
        if(local_tg && oppscvquant > 0)
        {
            tg_read_axis = XGRAD;
            tg_killer_axis = YGRAD;
        }
        else
        {
            tg_read_axis = read_axis;
            tg_killer_axis = killer_axis;
        }

        /* Set flag for minimizing time between XTG Y Killers */
        if ( ( getAps1Mod() == 2 ) && (local_tg == PSD_OFF) )
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_ON), XTG_minimizeYKillerGap) : PSD_ON;
        }
        else
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_OFF), XTG_minimizeYKillerGap) : PSD_OFF;
        }

        /* Set min_ssp */
        min_ssp = IMax( 2, RF_MIN_BLANK, RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH) );

        TGopslthick  = _TGopslthick.fixedflag ?  ((void)(10.0), TGopslthick) : 10.0;

        if((PSD_ON == local_tg) && (oppscvquant >0)) /* use shim vol for TG */
        {
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(psc_info[0].oppsclenx), TGopslthickx) : psc_info[0].oppsclenx;
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(psc_info[0].oppscleny), TGopslthicky) : psc_info[0].oppscleny;
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(psc_info[0].oppsclenz), TGopslthick) : psc_info[0].oppsclenz;


            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMin(2,TGopslthickx,cfsystemmaxfov)), TGopslthickx) : FMin(2,TGopslthickx,cfsystemmaxfov);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMin(2,TGopslthicky,cfsystemmaxfov)), TGopslthicky) : FMin(2,TGopslthicky,cfsystemmaxfov);
            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMin(2,TGopslthick,cfsystemmaxfov)), TGopslthick) : FMin(2,TGopslthick,cfsystemmaxfov);

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,MINFOV_TG)), TGopslthick) : FMax(2,TGopslthick,MINFOV_TG);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }
        else if(PSD_ON == local_tg)
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.8), fov_scaling) : 0.8;
            if(PSD_ON == opfus)
            {
                fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.5), fov_scaling) : 0.5;
            }
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(opslthick*opslquant*fov_scaling), TGopslthick) : opslthick*opslquant*fov_scaling;
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(get_act_freq_fov()*fov_scaling), TGopslthickx) : get_act_freq_fov()*fov_scaling;  /* use scan Rx */
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(get_act_phase_fov()*fov_scaling), TGopslthicky) : get_act_phase_fov()*fov_scaling;  /* use scan Rx */

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,20.0)), TGopslthick) : FMax(2,TGopslthick,20.0);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }

        cal_btw_rf_rba_ssp  = _cal_btw_rf_rba_ssp.fixedflag ?       ((void)(IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk)), cal_btw_rf_rba_ssp) : IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk);
        cal_grd_rf_delays  = _cal_grd_rf_delays.fixedflag ?      ((void)(IMax(2,0,psd_rf_wait-psd_grd_wait)), cal_grd_rf_delays) : IMax(2,0,psd_rf_wait-psd_grd_wait);

        if (psddebugcode)
        {
            psd_dump_coil_info();
        }

        if (FAILURE==PScveval())
        {
            return FAILURE;
        }
        if (FAILURE==FTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==XTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AScveval())
        {
            return FAILURE;
        }
        if (FAILURE==RGcveval())
        {
            return FAILURE;
        }

        if (FAILURE==RScveval())
        {
            return FAILURE;
        }
        if (FAILURE==DTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AutoCoilcveval())
        {
            return FAILURE;
        }
        if (FAILURE==ExtCalcveval())
        {
            return FAILURE;
        }

    } /* End of code inlined from Prescan.e PScveval */


    { /* Start of code inlined from loadrheader.e rheadereval */
        /* HSI addition for 128kHz bandwidth frequency fov truncation */
        /* Added additional check for CERD board to avoid 10% reduction in
           FOV when close to upper bound of filter. - GFN/JAP - 23/Sep/1997 */
        if ( (existcv(oprbw))          &&
             (exist(oprbw) >  60)      &&
             (existcv(psd_board_type)) && 
             (exist(psd_board_type) != PSDCERD) &&
             (exist(psd_board_type) != PSDDVMR) &&
             (exist(oppseq) != PSD_3PLANELOC) ) {
            rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.1), rhfreqscale) : 1.1;
            dfg  = _dfg.fixedflag ?  ((void)(1), dfg) : 1;
            dfscale = 2;
        }
        else { 
            rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.0), rhfreqscale) : 1.0;
            dfg  = _dfg.fixedflag ?  ((void)(2), dfg) : 2;
            dfscale = 1;
        }
    } /* End of code inlined from loadrheader.e rheadereval */

  }

 InitAdvPnlCVs();

#ifdef PSD_HW
 /* MR scanner (hardware): copy scan_info to ks_scan_info, so we can use this data on TGT */
 memcpy(ks_scan_info, scan_info, opslquant*sizeof(SCAN_INFO));
#else
  /* WTools (sim) */
  if (ks_simscan)
    simscan();
#endif

  return SUCCESS;

} /* GEReq_cveval() */


/**
 *******************************************************************************************************
 @brief #### Mandatory APx functions for PSDs from DV26

 DV26 requires getAPxAlgorithm() and getAPxParam() functions to exist in each PSD.
 Empty getAPxAlgorithm() and getAPxParam() functions are declared below in GERequired.e to allow
 compilation on DV26. If a PSD wants to use this new functionality in DV26 it should add the following
 line:
 #define KS_PSD_USE_APX 1
 in its @global section, so that KS_PSD_USE_APX is not set to 0 here, and hence getAPxAlgorithm() and
 getAPxParam() wont be redeclared here in GERequired.e.
********************************************************************************************************/
#if (KS_PSD_USE_APX == 0) && (EPIC_RELEASE >= 26)
void getAPxParam(optval *min,
            optval   *max,
            optdelta *delta,
            optfix   *fix,
            float    coverage,
            int      algorithm) {
    /* Need to be filled when APx is supported in this PSD */
}

int getAPxAlgorithm(optparam *optflag, int *algorithm) {
    return APX_CORE_NONE;
}
#endif



/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of cvcheck()

 In the beginning of `cvcheck()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_cveval();
 if (status != SUCCESS) return status;
 \endcode

 It is important that an error returned from GEReq_cvcheck() also results in an error in `cvcheck()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_cvcheck(void) {

  if (existcv(optr) && optr < avmintr) {
    epic_error(use_ermes, "The minimum TR is %-d ms", EM_PSD_TR_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintr/ 1000));
    return ADVISORY_FAILURE;
  }
  if ((exist(opte) < avminte) && existcv(opte)) {
    epic_error(use_ermes, "The minimum TE is %-d ms", EM_PSD_TE_OUT_OF_RANGE1, 1, INT_ARG, (avminte/ 1000));
    return ADVISORY_FAILURE;
  }
  if ((exist(opte) > avmaxte) && existcv(opte)) {
    epic_error(use_ermes, "The maximum TE is %-d ms", EM_PSD_TE_OUT_OF_RANGE1, 1, INT_ARG, (avmaxte/ 1000));
    return ADVISORY_FAILURE;
  }

  return SUCCESS;

} /* GEReq_cvcheck() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of predownload()

 In the beginning of `predownload()` the following lines should be added:
 \code{.c}
 STATUS status = GEReq_predownload();
 if (status != SUCCESS) return status;
 \endcode

 This function up various global GE stuff related to recon and data filters. Also, `ks_sarcheckdone` is
 checked to make sure that GEReq_eval_checkTR_SAR_calcs() has been called to monitor SAR/heating limits.

 It is important that an error returned from GEReq_predownload() also results in an error in `predownload()`, 
 otherwise it will not show up in the UI.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS GEReq_predownload(void) {

  {
    { /* Start of code inlined from vmx.e PreDownLoad */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e PreDownLoad */

  }

  nex  = _nex.fixedflag ?  ((void)(ceil(opnex)), nex) : ceil(opnex); /* nex is used in rheaderinit instead of opnex, so must set it here. otherwise prescan fails */

  /* UsePgenOnHost() (Imakefile) likes calling calcPulseParams() at this spot, containing "predownload.in" */
  calcPulseParams();

 {
    { /* Start of code inlined from loadrheader.e rheaderinit */

        /*
          rawdata   0=NOREC, 1=NPPROC
          eepf      1 for even echo phase flip
          oepf      1 for odd echo phase flip
          eeff      1 for even echo freq flip
        */

        eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
        eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;

        pinex = nex; /* initialize for pinex so APS can use it */

        if( (nex == 1) || (isOddNexGreaterThanOne) || (isNonIntNexGreaterThanOne) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
        }

        if( opimode == PSD_CINE )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
            if (isOddNexGreaterThanOne || isNonIntNexGreaterThanOne || nex < 2)
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_ON), cine_choplet) : PSD_ON;
            else
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_OFF), cine_choplet) : PSD_OFF;
        }

        if( rhbline )
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
        }
        else
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
        }

        rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        if( (nex > 1) && (opimode != PSD_CINE) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if ( isOddNexGreaterThanOne || isNonIntNexGreaterThanOne )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (opimode == PSD_CINE) && (!cine_choplet) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( opimode == PSD_CINE )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCINE), rhtype) : rhtype+RHTYPCINE;
        }
        if( oppseq == PSD_GE || 
            oppseq == PSD_TOF || oppseq == PSD_TOFSP ||
            oppseq == PSD_PC  || oppseq == PSD_PCSP ||
            oppseq == PSD_3PLANELOC )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPGR), rhtype) : rhtype+RHTYPGR;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.5, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTNEX), rhtype) : rhtype+RHTYPFRACTNEX;
        }
        if( opimode == PSD_3D )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP3D), rhtype) : rhtype+RHTYP3D;
        }
        if( (nop > 1) && (oppomp == PSD_OFF) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPNPW), rhtype) : rhtype+RHTYPNPW;
        }
        if( pitfeextra > 0 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTECHO), rhtype) : rhtype+RHTYPFRACTECHO;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.75, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP75NEX), rhtype) : rhtype+RHTYP75NEX;
        }
        if( oppomp )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPPOMP), rhtype) : rhtype+RHTYPPOMP;
        }

        rhnecho  = _rhnecho.fixedflag ?  ((void)(opnecho), rhnecho) : opnecho;

        if( (opimode == PSD_CINE)
            && ((oppseq == PSD_PC) || (oppseq == PSD_PCSP)) )
        {
            rhnslices  = _rhnslices.fixedflag ?          ((void)(opslquant*(2+2*(exist(opflaxall)==1))), rhnslices) : opslquant*(2+2*(exist(opflaxall)==1));
        }
        else if( opcgate )
        {
            rhnslices  = _rhnslices.fixedflag ?    ((void)(opslquant*opphases), rhnslices) : opslquant*opphases;
        }
        else
        {
            rhnslices  = _rhnslices.fixedflag ?  ((void)(opslquant), rhnslices) : opslquant;
        }

        rhptsize  = _rhptsize.fixedflag ?  ((void)(opptsize), rhptsize) : opptsize;



     rhnavs  = _rhnavs.fixedflag ?      ((void)(IMax(2,(INT)(nex/2),(INT)1)), rhnavs) : IMax(2,(INT)(nex/2),(INT)1);

        rhformat  = _rhformat.fixedflag ?  ((void)(0), rhformat) : 0;
        if (nofermi)
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_FERMI), rhformat) : rhformat|RHF_NO_FERMI;
        }
        else
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_FERMI), rhformat) : rhformat&~RHF_NO_FERMI;
        }

        if (nograd == PSD_OFF) /* use 2d or 3d gradwarp */
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_GRADWARP), rhformat) : rhformat&~RHF_NO_GRADWARP;
            if ((op3dgradwarp == PSD_ON) && (exist(opslquant)>1)) /* do 3d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP13DGRADWARP), rhtype1) : rhtype1|RHTYP13DGRADWARP;
            }
            else   /* do 2d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            }
        }
        else  /* no gradwarp */
        {
            rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_GRADWARP), rhformat) : rhformat|RHF_NO_GRADWARP;
        }
                
            
        if( opimode == PSD_3D )
        {
            if( zchop )
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_ZCHOP), rhformat) : rhformat|RHF_ZCHOP;
            }
            else
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_YCHOP), rhformat) : rhformat|RHF_YCHOP;
            }
        }

        rhapp  = _rhapp.fixedflag ?         
                      ((void)(((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger))), rhapp) : ((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger));

        if( (acq_type == TYPGRAD) && (opimode != PSD_CINE) )
        {
            eeff  = _eeff.fixedflag ?  ((void)(1), eeff) : 1;
        }
        else
        {
            eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        }

        if( (acq_type == TYPSPIN) && (opexor == PSD_OFF) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(1), eepf) : 1;
        }
        else if( (acq_type == TYPSPIN) && (opexor == PSD_ON) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }
        else
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }

        /* set bit0 in rhdacqctrl with rawdata */
        if( rawdata )
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(RHDC_RAWDATA), rhdacqctrl) : rhdacqctrl|RHDC_RAWDATA; 
        }
        else
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~(RHDC_RAWDATA)), rhdacqctrl) : rhdacqctrl&~(RHDC_RAWDATA);
        }

        set_echo_flip(_rhdacqctrl.fixedflag ? (_temp472_rhdacqctrl=rhdacqctrl,&_temp472_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

        rhexecctrl  = _rhexecctrl.fixedflag ?      
                        ((void)(RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter), rhexecctrl) : RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter;

        /* Begin RTIA comment --- RJF */

        /*
          For RTIA, we don't need the images to be routed to TIR.
          Neither do we want them to be displayed in autoview.
          Here is the bit definitions for rhexecctrl.

          RDB_AUTO_DISPLAY               0x0001    1 
          RDB_AUTO_LOCK                  0x0002    2 
          RDB_AUTO_PERM                  0x0004    4 
          RDB_XFER_IM                    0x0008    8 
          RDB_SAVE_IM                    0x0010    16 
          RDB_TAPE_LOCK                  0x0020    32 
          RDB_INTERMEDIATE               0x0040    64 
          RDB_OVERRIDE_BROADCAST         0x0080    128 
          RDB_OVERRIDE_IMG_INSTALL       0x0100    256 
          RDB_OVERRIDE_AUTODISPLAY       0x0200    512 
          RDB_RTD_XFER_IM_REMOTE         0x0400    1024 
          RDB_RTD_SCAN                   0x0800    2048 
          RDB_REF_SCAN                   0x1000    4096 
          RDB_DONT_WRITE_OR_INSTALL      0x2000    8192 
          RDB_RTD_XFER_ALL_IM_PER_PASS   0x4000    16384 
          RDB_XFER_IMG_RIR               0x8000    32768 
        */
        /*  End RTIA comment */

        /* Begin RTIA */

        if( (oprealtime == PSD_ON) || (opfluorotrigger == PSD_ON) )
        { 
            rhexecctrl  = _rhexecctrl.fixedflag ?        ((void)(RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR), rhexecctrl) : RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR; 
            
            if ( (saveinter == PSD_ON) && (track_flag == PSD_ON) )
            { /*for realtime imaging, enable saving intermediate images*/
                rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_INTERMEDIATE), rhexecctrl) : rhexecctrl|RHXC_INTERMEDIATE;
            }

            /* Added for Enabling Autoview for RTIA debug */
#ifdef RTIA_AUTOVIEW_ENABLE
            rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_AUTO_DISPLAY), rhexecctrl) : rhexecctrl|RHXC_AUTO_DISPLAY; 
#endif
        }

        /* MRIge66773 */
        if( opfluorotrigger == PSD_ON )
        {
            rhexecctrl  = _rhexecctrl.fixedflag ?    ((void)(RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)), rhexecctrl) : rhexecctrl|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock);
        }
 
        /* End RTIA */
        rhvquant  = _rhvquant.fixedflag ?  ((void)(opvquant), rhvquant) : opvquant;
        rhslblank  = _rhslblank.fixedflag ?  ((void)(pislblank), rhslblank) : pislblank;
        rhzeroph  = _rhzeroph.fixedflag ?         ((void)((eg_phaseres*nop/2)*(opphasefov)+0.5), rhzeroph) : (eg_phaseres*nop/2)*(opphasefov)+0.5;
        if( pitfeextra > 0 )
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(8), rhnwin) : 8;
        }
        else
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(0), rhnwin) : 0;
        }

        if(pitfeextra > 0)
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(4.0), rhntran) : 4.0;
        }
        else if( floatsAlmostEqualEpsilons(fn, 0.5, 2) && (nop > 1.0) )
        {
            rhntran  = _rhntran.fixedflag ?    ((void)(2.0*nop), rhntran) : 2.0*nop;
        }
        else
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(2.0), rhntran) : 2.0;
        }

        if (APODIZE_STRONG == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(3.0), fermi_w_factor) : 3.0;
        }
        else if (APODIZE_MEDIUM == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }
        else
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(1.0), fermi_r_factor) : 1.0;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }

        if( (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhfermr  = _rhfermr.fixedflag ?        ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor;
        }
        else
        {
            rhfermr  = _rhfermr.fixedflag ?      ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres);
        }
        rhfermw  = _rhfermw.fixedflag ?      ((void)(fermi_wc*fermi_w_factor*(float)10.0), rhfermw) : fermi_wc*fermi_w_factor*(float)10.0;

        /* JAH: MRIge68280 -- need to use this more robust means of defining
           the eccentricity of the fermi filter so the radius in the X and Y
           directions need not be equal or based on data acquisition or
           reconstruction sizes as determined in recon. */
        /* KVA: MRIge73462 Square pixel rhferme addition */

        if( (PSD_ON == opspiral) || (PSD_ON == exist(opsilentmr)) || 
            (PSD_SPECTRO == opimode) || (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhferme  = _rhferme.fixedflag ?  ((void)(1.0), rhferme) : 1.0;
        }
        else if( (PSD_ON == opepi) || (PSD_ON == opsquare) )
        {
            rhferme  = _rhferme.fixedflag ?    ((void)(opxres/(opyres*nop)), rhferme) : opxres/(opyres*nop);
        }
        else
        {
            rhferme  = _rhferme.fixedflag ?      ((void)(opxres/(opyres*opphasefov*nop)), rhferme) : opxres/(opyres*opphasefov*nop);
        }

        rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs), rhnpasses) : acqs;

        rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
        rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

        /* PURE */
        /*MRIge91361 add rhpure for PURE*/
        if (exist(oppurecal))
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE_CAL), rhpure) : PURE_CAL;
        }
        else
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(exist(oppure)), rhpure) : exist(oppure);
        }

        /* Turn on pure mix if PURE_ITKN4 is applied under SCENIC */
        if (PSD_ON == opscenic && SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE2), rhpure) : PURE2;
        }

        /*MRIge93538 set rhpurefilter to 1 as default*/
        rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(1), rhpurefilter) : 1;

        {
            int attribute_result_int = 0;
            float attribute_result_float = 0.0;

            /* PURE 2 */
            if(isDVSystem() && ((B0_15000 == cffield) && (!strncmp("memp_pure", get_psd_name(), 9) || !strncmp("fse_pure", get_psd_name(), 8))))
            {            	
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) || /* Turn on MSK PURE Mix for all products*/ 
                     isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES))
            {		
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else
            {
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(exist(cfpure_filtering_mode)), rhpure_filtering_mode) : exist(cfpure_filtering_mode);
            }
            rhpure_lambda  = _rhpure_lambda.fixedflag ?  ((void)(coilInfo[0].pureLambda), rhpure_lambda) : coilInfo[0].pureLambda;
            rhpure_tuning_factor_surface  = _rhpure_tuning_factor_surface.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorSurface), rhpure_tuning_factor_surface) : coilInfo[0].pureTuningFactorSurface;
            rhpure_tuning_factor_body  = _rhpure_tuning_factor_body.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorBody), rhpure_tuning_factor_body) : coilInfo[0].pureTuningFactorBody;

            /* PURE Blur */
            rhpure_blur_enable  = _rhpure_blur_enable.fixedflag ?        ((void)(getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0), rhpure_blur_enable) : getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0;
            rhpure_blur  = _rhpure_blur.fixedflag ?        ((void)(getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0), rhpure_blur) : getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0;

            /* PURE Mix */
            strcpy(model_parameters.psd_name, get_psd_name());
            model_parameters.flip = exist(opflip);
            model_parameters.slthick = exist(opslthick);
            model_parameters.cffield  = _cffield.fixedflag ?  ((void)(cffield), cffield) : cffield;
            model_parameters.slquant = exist(opslquant);
            model_parameters.irmode = exist(opirmode);
            model_parameters.irprep = exist(opirprep);
            model_parameters.fatsat_flag = exist(opfatcl) || exist(opfat) || exist(opspecir);
            model_parameters.flex_flag = exist(opmedal);
            model_parameters.ideal_flag = exist(opdixon);
            model_parameters.obplane = exist(opobplane);
            model_parameters.plane = exist(opplane);
            model_parameters.tr = exist(optr);
            model_parameters.xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(xtg_volRecCoil), xtg_volRecCoil) : xtg_volRecCoil;
            model_parameters.pure_support = pipure;
            model_parameters.pseq_type = exist(oppseq);
            model_parameters.realtime_flag = exist(oprealtime);
            model_parameters.imode = exist(opimode);
            model_parameters.imsize = rhimsize;
            model_parameters.fov = exist(opfov);
            model_parameters.slzipfactor = exist(opslzip4)? 4 : (exist(opslzip2)? 2 : 1);

            pure_mix.enable = 0;
            pure_mix.tuning_factor_surface = rhpure_tuning_factor_surface;
            pure_mix.tuning_factor_body = rhpure_tuning_factor_body;
            pure_mix.blur_enable = rhpure_blur_enable;
            pure_mix.blur = rhpure_blur;

            /* SCENIC */
            scenic.itkn4.allow = ((cfn4_num_levels_max>0) && cfn4_allowed);
            scenic.itkn4.slice_down_sample_rate = cfn4_slice_down_sample_rate;
            scenic.itkn4.inplane_down_sample_rate = cfn4_inplane_down_sample_rate;
            scenic.itkn4.num_levels_max = cfn4_num_levels_max;
            scenic.itkn4.num_iterations_max = cfn4_num_iterations_max;
            scenic.itkn4.convergence_threshold = cfn4_convergence_threshold;
            scenic.itkn4.gain_clamp_mode = cfn4_gain_clamp_mode;
            scenic.itkn4.gain_clamp_value = cfn4_gain_clamp_value;

            scenic.scic.allow = ((cfscic_focus>0.0) && cfscic_allowed);
            scenic.scic.focus = cfscic_focus;
            scenic.scic.smooth = cfscic_smooth;
            scenic.scic.edge = cfscic_edge;
            scenic.scic.gauss = cfscic_gauss;
            scenic.scic.reduction = cfscic_reduction;
            scenic.scic.threshold = cfscic_threshold;
            scenic.scic.contrast = cfscic_contrast;

            if (B0_30000 == cffield || PSD_PURE_COMPATIBLE_2==pipure) /* 3.0 T platform */
            {
                if (FAILURE == getPUREMixParameters(model_parameters, coilInfo, exist(opanatomy), &pure_mix, _pure_mix_tx_scale.fixedflag ? (_temp473_pure_mix_tx_scale=pure_mix_tx_scale,&_temp473_pure_mix_tx_scale) : &pure_mix_tx_scale))
                {
                    epic_error(use_ermes, "Support routine %s failed.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "getPUREMixParameters");
                    return FAILURE;
                }
            }

            if (pure_mix.enable)
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(pure_mix.lambda), rhpure_mix_lambda) : pure_mix.lambda;
                if ((!strncmp("dwi_pure",model_parameters.psd_name,8) || !strncmp("fsemaster_pure",model_parameters.psd_name,14) ||
                     !strncmp("t1memp_pure",model_parameters.psd_name,11) || !strncmp("2dfast_pure",model_parameters.psd_name,11) ||
                     !strncmp("3dfse_pure",model_parameters.psd_name,10) || !strncmp("3dradial_pure",model_parameters.psd_name,13) ||
                     !strncmp("efgre3d_pure",model_parameters.psd_name,12) || !strncmp("3dtof_pure",model_parameters.psd_name,10) ||
                     !strncmp("csmemp_pure",model_parameters.psd_name,11) || !strncmp("ssfse_pure",model_parameters.psd_name,10) ||
                     !strncmp("epi_pure",model_parameters.psd_name,8) || !strncmp("asl_pure",model_parameters.psd_name,8)) &&
                    (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)) && (isSVSystem()))
                {
                    rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(exist(opuser31)), rhpure_mix_lambda) : exist(opuser31);                
                }
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(pure_mix.tuning_factor_surface), rhpure_mix_tuning_factor_surface) : pure_mix.tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(pure_mix.tuning_factor_body), rhpure_mix_tuning_factor_body) : pure_mix.tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(pure_mix.blur_enable), rhpure_mix_blur_enable) : pure_mix.blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(pure_mix.blur), rhpure_mix_blur) : pure_mix.blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)));
                rhpure_mix_otsu_class_qty  = _rhpure_mix_otsu_class_qty.fixedflag ?  ((void)(pure_mix.otsu_class_qty), rhpure_mix_otsu_class_qty) : pure_mix.otsu_class_qty;
                rhpure_mix_exp_wt  = _rhpure_mix_exp_wt.fixedflag ?  ((void)(pure_mix.exp_wt), rhpure_mix_exp_wt) : pure_mix.exp_wt;
                rhpure_mix_erode_dist  = _rhpure_mix_erode_dist.fixedflag ?  ((void)(pure_mix.erode_dist), rhpure_mix_erode_dist) : pure_mix.erode_dist;
                rhpure_mix_dilate_dist  = _rhpure_mix_dilate_dist.fixedflag ?  ((void)(pure_mix.dilate_dist), rhpure_mix_dilate_dist) : pure_mix.dilate_dist;
                rhpure_mix_aniso_blur  = _rhpure_mix_aniso_blur.fixedflag ?  ((void)(pure_mix.aniso_blur), rhpure_mix_aniso_blur) : pure_mix.aniso_blur;
                rhpure_mix_aniso_erode_dist  = _rhpure_mix_aniso_erode_dist.fixedflag ?  ((void)(pure_mix.aniso_erode_dist), rhpure_mix_aniso_erode_dist) : pure_mix.aniso_erode_dist;
                rhpure_mix_aniso_dilate_dist  = _rhpure_mix_aniso_dilate_dist.fixedflag ?  ((void)(pure_mix.aniso_dilate_dist), rhpure_mix_aniso_dilate_dist) : pure_mix.aniso_dilate_dist;
            }
            else
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(rhpure_lambda), rhpure_mix_lambda) : rhpure_lambda;
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(rhpure_tuning_factor_surface), rhpure_mix_tuning_factor_surface) : rhpure_tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(rhpure_tuning_factor_body), rhpure_mix_tuning_factor_body) : rhpure_tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(rhpure_blur_enable), rhpure_mix_blur_enable) : rhpure_blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(rhpure_blur), rhpure_mix_blur) : rhpure_blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        
                                        
                                           ((void)((isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0), rhpure_mix_alpha) : (isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0;
            }

            /* SCENIC */
            if (FAILURE == getScenicParameters(model_parameters, &scenic))
            {
                epic_error(use_ermes, "Support routine %s failed.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "getScenicParameters");
                return FAILURE;
            }
            rhn4_slice_down_sample_rate    = _rhn4_slice_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.slice_down_sample_rate), rhn4_slice_down_sample_rate) : scenic.itkn4.slice_down_sample_rate;
            rhn4_inplane_down_sample_rate  = _rhn4_inplane_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.inplane_down_sample_rate), rhn4_inplane_down_sample_rate) : scenic.itkn4.inplane_down_sample_rate;
            rhn4_num_levels_max            = _rhn4_num_levels_max.fixedflag ?  ((void)(scenic.itkn4.num_levels_max), rhn4_num_levels_max) : scenic.itkn4.num_levels_max;
            rhn4_num_iterations_max        = _rhn4_num_iterations_max.fixedflag ?  ((void)(scenic.itkn4.num_iterations_max), rhn4_num_iterations_max) : scenic.itkn4.num_iterations_max;
            rhn4_convergence_threshold     = _rhn4_convergence_threshold.fixedflag ?  ((void)(scenic.itkn4.convergence_threshold), rhn4_convergence_threshold) : scenic.itkn4.convergence_threshold;
            rhn4_gain_clamp_mode           = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_mode), rhn4_gain_clamp_mode) : scenic.itkn4.gain_clamp_mode;
            rhn4_gain_clamp_value          = _rhn4_gain_clamp_value.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_value), rhn4_gain_clamp_value) : scenic.itkn4.gain_clamp_value;
    
            rh_ime_scic_enable   = _rh_ime_scic_enable.fixedflag ?    ((void)((scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type)), rh_ime_scic_enable) : (scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type);
            rh_ime_scic_focus    = _rh_ime_scic_focus.fixedflag ?  ((void)(scenic.scic.focus), rh_ime_scic_focus) : scenic.scic.focus;
            rh_ime_scic_smooth   = _rh_ime_scic_smooth.fixedflag ?  ((void)(scenic.scic.smooth), rh_ime_scic_smooth) : scenic.scic.smooth;
            rh_ime_scic_edge     = _rh_ime_scic_edge.fixedflag ?  ((void)(scenic.scic.edge), rh_ime_scic_edge) : scenic.scic.edge;
            rh_ime_scic_gauss    = _rh_ime_scic_gauss.fixedflag ?  ((void)(scenic.scic.gauss), rh_ime_scic_gauss) : scenic.scic.gauss;
            rh_ime_scic_reduction  = _rh_ime_scic_reduction.fixedflag ?  ((void)(scenic.scic.reduction), rh_ime_scic_reduction) : scenic.scic.reduction;
            rh_ime_scic_threshold  = _rh_ime_scic_threshold.fixedflag ?  ((void)(scenic.scic.threshold), rh_ime_scic_threshold) : scenic.scic.threshold;
            rh_ime_scic_contrast   = _rh_ime_scic_contrast.fixedflag ?  ((void)(scenic.scic.contrast), rh_ime_scic_contrast) : scenic.scic.contrast;

            if (PURE2 == exist(oppure) || SCENIC_TYPE_ITKN4_FILTER <= rhscenic_type) 
            {
                /* turn off gain clamp mode when gain_clamp_value is less
                 *              * than 0.5 or bigger than 5.0*/
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?    ((void)((rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f)), rhn4_gain_clamp_mode) : (rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f);
            }
            else
            {
                rhn4_gain_clamp_value  = _rhn4_gain_clamp_value.fixedflag ?  ((void)(5.0f), rhn4_gain_clamp_value) : 5.0f;
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(0), rhn4_gain_clamp_mode) : 0;
            }
            rhpure_gain_clamp_value  = _rhpure_gain_clamp_value.fixedflag ?  ((void)(rhn4_gain_clamp_value), rhpure_gain_clamp_value) : rhn4_gain_clamp_value;
            rhpure_gain_clamp_mode  = _rhpure_gain_clamp_mode.fixedflag ?  ((void)(rhn4_gain_clamp_mode), rhpure_gain_clamp_mode) : rhn4_gain_clamp_mode;        
        }

        if( truenex <= 0 )
        {
            /* PSDs which do not use truenex, as tools, and Spectro,
               will use nex. Truenex is used in Odd Nex NPW cases */
            truenex  = _truenex.fixedflag ?  ((void)(nex), truenex) : nex;
        }

        /* Set NEX for unacquired encodes for when zero-fill BAM is enabled */
        rhnex_unacquired  = _rhnex_unacquired.fixedflag ?  ((void)((int)(ceil(truenex))), rhnex_unacquired) : (int)(ceil(truenex));

        if( opimode==PSD_CINE )
        {
            rhrawsize = (n64)opclocs * (n64)opnecho * (n64)rhfrsize
                * (n64)((oppseq == PSD_PC || oppseq == PSD_PCSP) ?
                        (2 + (opflaxall == 1 ? 2 : 0)) : 1)
                * (n64)(2*rhptsize) * (n64)opcphases
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((float)(1 - rawdata) + (truenex * (float)rawdata)));

        }
        else
        {
            rhrawsize = (n64)slquant1 * (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));

            /*a MRIge91983 - RDP - minimal acquisition size (single coil, single slice, 50 views) */
            if (rotateflag == 2)
            {
                rhrawsize = (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                    * (n64)ceil((float)(1 + (rhbline * rawdata) + 50 + rhhnover)
                                * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));
            }
        }


     if( oppomp )
     {
         if( opxres == 512 )
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(1024), rhrcyres) : 1024;
         }
         else
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(512), rhrcyres) : 512;
         }
     }
     else
     {
         rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
     }

        if( ((exist(opzip512) == PSD_ON) && (existcv(opzip512)) )
            || (exist(opxres) > 256) )
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(512), rhrcxres) : 512;           /* 512 ZIP or standard 512 recon */
        }
        else 
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(256), rhrcxres) : 256;           /* Standard 256 recon */
        }

        rhmethod  = _rhmethod.fixedflag ?  ((void)(oppomp), rhmethod) : oppomp;
        rhdaxres  = _rhdaxres.fixedflag ?  ((void)(opxres), rhdaxres) : opxres;

        rhrcctrl  = _rhrcctrl.fixedflag ?            
                          ((void)(recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG), rhrcctrl) : recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG;
        if( cfcompress < 100 )
        {
            rhrcctrl  = _rhrcctrl.fixedflag ?  ((void)(RHRCCOMP), rhrcctrl) : rhrcctrl+RHRCCOMP;
        }

        if ( opimode==PSD_CINE )
        {
            rhcphases  = _rhcphases.fixedflag ?  ((void)(opcphases), rhcphases) : opcphases;
            /*have to convert this from uSec to Sec */
            rhctr  = _rhctr.fixedflag ?  ((void)((FLOAT)optr/1000000.0), rhctr) : (FLOAT)optr/1000000.0;
            rhcrrtime  = _rhcrrtime.fixedflag ?  ((void)(60.0/(FLOAT)opchrate), rhcrrtime) : 60.0/(FLOAT)opchrate; /* also in Sec */
        }

        /* Support choice of gradient coil for twin gradient coils (Gili) */
        rhgradmode  = _rhgradmode.fixedflag ?  ((void)(opgradmode), rhgradmode) : opgradmode;

        rhte  = _rhte.fixedflag ?  ((void)(opte), rhte) : opte;
        rhte2  = _rhte2.fixedflag ?  ((void)(opte2), rhte2) : opte2;
        
        rhscancent  = _rhscancent.fixedflag ?  ((void)(piscancenter), rhscancent) : piscancenter;
       
        if(PSD_MINTE == exist(opautote))
        {
          /* EPI - MinTE with ramp sampling will be a problem hence not supported
             SSFSE - MinTE but full acquisition is done , disabled temporarily */
          if((PSD_ON == exist(opepi)) || (PSD_ON == exist(opssfse)) || (PSD_ON == exist(opspiral)))
            rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
          else if((PSD_3D == exist(opimode)) && (PSD_ON == exist(opdixon)))
            rhfeextra  = _rhfeextra.fixedflag ?       ((void)((int)((fnecho_lim-0.5)*rhfrsize+0.5)), rhfeextra) : (int)((fnecho_lim-0.5)*rhfrsize+0.5);
          else
           rhfeextra  = _rhfeextra.fixedflag ?    ((void)(rhfrsize-exist(opxres)/2), rhfeextra) : rhfrsize-exist(opxres)/2;
        }
        else
        {
          rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
        }

        rh3dgw_interptype  = _rh3dgw_interptype.fixedflag ?  ((void)(RH3DGW_BICUBIC_INTERP), rh3dgw_interptype) : RH3DGW_BICUBIC_INTERP; 

    } /* End of code inlined from loadrheader.e rheaderinit */

{ /* Start of code inlined from Prescan.e PSfilter */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                            PSfilter                               *
     *                                                                   *
     * Write here the code unique to the Host PSD process.               *
     *********************************************************************/
    /* PS filter must be called with no arguments. num_filter_slot 
       is a CV which comes from individual PSDs, which get incremented 
       in the PSD so that Prescan filter generation takes place for 
       the next slot in psd_filter_spec. - RJF 13/Oct/1998 */
    /* vmx 10/13/94 YI */
    PSfilter();
    /* end vmx */

    if(psddebugcode)
    {
        dump_runtime_filter_info(psd_filt_spec);
    }
} /* End of code inlined from Prescan.e PSfilter */

  }

  /* Set rhkacq_uid for ARC support and linking plots */
  int uid;
  struct tm now;
  time_t now_epoch = time(NULL);
  /* Generate unique ID for this scan for naming kacq files and
     debug files.  Use the current date and time (MMDDHHMMSS).
     Cannot include the year because this is larger than a
     signed 32-bit integer */
  localtime_r(&now_epoch, &now);
  uid = now.tm_sec +
        now.tm_min  * 100 +
        now.tm_hour * 10000 +
        now.tm_mday * 1000000 +
        (now.tm_mon + 1) * 100000000;
  rhkacq_uid  = _rhkacq_uid.fixedflag ?  ((void)(uid), rhkacq_uid) : uid;


 /* Check that SAR calculations have been performed */
  if (ks_sarcheckdone != TRUE) {
#ifdef SIM
    if (existcv(optr) == TRUE && existcv(opte) == TRUE && existcv(opslquant) == TRUE) {
      /* In simulation (WTools), predownload is called every time a CV is changed but
      ks_sarcheckdone will not be set to TRUE in GEReq_eval_checkTR_SAR_calcs() unless
      optr, opte and opslquant have all been set (existcv() != FALSE). Hence, in simulation,
      we cannot throw an error before these have been set */
      return ks_error("%s: Missing call to GEReq_eval_checkTR_SAR()", __FUNCTION__);
    }
#else
    return ks_error("%s: Missing call to GEReq_eval_checkTR_SAR()", __FUNCTION__);
#endif
  }

 return SUCCESS;

} /* GEReq_predownload() */




#ifndef sys_psdiopt_h
#define sys_psdiopt_h
#include "psdIF.h"
#include "psdiopt.h"
#endif
#ifndef _SYSCHECK_
#define _SYSCHECK_
STATUS syscheck(INT *p_syscheck_limit, int *p_status_flag)
{
    /* Variables to hold the minseq  values. These are local to syscheck*/
    INT syscheck_min_seqgrad = 0;
    INT syscheck_min_seqrfamp = 0; 

    /* Flag to turn on or off syscheck logging */
    int syschecklog_on = 0;

    /* The file pointer to enable or disable RF check with the help of a file*/
    FILE *fp_rfon;
    FILE *fp_syschecklog_on;

    int iopt_num=0;/* Imaging option Num*/

    char im_opt_name[128];/* Imaging option String*/
    char logValues[1024];

    INT seq_entry_index = 0;

    char path[128] = "/usr/g/service/log/";
    char filename[64] = "psd_syscheck_error.log";
    char macro_name[32];
    float tolerance_percentage = 0.0;
    const int TOLERANCE_LIMIT = 5;
    int syscheck_limit = 0;
    float syscheck_limit_tolerance = 0.0;
    int debug_syscheck;
    debug_syscheck = (getenv("DEBUG_SYSCHECK")!='\0');

if(debug_syscheck){
        printf(" Calling minseq from macro\n");
        fflush(stdout);
        }
    strcpy(macro_name,"SYSCHECK_MINSEQ_PGOH");
    if (FAILURE == minseq(&syscheck_min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seq_entry_index, tsamp,
                                avail_image_time,
                                use_ermes, seg_debug ) )
             {
        log_error(path,filename,1,"%s %d %d  %d","Minseq failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        if(debug_syscheck){
            printf(" Minseq failed in syscheck \n");
            fflush(stdout);
        }
        *p_status_flag=1;
    }
    else
    {
        if(debug_syscheck){
            printf("minseq completed successfully with values\n syscheck_min_seqgrad : %d\n",syscheck_min_seqgrad);
            fflush(stdout);
        }
    }
    /****** To include Rf calculation based on the choice made ****/

    fp_rfon = fopen("/usr/g/bin/.RFCHECKON","r");
    if(fp_rfon !=NULL)
    {
       if(debug_syscheck){
           printf("Calling minseqrfamp from macro\n");
           fflush(stdout);
       }
       if(minseqrfamp(&syscheck_min_seqrfamp,(int)RF_FREE,rfpulse,L_SCAN) == FAILURE)
         {
             log_error(path,filename,1,"%s \n file:%s line:%d Error no:%d","Minseqrfamp failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
             if(debug_syscheck){
                 printf(" Minseqrfamp failed in syscheck\n");
                 fflush(stdout);
             }
             *p_status_flag= 1;
         }
         else
         {
            if(debug_syscheck){
                printf("Completed minseqrfamp successfully with syscheck_min_seqrfamp %d\n",syscheck_min_seqrfamp);
                fflush(stdout);
            }
        }
    }

    /** to check for the environment variable whether logging has to be done or not ***/

    fp_syschecklog_on = fopen("/usr/g/bin/.SYSCHECKLOGON","r");
    syschecklog_on =((getenv("SYSCHECKLOGON")!='\0') || (fp_syschecklog_on!=NULL));
    /*** if RF check is on include the min_seqrfamp for syscheck_safety_limit and for comparison with optr ***/

        if(fp_rfon !=NULL)
        {
            if(debug_syscheck){
                printf("\nRF included");
                fflush(stdout);
            }
            syscheck_limit = IMax(2,syscheck_min_seqgrad,syscheck_min_seqrfamp);
        }
        else
        {
           if(debug_syscheck){
               printf("\nRf calculation not included");
               fflush(stdout);
           }
           syscheck_limit = syscheck_min_seqgrad;
        }
        if (9000 == cfgradamp) 
           syscheck_limit = syscheck_min_seqrfamp; 
        /*** Calculate the tolerance percentage to allow a maximum of 5% tolerance before comparision***/
        tolerance_percentage = 1-(TOLERANCE_LIMIT * 0.01);
        if(psd_tol_value!=0){
            if((((oppseq == PSD_GE) || (oppseq == PSD_SPGR) || (oppseq == PSD_TOF) || (oppseq == PSD_TOFSP) || (oppseq == PSD_SSFP)) &&
                (opfast == PSD_ON) && (opimode == PSD_3D) && ((opirprep == PSD_ON) || ((opgirmode == PSD_GIRMANUAL) && (opnumgir > 0)))) ||
               (((oppseq == PSD_GE) || (oppseq == PSD_SPGR)) && (opimode == PSD_2D) && (oprealtime == PSD_ON) && (opfast == PSD_ON))){
                if(debug_syscheck){
                    printf("Special case for syscheck considered");
                    printf(" VALUE OF PSD_TOL_VALUE = %d",psd_tol_value);
                    fflush(stdout);
                }
            }
            else{
                if(debug_syscheck){
                    printf("Not allowing a tolerance.Not a  special cases");
                }
                cvoverride(psd_tol_value,0,PSD_FIX_ON,PSD_EXIST_ON);
           }
        }
        syscheck_limit_tolerance = (syscheck_limit * tolerance_percentage) - psd_tol_value;
        *p_syscheck_limit = (int)(syscheck_limit_tolerance);
        /*** Compare the optr with the minseq values if found less than max of minseq values,log an error ***/
        /*** MRIhc37381: Bypass the optr check for Phase Contrast to avoid the download failure ***/
        /*** MRIhc42193: remove the code added by MRIhc37381, enable syscheck for Phase Contrast ***/
        if( (exist(optr)) < (*p_syscheck_limit) || (optr) < (*p_syscheck_limit ) )
        {
            log_error(path,filename,1,"%s \nfile:%s line:%d","ERROR : PSD SAFETY CHECK ERROR!!! ILLEGAL OPTR DETECTED IN SYSCHECK!!!",__FILE__,__LINE__);
            *p_status_flag = 2;
            if(debug_syscheck){
                printf("Illegal optr  value found %d\n",exist(optr));
                fflush(stdout);
            }
        }
        else
        {
            /**** Log a positive message for no error case *****/
            log_error(path,filename,1,"%s", "SAFETY CHECK RAN SUCCESSFULLY!OPTR VALUES FOUND SAFE!");
            *p_status_flag = 0;
        }
        if(((*p_status_flag ==0) && (syschecklog_on)) || (*p_status_flag ==2))
        {
            sprintf(logValues,"\noptr : %d\ntmin : %d\t\ttmin_total : %d\nmin_seqgrad : %d\tsyscheck_min_seqgrad : %d\nsyscheck_safety_limit : %d",exist(optr),tmin,tmin_total,min_seqgrad,syscheck_min_seqgrad,*p_syscheck_limit);
            log_error(path,filename,0,"%s %s","Values found:",logValues);
            if(fp_rfon!=NULL)
            {
                sprintf(logValues,"min_seqrfamp : %d\t syscheck_min_seqrfamp : %d\n",min_seqrfamp,syscheck_min_seqrfamp);
                log_error(path,filename,0,"%s",logValues);
            }
        }
            /************** Log the PSD name & IOPT selected *****/
            log_error(path,filename,0,"%s %s ","PSD:",get_psd_name());
            for(iopt_num = 0;iopt_num < PSD_NUM_IOPTS; iopt_num++){
                if(is_iopt_selected(iopt_num)){
                return_iopt_name(iopt_num,im_opt_name);
                log_error(path,filename,0,"%s %s","Imaging Option :",im_opt_name);
            }
        }

    log_error(path,filename,0,"%s",macro_name);
    if((*p_status_flag) != 0)
    {
        return FAILURE;
    }
    else
    {
        return SUCCESS;
    }
}
#endif
/***************************************************************/

/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  GERequired.e: PULSEGEN functions
 *                Accessible on TGT, and also HOST if UsePgenOnHost() in the Imakefile
 *
 *******************************************************************************************************
 *******************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

#include "addrfbits.h"
#include "rfsspsummary.h"

int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short dyntg_txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1  = _temp_res_rf2mps1.fixedflag ?  ((void)(res_rf2mps1), temp_res_rf2mps1) : res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(rfpulseInfo[RF2_APS1_SLOT].newres), res_rf2mps1) : rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(temp_res_rf2mps1), res_rf2mps1) : temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl  = _temp_res_rf1cfl.fixedflag ?  ((void)(res_rf1cfl), temp_res_rf1cfl) : res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(rfpulseInfo[RF1_CFL_SLOT].newres), res_rf1cfl) : rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cflloggrd.zbeta), pg_beta) : cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(temp_res_rf1cfl), res_rf1cfl) : temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


        if(3 == rcvn_flag)   /* Additional gradient waveform for Grad prognostic */
        {
            long ctrl_word;

               
  {
    pulsename(&grd_trig,"grd_trig");
    createconst(&grd_trig,(WF_PROCESSOR)wg_grd_trig,pw_grd_trig,(short)0); 
    createinstr( &grd_trig,(long)(posstart),pw_grd_trig,0);
  }

            getctrl(&ctrl_word, &grd_trig, 0);
            ctrl_word = ctrl_word | PSD_GRADR_SYNC;
            setctrl(ctrl_word, &grd_trig, 0);
            posstart = RUP_GRD(pendallssp(&grd_trig, 0)); 

            postemp = RUP_GRD(pend(&gxkrcvnd,"gxkrcvnd",0) + pw_gxk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gxk2rcvn, "gxk2rcvn", &gxk2rcvn, &gxk2rcvna,
                        &gxk2rcvnd, pw_gxk2rcvn, pw_gxk2rcvna, pw_gxk2rcvnd,
                        ia_gxk2rcvn, 0, 0, 0, 0, postemp-pw_gxk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gykrcvnd,"gykrcvnd",0) + pw_gyk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gyk2rcvn, "gyk2rcvn", &gyk2rcvn, &gyk2rcvna,
                        &gyk2rcvnd, pw_gyk2rcvn, pw_gyk2rcvna, pw_gyk2rcvnd,
                        ia_gyk2rcvn, 0, 0, 0, 0, postemp-pw_gyk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gzkrcvnd,"gzkrcvnd",0) + pw_gzk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gzk2rcvn, "gzk2rcvn", &gzk2rcvn, &gzk2rcvna,
                        &gzk2rcvnd, pw_gzk2rcvn, pw_gzk2rcvna, pw_gzk2rcvnd,
                        ia_gzk2rcvn, 0, 0, 0, 0, postemp-pw_gzk2rcvna, TRAP_ALL,
                        &rcvnloggrd);

        }
    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);

                movestretchedwave( grad_zrf0cfh, res_gzrf0cfh,
                                   &gzrf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(1.0), cyc_rf0cfh) : 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

            movestretchedwave( rf_rf0cfh, res_rf0cfh,
                               &rf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {
        INT old_res =  res_omegarf0cfh; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0cfh  = _n_omegarf0cfh.fixedflag ?  ((void)(1), n_omegarf0cfh) : n_omegarf0cfh+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

                movestretchedwave( fileloc_omegarf0cfh, old_res,
                                   &omegarf0cfh, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(new_res), res_omegarf0cfh) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(old_res), res_omegarf0cfh) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh  = _temp_res_rf1cfh.fixedflag ?  ((void)(res_rf1cfh), temp_res_rf1cfh) : res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(rfpulseInfo[RF1_CFH_SLOT].newres), res_rf1cfh) : rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(temp_res_rf1cfh), res_rf1cfh) : temp_res_rf1cfh;
  }


    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (int)(0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                       + IMax(2, min_ssp,
                              (pw_gzrf1cfhd + pw_gzrf2lcfha
                               + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                       + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                       + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                            + IMax(2, min_ssp,
                                   (pw_gzrf1cfhd + pw_gzrf2lcfha
                                    + pw_gzrf2lcfh + pw_gzrf2lcfhd)));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                                 IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                                 + presscfh_wait_rf12);

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = (int)(0.5 * pw_rf3cfh
                                    + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                                    + presscfh_wait_rf23);
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = (int)(0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                                    + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                                    + presscfh_wait_rf34);

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh  = _res_rf2cfh.fixedflag ?  ((void)(rfpulseInfo[RF2_CFH_SLOT].newres), res_rf2cfh) : rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


      
  {
    pulsename(&seqcfhwait,"seqcfhwait");
    createseq(&seqcfhwait,wait_time_before_cfh, off_seqcfhwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfhwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfhwait = %d\n", idx_seqcfhwait );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr  = _csw_tr.fixedflag ?          
           ((void)(15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi), csw_tr) : 15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr  = _csw_tr.fixedflag ?  ((void)(RUP_GRD(1000)), csw_tr) : RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg  = _temp_res_rf1ftg.fixedflag ?  ((void)(res_rf1ftg), temp_res_rf1ftg) : res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(rfpulseInfo[RF1_FTG_SLOT].newres), res_rf1ftg) : rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(temp_res_rf1ftg), res_rf1ftg) : temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg  = _temp_res_rf2ftg.fixedflag ?  ((void)(res_rf2ftg), temp_res_rf2ftg) : res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(rfpulseInfo[RF2_FTG_SLOT].newres), res_rf2ftg) : rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(temp_res_rf2ftg), res_rf2ftg) : temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg  = _temp_res_rf3ftg.fixedflag ?  ((void)(res_rf3ftg), temp_res_rf3ftg) : res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(rfpulseInfo[RF3_FTG_SLOT].newres), res_rf3ftg) : rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(temp_res_rf3ftg), res_rf3ftg) : temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGyKXTG;          /* Y Killer pulse location          */
    INT PosOffResXTG;       /* Off resonance pulse location     */
    INT PosGzDephaserXTG;   /* Slice dephaser location          */
    INT PosGzRephaserXTG;   /* Slice rephaser location          */
    INT PosReadoutWindow;   /* Readout window location          */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

    }

    /* Set timing for YKillerL */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerL at same time as ZDephaser */
        PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                            pw_rf2xtg/2 - IMax(2, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld,
                            pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga) + pw_gykxtgla);
    }
    else
    {
        /* Apply YKillerL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gyrf1xtgd + pw_gykxtgla);
        }
        else
        {
            /* RF1 + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gykxtgla);
        }
    }
    /* Create YKillerL */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiL, accounting for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gyrf1xtgd));
        }
        else
        {
            /* RF1 + GzRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gzrf1xtgd));
        }
    }
    else
    {
        /* Apply FermiL after YKillerL */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf1xtg,"rf1xtg",0) + min_ssp, pendall(&gykxtgl,0)));
    }
    /* Create FermiL */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    /* theta1 Slice Dephaser */
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzDephaserXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                               pw_rf2xtg/2 - pw_gzrf2xtga - pw_gz1xtgd - pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGzDephaserXTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* rf2xtg Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 - pw_rf2xtg/2);
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg  = _temp_res_rf2xtg.fixedflag ?  ((void)(res_rf2xtg), temp_res_rf2xtg) : res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(rfpulseInfo[RF2_XTG_SLOT].newres), res_rf2xtg) : rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(temp_res_rf2xtg), res_rf2xtg) : temp_res_rf2xtg;
  }


    /* theta2 Slice Rephaser */ 
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzRephaserXTG = pendall(&gzrf2xtg, 0) + pw_gz2xtga;
           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGzRephaserXTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiR, account for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiR after both ZRephaser and YKillerR */
        PosOffResXTG = RUP_GRD(pendall(&gzrf2xtg,0) - pw_gzrf2xtgd +
                               IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd,
                                                     pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd)));
    }
    else
    {
        /* Apply FermiR after ZRephaser */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf2xtg,"rf2xtg",0) + min_ssp, pendall(&gz2xtg,0)));
    }
    /* Create FermiR */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    /* Set timing for YKillerR */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerR after GzRF2 */
        PosGyKXTG = pendall(&gzrf2xtg,0) + pw_gykxtgra;
    }
    else
    {
        /* Apply YKillerR after FermiR */
        PosGyKXTG = RUP_GRD(pendall(&rf4xtg,0) + pw_gykxtgra);
    }
    /* Create YKillerR */
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout dephaser */
    postemp = RUP_GRD(pendall(&rf2xtg,0) - pw_rf2xtg/2 + XTGtau1 - 
                      pw_gxw1xtg/2-pw_gxw1xtga - pw_gx1bxtgd - pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout window */
    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 +
                                   2*XTGtau1 - pw_gxw1xtg/2));
    /* HD--Error Check For Gradient Overlap. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga))
    {
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }
           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0))); /* Update PosReadoutWindow to final value */
         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);
     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as  = _temp_res_rf1as.fixedflag ?  ((void)(res_rf1as), temp_res_rf1as) : res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(rfpulseInfo[RF1_AUTOSHIM].newres), res_rf1as) : rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(asloggrd.zbeta), pg_beta) : asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(temp_res_rf1as), res_rf1as) : temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    disableRfSspControl();
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }

    enableRfSspControl();

        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(PSTR_PASS), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay  = _DD_delay.fixedflag ?  ((void)(2000), DD_delay) : 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(temp_res), res_rf1rs) : temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbrs; /* temp holder for old pulse resolution */

    if ( (wg_rfbrs != TYPRHO1)  && (wg_rfbrs != TYPRHO2) &&
         (wg_rfbrs != TYPTHETA) && (wg_rfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbrs  = _n_rfbrs.fixedflag ?  ((void)(1), n_rfbrs) : n_rfbrs+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbrs,"rfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbrs, (WF_PROCESSOR)wg_rfbrs, new_res);

                movestretchedwave( fileloc_rfbrs, old_res,
                                   &rfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(new_res), res_rfbrs) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
                          old_res,fileloc_rfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbrs,ia_rfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbrs,off_rfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbrs);
    

    /*** Reset Resolution ***/
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(old_res), res_rfbrs) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbrs; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbrs != TYPRHO1)  && (wg_thetarfbrs != TYPRHO2) &&
         (wg_thetarfbrs != TYPTHETA) && (wg_thetarfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbrs  = _n_thetarfbrs.fixedflag ?  ((void)(1), n_thetarfbrs) : n_thetarfbrs+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbrs,"thetarfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbrs, (WF_PROCESSOR)wg_thetarfbrs, new_res);

                movestretchedwave( fileloc_thetarfbrs, old_res,
                                   &thetarfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(new_res), res_thetarfbrs) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
                          old_res,fileloc_thetarfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbrs,ia_thetarfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbrs,off_thetarfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbrs);
    

    /*** Reset Resolution ***/
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(old_res), res_thetarfbrs) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbrs, &rfbrs, 0);
    setiamp(ia_thetarfbrs, &thetarfbrs, 0);

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(temp_res), res_rf1dtg) : temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_rfbdtg != TYPRHO1)  && (wg_rfbdtg != TYPRHO2) &&
         (wg_rfbdtg != TYPTHETA) && (wg_rfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbdtg  = _n_rfbdtg.fixedflag ?  ((void)(1), n_rfbdtg) : n_rfbdtg+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbdtg,"rfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbdtg, (WF_PROCESSOR)wg_rfbdtg, new_res);

                movestretchedwave( fileloc_rfbdtg, old_res,
                                   &rfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(new_res), res_rfbdtg) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
                          old_res,fileloc_rfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbdtg,ia_rfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbdtg,off_rfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbdtg);
    

    /*** Reset Resolution ***/
    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(old_res), res_rfbdtg) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbdtg != TYPRHO1)  && (wg_thetarfbdtg != TYPRHO2) &&
         (wg_thetarfbdtg != TYPTHETA) && (wg_thetarfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbdtg  = _n_thetarfbdtg.fixedflag ?  ((void)(1), n_thetarfbdtg) : n_thetarfbdtg+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbdtg,"thetarfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbdtg, (WF_PROCESSOR)wg_thetarfbdtg, new_res);

                movestretchedwave( fileloc_thetarfbdtg, old_res,
                                   &thetarfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(new_res), res_thetarfbdtg) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
                          old_res,fileloc_thetarfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbdtg,ia_thetarfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbdtg,off_thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbdtg);
    

    /*** Reset Resolution ***/
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(old_res), res_thetarfbdtg) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbdtg, &rfbdtg, 0);
    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}



/*
 *  ExtCalpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcalwa  = _ia_gzcombcalwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzcombcalwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcalwb  = _ia_gzcombcalwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzcombcalwb) : max_pg_wamp;

    ia_gzprcalwa  = _ia_gzprcalwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzprcalwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcalwb  = _ia_gzprcalwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzprcalwb) : max_pg_wamp;

    /* selective RF1 */
    PosStart = td0cal + pw_gzrf1cala;

         
               
  {
        INT old_res =  res_rf1cal; /* temp holder for old pulse resolution */

    if ( (wg_rf1cal != TYPRHO1)  && (wg_rf1cal != TYPRHO2) &&
         (wg_rf1cal != TYPTHETA) && (wg_rf1cal != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1cal  = _n_rf1cal.fixedflag ?  ((void)(1), n_rf1cal) : n_rf1cal+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1cal.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1cal,"rf1cal");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1cal].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1cal].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1cal, (WF_PROCESSOR)wg_rf1cal, new_res);

                movestretchedwave( fileloc_rf1cal, old_res,
                                   &rf1cal, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(new_res), res_rf1cal) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1cal,(WF_PROCESSOR)wg_rf1cal,
                          old_res,fileloc_rf1cal);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1cal,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1cal,ia_rf1cal);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1cal,off_rf1cal,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1cal);
    

    /*** Reset Resolution ***/
    res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(old_res), res_rf1cal) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1cal, &rf1cal, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1cal, "gzrf1cal", &gzrf1cal, &gzrf1cala,
                        &gzrf1cald, pw_gzrf1cal, pw_gzrf1cala, pw_gzrf1cald,
                        ia_gzrf1cal, 0, 0, 0, 0, pbeg(&rf1cal,"rf1cal",0)-psd_rf_wait-pw_gzrf1cala, TRAP_ALL,
                        &calloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) + pw_gzrf1cald);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcal_mem[res_gzcombcal];
        s16 gzcombcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp474_pg_beta=pg_beta,&_temp474_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcombcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcalf != 0))
        {
            uramp( (&gzcombcal_mem[gzcombcal_indx]),
                   (pw_gzcombcalf/per_gzcombcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcal_indx = ( pw_gzcombcalf/ per_gzcombcal );
            gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcala/per_gzcombcal),
               (short) 0, ia_gzcombcalwa , pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcalf)/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcal_mem[gzcombcal_indx]),
              (pw_gzcombcal/per_gzcombcal),
              ia_gzcombcalwa, ia_gzcombcalwb, pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcal + pw_gzcombcalf )/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcald/per_gzcombcal),
               ia_gzcombcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcal, "gzcombcal" );
        createreserve( &gzcombcal, (WF_PROCESSOR)wg_gzcombcal, res_gzcombcal );
        createinstr( &gzcombcal,(LONG)(PosTemp+pw_gzcombcala-pw_gzcombcala - 
                                         pw_gzcombcalf),
                     (pw_gzcombcalf + pw_gzcombcala + 
                      pw_gzcombcal + pw_gzcombcald), 
                     ia_gzcombcal );
        /* Move user pulse into waveform mem */
        gzcombcal_mem[res_gzcombcal-1] |= WEOS_BIT;  
        movewaveimm(gzcombcal_mem, &gzcombcal, 
                    (int)0, res_gzcombcal, TOHARDWARE);
        if ((wg_gzcombcal==TYPRHO1)||(wg_gzcombcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcal,0,(LONG)(PosTemp+pw_gzcombcala),
                      (pw_gzcombcala + pw_gzcombcal + pw_gzcombcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcal, "gzcombcal",
                   &gzcombcal, &gzcombcala, &gzcombcald,
                   pw_gzcombcal, pw_gzcombcala, pw_gzcombcald,
                   ia_gzcombcal, ia_gzcombcalwa, ia_gzcombcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcala - pw_gzcombcala - pw_gzcombcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal + tacq_cal/2 + pw_gzprcala);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcal_mem[res_gzprcal];
        s16 gzprcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp475_pg_beta=pg_beta,&_temp475_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzprcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcalf != 0))
        {
            uramp( (&gzprcal_mem[gzprcal_indx]),
                   (pw_gzprcalf/per_gzprcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcal_indx = ( pw_gzprcalf/ per_gzprcal );
            gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcala/per_gzprcal),
               (short) 0, ia_gzprcalwa , pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcalf)/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcal_mem[gzprcal_indx]),
              (pw_gzprcal/per_gzprcal),
              ia_gzprcalwa, ia_gzprcalwb, pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcal + pw_gzprcalf )/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcald/per_gzprcal),
               ia_gzprcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcal, "gzprcal" );
        createreserve( &gzprcal, (WF_PROCESSOR)wg_gzprcal, res_gzprcal );
        createinstr( &gzprcal,(LONG)(PosTemp-pw_gzprcala - 
                                         pw_gzprcalf),
                     (pw_gzprcalf + pw_gzprcala + 
                      pw_gzprcal + pw_gzprcald), 
                     ia_gzprcal );
        /* Move user pulse into waveform mem */
        gzprcal_mem[res_gzprcal-1] |= WEOS_BIT;  
        movewaveimm(gzprcal_mem, &gzprcal, 
                    (int)0, res_gzprcal, TOHARDWARE);
        if ((wg_gzprcal==TYPRHO1)||(wg_gzprcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcal,0,(LONG)(PosTemp),
                      (pw_gzprcala + pw_gzprcal + pw_gzprcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcal, "gzprcal",
                   &gzprcal, &gzprcala, &gzprcald,
                   pw_gzprcal, pw_gzprcala, pw_gzprcald,
                   ia_gzprcal, ia_gzprcalwa, ia_gzprcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcala - pw_gzprcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal - tacq_cal/2); /* from TE */
         

  trapezoid((WF_PROCESSOR)wg_gxwcal, "gxwcal", &gxwcal, &gxwcala,
                        &gxwcald, pw_gxwcal, pw_gxwcala, pw_gxwcald,
                        ia_gxwcal, 0, 0, 0, 0, PosTemp-pw_gxwcala, TRAP_ALL,
                        &calloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1cal,"echo1cal");
    acqq(&echo1cal, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1cal,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcal,"d3dcal");
    create3dim(&d3dcal,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcal, 0) - (pw_gx1cal + pw_gx1cald));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1cal_mem[res_gx1cal];
        s16 gx1cal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp476_pg_beta=pg_beta,&_temp476_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gx1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1calf != 0))
        {
            uramp( (&gx1cal_mem[gx1cal_indx]),
                   (pw_gx1calf/per_gx1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1cal_indx = ( pw_gx1calf/ per_gx1cal );
            gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cala/per_gx1cal),
               (short) 0, ia_gx1calwa , pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1calf)/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1cal_mem[gx1cal_indx]),
              (pw_gx1cal/per_gx1cal),
              ia_gx1calwa, ia_gx1calwb, pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1cal + pw_gx1calf )/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cald/per_gx1cal),
               ia_gx1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1cal, "gx1cal" );
        createreserve( &gx1cal, (WF_PROCESSOR)wg_gx1cal, res_gx1cal );
        createinstr( &gx1cal,(LONG)(PosTemp-pw_gx1cala - 
                                         pw_gx1calf),
                     (pw_gx1calf + pw_gx1cala + 
                      pw_gx1cal + pw_gx1cald), 
                     ia_gx1cal );
        /* Move user pulse into waveform mem */
        gx1cal_mem[res_gx1cal-1] |= WEOS_BIT;  
        movewaveimm(gx1cal_mem, &gx1cal, 
                    (int)0, res_gx1cal, TOHARDWARE);
        if ((wg_gx1cal==TYPRHO1)||(wg_gx1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1cal,0,(LONG)(PosTemp),
                      (pw_gx1cala + pw_gx1cal + pw_gx1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1cal, "gx1cal",
                   &gx1cal, &gx1cala, &gx1cald,
                   pw_gx1cal, pw_gx1cala, pw_gx1cald,
                   ia_gx1cal, ia_gx1calwa, ia_gx1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1cala - pw_gx1calf),
                   TRAP_ALL, &calloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1cal,"gzrf1cal",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1cal_mem[res_gy1cal];
        s16 gy1cal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp477_pg_beta=pg_beta,&_temp477_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1calf != 0))
        {
            uramp( (&gy1cal_mem[gy1cal_indx]),
                   (pw_gy1calf/per_gy1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1cal_indx = ( pw_gy1calf/ per_gy1cal );
            gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cala/per_gy1cal),
               (short) 0, ia_gy1calwa , pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1calf)/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1cal_mem[gy1cal_indx]),
              (pw_gy1cal/per_gy1cal),
              ia_gy1calwa, ia_gy1calwb, pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1cal + pw_gy1calf )/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cald/per_gy1cal),
               ia_gy1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1cal, "gy1cal" );
        createreserve( &gy1cal, (WF_PROCESSOR)wg_gy1cal, res_gy1cal );
        createinstr( &gy1cal,(LONG)(PosTemp+pw_gy1cala-pw_gy1cala - 
                                         pw_gy1calf),
                     (pw_gy1calf + pw_gy1cala + 
                      pw_gy1cal + pw_gy1cald), 
                     ia_gy1cal );
        /* Move user pulse into waveform mem */
        gy1cal_mem[res_gy1cal-1] |= WEOS_BIT;  
        movewaveimm(gy1cal_mem, &gy1cal, 
                    (int)0, res_gy1cal, TOHARDWARE);
        if ((wg_gy1cal==TYPRHO1)||(wg_gy1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1cal,0,(LONG)(PosTemp+pw_gy1cala),
                      (pw_gy1cala + pw_gy1cal + pw_gy1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1cal, "gy1cal",
                   &gy1cal, &gy1cala, &gy1cald,
                   pw_gy1cal, pw_gy1cala, pw_gy1cald,
                   ia_gy1cal, ia_gy1calwa, ia_gy1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1cala - pw_gy1cala - pw_gy1calf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcal,"gxwcal", 0) + tacq_cal);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcal_mem[res_gy1rcal];
        s16 gy1rcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp478_pg_beta=pg_beta,&_temp478_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1rcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcalf != 0))
        {
            uramp( (&gy1rcal_mem[gy1rcal_indx]),
                   (pw_gy1rcalf/per_gy1rcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcal_indx = ( pw_gy1rcalf/ per_gy1rcal );
            gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcala/per_gy1rcal),
               (short) 0, ia_gy1rcalwa , pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcalf)/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcal_mem[gy1rcal_indx]),
              (pw_gy1rcal/per_gy1rcal),
              ia_gy1rcalwa, ia_gy1rcalwb, pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcal + pw_gy1rcalf )/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcald/per_gy1rcal),
               ia_gy1rcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcal, "gy1rcal" );
        createreserve( &gy1rcal, (WF_PROCESSOR)wg_gy1rcal, res_gy1rcal );
        createinstr( &gy1rcal,(LONG)(PosTemp+pw_gy1rcala-pw_gy1rcala - 
                                         pw_gy1rcalf),
                     (pw_gy1rcalf + pw_gy1rcala + 
                      pw_gy1rcal + pw_gy1rcald), 
                     ia_gy1rcal );
        /* Move user pulse into waveform mem */
        gy1rcal_mem[res_gy1rcal-1] |= WEOS_BIT;  
        movewaveimm(gy1rcal_mem, &gy1rcal, 
                    (int)0, res_gy1rcal, TOHARDWARE);
        if ((wg_gy1rcal==TYPRHO1)||(wg_gy1rcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcal,0,(LONG)(PosTemp+pw_gy1rcala),
                      (pw_gy1rcala + pw_gy1rcal + pw_gy1rcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcal, "gy1rcal",
                   &gy1rcal, &gy1rcala, &gy1rcald,
                   pw_gy1rcal, pw_gy1rcala, pw_gy1rcald,
                   ia_gy1rcal, ia_gy1rcalwa, ia_gy1rcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcala - pw_gy1rcala - pw_gy1rcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycal,"attenuator_keycal");
  createatten(&attenuator_keycal, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcal,"seqcal");
    createseq(&seqcal,RUP_GRD(tr_cal), off_seqcal);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcal );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcal = %d\n", idx_seqcal );
#endif
  }

    attenflagon(&seqcal, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscal,"d3dpasscal");
    create3dim(&d3dpasscal,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecal,"pass_pulsecal");
    createpass(&pass_pulsecal,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcalpass,"seqcalpass");
    createseq(&seqcalpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssical), off_seqcalpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcalpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcalpass = %d\n", idx_seqcalpass );
#endif
  }


    return SUCCESS;
}   /* End of ExtCalpulsegen */


/*
 *  AutoCoilpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AutoCoilpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcoilwa  = _ia_gzcombcoilwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzcombcoilwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcoilwb  = _ia_gzcombcoilwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzcombcoilwb) : max_pg_wamp;
    
    ia_gzprcoilwa  = _ia_gzprcoilwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzprcoilwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcoilwb  = _ia_gzprcoilwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzprcoilwb) : max_pg_wamp;

    /* selective RF1 */
    PosStart = td0coil + pw_gzrf1coila;

         
               
  {
        INT old_res =  res_rf1coil; /* temp holder for old pulse resolution */

    if ( (wg_rf1coil != TYPRHO1)  && (wg_rf1coil != TYPRHO2) &&
         (wg_rf1coil != TYPTHETA) && (wg_rf1coil != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1coil  = _n_rf1coil.fixedflag ?  ((void)(1), n_rf1coil) : n_rf1coil+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1coil.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1coil,"rf1coil");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1coil].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1coil].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1coil, (WF_PROCESSOR)wg_rf1coil, new_res);

                movestretchedwave( fileloc_rf1coil, old_res,
                                   &rf1coil, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(new_res), res_rf1coil) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1coil,(WF_PROCESSOR)wg_rf1coil,
                          old_res,fileloc_rf1coil);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1coil,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1coil,ia_rf1coil);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1coil,off_rf1coil,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1coil);
    

    /*** Reset Resolution ***/
    res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(old_res), res_rf1coil) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1coil, &rf1coil, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1coil, "gzrf1coil", &gzrf1coil, &gzrf1coila,
                        &gzrf1coild, pw_gzrf1coil, pw_gzrf1coila, pw_gzrf1coild,
                        ia_gzrf1coil, 0, 0, 0, 0, pbeg(&rf1coil,"rf1coil",0)-psd_rf_wait-pw_gzrf1coila, TRAP_ALL,
                        &coilloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) + pw_gzrf1coild);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcoil_mem[res_gzcombcoil];
        s16 gzcombcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp479_pg_beta=pg_beta,&_temp479_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcombcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcoilf != 0))
        {
            uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
                   (pw_gzcombcoilf/per_gzcombcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcoil_indx = ( pw_gzcombcoilf/ per_gzcombcoil );
            gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoila/per_gzcombcoil),
               (short) 0, ia_gzcombcoilwa , pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoilf)/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcoil_mem[gzcombcoil_indx]),
              (pw_gzcombcoil/per_gzcombcoil),
              ia_gzcombcoilwa, ia_gzcombcoilwb, pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoilf )/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoild/per_gzcombcoil),
               ia_gzcombcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcoil, "gzcombcoil" );
        createreserve( &gzcombcoil, (WF_PROCESSOR)wg_gzcombcoil, res_gzcombcoil );
        createinstr( &gzcombcoil,(LONG)(PosTemp+pw_gzcombcoila-pw_gzcombcoila - 
                                         pw_gzcombcoilf),
                     (pw_gzcombcoilf + pw_gzcombcoila + 
                      pw_gzcombcoil + pw_gzcombcoild), 
                     ia_gzcombcoil );
        /* Move user pulse into waveform mem */
        gzcombcoil_mem[res_gzcombcoil-1] |= WEOS_BIT;  
        movewaveimm(gzcombcoil_mem, &gzcombcoil, 
                    (int)0, res_gzcombcoil, TOHARDWARE);
        if ((wg_gzcombcoil==TYPRHO1)||(wg_gzcombcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcoil,0,(LONG)(PosTemp+pw_gzcombcoila),
                      (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcoil, "gzcombcoil",
                   &gzcombcoil, &gzcombcoila, &gzcombcoild,
                   pw_gzcombcoil, pw_gzcombcoila, pw_gzcombcoild,
                   ia_gzcombcoil, ia_gzcombcoilwa, ia_gzcombcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcoila - pw_gzcombcoila - pw_gzcombcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil + tacq_coil/2 + pw_gzprcoila);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcoil_mem[res_gzprcoil];
        s16 gzprcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp480_pg_beta=pg_beta,&_temp480_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzprcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcoilf != 0))
        {
            uramp( (&gzprcoil_mem[gzprcoil_indx]),
                   (pw_gzprcoilf/per_gzprcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcoil_indx = ( pw_gzprcoilf/ per_gzprcoil );
            gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoila/per_gzprcoil),
               (short) 0, ia_gzprcoilwa , pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoilf)/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcoil_mem[gzprcoil_indx]),
              (pw_gzprcoil/per_gzprcoil),
              ia_gzprcoilwa, ia_gzprcoilwb, pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoil + pw_gzprcoilf )/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoild/per_gzprcoil),
               ia_gzprcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcoil, "gzprcoil" );
        createreserve( &gzprcoil, (WF_PROCESSOR)wg_gzprcoil, res_gzprcoil );
        createinstr( &gzprcoil,(LONG)(PosTemp-pw_gzprcoila - 
                                         pw_gzprcoilf),
                     (pw_gzprcoilf + pw_gzprcoila + 
                      pw_gzprcoil + pw_gzprcoild), 
                     ia_gzprcoil );
        /* Move user pulse into waveform mem */
        gzprcoil_mem[res_gzprcoil-1] |= WEOS_BIT;  
        movewaveimm(gzprcoil_mem, &gzprcoil, 
                    (int)0, res_gzprcoil, TOHARDWARE);
        if ((wg_gzprcoil==TYPRHO1)||(wg_gzprcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcoil,0,(LONG)(PosTemp),
                      (pw_gzprcoila + pw_gzprcoil + pw_gzprcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcoil, "gzprcoil",
                   &gzprcoil, &gzprcoila, &gzprcoild,
                   pw_gzprcoil, pw_gzprcoila, pw_gzprcoild,
                   ia_gzprcoil, ia_gzprcoilwa, ia_gzprcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcoila - pw_gzprcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil - tacq_coil/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwcoil, "gxwcoil", &gxwcoil, &gxwcoila,
                        &gxwcoild, pw_gxwcoil, pw_gxwcoila, pw_gxwcoild,
                        ia_gxwcoil, 0, 0, 0, 0, PosTemp-pw_gxwcoila, TRAP_ALL,
                        &coilloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1coil,"echo1coil");
    acqq(&echo1coil, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1coil,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcoil,"d3dcoil");
    create3dim(&d3dcoil,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcoil, 0) - (pw_gx1coil + pw_gx1coild));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1coil_mem[res_gx1coil];
        s16 gx1coil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp481_pg_beta=pg_beta,&_temp481_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gx1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1coilf != 0))
        {
            uramp( (&gx1coil_mem[gx1coil_indx]),
                   (pw_gx1coilf/per_gx1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1coil_indx = ( pw_gx1coilf/ per_gx1coil );
            gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coila/per_gx1coil),
               (short) 0, ia_gx1coilwa , pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coilf)/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1coil_mem[gx1coil_indx]),
              (pw_gx1coil/per_gx1coil),
              ia_gx1coilwa, ia_gx1coilwb, pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coil + pw_gx1coilf )/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coild/per_gx1coil),
               ia_gx1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1coil, "gx1coil" );
        createreserve( &gx1coil, (WF_PROCESSOR)wg_gx1coil, res_gx1coil );
        createinstr( &gx1coil,(LONG)(PosTemp-pw_gx1coila - 
                                         pw_gx1coilf),
                     (pw_gx1coilf + pw_gx1coila + 
                      pw_gx1coil + pw_gx1coild), 
                     ia_gx1coil );
        /* Move user pulse into waveform mem */
        gx1coil_mem[res_gx1coil-1] |= WEOS_BIT;  
        movewaveimm(gx1coil_mem, &gx1coil, 
                    (int)0, res_gx1coil, TOHARDWARE);
        if ((wg_gx1coil==TYPRHO1)||(wg_gx1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1coil,0,(LONG)(PosTemp),
                      (pw_gx1coila + pw_gx1coil + pw_gx1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1coil, "gx1coil",
                   &gx1coil, &gx1coila, &gx1coild,
                   pw_gx1coil, pw_gx1coila, pw_gx1coild,
                   ia_gx1coil, ia_gx1coilwa, ia_gx1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1coila - pw_gx1coilf),
                   TRAP_ALL, &coilloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1coil,"gzrf1coil",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1coil_mem[res_gy1coil];
        s16 gy1coil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp482_pg_beta=pg_beta,&_temp482_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1coilf != 0))
        {
            uramp( (&gy1coil_mem[gy1coil_indx]),
                   (pw_gy1coilf/per_gy1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1coil_indx = ( pw_gy1coilf/ per_gy1coil );
            gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coila/per_gy1coil),
               (short) 0, ia_gy1coilwa , pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coilf)/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1coil_mem[gy1coil_indx]),
              (pw_gy1coil/per_gy1coil),
              ia_gy1coilwa, ia_gy1coilwb, pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coil + pw_gy1coilf )/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coild/per_gy1coil),
               ia_gy1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1coil, "gy1coil" );
        createreserve( &gy1coil, (WF_PROCESSOR)wg_gy1coil, res_gy1coil );
        createinstr( &gy1coil,(LONG)(PosTemp+pw_gy1coila-pw_gy1coila - 
                                         pw_gy1coilf),
                     (pw_gy1coilf + pw_gy1coila + 
                      pw_gy1coil + pw_gy1coild), 
                     ia_gy1coil );
        /* Move user pulse into waveform mem */
        gy1coil_mem[res_gy1coil-1] |= WEOS_BIT;  
        movewaveimm(gy1coil_mem, &gy1coil, 
                    (int)0, res_gy1coil, TOHARDWARE);
        if ((wg_gy1coil==TYPRHO1)||(wg_gy1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1coil,0,(LONG)(PosTemp+pw_gy1coila),
                      (pw_gy1coila + pw_gy1coil + pw_gy1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1coil, "gy1coil",
                   &gy1coil, &gy1coila, &gy1coild,
                   pw_gy1coil, pw_gy1coila, pw_gy1coild,
                   ia_gy1coil, ia_gy1coilwa, ia_gy1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1coila - pw_gy1coila - pw_gy1coilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcoil,"gxwcoil", 0) + tacq_coil);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcoil_mem[res_gy1rcoil];
        s16 gy1rcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp483_pg_beta=pg_beta,&_temp483_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1rcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcoilf != 0))
        {
            uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
                   (pw_gy1rcoilf/per_gy1rcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcoil_indx = ( pw_gy1rcoilf/ per_gy1rcoil );
            gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoila/per_gy1rcoil),
               (short) 0, ia_gy1rcoilwa , pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoilf)/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcoil_mem[gy1rcoil_indx]),
              (pw_gy1rcoil/per_gy1rcoil),
              ia_gy1rcoilwa, ia_gy1rcoilwb, pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoilf )/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoild/per_gy1rcoil),
               ia_gy1rcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcoil, "gy1rcoil" );
        createreserve( &gy1rcoil, (WF_PROCESSOR)wg_gy1rcoil, res_gy1rcoil );
        createinstr( &gy1rcoil,(LONG)(PosTemp+pw_gy1rcoila-pw_gy1rcoila - 
                                         pw_gy1rcoilf),
                     (pw_gy1rcoilf + pw_gy1rcoila + 
                      pw_gy1rcoil + pw_gy1rcoild), 
                     ia_gy1rcoil );
        /* Move user pulse into waveform mem */
        gy1rcoil_mem[res_gy1rcoil-1] |= WEOS_BIT;  
        movewaveimm(gy1rcoil_mem, &gy1rcoil, 
                    (int)0, res_gy1rcoil, TOHARDWARE);
        if ((wg_gy1rcoil==TYPRHO1)||(wg_gy1rcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcoil,0,(LONG)(PosTemp+pw_gy1rcoila),
                      (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcoil, "gy1rcoil",
                   &gy1rcoil, &gy1rcoila, &gy1rcoild,
                   pw_gy1rcoil, pw_gy1rcoila, pw_gy1rcoild,
                   ia_gy1rcoil, ia_gy1rcoilwa, ia_gy1rcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcoila - pw_gy1rcoila - pw_gy1rcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycoil,"attenuator_keycoil");
  createatten(&attenuator_keycoil, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcoil,"seqcoil");
    createseq(&seqcoil,RUP_GRD(tr_coil), off_seqcoil);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoil );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoil = %d\n", idx_seqcoil );
#endif
  }

    attenflagon(&seqcoil, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscoil,"d3dpasscoil");
    create3dim(&d3dpasscoil,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecoil,"pass_pulsecoil");
    createpass(&pass_pulsecoil,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcoilpass,"seqcoilpass");
    createseq(&seqcoilpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssicoil), off_seqcoilpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoilpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoilpass = %d\n", idx_seqcoilpass );
#endif
  }


    return SUCCESS;
}   /* End of AutoCoilpulsegen */



/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the beginning of pulsegen()

 In the beginning of `pulsegen()` the following lines should be added:
 \code{.c}
 GEReq_pulsegenBegin();
 \endcode

 This function up various global GE stuff related to pulsegen()
********************************************************************************************************/
void GEReq_pulsegenBegin(void) {

  sspinit(psd_board_type);

  {
    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */

  }
} /* GEReq_pulsegenBegin() */




/**
 *******************************************************************************************************
 @brief #### Helper function to be called at the end of pulsegen()

 In the end of `pulsegen()`, but before `buildinstr()`, the following lines should be added:
 \code{.c}
 GEReq_pulsegenEnd();
 \endcode

 This function up prescan pulsegen and adds a PASSPACK sequence ("GEendpass"), which is used to dump
 rawdata and mark the end of scan. See GEReq_endofpass() and GEReq_endofscan() and how they are used
 in a psd.
********************************************************************************************************/
void GEReq_pulsegenEnd(void) {

#ifdef IPG
  {
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();
AutoCoilpulsegen();
ExtCalpulsegen();

  }

/* pass sequence to dump Pfiles */
 
  {
    pulsename(&GEendpass,"GEendpass");
    createpass(&GEendpass,(long)(pw_passpacket-1000));
  }

  
  {
    pulsename(&GEpass,"GEpass");
    createseq(&GEpass,pw_passpacket, off_GEpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_GEpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_GEpass = %d\n", idx_GEpass );
#endif
  }


#endif
} /* GEReq_pulsegenEnd() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to trigger data (Pfile) writing and reconstruction

 After calling this function, the parent function must switch back to the previous/main sequence 
 using ks_scan_playsequence() (or *boffset()*).
********************************************************************************************************/
void GEReq_endofpass() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABPASS, &GEendpass, 2 ); /* end of pass */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofpass() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofscan() {
#ifdef IPG
  boffset(off_GEpass);
  setwamp(SSPD + DABSCAN, &GEendpass, 2 ); /* end of scan */
  startseq(0, (short) MAY_PAUSE);
#endif
} /* GEReq_endofscan() */




/**
 *******************************************************************************************************
 @brief #### Sets SSP word in sequence off_GEpass() to tell system that scan is done
********************************************************************************************************/
void GEReq_endofpassandscan() {
  #ifdef IPG
    boffset(off_GEpass);
    setwamp(SSPD + DABPASS + DABSCAN, &GEendpass, 2 ); /* end of scan */
    startseq(0, (short) MAY_PAUSE);
  #endif
  } /* GEReq_endofscan() */
  
  

/*****************************************************************************************************
 * RSP Variables
 * Accessible for tgt.c (on TGT)
 *****************************************************************************************************/
/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: Host declarations
 *
 *******************************************************************************************************
 *******************************************************************************************************/

abstract("GRE Tutorial [KSFoundation]");
psdname("ksgre_tutorial");

int ksgre_scan_sliceloop_nargs(int slperpass, int nargs, void **args);
float ksgre_scan_acqloop(int passindx);
float ksgre_scan_scanloop();
STATUS ksgre_scan_seqstate(SCAN_INFO slice_info, int kyview);

#include "epic_iopt_util.h"
#include <psdiopt.h>


/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: CVINIT
 *
 *******************************************************************************************************
 *******************************************************************************************************/


int sequence_iopts[] = {
  PSD_IOPT_SEQUENTIAL /* opirmode */
#ifdef UNDEF
  PSD_IOPT_ARC, /* oparc */
  PSD_IOPT_ASSET, /* opasset */
  PSD_IOPT_EDR, /* opptsize */
  PSD_IOPT_DYNPL, /* opdynaplan */
  PSD_IOPT_ZIP_512, /* opzip512 */
  PSD_IOPT_IR_PREP, /* opirprep */
  PSD_IOPT_MILDNOTE, /* opsilent */
  PSD_IOPT_ZIP_1024, /* opzip1024 */
  PSD_IOPT_SLZIP_X2, /* opzip2 */
  PSD_IOPT_MPH, /* opmph */
  PSD_IOPT_NAV, /* opnav */
  PSD_IOPT_FLOW_COMP, /* opfcomp */
#endif
};




/**
 *******************************************************************************************************
 @brief #### Initial handling of imaging options buttons and top-level CVs at the PSD type-in page
 @return void
********************************************************************************************************/
void ksgre_init_imagingoptions(void) {
  int numopts = sizeof(sequence_iopts)/ sizeof(int);

  psd_init_iopt_activity();
  activate_iopt_list(numopts, sequence_iopts);
  enable_iopt_list(numopts, sequence_iopts);

  /* Imaging option control functions (using PSD_IOPT_ZIP_512 as example):
    - Make an option unchecked and not selectable: disable_ioption(PSD_IOPT_ZIP_512)
    - Make an option checked and not selectable:   set_required_disabled_option(PSD_IOPT_ZIP_512)
    - Remove the imaging option:                   deactivate_ioption(PSD_IOPT_ZIP_512)
  */

  /* default slice order is interleaved */
  cvdef(opirmode, 0); opirmode  = _opirmode.fixedflag ?  ((void)(0), opirmode) : 0;

} /* ksgre_init_imagingoptions() */




/**
 *******************************************************************************************************
 @brief #### Initial setup of user interface (UI) with default values for menus and fields
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_init_UI(void) {

  /* Menus and button content 
     See epic.h or ksgre.e for more pi*** CVs to use to set up the user menus and buttons */
  
  /* Gradient Echo Type of sequence */
  acq_type  = _acq_type.fixedflag ?  ((void)(TYPGRAD), acq_type) : TYPGRAD; /* loadrheader.e rheaderinit: sets eeff = 1 */

  /* show "Minimum" as 1st option in TR menu */
  pitrval2 = PSD_MINIMUMTR;

  /* show "MinimumFull" as 1st option in TE menu */
  pite1val2 = PSD_MINFULLTE;

  /* show flip angle menu */
  pifanub = 2;
  
  /* hide second bandwidth option */
  pircb2nub = 0;

  /* default low FA */
  cvdef(opflip, 5);
  opflip  = _opflip.fixedflag ?  ((void)(_opflip.defval), opflip) : _opflip.defval;

  return SUCCESS;

} /* ksgre_init_UI() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: CVEVAL
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Gets the current UI and checks for valid inputs
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_eval_UI() {

  if (ksgre_init_UI() == FAILURE)
    return FAILURE;

  /* add code here that is related to the user interface (i.e. scan parameter) changes */

  return SUCCESS;

} /* ksgre_eval_UI() */




/**
 *******************************************************************************************************
 @brief #### Sets up all sequence objects for the main sequence module (KSGRE_SEQUENCE ksgre)
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_eval_setupobjects() {
  STATUS status;

  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/

  /* RF pulse choice (KSFoundation_GERF.h) */
  ksgre.selrfexc.rf = exc_3dfgre;

  ksgre.selrfexc.rf.flip = opflip;
  ksgre.selrfexc.slthick = opslthick/ ksgre_gscalerfexc;

  /* selective RF excitation */
  if (ks_eval_selrf(&ksgre.selrfexc, "rfexc") == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
   *  Readout
   *******************************************************************************************************/

  ksgre.read.fov = opfov;
  ksgre.read.res = RUP_FACTOR(opxres, 2); /* round up (RUP) to nearest multiple of 2 */
  ksgre.read.acq.rbw = oprbw;
  status = ks_eval_readtrap(&ksgre.read, "read");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  Readout dephaser
   *******************************************************************************************************/

  ksgre.readdephaser.area = -ksgre.read.area2center;
  status = ks_eval_trap(&ksgre.readdephaser, "readdephaser");
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
  *  Phase encoding
  *******************************************************************************************************/
 
  ksgre.phaseenc.fov = opfov * opphasefov;
  ksgre.phaseenc.res = RUP_FACTOR((int) (opyres * opphasefov), 2); /* round up (RUP) to nearest multiple of 2 */

  if (ks_eval_phaser(&ksgre.phaseenc, "phaseenc") == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
  *  Spoiler
  *******************************************************************************************************/
/* ------ emmweber --------------*/
  ksgre.spoiler.area = ksgre_spoilreadarea;

  if (ks_eval_trap(&ksgre.spoiler, "spoiler") == FAILURE)
    return FAILURE;

  /*******************************************************************************************************
   *  Init (reset) sequence control and set the SSI time
   *******************************************************************************************************/
  ks_init_seqcontrol(&ksgre.seqctrl);
  strcpy(ksgre.seqctrl.description, "ksgremain");
  /* Copy SSI CV to seqctrl field used by setssitime() */
  ksgre.seqctrl.ssi_time = RUP_GRD(ksgre_ssi_time);

  return SUCCESS;

} /* ksgre_eval_setupobjects() */




/**
 *******************************************************************************************************
 @brief #### Sets the min TE based on the durations of the sequence objects in KSGRE_SEQUENCE (ksgre)

 @retval STATUS `SUCCESS` or `FAILURE`
******************************************************************************************************/
STATUS ksgre_eval_TErange() {
 
  /* Minimum TE */
  avminte = ksgre.selrfexc.rf.iso2end;
  avminte += IMax(3, \
        ksgre.readdephaser.duration + ksgre.read.acqdelay, \
        ksgre.phaseenc.grad.duration, \
        ksgre.selrfexc.grad.ramptime + ksgre.selrfexc.postgrad.duration);
  avminte += ksgre.read.time2center - ksgre.read.acqdelay; /* from start of acq win to k-space center */
  avminte = RUP_FACTOR(avminte + 8  , 8); /* add 8us margin and round up to make time divisible by 8us */

  if (opautote) {
    setpopup(opte, PSD_OFF);
    cvoverride(opte, avminte, PSD_FIX_ON, PSD_EXIST_ON); /* AutoTE: force TE to minimum */
  } else {
    setpopup(opte, PSD_ON);
    if (opte < avminte)
      opte  = _opte.fixedflag ?  ((void)(avminte), opte) : avminte;
  }

  return SUCCESS;

} /* ksgre_eval_TErange() */




/**
 *******************************************************************************************************
 @brief #### Evaluation of number of slices / TR, set up of slice plan, TR validation and SAR checks

 With the current sequence collection (see my_cveval()), and a function pointer to an
 argument-standardized wrapper function (ksgre_scan_sliceloop_nargs()) to the slice loop function
 (ksgre_scan_sliceloop(), this function calls GEReq_eval_TR(), where number of slices that can fit
 within one TR is determined by adding more slices as input argument to the slice loop function.
 For more details see GEReq_eval_TR().

 With the number of slices/TR now known, a standard 2D slice plan is set up using ks_calc_sliceplan()
 and the duration of the main sequence is increased based on timetoadd_perTR, which was returned by
 GEReq_eval_TR(). timetoadd_perTR > 0 when optr > avmintr and when heat or SAR restrictions requires
 `avmintr` to be larger than the net sum of sequence modules in the slice loop.

 At the end of this function, TR validation and heat/SAR checks are done using GEReq_eval_checkTR_SAR().
 @param[in] seqcollection Pointer to the KS_SEQ_COLLECTION struct holding all sequence modules
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_eval_tr(KS_SEQ_COLLECTION *seqcollection) {
  int timetoadd_perTR;
  STATUS status;
  int slperpass, min_npasses;

  /* interleaved slices in slice gap menu, force 2+ acqs */
  if (opileave)
    min_npasses = 2;
  else
    min_npasses = 1;

   /* Calculate # slices per TR, # acquisitions and how much spare time we have within the current TR by running the slice loop, honoring heating and SAR limits */
  status = GEReq_eval_TR(&slperpass, &timetoadd_perTR, min_npasses, seqcollection, ksgre_scan_sliceloop_nargs, 0, NULL);
  if (status != SUCCESS) return status;

  /* Calculate the slice plan (ordering) and passes (acqs). ks_slice_plan is passed to GEReq_predownload_store_sliceplan() in predownload() */
  ks_calc_sliceplan(&ks_slice_plan, exist(opslquant), slperpass);

  /* We spread the available timetoadd_perTR evenly, by increasing the .duration of each slice by timetoadd_perTR/slperpass */
  ksgre.seqctrl.duration = RUP_GRD(ksgre.seqctrl.duration + CEIL_DIV(timetoadd_perTR, ks_slice_plan.nslices_per_pass));

  /* Update SAR values in the UI (error will occur if the sum of sequence durations differs from optr) */
  status = GEReq_eval_checkTR_SAR(seqcollection, ks_slice_plan.nslices_per_pass, ksgre_scan_sliceloop_nargs, 0, NULL);
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* ksgre_eval_tr() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: CVCHECK
 *
 *******************************************************************************************************
 *******************************************************************************************************/


/**
 *******************************************************************************************************
 @brief #### Returns error of various parameter combinations that are not allowed for ksgre
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_check() {


  return SUCCESS;

} /* ksgre_check() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: PREDOWNLOAD
 *
 *******************************************************************************************************
 *******************************************************************************************************/



/**
 *******************************************************************************************************
 @brief #### Plotting of sequence modules and slice timing to PNG/SVG/PDF files

 The ks_plot_*** functions used in here will save plots to disk depending on the value of the CV 
 `ks_plot_filefmt` (see KS_PLOT_FILEFORMATS). E.g. if ks_plot_filefmt = KS_PLOT_OFF, nothing will be
 written to disk. On the MR scanner, the output will be located in /usr/g/mrraw/plot/<ks_psdname>. In
 simulation, it will be placed in the current directory (./plot/).

 Please see the documentation on how to install the required python version and links. Specifically,
 there must be a link /usr/local/bin/apython pointing to the Anaconda 2 python binary (v. 2.7).

 In addition, the following text files is printed out
 - <ks_psdname>_objects.txt

@return STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_predownload_plot(KS_SEQ_COLLECTION* seqcollection) {
  char tmpstr[1000];

#ifdef PSD_HW
  sprintf(tmpstr, "/usr/g/mrraw/%s_objects.txt", ks_psdname);
#else
  sprintf(tmpstr, "./%s_objects.txt", ks_psdname);
#endif
  FILE *fp  = fopen(tmpstr, "w");

  /* Note: 'fp' can be replaced with 'stdout' or 'stderr' to get these
     values printed out in the WTools window in simulation. However,
     heavy printing may result in that the WTools window closes,
     why we here write to a file ksgre_objects.txt instead */
  ks_print_readtrap(ksgre.read, fp);
  ks_print_trap(ksgre.readdephaser, fp);
  ks_print_phaser(ksgre.phaseenc, fp);
  ks_print_trap(ksgre.spoiler, fp);
  ks_print_selrf(ksgre.selrfexc, fp);
  fclose(fp);


  /* ks_plot_host():
  Plot each sequence module as a separate file (PNG/SVG/PDF depending on ks_plot_filefmt (GERequired.e))
  See KS_PLOT_FILEFORMATS in KSFoundation.h for options.
  Note that the phase encoding amplitudes corresponds to the first shot, as set by the call to ksgre_scan_seqstate below */
  ksgre_scan_seqstate(ks_scan_info[0], 0);
  ks_plot_host(seqcollection, NULL);

  /* Sequence timing plot */
  ks_plot_slicetime_begin();
  ksgre_scan_scanloop();
  ks_plot_slicetime_end();

  /* ks_plot_tgt_reset():
  Creates sub directories and clear old files for later use of ksgre_scan_acqloop()->ks_plot_tgt_addframe().
  ks_plot_tgt_addframe() will only write in MgdSim (WTools) to avoid timing issues on the MR scanner. Hence,
  unlike ks_plot_host() and the sequence timing plot, one has to open MgdSim and press RunEntry (and also
  press PlotPulse several times after pressing RunEntry). */
  ks_plot_tgt_reset(&ksgre.seqctrl);


  return SUCCESS;

}  /* ksgre_predownload_plot() */


/**
 *******************************************************************************************************
 @brief #### Last-resort function to override certain recon variables not set up correctly already

 For most cases, the GEReq_predownload_*** functions in predownload() in ksgre.e set up
 the necessary rh*** variables for the reconstruction to work properly. However, if this sequence is
 customized, certain rh*** variables may need to be changed. Doing this here instead of in predownload()
 directly separates these changes from the standard behavior.

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_predownload_setrecon() {

  return SUCCESS;

} /* ksgre_predownload_setrecon() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_tutorial_implementation.e: PULSEGEN - builing of the sequence from the sequence objects
 *
 *  HOST: Called in cveval() to dry-run the sequence to determine timings
 *  TGT:  Waveforms are being written to hardware and necessary memory automatically alloacted
 *
 *******************************************************************************************************
 *******************************************************************************************************/




/**
 *******************************************************************************************************
 @brief #### The ksgre (main) pulse sequence

 This is the main pulse sequence in ksgre.e using the sequence objects in KSGRE_SEQUENCE with
 the sequence module name "ksgremain" (= ksgre.seqctrl.description)

 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_pg() {
  KS_SEQLOC tmploc = KS_INIT_SEQLOC;
  int readstart_pos;
  int endofseq_pos;
  STATUS status;


  /*******************************************************************************************************
   *  RF Excitation
   *******************************************************************************************************/
  tmploc.pos = RUP_GRD(KS_RFSSP_PRETIME);
  tmploc.board = ZGRAD;

  /* N.B.: ks_pg_selrf()->ks_pg_rf() detects that ksgre.selrfexc is an excitation pulse
     (ksgre.selrfexc.rf.role = KS_RF_ROLE_EXC) and will also set ksgre.seqctrl.momentstart
     to the absolute position in [us] of the isocenter of the RF excitation pulse */
  status = ks_pg_selrf(&ksgre.selrfexc, tmploc, &ksgre.seqctrl);
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
  *  Readout timing
  *******************************************************************************************************/

  /* With ksgre.seqctrl.momentstart set by ks_pg_selrf(&ksgre.selrfexc, ...), the absolute readout position
     can be determined (for both full Fourier and partial Fourier readouts using ksgre.read.time2center) */
  readstart_pos = ksgre.seqctrl.momentstart + opte - ksgre.read.time2center;

  /*******************************************************************************************************
   *  Phase encoding
   *******************************************************************************************************/

   /* emmweber */
  /* tmploc.pos = readstart_pos + RUP_GRD(ksgre.read.acqdelay) - ksgre.phaseenc.grad.duration - 380; */

  tmploc.pos = readstart_pos - ksgre.phaseenc.grad.duration ;
  tmploc.board = YGRAD;

  status = ks_pg_phaser(&ksgre.phaseenc, tmploc, &ksgre.seqctrl);
  if (status != SUCCESS) return status;

  /* set phase encode amps to first ky view (for plotting & moment calcs in WTools) */
  ks_scan_phaser_toline(&ksgre.phaseenc, 0, 0);

  /*******************************************************************************************************
   *  Readout dephaser
   *******************************************************************************************************/

  tmploc.pos = readstart_pos - ksgre.readdephaser.duration;
  tmploc.board = XGRAD;

  status = ks_pg_trap(&ksgre.readdephaser, tmploc, &ksgre.seqctrl);
  if (status != SUCCESS) return status;

  /*******************************************************************************************************
   *  Readout
   *******************************************************************************************************/

  tmploc.pos = readstart_pos;
  tmploc.board = XGRAD;

  status = ks_pg_readtrap(&ksgre.read, tmploc, &ksgre.seqctrl);
  if (status != SUCCESS) return status;



  /*******************************************************************************************************
   *  Spoiler
   *******************************************************************************************************/

  tmploc.pos = readstart_pos + ksgre.read.grad.duration;
  tmploc.board = XGRAD;
  status = ks_pg_trap(&ksgre.spoiler, tmploc, &ksgre.seqctrl);

  if (status != SUCCESS) return status;


  /* emmweber -------- Y spoiler grad ---------------------------*/

  
  tmploc.board = YGRAD;
  ks_pg_trap(&ksgre.spoiler, tmploc, &ksgre.seqctrl);

  /* emmweber -------- Z spoiler grad ---------------------------*/
  tmploc.board = ZGRAD;
  ks_pg_trap(&ksgre.spoiler, tmploc, &ksgre.seqctrl);



  /*******************************************************************************************************
   *  Set the minimal sequence duration (ksgre.seqctrl.min_duration) by calling
   *  ks_eval_seqctrl_setminduration()
   *******************************************************************************************************/

  endofseq_pos = RUP_GRD(tmploc.pos + ksgre.spoiler.duration);

#ifdef HOST_TGT
  /* On HOST only: Sequence duration (ksgre.seqctrl.ssi_time must be > 0 and is added to ksgre.seqctrl.min_duration in ks_eval_seqctrl_setminduration() */
  ks_eval_seqctrl_setminduration(&ksgre.seqctrl, endofseq_pos); /* endofseq_pos now corresponds to the end of last gradient in the sequence */
#endif

  return SUCCESS;

} /* ksgre_pg() */




/*******************************************************************************************************
 *******************************************************************************************************
 *
 *  ksgre_implementation.e: SCAN in @pg section (functions accessible to both HOST and TGT)
 *
 *  Here are functions related to the scan process (ksgre_scan_***) that have to be placed here in @pg
 *  (not @rsp) to make them also accessible on HOST in order to enable scan-on-host for TR timing
 *  in my_cveval()
 *
 *******************************************************************************************************
 *******************************************************************************************************/




/**
 *******************************************************************************************************
 @brief #### Sets the current state of all ksgre sequence objects being part of KSGRE_SEQUENCE

 This function sets the current state of all ksgre sequence objects being part of KSGRE_SEQUENCE, incl.
 gradient amplitude changes, RF freq/phases and receive freq/phase based on current slice position and
 phase encoding indices.

 The idea of having a 'seqstate' function is to be able to come back to a certain sequence state at any
 time and possibly play it out once more. This could for example be useful when certain lines or slices
 need to be rescanned due to image artifacts detected during scanning.

 @param[in] slice_info Position of the slice to be played out (one element in the `ks_scan_info[]` array)
 @param[in] kyview Phase encoding index related to `ksgre.phaseenc`. A value outside of
                   `[0, ksgre.phaseenc.res-1]` will set the phase encoding gradient amplitude to 0.
 @retval STATUS `SUCCESS` or `FAILURE`
********************************************************************************************************/
STATUS ksgre_scan_seqstate(SCAN_INFO slice_info, int kyview) {
  float rfphase = 0;

  /* rotate the slice plane */
  ks_scan_rotate(slice_info);

  /* RF frequency & phase */
  ks_scan_rf_on(&ksgre.selrfexc.rf, INSTRALL);
  ks_scan_selrf_setfreqphase(&ksgre.selrfexc, 0 /* instance */, slice_info, rfphase);

  /* FOV offsets (by changing freq/phase of ksgre.read) */
  ks_scan_offsetfov(&ksgre.read, INSTRALL, slice_info, kyview, opphasefov, rfphase);

  /* phase enc amp */
  ks_scan_phaser_toline(&ksgre.phaseenc,   0, kyview); 

  return SUCCESS;

} /* ksgre_scan_seqstate() */




/**
 *******************************************************************************************************
 @brief #### Plays out one slice in real time during scanning together with other active sequence modules

  On TGT on the MR system (PSD_HW), this function sets up (ksgre_scan_seqstate()) and plays out the
  core ksgre sequence with optional sequence modules also called in this function. The low-level
  function call `startseq()`, which actually starts the realtime sequence playout is called from within
  ks_scan_playsequence(), which in addition also returns the time to play out that sequence module (see
  time += ...).

  On HOST (in ksgre_eval_tr()) we call ksgre_scan_sliceloop_nargs(), which in turn calls this function
  that returns the total time in [us] taken to play out this core slice. These times are increasing in
  each parent function until ultimately ksgre_scan_scantime(), which returns the total time of the
  entire scan.

  After each call to ks_scan_playsequence(), ks_plot_slicetime() is called to add slice-timing
  information on file for later PDF-generation of the sequence. As scanning is performed in real-time
  and may fail if interrupted, ks_plot_slicetime() will return quietly if it detects both IPG (TGT)
  and PSD_HW (on the MR scanner). See predownload() for the PNG/PDF generation.

  @param[in] slice_pos Position of the slice to be played out (one element in the global
                      `ks_scan_info[]` array)
  @param[in] dabslice  0-based slice index for data storage
  @param[in] kyindx Phase encoding index related to `ksgre.phaseenc`. A value outside of
                    `[0, ksgre.phaseenc.res-1]` will set the phase encoding gradient amplitude to 0.
  @param[in] exc Excitation index in range [0, NEX-1], where NEX = number of excitations (opnex)
  @retval coreslicetime Time taken in [us] to play out one slice with potentially other sequence modules
********************************************************************************************************/
int ksgre_scan_coreslice(const SCAN_INFO *slice_pos, int dabslice, /* psd specific: */ int kyindx, int exc) {
  int echoindx;
  int dabop, dabview, acqflag;
  int time = 0;
  float tloc = 0.0;

  if (slice_pos != NULL) {
    /* modify sequence for next playout */
    ksgre_scan_seqstate(*slice_pos, ksgre.phaseenc.linetoacq[kyindx]);
    tloc = slice_pos->optloc;
  } else {
    /* false slice, shut off RF */
    ks_scan_rf_off(&ksgre.selrfexc.rf, INSTRALL);
  }

  /* data acquisition control */
  acqflag = (kyindx >= 0 && slice_pos != NULL && dabslice >= 0) ? DABON : DABOFF; /* open or close data receiver */
  dabop = (exc <= 0) ? DABSTORE : DABADD; /* replace or add to data */
  dabview = (kyindx >= 0) ? ksgre.phaseenc.linetoacq[kyindx] : KS_NOTSET;

  for (echoindx = 0; echoindx < ksgre.read.acq.base.ngenerated; echoindx++) {
    loaddab(&ksgre.read.acq.echo[echoindx], dabslice, echoindx, dabop, dabview + 1, acqflag, PSD_LOAD_DAB_ALL);
  }

  time += ks_scan_playsequence(&ksgre.seqctrl);

  int plottag = (slice_pos == NULL) ? KS_PLOT_NO_EXCITATION : KS_PLOT_STANDARD;
  ks_plot_slicetime(&ksgre.seqctrl, 1, &tloc, opslthick, plottag);

  return time; /* in [us] */

} /* ksgre_scan_coreslice() */




/**
 *******************************************************************************************************
 @brief #### Plays out `slperpass` slices corresponding to one TR

 This function gets a spatial slice location index based on the pass index and temporal position within
 current pass. It then calls ksgre_scan_coreslice() to play out one coreslice (i.e. the main ksgre main
 sequence + optional sequence modules, excluding inversion modules).

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] passindx  0-based pass index in range [0, ks_slice_plan.npasses - 1]
 @param[in] kyindx Phase encoding index related to `ksgre.phaseenc`. A value outside of
                   `[0, ksgre.phaseenc.res-1]` will set the phase encoding gradient amplitude to 0.
 @param[in] exc Excitation index in range [0, NEX-1], where NEX = number of excitations (opnex)
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksgre_scan_sliceloop(int slperpass, int passindx, int kyindx, int exc) {
  int time = 0;
  int slloc, sltimeinpass;

  for (sltimeinpass = 0; sltimeinpass < slperpass; sltimeinpass++) {

    /* slice location from slice plan (KS_NOTSET (= -1) means dummy slice) */
    slloc = ks_scan_getsliceloc(&ks_slice_plan, passindx, sltimeinpass);

    time += ksgre_scan_coreslice((slloc != KS_NOTSET) ? &ks_scan_info[slloc] : NULL, sltimeinpass, kyindx, exc);

  }

  return time; /* in [us] */

} /* ksgre_scan_sliceloop() */




/**
 *******************************************************************************************************
 @brief #### Wrapper function to ksgre_scan_sliceloop() with standardized input arguments

 For TR timing heat/SAR calculations of regular 2D multislice sequences, GEReq_eval_TR(),
 ks_eval_mintr() and GEReq_eval_checkTR_SAR() use a standardized function pointer with a fixed set of
 input arguments to call the sliceloop of the main sequence with different number of slices to check
 current slice loop duration. As different pulse sequences may need different number of input arguments
 (with different meaning) this ksgre_scan_sliceloop_nargs() wrapper function provides the argument
 translation for ksgre_scan_sliceloop().

 The function pointer must have an integer corresponding to the number of slices to use as its first
 argument while the remaining input arguments (to ksgre_scan_sliceloop()) are stored in the generic void
 pointer array with `nargs` elements, which is then unpacked before calling ksgre_scan_sliceloop().

 @param[in] slperpass Number of slices to play in the slice loop
 @param[in] nargs Number of extra input arguments to ksgre_scan_sliceloop() in range [0,4]
 @param[in] args  Void pointer array pointing to the variables containing the actual values needed for
                  ksgre_scan_sliceloop()
 @retval slicelooptime Time taken in [us] to play out `slperpass` slices
********************************************************************************************************/
int ksgre_scan_sliceloop_nargs(int slperpass, int nargs, void **args) {
  int passindx = 0;
  int kyindx = KS_NOTSET; /* off */
  int exc = 0;

  if (nargs < 0 || nargs > 3) {
    ks_error("%s: 3rd arg (void **) must contain up to 4 elements: passindx, kyindx, exc", __FUNCTION__);
    return -1;
  } else if (nargs > 0 && args == NULL) {
    ks_error("%s: 3rd arg (void **) cannot be NULL if nargs (2nd arg) != 0", __FUNCTION__);
    return -1;
  }

  if (nargs >= 1 && args[0] != NULL) {
    passindx = *((int *) args[0]);
  }
  if (nargs >= 2 && args[1] != NULL) {
    kyindx = *((int *) args[1]);
  }
  if (nargs >= 3 && args[2] != NULL) {
    exc = *((int *) args[2]);
  }

  return ksgre_scan_sliceloop(slperpass, passindx, kyindx, exc); /* in [us] */

} /* ksgre_scan_sliceloop_nargs() */




/**
 *******************************************************************************************************
 @brief #### Plays out all phase encodes for all slices belonging to one pass

 This function traverses through all phase encodes to be played out and runs the
 ksgre_scan_sliceloop() for each set of kyindx, and excitation. If ksgre_dda > 0, dummy scans
 will be played out before the phase encoding begins.

 @param[in] passindx  0-based pass index in range [0, ks_slice_plan.npasses - 1]
 @retval passlooptime Time taken in [us] to play out all phase encodes and excitations for `slperpass`
                      slices. Note that the value is a `float` instead of `int` to avoid int overrange
                      at 38 mins of scanning
********************************************************************************************************/
float ksgre_scan_acqloop(int passindx) {
  float time = 0.0;
  int dda, kyindx, exc;

  /* dummy scans for steady state */
  for (dda = 0; dda < ksgre_dda; dda++) {
    time += (float) ksgre_scan_sliceloop(ks_slice_plan.nslices_per_pass, passindx, KS_NOTSET, KS_NOTSET);
    ks_plot_slicetime_endofslicegroup("ksgre dummy TR");
  }
  if (ksgre_dda > 0) {
    ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_DUMMY);
  }

  for (kyindx = 0; kyindx < ksgre.phaseenc.numlinestoacq; kyindx++) {
    for (exc = 0; exc < (int) ceil(opnex); exc++) { /* ceil rounds up opnex < 1 (used for partial Fourier) to 1 */

      time += (float) ksgre_scan_sliceloop(ks_slice_plan.nslices_per_pass, passindx, kyindx, exc);

    } /* for exc */


    ks_plot_slicetime_endofslicegroup("ksgre line");

    /* save a frame of the main sequence */
    ks_plot_tgt_addframe(&ksgre.seqctrl);

  } /* for kyindx */

  ks_plot_slicetime_endofpass(KS_PLOT_PASS_WAS_STANDARD);

  return time; /* in [us] */

} /* ksgre_scan_acqloop() */




/**
 *****************************************************************************************************
 @brief #### Plays out all passes of a single or multi-pass scan

 This function traverses through all phase encodes to be played out, and runs the ksgre_scan_sliceloop()
 for each set of kyindx and excitation. If ksgre_dda > 0, dummy scans will be played out before
 the phase encoding begins.

 @retval scantime Total scan time in [us] (float to avoid int overrange after 38 mins)
********************************************************************************************************/
float ksgre_scan_scanloop() {
  float time = 0.0;

  for (volindx = 0; volindx < opfphases; volindx++) { /* opfphases is # volumes */

    for (passindx = 0; passindx < ks_slice_plan.npasses; passindx++) {

      time += ksgre_scan_acqloop(passindx);

#ifdef IPG
      /* Send instruction to dump Pfile (if autolock = 1) and for GE's recon to start reconstructing the slices for current pass */
      GEReq_endofpass();
#endif

    } /* end: acqs (pass) loop */

  } /* end: volume loop */

  return time;

} /* ksgre_scan_scanloop() */





/*****************************************************************************************************
 * Host Functions and variables
 *****************************************************************************************************/

  /* Collection (handle) of all sequence modules */
  KS_SEQ_COLLECTION seqcollection;

/*****************************************************************************************************
 * CVINIT (Executes at init and when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cvinit(void) {
  STATUS status;

  status = GEReq_cvinit();
  if (status != SUCCESS) return status;

  /* reset debug file ./ks_debug.txt (SIM) or /usr/g/mrraw/ks_debug.txt (HW) */
  ks_dbg_reset();

  /* Imaging Options buttons */
  ksgre_init_imagingoptions();

  /* Setup UI buttons */
  status = ksgre_init_UI();
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* cvinit() */



/*****************************************************************************************************
 * CVEVAL (Executes when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cveval(void) {

    /*
   cveval() is called 37+ times per UI button push on the MR system, while cvcheck() is only called once.
   For a faster execution we have a my_cveval() function that is called in cvcheck() instead
   */

  return SUCCESS;
}


STATUS my_cveval(void) {
  STATUS status;

  ks_init_seqcollection(&seqcollection);

  status = GEReq_cveval();
  if (status != SUCCESS) return status;

  /* User Interface updates & opuserCV sync */
  status = ksgre_eval_UI();
  if (status != SUCCESS) return status;

  /* Setup sequence objects */
  status = ksgre_eval_setupobjects();
   if (status != SUCCESS) return status;

  /* Calculate minimum (and maximum TE) */
  status = ksgre_eval_TErange();
  if (status != SUCCESS) return status;

  /* Run the sequence once (and only once after ksgre_eval_setupobjects()) in cveval() to
     get the sequence duration and the number of object instances (for grad/rf limits) */
  status = ksgre_pg();
  if (status != SUCCESS) return status;

  status = ks_eval_addtoseqcollection(&seqcollection, &ksgre.seqctrl);
  if (status != SUCCESS) return status;


  /*--------- Begin: Additional sequence modules -----------*/



  /*--------- End: Additional sequence modules -----------*/


  /* Min TR, #slices per TR, RF/gradient heating & SAR */
  status = ksgre_eval_tr(&seqcollection);
  if (status != SUCCESS) return status;

  /* RF scaling across sequence modules */
  status = GEReq_eval_rfscaling(&seqcollection);
  if (status != SUCCESS) return status;

  /* scan time */
  pitscan  = _pitscan.fixedflag ?  ((void)(ksgre_scan_scanloop()), pitscan) : ksgre_scan_scanloop();

  return SUCCESS;

} /* my_cveval() */


/*****************************************************************************************************
 * CVCHECK (Executes when a change is made in the user interface)
 *****************************************************************************************************/

STATUS cvcheck(void) {
  STATUS status;

  status = my_cveval();
  if (status != SUCCESS) return status;

  status = GEReq_cvcheck();
  if (status != SUCCESS) return status;

  status = ksgre_check();
  if (status != SUCCESS) return status;

  return SUCCESS;

} /* cvcheck() */


/*****************************************************************************************************
 * PREDOWNLOAD (Executes when pressing SaveRx on MR scanner (HW) or on value change in EvalTool (SIM)
 ****************************************************************************************************/
STATUS predownload( void ) {
  STATUS status;

  status = GEReq_predownload();
  if (status != SUCCESS) return status;

  /* Set filter slot # for SCAN, APS2, MPS2 */
  GEReq_predownload_setfilter(&ksgre.read.acq.filt);

  /* slice ordering */
  /* The following GE globals must be set appropriately:
     data_acq_order[], rsp_info[], rsprot[], rsptrigger[]. This is a must for a main pulse sequence */
  status = GEReq_predownload_store_sliceplan(ks_slice_plan);
  if (status != SUCCESS) return status;

  /* generic rh-vars setup */
  GEReq_predownload_setrecon_readphase(&ksgre.read, &ksgre.phaseenc, NULL, KS_IMSIZE_MIN256, KS_SAVEPFILES * autolock + KS_GERECON * (rhrecon < 1000) /* online recon if rhrecon < 1000 */);
  GEReq_predownload_setrecon_annotations_readtrap(&ksgre.read, 0);
  GEReq_predownload_setrecon_voldata(opfphases, ks_slice_plan); /* opfphases = number of volumes */

  /* further sequence specific recon settings that have not been set correctly at this point */
  status = ksgre_predownload_setrecon();
  if (status != SUCCESS) return status;

  /* plotting of sequence modules and slice timing to disk */
  ksgre_predownload_plot(&seqcollection);

  return SUCCESS;

} /* predownload() */




/*****************************************************************************************************
 * PULSEGEN (Executes when pressing Scan or Research->Download)
 *****************************************************************************************************/

STATUS pulsegen( void ) {

  GEReq_pulsegenBegin();

  /* Main Pulse Sequence */
  ksgre_pg();
   
    {
      if (ksgre.seqctrl.duration > 0) {

        if (ksgre.seqctrl.duration - ksgre.seqctrl.ssi_time < 0) {

          ks_error("KS_SEQLENGTH (%s): (.duration - .ssi_time) is negative", ksgre.seqctrl.description);

        } else {

          STATUS status = pulsename(&seqcore, "seqcore");
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): pulsename(seqcore) failed", ksgre.seqctrl.description);
          }  
          status = createseq(&seqcore, ksgre.seqctrl.duration - ksgre.seqctrl.ssi_time, off_seqcore);
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): createseq(seqcore) failed", ksgre.seqctrl.description);
          } 

#if defined(HOST_TGT)
          /* Update sequence counter and get current sequence entry index */
          status = updateIndex( &idx_seqcore );
          if (status != SUCCESS) {
            ks_error("KS_SEQLENGTH (%s): updateIndex(seqcore) failed", ksgre.seqctrl.description);
          }
          printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "KS_SEQLENGTH",
                      "idx_seqcore = %d\n", idx_seqcore );
          ksgre.seqctrl.handle.index = idx_seqcore;
#endif
          /* copy seqyence_enties to the KS_SEQ seq_struct */
          ksgre.seqctrl.handle.offset = off_seqcore;
          ksgre.seqctrl.handle.pulse = &seqcore;
        } /* duration - ssi_time > 0 */

      } /* duration > 0 */
    }
  

  GEReq_pulsegenEnd();

  buildinstr(); /* load the sequencer memory */

  return SUCCESS;

} /* pulsegen() */



/* Include special CV download code */
#include "ksgre_tutorial.cvcopy.cpp"

